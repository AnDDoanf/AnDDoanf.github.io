{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/entities.generated.ts"],"sourcesContent":["/**\n * Auto-generated HTML entity mappings for CommonMark compliance\n * Generated from https://html.spec.whatwg.org/entities.json\n * Generated by scripts/generate-entities.ts\n * \n * Simple object mapping entity names to Unicode characters.\n * Stores only lowercase versions when case variants map to the same Unicode (saves ~8.8 KB).\n * Case-sensitive entities (where uppercase/lowercase differ) are stored with both keys.\n */\n\nexport const NAMED_CODES_TO_UNICODE: Record<string, string> = {\n  \"af\":\"â¡\",\n  \"applyfunction\":\"â¡\",\n  \"ic\":\"â£\",\n  \"invisiblecomma\":\"â£\",\n  \"invisibletimes\":\"â¢\",\n  \"it\":\"â¢\",\n  \"lrm\":\"â€\",\n  \"negativemediumspace\":\"â€‹\",\n  \"negativethickspace\":\"â€‹\",\n  \"negativethinspace\":\"â€‹\",\n  \"negativeverythinspace\":\"â€‹\",\n  \"nobreak\":\"â \",\n  \"rlm\":\"â€\",\n  \"shy\":\"Â­\",\n  \"zerowidthspace\":\"â€‹\",\n  \"zwj\":\"â€\",\n  \"zwnj\":\"â€Œ\",\n  \"downbreve\":\"Ì‘\",\n  \"tdot\":\"âƒ›\",\n  \"tripledot\":\"âƒ›\",\n  \"dotdot\":\"âƒœ\",\n  \"tab\":\"\t\",\n  \"newline\":\"\\n\",\n  \"emsp\":\"â€ƒ\",\n  \"emsp13\":\"â€„\",\n  \"emsp14\":\"â€…\",\n  \"ensp\":\"â€‚\",\n  \"hairsp\":\"â€Š\",\n  \"mediumspace\":\"âŸ\",\n  \"puncsp\":\"â€ˆ\",\n  \"thinsp\":\"â€‰\",\n  \"thinspace\":\"â€‰\",\n  \"verythinspace\":\"â€Š\",\n  \"nbsp\":\"Â \",\n  \"nonbreakingspace\":\"Â \",\n  \"numsp\":\"â€‡\",\n  \"thickspace\":\"âŸâ€Š\",\n  \"oline\":\"â€¾\",\n  \"overbar\":\"â€¾\",\n  \"lowbar\":\"_\",\n  \"underbar\":\"_\",\n  \"dash\":\"â€\",\n  \"hyphen\":\"â€\",\n  \"ndash\":\"â€“\",\n  \"mdash\":\"â€”\",\n  \"horbar\":\"â€•\",\n  \"comma\":\",\",\n  \"semi\":\";\",\n  \"bsemi\":\"â\",\n  \"colon\":\":\",\n  \"Colone\":\"â©´\",\n  \"excl\":\"!\",\n  \"iexcl\":\"Â¡\",\n  \"quest\":\"?\",\n  \"iquest\":\"Â¿\",\n  \"period\":\".\",\n  \"nldr\":\"â€¥\",\n  \"hellip\":\"â€¦\",\n  \"mldr\":\"â€¦\",\n  \"centerdot\":\"Â·\",\n  \"middot\":\"Â·\",\n  \"apos\":\"'\",\n  \"lsquo\":\"â€˜\",\n  \"opencurlyquote\":\"â€˜\",\n  \"closecurlyquote\":\"â€™\",\n  \"rsquo\":\"â€™\",\n  \"rsquor\":\"â€™\",\n  \"lsquor\":\"â€š\",\n  \"sbquo\":\"â€š\",\n  \"lsaquo\":\"â€¹\",\n  \"rsaquo\":\"â€º\",\n  \"quot\":\"\\\"\",\n  \"ldquo\":\"â€œ\",\n  \"opencurlydoublequote\":\"â€œ\",\n  \"closecurlydoublequote\":\"â€\",\n  \"rdquo\":\"â€\",\n  \"rdquor\":\"â€\",\n  \"bdquo\":\"â€\",\n  \"ldquor\":\"â€\",\n  \"laquo\":\"Â«\",\n  \"raquo\":\"Â»\",\n  \"lpar\":\"(\",\n  \"rpar\":\")\",\n  \"lbrack\":\"[\",\n  \"lsqb\":\"[\",\n  \"rbrack\":\"]\",\n  \"rsqb\":\"]\",\n  \"lbrace\":\"{\",\n  \"lcub\":\"{\",\n  \"rbrace\":\"}\",\n  \"rcub\":\"}\",\n  \"lceil\":\"âŒˆ\",\n  \"leftceiling\":\"âŒˆ\",\n  \"rceil\":\"âŒ‰\",\n  \"rightceiling\":\"âŒ‰\",\n  \"leftfloor\":\"âŒŠ\",\n  \"lfloor\":\"âŒŠ\",\n  \"rfloor\":\"âŒ‹\",\n  \"rightfloor\":\"âŒ‹\",\n  \"lopar\":\"â¦…\",\n  \"ropar\":\"â¦†\",\n  \"lbrke\":\"â¦‹\",\n  \"rbrke\":\"â¦Œ\",\n  \"lbrkslu\":\"â¦\",\n  \"rbrksld\":\"â¦\",\n  \"lbrksld\":\"â¦\",\n  \"rbrkslu\":\"â¦\",\n  \"langd\":\"â¦‘\",\n  \"rangd\":\"â¦’\",\n  \"lparlt\":\"â¦“\",\n  \"rpargt\":\"â¦”\",\n  \"gtlpar\":\"â¦•\",\n  \"ltrpar\":\"â¦–\",\n  \"leftdoublebracket\":\"âŸ¦\",\n  \"lobrk\":\"âŸ¦\",\n  \"rightdoublebracket\":\"âŸ§\",\n  \"robrk\":\"âŸ§\",\n  \"lang\":\"âŸ¨\",\n  \"langle\":\"âŸ¨\",\n  \"leftanglebracket\":\"âŸ¨\",\n  \"rang\":\"âŸ©\",\n  \"rangle\":\"âŸ©\",\n  \"rightanglebracket\":\"âŸ©\",\n  \"Lang\":\"âŸª\",\n  \"Rang\":\"âŸ«\",\n  \"loang\":\"âŸ¬\",\n  \"roang\":\"âŸ­\",\n  \"lbbrk\":\"â²\",\n  \"rbbrk\":\"â³\",\n  \"Verbar\":\"â€–\",\n  \"Vert\":\"â€–\",\n  \"sect\":\"Â§\",\n  \"para\":\"Â¶\",\n  \"commat\":\"@\",\n  \"ast\":\"*\",\n  \"midast\":\"*\",\n  \"sol\":\"/\",\n  \"bsol\":\"\\\\\",\n  \"amp\":\"&\",\n  \"num\":\"#\",\n  \"percnt\":\"%\",\n  \"permil\":\"â€°\",\n  \"pertenk\":\"â€±\",\n  \"dagger\":\"â€ \",\n  \"Dagger\":\"â€¡\",\n  \"ddagger\":\"â€¡\",\n  \"bull\":\"â€¢\",\n  \"bullet\":\"â€¢\",\n  \"hybull\":\"âƒ\",\n  \"prime\":\"â€²\",\n  \"Prime\":\"â€³\",\n  \"tprime\":\"â€´\",\n  \"qprime\":\"â—\",\n  \"backprime\":\"â€µ\",\n  \"bprime\":\"â€µ\",\n  \"caret\":\"â\",\n  \"diacriticalgrave\":\"`\",\n  \"grave\":\"`\",\n  \"acute\":\"Â´\",\n  \"diacriticalacute\":\"Â´\",\n  \"diacriticaltilde\":\"Ëœ\",\n  \"tilde\":\"Ëœ\",\n  \"hat\":\"^\",\n  \"macr\":\"Â¯\",\n  \"strns\":\"Â¯\",\n  \"breve\":\"Ë˜\",\n  \"diacriticaldot\":\"Ë™\",\n  \"dot\":\"Ë™\",\n  \"die\":\"Â¨\",\n  \"Dot\":\"Â¨\",\n  \"doubledot\":\"Â¨\",\n  \"uml\":\"Â¨\",\n  \"ring\":\"Ëš\",\n  \"dblac\":\"Ë\",\n  \"diacriticaldoubleacute\":\"Ë\",\n  \"cedil\":\"Â¸\",\n  \"cedilla\":\"Â¸\",\n  \"ogon\":\"Ë›\",\n  \"circ\":\"Ë†\",\n  \"caron\":\"Ë‡\",\n  \"hacek\":\"Ë‡\",\n  \"deg\":\"Â°\",\n  \"copy\":\"Â©\",\n  \"circledr\":\"Â®\",\n  \"reg\":\"Â®\",\n  \"copysr\":\"â„—\",\n  \"weierp\":\"â„˜\",\n  \"wp\":\"â„˜\",\n  \"rx\":\"â„\",\n  \"mho\":\"â„§\",\n  \"iiota\":\"â„©\",\n  \"larr\":\"â†\",\n  \"leftarrow\":\"â†\",\n  \"shortleftarrow\":\"â†\",\n  \"slarr\":\"â†\",\n  \"nlarr\":\"â†š\",\n  \"nleftarrow\":\"â†š\",\n  \"rarr\":\"â†’\",\n  \"rightarrow\":\"â†’\",\n  \"shortrightarrow\":\"â†’\",\n  \"srarr\":\"â†’\",\n  \"nrarr\":\"â†›\",\n  \"nrightarrow\":\"â†›\",\n  \"shortuparrow\":\"â†‘\",\n  \"uarr\":\"â†‘\",\n  \"uparrow\":\"â†‘\",\n  \"darr\":\"â†“\",\n  \"downarrow\":\"â†“\",\n  \"shortdownarrow\":\"â†“\",\n  \"harr\":\"â†”\",\n  \"leftrightarrow\":\"â†”\",\n  \"nharr\":\"â†®\",\n  \"nleftrightarrow\":\"â†®\",\n  \"updownarrow\":\"â†•\",\n  \"varr\":\"â†•\",\n  \"nwarr\":\"â†–\",\n  \"nwarrow\":\"â†–\",\n  \"upperleftarrow\":\"â†–\",\n  \"nearr\":\"â†—\",\n  \"nearrow\":\"â†—\",\n  \"upperrightarrow\":\"â†—\",\n  \"lowerrightarrow\":\"â†˜\",\n  \"searr\":\"â†˜\",\n  \"searrow\":\"â†˜\",\n  \"lowerleftarrow\":\"â†™\",\n  \"swarr\":\"â†™\",\n  \"swarrow\":\"â†™\",\n  \"rarrw\":\"â†\",\n  \"rightsquigarrow\":\"â†\",\n  \"nrarrw\":\"â†Ì¸\",\n  \"Larr\":\"â†\",\n  \"twoheadleftarrow\":\"â†\",\n  \"Uarr\":\"â†Ÿ\",\n  \"Rarr\":\"â† \",\n  \"twoheadrightarrow\":\"â† \",\n  \"Darr\":\"â†¡\",\n  \"larrtl\":\"â†¢\",\n  \"leftarrowtail\":\"â†¢\",\n  \"rarrtl\":\"â†£\",\n  \"rightarrowtail\":\"â†£\",\n  \"leftteearrow\":\"â†¤\",\n  \"mapstoleft\":\"â†¤\",\n  \"mapstoup\":\"â†¥\",\n  \"upteearrow\":\"â†¥\",\n  \"map\":\"â†¦\",\n  \"mapsto\":\"â†¦\",\n  \"rightteearrow\":\"â†¦\",\n  \"downteearrow\":\"â†§\",\n  \"mapstodown\":\"â†§\",\n  \"hookleftarrow\":\"â†©\",\n  \"larrhk\":\"â†©\",\n  \"hookrightarrow\":\"â†ª\",\n  \"rarrhk\":\"â†ª\",\n  \"larrlp\":\"â†«\",\n  \"looparrowleft\":\"â†«\",\n  \"looparrowright\":\"â†¬\",\n  \"rarrlp\":\"â†¬\",\n  \"harrw\":\"â†­\",\n  \"leftrightsquigarrow\":\"â†­\",\n  \"lsh\":\"â†°\",\n  \"rsh\":\"â†±\",\n  \"ldsh\":\"â†²\",\n  \"rdsh\":\"â†³\",\n  \"crarr\":\"â†µ\",\n  \"cularr\":\"â†¶\",\n  \"curvearrowleft\":\"â†¶\",\n  \"curarr\":\"â†·\",\n  \"curvearrowright\":\"â†·\",\n  \"circlearrowleft\":\"â†º\",\n  \"olarr\":\"â†º\",\n  \"circlearrowright\":\"â†»\",\n  \"orarr\":\"â†»\",\n  \"leftharpoonup\":\"â†¼\",\n  \"leftvector\":\"â†¼\",\n  \"lharu\":\"â†¼\",\n  \"downleftvector\":\"â†½\",\n  \"leftharpoondown\":\"â†½\",\n  \"lhard\":\"â†½\",\n  \"rightupvector\":\"â†¾\",\n  \"uharr\":\"â†¾\",\n  \"upharpoonright\":\"â†¾\",\n  \"leftupvector\":\"â†¿\",\n  \"uharl\":\"â†¿\",\n  \"upharpoonleft\":\"â†¿\",\n  \"rharu\":\"â‡€\",\n  \"rightharpoonup\":\"â‡€\",\n  \"rightvector\":\"â‡€\",\n  \"downrightvector\":\"â‡\",\n  \"rhard\":\"â‡\",\n  \"rightharpoondown\":\"â‡\",\n  \"dharr\":\"â‡‚\",\n  \"downharpoonright\":\"â‡‚\",\n  \"rightdownvector\":\"â‡‚\",\n  \"dharl\":\"â‡ƒ\",\n  \"downharpoonleft\":\"â‡ƒ\",\n  \"leftdownvector\":\"â‡ƒ\",\n  \"rightarrowleftarrow\":\"â‡„\",\n  \"rightleftarrows\":\"â‡„\",\n  \"rlarr\":\"â‡„\",\n  \"udarr\":\"â‡…\",\n  \"uparrowdownarrow\":\"â‡…\",\n  \"leftarrowrightarrow\":\"â‡†\",\n  \"leftrightarrows\":\"â‡†\",\n  \"lrarr\":\"â‡†\",\n  \"leftleftarrows\":\"â‡‡\",\n  \"llarr\":\"â‡‡\",\n  \"upuparrows\":\"â‡ˆ\",\n  \"uuarr\":\"â‡ˆ\",\n  \"rightrightarrows\":\"â‡‰\",\n  \"rrarr\":\"â‡‰\",\n  \"ddarr\":\"â‡Š\",\n  \"downdownarrows\":\"â‡Š\",\n  \"leftrightharpoons\":\"â‡‹\",\n  \"lrhar\":\"â‡‹\",\n  \"reverseequilibrium\":\"â‡‹\",\n  \"equilibrium\":\"â‡Œ\",\n  \"rightleftharpoons\":\"â‡Œ\",\n  \"rlhar\":\"â‡Œ\",\n  \"doubleleftarrow\":\"â‡\",\n  \"lArr\":\"â‡\",\n  \"Leftarrow\":\"â‡\",\n  \"nlArr\":\"â‡\",\n  \"nLeftarrow\":\"â‡\",\n  \"doubleuparrow\":\"â‡‘\",\n  \"uArr\":\"â‡‘\",\n  \"Uparrow\":\"â‡‘\",\n  \"doublerightarrow\":\"â‡’\",\n  \"implies\":\"â‡’\",\n  \"rArr\":\"â‡’\",\n  \"Rightarrow\":\"â‡’\",\n  \"nrArr\":\"â‡\",\n  \"nRightarrow\":\"â‡\",\n  \"dArr\":\"â‡“\",\n  \"doubledownarrow\":\"â‡“\",\n  \"Downarrow\":\"â‡“\",\n  \"doubleleftrightarrow\":\"â‡”\",\n  \"hArr\":\"â‡”\",\n  \"iff\":\"â‡”\",\n  \"Leftrightarrow\":\"â‡”\",\n  \"nhArr\":\"â‡\",\n  \"nLeftrightarrow\":\"â‡\",\n  \"doubleupdownarrow\":\"â‡•\",\n  \"Updownarrow\":\"â‡•\",\n  \"vArr\":\"â‡•\",\n  \"nwArr\":\"â‡–\",\n  \"neArr\":\"â‡—\",\n  \"seArr\":\"â‡˜\",\n  \"swArr\":\"â‡™\",\n  \"laarr\":\"â‡š\",\n  \"lleftarrow\":\"â‡š\",\n  \"raarr\":\"â‡›\",\n  \"rrightarrow\":\"â‡›\",\n  \"zigrarr\":\"â‡\",\n  \"larrb\":\"â‡¤\",\n  \"leftarrowbar\":\"â‡¤\",\n  \"rarrb\":\"â‡¥\",\n  \"rightarrowbar\":\"â‡¥\",\n  \"downarrowuparrow\":\"â‡µ\",\n  \"duarr\":\"â‡µ\",\n  \"loarr\":\"â‡½\",\n  \"roarr\":\"â‡¾\",\n  \"hoarr\":\"â‡¿\",\n  \"forall\":\"âˆ€\",\n  \"comp\":\"âˆ\",\n  \"complement\":\"âˆ\",\n  \"part\":\"âˆ‚\",\n  \"partiald\":\"âˆ‚\",\n  \"npart\":\"âˆ‚Ì¸\",\n  \"exist\":\"âˆƒ\",\n  \"exists\":\"âˆƒ\",\n  \"nexist\":\"âˆ„\",\n  \"nexists\":\"âˆ„\",\n  \"notexists\":\"âˆ„\",\n  \"empty\":\"âˆ…\",\n  \"emptyset\":\"âˆ…\",\n  \"emptyv\":\"âˆ…\",\n  \"varnothing\":\"âˆ…\",\n  \"del\":\"âˆ‡\",\n  \"nabla\":\"âˆ‡\",\n  \"element\":\"âˆˆ\",\n  \"in\":\"âˆˆ\",\n  \"isin\":\"âˆˆ\",\n  \"isinv\":\"âˆˆ\",\n  \"notelement\":\"âˆ‰\",\n  \"notin\":\"âˆ‰\",\n  \"notinva\":\"âˆ‰\",\n  \"ni\":\"âˆ‹\",\n  \"niv\":\"âˆ‹\",\n  \"reverseelement\":\"âˆ‹\",\n  \"suchthat\":\"âˆ‹\",\n  \"notni\":\"âˆŒ\",\n  \"notniva\":\"âˆŒ\",\n  \"notreverseelement\":\"âˆŒ\",\n  \"backepsilon\":\"Ï¶\",\n  \"bepsi\":\"Ï¶\",\n  \"prod\":\"âˆ\",\n  \"product\":\"âˆ\",\n  \"coprod\":\"âˆ\",\n  \"coproduct\":\"âˆ\",\n  \"sum\":\"âˆ‘\",\n  \"plus\":\"+\",\n  \"plusminus\":\"Â±\",\n  \"plusmn\":\"Â±\",\n  \"pm\":\"Â±\",\n  \"div\":\"Ã·\",\n  \"divide\":\"Ã·\",\n  \"times\":\"Ã—\",\n  \"lt\":\"<\",\n  \"nless\":\"â‰®\",\n  \"nlt\":\"â‰®\",\n  \"notless\":\"â‰®\",\n  \"nvlt\":\"<âƒ’\",\n  \"equals\":\"=\",\n  \"ne\":\"â‰ \",\n  \"notequal\":\"â‰ \",\n  \"bne\":\"=âƒ¥\",\n  \"equal\":\"â©µ\",\n  \"gt\":\">\",\n  \"ngt\":\"â‰¯\",\n  \"ngtr\":\"â‰¯\",\n  \"notgreater\":\"â‰¯\",\n  \"nvgt\":\">âƒ’\",\n  \"not\":\"Â¬\",\n  \"verbar\":\"|\",\n  \"vert\":\"|\",\n  \"verticalline\":\"|\",\n  \"brvbar\":\"Â¦\",\n  \"minus\":\"âˆ’\",\n  \"minusplus\":\"âˆ“\",\n  \"mnplus\":\"âˆ“\",\n  \"mp\":\"âˆ“\",\n  \"dotplus\":\"âˆ”\",\n  \"plusdo\":\"âˆ”\",\n  \"frasl\":\"â„\",\n  \"backslash\":\"âˆ–\",\n  \"setminus\":\"âˆ–\",\n  \"setmn\":\"âˆ–\",\n  \"smallsetminus\":\"âˆ–\",\n  \"ssetmn\":\"âˆ–\",\n  \"lowast\":\"âˆ—\",\n  \"compfn\":\"âˆ˜\",\n  \"smallcircle\":\"âˆ˜\",\n  \"radic\":\"âˆš\",\n  \"sqrt\":\"âˆš\",\n  \"prop\":\"âˆ\",\n  \"proportional\":\"âˆ\",\n  \"propto\":\"âˆ\",\n  \"varpropto\":\"âˆ\",\n  \"vprop\":\"âˆ\",\n  \"infin\":\"âˆ\",\n  \"angrt\":\"âˆŸ\",\n  \"ang\":\"âˆ \",\n  \"angle\":\"âˆ \",\n  \"nang\":\"âˆ âƒ’\",\n  \"angmsd\":\"âˆ¡\",\n  \"measuredangle\":\"âˆ¡\",\n  \"angsph\":\"âˆ¢\",\n  \"mid\":\"âˆ£\",\n  \"shortmid\":\"âˆ£\",\n  \"smid\":\"âˆ£\",\n  \"verticalbar\":\"âˆ£\",\n  \"nmid\":\"âˆ¤\",\n  \"notverticalbar\":\"âˆ¤\",\n  \"nshortmid\":\"âˆ¤\",\n  \"nsmid\":\"âˆ¤\",\n  \"doubleverticalbar\":\"âˆ¥\",\n  \"par\":\"âˆ¥\",\n  \"parallel\":\"âˆ¥\",\n  \"shortparallel\":\"âˆ¥\",\n  \"spar\":\"âˆ¥\",\n  \"notdoubleverticalbar\":\"âˆ¦\",\n  \"npar\":\"âˆ¦\",\n  \"nparallel\":\"âˆ¦\",\n  \"nshortparallel\":\"âˆ¦\",\n  \"nspar\":\"âˆ¦\",\n  \"and\":\"âˆ§\",\n  \"wedge\":\"âˆ§\",\n  \"or\":\"âˆ¨\",\n  \"vee\":\"âˆ¨\",\n  \"cap\":\"âˆ©\",\n  \"caps\":\"âˆ©ï¸€\",\n  \"cup\":\"âˆª\",\n  \"cups\":\"âˆªï¸€\",\n  \"int\":\"âˆ«\",\n  \"integral\":\"âˆ«\",\n  \"Int\":\"âˆ¬\",\n  \"iiint\":\"âˆ­\",\n  \"tint\":\"âˆ­\",\n  \"iiiint\":\"â¨Œ\",\n  \"qint\":\"â¨Œ\",\n  \"conint\":\"âˆ®\",\n  \"contourintegral\":\"âˆ®\",\n  \"oint\":\"âˆ®\",\n  \"Conint\":\"âˆ¯\",\n  \"doublecontourintegral\":\"âˆ¯\",\n  \"cconint\":\"âˆ°\",\n  \"cwint\":\"âˆ±\",\n  \"clockwisecontourintegral\":\"âˆ²\",\n  \"cwconint\":\"âˆ²\",\n  \"awconint\":\"âˆ³\",\n  \"counterclockwisecontourintegral\":\"âˆ³\",\n  \"there4\":\"âˆ´\",\n  \"therefore\":\"âˆ´\",\n  \"becaus\":\"âˆµ\",\n  \"because\":\"âˆµ\",\n  \"ratio\":\"âˆ¶\",\n  \"Colon\":\"âˆ·\",\n  \"proportion\":\"âˆ·\",\n  \"dotminus\":\"âˆ¸\",\n  \"minusd\":\"âˆ¸\",\n  \"mddot\":\"âˆº\",\n  \"homtht\":\"âˆ»\",\n  \"sim\":\"âˆ¼\",\n  \"thicksim\":\"âˆ¼\",\n  \"thksim\":\"âˆ¼\",\n  \"Tilde\":\"âˆ¼\",\n  \"nottilde\":\"â‰\",\n  \"nsim\":\"â‰\",\n  \"nvsim\":\"âˆ¼âƒ’\",\n  \"backsim\":\"âˆ½\",\n  \"bsim\":\"âˆ½\",\n  \"race\":\"âˆ½Ì±\",\n  \"ac\":\"âˆ¾\",\n  \"mstpos\":\"âˆ¾\",\n  \"ace\":\"âˆ¾Ì³\",\n  \"acd\":\"âˆ¿\",\n  \"verticaltilde\":\"â‰€\",\n  \"wr\":\"â‰€\",\n  \"wreath\":\"â‰€\",\n  \"eqsim\":\"â‰‚\",\n  \"equaltilde\":\"â‰‚\",\n  \"esim\":\"â‰‚\",\n  \"nesim\":\"â‰‚Ì¸\",\n  \"notequaltilde\":\"â‰‚Ì¸\",\n  \"sime\":\"â‰ƒ\",\n  \"simeq\":\"â‰ƒ\",\n  \"tildeequal\":\"â‰ƒ\",\n  \"nottildeequal\":\"â‰„\",\n  \"nsime\":\"â‰„\",\n  \"nsimeq\":\"â‰„\",\n  \"cong\":\"â‰…\",\n  \"tildefullequal\":\"â‰…\",\n  \"ncong\":\"â‰‡\",\n  \"nottildefullequal\":\"â‰‡\",\n  \"simne\":\"â‰†\",\n  \"ap\":\"â‰ˆ\",\n  \"approx\":\"â‰ˆ\",\n  \"asymp\":\"â‰ˆ\",\n  \"thickapprox\":\"â‰ˆ\",\n  \"thkap\":\"â‰ˆ\",\n  \"tildetilde\":\"â‰ˆ\",\n  \"nap\":\"â‰‰\",\n  \"napprox\":\"â‰‰\",\n  \"nottildetilde\":\"â‰‰\",\n  \"ape\":\"â‰Š\",\n  \"approxeq\":\"â‰Š\",\n  \"apid\":\"â‰‹\",\n  \"napid\":\"â‰‹Ì¸\",\n  \"backcong\":\"â‰Œ\",\n  \"bcong\":\"â‰Œ\",\n  \"asympeq\":\"â‰\",\n  \"CupCap\":\"â‰\",\n  \"notcupcap\":\"â‰­\",\n  \"nvap\":\"â‰âƒ’\",\n  \"bump\":\"â‰\",\n  \"Bumpeq\":\"â‰\",\n  \"humpdownhump\":\"â‰\",\n  \"nbump\":\"â‰Ì¸\",\n  \"nothumpdownhump\":\"â‰Ì¸\",\n  \"bumpe\":\"â‰\",\n  \"bumpeq\":\"â‰\",\n  \"humpequal\":\"â‰\",\n  \"nbumpe\":\"â‰Ì¸\",\n  \"nothumpequal\":\"â‰Ì¸\",\n  \"doteq\":\"â‰\",\n  \"dotequal\":\"â‰\",\n  \"esdot\":\"â‰\",\n  \"nedot\":\"â‰Ì¸\",\n  \"doteqdot\":\"â‰‘\",\n  \"eDot\":\"â‰‘\",\n  \"efdot\":\"â‰’\",\n  \"fallingdotseq\":\"â‰’\",\n  \"erdot\":\"â‰“\",\n  \"risingdotseq\":\"â‰“\",\n  \"assign\":\"â‰”\",\n  \"colone\":\"â‰”\",\n  \"coloneq\":\"â‰”\",\n  \"ecolon\":\"â‰•\",\n  \"eqcolon\":\"â‰•\",\n  \"ecir\":\"â‰–\",\n  \"eqcirc\":\"â‰–\",\n  \"circeq\":\"â‰—\",\n  \"cire\":\"â‰—\",\n  \"wedgeq\":\"â‰™\",\n  \"veeeq\":\"â‰š\",\n  \"triangleq\":\"â‰œ\",\n  \"trie\":\"â‰œ\",\n  \"equest\":\"â‰Ÿ\",\n  \"questeq\":\"â‰Ÿ\",\n  \"congruent\":\"â‰¡\",\n  \"equiv\":\"â‰¡\",\n  \"nequiv\":\"â‰¢\",\n  \"notcongruent\":\"â‰¢\",\n  \"bnequiv\":\"â‰¡âƒ¥\",\n  \"le\":\"â‰¤\",\n  \"leq\":\"â‰¤\",\n  \"nle\":\"â‰°\",\n  \"nleq\":\"â‰°\",\n  \"notlessequal\":\"â‰°\",\n  \"nvle\":\"â‰¤âƒ’\",\n  \"ge\":\"â‰¥\",\n  \"geq\":\"â‰¥\",\n  \"greaterequal\":\"â‰¥\",\n  \"nge\":\"â‰±\",\n  \"ngeq\":\"â‰±\",\n  \"notgreaterequal\":\"â‰±\",\n  \"nvge\":\"â‰¥âƒ’\",\n  \"lE\":\"â‰¦\",\n  \"leqq\":\"â‰¦\",\n  \"lessfullequal\":\"â‰¦\",\n  \"nlE\":\"â‰¦Ì¸\",\n  \"nleqq\":\"â‰¦Ì¸\",\n  \"gE\":\"â‰§\",\n  \"geqq\":\"â‰§\",\n  \"greaterfullequal\":\"â‰§\",\n  \"ngE\":\"â‰§Ì¸\",\n  \"ngeqq\":\"â‰§Ì¸\",\n  \"notgreaterfullequal\":\"â‰§Ì¸\",\n  \"lnE\":\"â‰¨\",\n  \"lneqq\":\"â‰¨\",\n  \"lvertneqq\":\"â‰¨ï¸€\",\n  \"lvne\":\"â‰¨ï¸€\",\n  \"gnE\":\"â‰©\",\n  \"gneqq\":\"â‰©\",\n  \"gvertneqq\":\"â‰©ï¸€\",\n  \"gvne\":\"â‰©ï¸€\",\n  \"ll\":\"â‰ª\",\n  \"Lt\":\"â‰ª\",\n  \"nestedlessless\":\"â‰ª\",\n  \"nltv\":\"â‰ªÌ¸\",\n  \"notlessless\":\"â‰ªÌ¸\",\n  \"nLt\":\"â‰ªâƒ’\",\n  \"gg\":\"â‰«\",\n  \"Gt\":\"â‰«\",\n  \"nestedgreatergreater\":\"â‰«\",\n  \"ngtv\":\"â‰«Ì¸\",\n  \"notgreatergreater\":\"â‰«Ì¸\",\n  \"nGt\":\"â‰«âƒ’\",\n  \"between\":\"â‰¬\",\n  \"twixt\":\"â‰¬\",\n  \"lesssim\":\"â‰²\",\n  \"lesstilde\":\"â‰²\",\n  \"lsim\":\"â‰²\",\n  \"nlsim\":\"â‰´\",\n  \"notlesstilde\":\"â‰´\",\n  \"greatertilde\":\"â‰³\",\n  \"gsim\":\"â‰³\",\n  \"gtrsim\":\"â‰³\",\n  \"ngsim\":\"â‰µ\",\n  \"notgreatertilde\":\"â‰µ\",\n  \"lessgreater\":\"â‰¶\",\n  \"lessgtr\":\"â‰¶\",\n  \"lg\":\"â‰¶\",\n  \"notlessgreater\":\"â‰¸\",\n  \"ntlg\":\"â‰¸\",\n  \"gl\":\"â‰·\",\n  \"greaterless\":\"â‰·\",\n  \"gtrless\":\"â‰·\",\n  \"notgreaterless\":\"â‰¹\",\n  \"ntgl\":\"â‰¹\",\n  \"pr\":\"â‰º\",\n  \"prec\":\"â‰º\",\n  \"precedes\":\"â‰º\",\n  \"notprecedes\":\"âŠ€\",\n  \"npr\":\"âŠ€\",\n  \"nprec\":\"âŠ€\",\n  \"sc\":\"â‰»\",\n  \"succ\":\"â‰»\",\n  \"succeeds\":\"â‰»\",\n  \"notsucceeds\":\"âŠ\",\n  \"nsc\":\"âŠ\",\n  \"nsucc\":\"âŠ\",\n  \"prcue\":\"â‰¼\",\n  \"preccurlyeq\":\"â‰¼\",\n  \"precedesslantequal\":\"â‰¼\",\n  \"notprecedesslantequal\":\"â‹ \",\n  \"nprcue\":\"â‹ \",\n  \"sccue\":\"â‰½\",\n  \"succcurlyeq\":\"â‰½\",\n  \"succeedsslantequal\":\"â‰½\",\n  \"notsucceedsslantequal\":\"â‹¡\",\n  \"nsccue\":\"â‹¡\",\n  \"precedestilde\":\"â‰¾\",\n  \"precsim\":\"â‰¾\",\n  \"prsim\":\"â‰¾\",\n  \"scsim\":\"â‰¿\",\n  \"succeedstilde\":\"â‰¿\",\n  \"succsim\":\"â‰¿\",\n  \"notsucceedstilde\":\"â‰¿Ì¸\",\n  \"sub\":\"âŠ‚\",\n  \"subset\":\"âŠ‚\",\n  \"nsub\":\"âŠ„\",\n  \"notsubset\":\"âŠ‚âƒ’\",\n  \"nsubset\":\"âŠ‚âƒ’\",\n  \"vnsub\":\"âŠ‚âƒ’\",\n  \"sup\":\"âŠƒ\",\n  \"superset\":\"âŠƒ\",\n  \"supset\":\"âŠƒ\",\n  \"nsup\":\"âŠ…\",\n  \"notsuperset\":\"âŠƒâƒ’\",\n  \"nsupset\":\"âŠƒâƒ’\",\n  \"vnsup\":\"âŠƒâƒ’\",\n  \"sube\":\"âŠ†\",\n  \"subseteq\":\"âŠ†\",\n  \"subsetequal\":\"âŠ†\",\n  \"notsubsetequal\":\"âŠˆ\",\n  \"nsube\":\"âŠˆ\",\n  \"nsubseteq\":\"âŠˆ\",\n  \"supe\":\"âŠ‡\",\n  \"supersetequal\":\"âŠ‡\",\n  \"supseteq\":\"âŠ‡\",\n  \"notsupersetequal\":\"âŠ‰\",\n  \"nsupe\":\"âŠ‰\",\n  \"nsupseteq\":\"âŠ‰\",\n  \"subne\":\"âŠŠ\",\n  \"subsetneq\":\"âŠŠ\",\n  \"varsubsetneq\":\"âŠŠï¸€\",\n  \"vsubne\":\"âŠŠï¸€\",\n  \"supne\":\"âŠ‹\",\n  \"supsetneq\":\"âŠ‹\",\n  \"varsupsetneq\":\"âŠ‹ï¸€\",\n  \"vsupne\":\"âŠ‹ï¸€\",\n  \"cupdot\":\"âŠ\",\n  \"unionplus\":\"âŠ\",\n  \"uplus\":\"âŠ\",\n  \"sqsub\":\"âŠ\",\n  \"sqsubset\":\"âŠ\",\n  \"squaresubset\":\"âŠ\",\n  \"notsquaresubset\":\"âŠÌ¸\",\n  \"sqsup\":\"âŠ\",\n  \"sqsupset\":\"âŠ\",\n  \"squaresuperset\":\"âŠ\",\n  \"notsquaresuperset\":\"âŠÌ¸\",\n  \"sqsube\":\"âŠ‘\",\n  \"sqsubseteq\":\"âŠ‘\",\n  \"squaresubsetequal\":\"âŠ‘\",\n  \"notsquaresubsetequal\":\"â‹¢\",\n  \"nsqsube\":\"â‹¢\",\n  \"sqsupe\":\"âŠ’\",\n  \"sqsupseteq\":\"âŠ’\",\n  \"squaresupersetequal\":\"âŠ’\",\n  \"notsquaresupersetequal\":\"â‹£\",\n  \"nsqsupe\":\"â‹£\",\n  \"sqcap\":\"âŠ“\",\n  \"sqcaps\":\"âŠ“ï¸€\",\n  \"squareintersection\":\"âŠ“\",\n  \"sqcup\":\"âŠ”\",\n  \"sqcups\":\"âŠ”ï¸€\",\n  \"squareunion\":\"âŠ”\",\n  \"circleplus\":\"âŠ•\",\n  \"oplus\":\"âŠ•\",\n  \"circleminus\":\"âŠ–\",\n  \"ominus\":\"âŠ–\",\n  \"circletimes\":\"âŠ—\",\n  \"otimes\":\"âŠ—\",\n  \"osol\":\"âŠ˜\",\n  \"circledot\":\"âŠ™\",\n  \"odot\":\"âŠ™\",\n  \"circledcirc\":\"âŠš\",\n  \"ocir\":\"âŠš\",\n  \"circledast\":\"âŠ›\",\n  \"oast\":\"âŠ›\",\n  \"circleddash\":\"âŠ\",\n  \"odash\":\"âŠ\",\n  \"boxplus\":\"âŠ\",\n  \"plusb\":\"âŠ\",\n  \"boxminus\":\"âŠŸ\",\n  \"minusb\":\"âŠŸ\",\n  \"boxtimes\":\"âŠ \",\n  \"timesb\":\"âŠ \",\n  \"dotsquare\":\"âŠ¡\",\n  \"sdotb\":\"âŠ¡\",\n  \"righttee\":\"âŠ¢\",\n  \"vdash\":\"âŠ¢\",\n  \"nvdash\":\"âŠ¬\",\n  \"dashv\":\"âŠ£\",\n  \"lefttee\":\"âŠ£\",\n  \"downtee\":\"âŠ¤\",\n  \"top\":\"âŠ¤\",\n  \"bot\":\"âŠ¥\",\n  \"bottom\":\"âŠ¥\",\n  \"perp\":\"âŠ¥\",\n  \"uptee\":\"âŠ¥\",\n  \"models\":\"âŠ§\",\n  \"doublerighttee\":\"âŠ¨\",\n  \"vDash\":\"âŠ¨\",\n  \"nvDash\":\"âŠ­\",\n  \"Vdash\":\"âŠ©\",\n  \"nVdash\":\"âŠ®\",\n  \"vvdash\":\"âŠª\",\n  \"VDash\":\"âŠ«\",\n  \"nVDash\":\"âŠ¯\",\n  \"prurel\":\"âŠ°\",\n  \"lefttriangle\":\"âŠ²\",\n  \"vartriangleleft\":\"âŠ²\",\n  \"vltri\":\"âŠ²\",\n  \"nltri\":\"â‹ª\",\n  \"notlefttriangle\":\"â‹ª\",\n  \"ntriangleleft\":\"â‹ª\",\n  \"righttriangle\":\"âŠ³\",\n  \"vartriangleright\":\"âŠ³\",\n  \"vrtri\":\"âŠ³\",\n  \"notrighttriangle\":\"â‹«\",\n  \"nrtri\":\"â‹«\",\n  \"ntriangleright\":\"â‹«\",\n  \"lefttriangleequal\":\"âŠ´\",\n  \"ltrie\":\"âŠ´\",\n  \"trianglelefteq\":\"âŠ´\",\n  \"nltrie\":\"â‹¬\",\n  \"notlefttriangleequal\":\"â‹¬\",\n  \"ntrianglelefteq\":\"â‹¬\",\n  \"nvltrie\":\"âŠ´âƒ’\",\n  \"righttriangleequal\":\"âŠµ\",\n  \"rtrie\":\"âŠµ\",\n  \"trianglerighteq\":\"âŠµ\",\n  \"notrighttriangleequal\":\"â‹­\",\n  \"nrtrie\":\"â‹­\",\n  \"ntrianglerighteq\":\"â‹­\",\n  \"nvrtrie\":\"âŠµâƒ’\",\n  \"origof\":\"âŠ¶\",\n  \"imof\":\"âŠ·\",\n  \"multimap\":\"âŠ¸\",\n  \"mumap\":\"âŠ¸\",\n  \"hercon\":\"âŠ¹\",\n  \"intcal\":\"âŠº\",\n  \"intercal\":\"âŠº\",\n  \"veebar\":\"âŠ»\",\n  \"barvee\":\"âŠ½\",\n  \"angrtvb\":\"âŠ¾\",\n  \"lrtri\":\"âŠ¿\",\n  \"bigwedge\":\"â‹€\",\n  \"Wedge\":\"â‹€\",\n  \"xwedge\":\"â‹€\",\n  \"bigvee\":\"â‹\",\n  \"Vee\":\"â‹\",\n  \"xvee\":\"â‹\",\n  \"bigcap\":\"â‹‚\",\n  \"intersection\":\"â‹‚\",\n  \"xcap\":\"â‹‚\",\n  \"bigcup\":\"â‹ƒ\",\n  \"union\":\"â‹ƒ\",\n  \"xcup\":\"â‹ƒ\",\n  \"diam\":\"â‹„\",\n  \"diamond\":\"â‹„\",\n  \"sdot\":\"â‹…\",\n  \"sstarf\":\"â‹†\",\n  \"Star\":\"â‹†\",\n  \"divideontimes\":\"â‹‡\",\n  \"divonx\":\"â‹‡\",\n  \"bowtie\":\"â‹ˆ\",\n  \"ltimes\":\"â‹‰\",\n  \"rtimes\":\"â‹Š\",\n  \"leftthreetimes\":\"â‹‹\",\n  \"lthree\":\"â‹‹\",\n  \"rightthreetimes\":\"â‹Œ\",\n  \"rthree\":\"â‹Œ\",\n  \"backsimeq\":\"â‹\",\n  \"bsime\":\"â‹\",\n  \"curlyvee\":\"â‹\",\n  \"cuvee\":\"â‹\",\n  \"curlywedge\":\"â‹\",\n  \"cuwed\":\"â‹\",\n  \"Sub\":\"â‹\",\n  \"Subset\":\"â‹\",\n  \"Sup\":\"â‹‘\",\n  \"Supset\":\"â‹‘\",\n  \"Cap\":\"â‹’\",\n  \"Cup\":\"â‹“\",\n  \"fork\":\"â‹”\",\n  \"pitchfork\":\"â‹”\",\n  \"epar\":\"â‹•\",\n  \"lessdot\":\"â‹–\",\n  \"ltdot\":\"â‹–\",\n  \"gtdot\":\"â‹—\",\n  \"gtrdot\":\"â‹—\",\n  \"Ll\":\"â‹˜\",\n  \"nll\":\"â‹˜Ì¸\",\n  \"Gg\":\"â‹™\",\n  \"ggg\":\"â‹™\",\n  \"ngg\":\"â‹™Ì¸\",\n  \"leg\":\"â‹š\",\n  \"lesg\":\"â‹šï¸€\",\n  \"lesseqgtr\":\"â‹š\",\n  \"lessequalgreater\":\"â‹š\",\n  \"gel\":\"â‹›\",\n  \"gesl\":\"â‹›ï¸€\",\n  \"greaterequalless\":\"â‹›\",\n  \"gtreqless\":\"â‹›\",\n  \"cuepr\":\"â‹\",\n  \"curlyeqprec\":\"â‹\",\n  \"cuesc\":\"â‹Ÿ\",\n  \"curlyeqsucc\":\"â‹Ÿ\",\n  \"lnsim\":\"â‹¦\",\n  \"gnsim\":\"â‹§\",\n  \"precnsim\":\"â‹¨\",\n  \"prnsim\":\"â‹¨\",\n  \"scnsim\":\"â‹©\",\n  \"succnsim\":\"â‹©\",\n  \"vellip\":\"â‹®\",\n  \"ctdot\":\"â‹¯\",\n  \"utdot\":\"â‹°\",\n  \"dtdot\":\"â‹±\",\n  \"disin\":\"â‹²\",\n  \"isinsv\":\"â‹³\",\n  \"isins\":\"â‹´\",\n  \"isindot\":\"â‹µ\",\n  \"notindot\":\"â‹µÌ¸\",\n  \"notinvc\":\"â‹¶\",\n  \"notinvb\":\"â‹·\",\n  \"isine\":\"â‹¹\",\n  \"notine\":\"â‹¹Ì¸\",\n  \"nisd\":\"â‹º\",\n  \"xnis\":\"â‹»\",\n  \"nis\":\"â‹¼\",\n  \"notnivc\":\"â‹½\",\n  \"notnivb\":\"â‹¾\",\n  \"barwed\":\"âŒ…\",\n  \"barwedge\":\"âŒ…\",\n  \"Barwed\":\"âŒ†\",\n  \"doublebarwedge\":\"âŒ†\",\n  \"drcrop\":\"âŒŒ\",\n  \"dlcrop\":\"âŒ\",\n  \"urcrop\":\"âŒ\",\n  \"ulcrop\":\"âŒ\",\n  \"bnot\":\"âŒ\",\n  \"profline\":\"âŒ’\",\n  \"profsurf\":\"âŒ“\",\n  \"telrec\":\"âŒ•\",\n  \"target\":\"âŒ–\",\n  \"ulcorn\":\"âŒœ\",\n  \"ulcorner\":\"âŒœ\",\n  \"urcorn\":\"âŒ\",\n  \"urcorner\":\"âŒ\",\n  \"dlcorn\":\"âŒ\",\n  \"llcorner\":\"âŒ\",\n  \"drcorn\":\"âŒŸ\",\n  \"lrcorner\":\"âŒŸ\",\n  \"frown\":\"âŒ¢\",\n  \"sfrown\":\"âŒ¢\",\n  \"smile\":\"âŒ£\",\n  \"ssmile\":\"âŒ£\",\n  \"cylcty\":\"âŒ­\",\n  \"profalar\":\"âŒ®\",\n  \"topbot\":\"âŒ¶\",\n  \"ovbar\":\"âŒ½\",\n  \"solbar\":\"âŒ¿\",\n  \"angzarr\":\"â¼\",\n  \"lmoust\":\"â°\",\n  \"lmoustache\":\"â°\",\n  \"rmoust\":\"â±\",\n  \"rmoustache\":\"â±\",\n  \"overbracket\":\"â´\",\n  \"tbrk\":\"â´\",\n  \"bbrk\":\"âµ\",\n  \"underbracket\":\"âµ\",\n  \"bbrktbrk\":\"â¶\",\n  \"overparenthesis\":\"âœ\",\n  \"underparenthesis\":\"â\",\n  \"overbrace\":\"â\",\n  \"underbrace\":\"âŸ\",\n  \"trpezium\":\"â¢\",\n  \"elinters\":\"â§\",\n  \"blank\":\"â£\",\n  \"boxh\":\"â”€\",\n  \"horizontalline\":\"â”€\",\n  \"boxv\":\"â”‚\",\n  \"boxdr\":\"â”Œ\",\n  \"boxdl\":\"â”\",\n  \"boxur\":\"â””\",\n  \"boxul\":\"â”˜\",\n  \"boxvr\":\"â”œ\",\n  \"boxvl\":\"â”¤\",\n  \"boxhd\":\"â”¬\",\n  \"boxhu\":\"â”´\",\n  \"boxvh\":\"â”¼\",\n  \"boxH\":\"â•\",\n  \"boxV\":\"â•‘\",\n  \"boxdR\":\"â•’\",\n  \"boxDr\":\"â•“\",\n  \"boxDR\":\"â•”\",\n  \"boxdL\":\"â••\",\n  \"boxDl\":\"â•–\",\n  \"boxDL\":\"â•—\",\n  \"boxuR\":\"â•˜\",\n  \"boxUr\":\"â•™\",\n  \"boxUR\":\"â•š\",\n  \"boxuL\":\"â•›\",\n  \"boxUl\":\"â•œ\",\n  \"boxUL\":\"â•\",\n  \"boxvR\":\"â•\",\n  \"boxVr\":\"â•Ÿ\",\n  \"boxVR\":\"â• \",\n  \"boxvL\":\"â•¡\",\n  \"boxVl\":\"â•¢\",\n  \"boxVL\":\"â•£\",\n  \"boxHd\":\"â•¤\",\n  \"boxhD\":\"â•¥\",\n  \"boxHD\":\"â•¦\",\n  \"boxHu\":\"â•§\",\n  \"boxhU\":\"â•¨\",\n  \"boxHU\":\"â•©\",\n  \"boxvH\":\"â•ª\",\n  \"boxVh\":\"â•«\",\n  \"boxVH\":\"â•¬\",\n  \"uhblk\":\"â–€\",\n  \"lhblk\":\"â–„\",\n  \"block\":\"â–ˆ\",\n  \"blk14\":\"â–‘\",\n  \"blk12\":\"â–’\",\n  \"blk34\":\"â–“\",\n  \"squ\":\"â–¡\",\n  \"square\":\"â–¡\",\n  \"blacksquare\":\"â–ª\",\n  \"filledverysmallsquare\":\"â–ª\",\n  \"squarf\":\"â–ª\",\n  \"squf\":\"â–ª\",\n  \"emptyverysmallsquare\":\"â–«\",\n  \"rect\":\"â–­\",\n  \"marker\":\"â–®\",\n  \"fltns\":\"â–±\",\n  \"bigtriangleup\":\"â–³\",\n  \"xutri\":\"â–³\",\n  \"blacktriangle\":\"â–´\",\n  \"utrif\":\"â–´\",\n  \"triangle\":\"â–µ\",\n  \"utri\":\"â–µ\",\n  \"blacktriangleright\":\"â–¸\",\n  \"rtrif\":\"â–¸\",\n  \"rtri\":\"â–¹\",\n  \"triangleright\":\"â–¹\",\n  \"bigtriangledown\":\"â–½\",\n  \"xdtri\":\"â–½\",\n  \"blacktriangledown\":\"â–¾\",\n  \"dtrif\":\"â–¾\",\n  \"dtri\":\"â–¿\",\n  \"triangledown\":\"â–¿\",\n  \"blacktriangleleft\":\"â—‚\",\n  \"ltrif\":\"â—‚\",\n  \"ltri\":\"â—ƒ\",\n  \"triangleleft\":\"â—ƒ\",\n  \"loz\":\"â—Š\",\n  \"lozenge\":\"â—Š\",\n  \"cir\":\"â—‹\",\n  \"tridot\":\"â—¬\",\n  \"bigcirc\":\"â—¯\",\n  \"xcirc\":\"â—¯\",\n  \"ultri\":\"â—¸\",\n  \"urtri\":\"â—¹\",\n  \"lltri\":\"â—º\",\n  \"emptysmallsquare\":\"â—»\",\n  \"filledsmallsquare\":\"â—¼\",\n  \"bigstar\":\"â˜…\",\n  \"starf\":\"â˜…\",\n  \"star\":\"â˜†\",\n  \"phone\":\"â˜\",\n  \"female\":\"â™€\",\n  \"male\":\"â™‚\",\n  \"spades\":\"â™ \",\n  \"spadesuit\":\"â™ \",\n  \"clubs\":\"â™£\",\n  \"clubsuit\":\"â™£\",\n  \"hearts\":\"â™¥\",\n  \"heartsuit\":\"â™¥\",\n  \"diamondsuit\":\"â™¦\",\n  \"diams\":\"â™¦\",\n  \"sung\":\"â™ª\",\n  \"check\":\"âœ“\",\n  \"checkmark\":\"âœ“\",\n  \"cross\":\"âœ—\",\n  \"malt\":\"âœ \",\n  \"maltese\":\"âœ \",\n  \"sext\":\"âœ¶\",\n  \"verticalseparator\":\"â˜\",\n  \"bsolhsub\":\"âŸˆ\",\n  \"suphsol\":\"âŸ‰\",\n  \"longleftarrow\":\"âŸµ\",\n  \"xlarr\":\"âŸµ\",\n  \"longrightarrow\":\"âŸ¶\",\n  \"xrarr\":\"âŸ¶\",\n  \"longleftrightarrow\":\"âŸ·\",\n  \"xharr\":\"âŸ·\",\n  \"doublelongleftarrow\":\"âŸ¸\",\n  \"Longleftarrow\":\"âŸ¸\",\n  \"xlArr\":\"âŸ¸\",\n  \"doublelongrightarrow\":\"âŸ¹\",\n  \"Longrightarrow\":\"âŸ¹\",\n  \"xrArr\":\"âŸ¹\",\n  \"doublelongleftrightarrow\":\"âŸº\",\n  \"Longleftrightarrow\":\"âŸº\",\n  \"xhArr\":\"âŸº\",\n  \"longmapsto\":\"âŸ¼\",\n  \"xmap\":\"âŸ¼\",\n  \"dzigrarr\":\"âŸ¿\",\n  \"nvlarr\":\"â¤‚\",\n  \"nvrarr\":\"â¤ƒ\",\n  \"nvharr\":\"â¤„\",\n  \"Map\":\"â¤…\",\n  \"lbarr\":\"â¤Œ\",\n  \"bkarow\":\"â¤\",\n  \"lBarr\":\"â¤\",\n  \"dbkarow\":\"â¤\",\n  \"rBarr\":\"â¤\",\n  \"drbkarow\":\"â¤\",\n  \"rbarr\":\"â¤\",\n  \"RBarr\":\"â¤\",\n  \"ddotrahd\":\"â¤‘\",\n  \"uparrowbar\":\"â¤’\",\n  \"downarrowbar\":\"â¤“\",\n  \"Rarrtl\":\"â¤–\",\n  \"latail\":\"â¤™\",\n  \"ratail\":\"â¤š\",\n  \"lAtail\":\"â¤›\",\n  \"rAtail\":\"â¤œ\",\n  \"larrfs\":\"â¤\",\n  \"rarrfs\":\"â¤\",\n  \"larrbfs\":\"â¤Ÿ\",\n  \"rarrbfs\":\"â¤ \",\n  \"nwarhk\":\"â¤£\",\n  \"nearhk\":\"â¤¤\",\n  \"hksearow\":\"â¤¥\",\n  \"searhk\":\"â¤¥\",\n  \"hkswarow\":\"â¤¦\",\n  \"swarhk\":\"â¤¦\",\n  \"nwnear\":\"â¤§\",\n  \"nesear\":\"â¤¨\",\n  \"toea\":\"â¤¨\",\n  \"seswar\":\"â¤©\",\n  \"tosa\":\"â¤©\",\n  \"swnwar\":\"â¤ª\",\n  \"rarrc\":\"â¤³\",\n  \"nrarrc\":\"â¤³Ì¸\",\n  \"cudarrr\":\"â¤µ\",\n  \"ldca\":\"â¤¶\",\n  \"rdca\":\"â¤·\",\n  \"cudarrl\":\"â¤¸\",\n  \"larrpl\":\"â¤¹\",\n  \"curarrm\":\"â¤¼\",\n  \"cularrp\":\"â¤½\",\n  \"rarrpl\":\"â¥…\",\n  \"harrcir\":\"â¥ˆ\",\n  \"uarrocir\":\"â¥‰\",\n  \"lurdshar\":\"â¥Š\",\n  \"ldrushar\":\"â¥‹\",\n  \"leftrightvector\":\"â¥\",\n  \"rightupdownvector\":\"â¥\",\n  \"downleftrightvector\":\"â¥\",\n  \"leftupdownvector\":\"â¥‘\",\n  \"leftvectorbar\":\"â¥’\",\n  \"rightvectorbar\":\"â¥“\",\n  \"rightupvectorbar\":\"â¥”\",\n  \"rightdownvectorbar\":\"â¥•\",\n  \"downleftvectorbar\":\"â¥–\",\n  \"downrightvectorbar\":\"â¥—\",\n  \"leftupvectorbar\":\"â¥˜\",\n  \"leftdownvectorbar\":\"â¥™\",\n  \"leftteevector\":\"â¥š\",\n  \"rightteevector\":\"â¥›\",\n  \"rightupteevector\":\"â¥œ\",\n  \"rightdownteevector\":\"â¥\",\n  \"downleftteevector\":\"â¥\",\n  \"downrightteevector\":\"â¥Ÿ\",\n  \"leftupteevector\":\"â¥ \",\n  \"leftdownteevector\":\"â¥¡\",\n  \"lhar\":\"â¥¢\",\n  \"uhar\":\"â¥£\",\n  \"rhar\":\"â¥¤\",\n  \"dhar\":\"â¥¥\",\n  \"luruhar\":\"â¥¦\",\n  \"ldrdhar\":\"â¥§\",\n  \"ruluhar\":\"â¥¨\",\n  \"rdldhar\":\"â¥©\",\n  \"lharul\":\"â¥ª\",\n  \"llhard\":\"â¥«\",\n  \"rharul\":\"â¥¬\",\n  \"lrhard\":\"â¥­\",\n  \"udhar\":\"â¥®\",\n  \"upequilibrium\":\"â¥®\",\n  \"duhar\":\"â¥¯\",\n  \"reverseupequilibrium\":\"â¥¯\",\n  \"roundimplies\":\"â¥°\",\n  \"erarr\":\"â¥±\",\n  \"simrarr\":\"â¥²\",\n  \"larrsim\":\"â¥³\",\n  \"rarrsim\":\"â¥´\",\n  \"rarrap\":\"â¥µ\",\n  \"ltlarr\":\"â¥¶\",\n  \"gtrarr\":\"â¥¸\",\n  \"subrarr\":\"â¥¹\",\n  \"suplarr\":\"â¥»\",\n  \"lfisht\":\"â¥¼\",\n  \"rfisht\":\"â¥½\",\n  \"ufisht\":\"â¥¾\",\n  \"dfisht\":\"â¥¿\",\n  \"vzigzag\":\"â¦š\",\n  \"vangrt\":\"â¦œ\",\n  \"angrtvbd\":\"â¦\",\n  \"ange\":\"â¦¤\",\n  \"range\":\"â¦¥\",\n  \"dwangle\":\"â¦¦\",\n  \"uwangle\":\"â¦§\",\n  \"angmsdaa\":\"â¦¨\",\n  \"angmsdab\":\"â¦©\",\n  \"angmsdac\":\"â¦ª\",\n  \"angmsdad\":\"â¦«\",\n  \"angmsdae\":\"â¦¬\",\n  \"angmsdaf\":\"â¦­\",\n  \"angmsdag\":\"â¦®\",\n  \"angmsdah\":\"â¦¯\",\n  \"bemptyv\":\"â¦°\",\n  \"demptyv\":\"â¦±\",\n  \"cemptyv\":\"â¦²\",\n  \"raemptyv\":\"â¦³\",\n  \"laemptyv\":\"â¦´\",\n  \"ohbar\":\"â¦µ\",\n  \"omid\":\"â¦¶\",\n  \"opar\":\"â¦·\",\n  \"operp\":\"â¦¹\",\n  \"olcross\":\"â¦»\",\n  \"odsold\":\"â¦¼\",\n  \"olcir\":\"â¦¾\",\n  \"ofcir\":\"â¦¿\",\n  \"olt\":\"â§€\",\n  \"ogt\":\"â§\",\n  \"cirscir\":\"â§‚\",\n  \"cirE\":\"â§ƒ\",\n  \"solb\":\"â§„\",\n  \"bsolb\":\"â§…\",\n  \"boxbox\":\"â§‰\",\n  \"trisb\":\"â§\",\n  \"rtriltri\":\"â§\",\n  \"lefttrianglebar\":\"â§\",\n  \"notlefttrianglebar\":\"â§Ì¸\",\n  \"righttrianglebar\":\"â§\",\n  \"notrighttrianglebar\":\"â§Ì¸\",\n  \"iinfin\":\"â§œ\",\n  \"infintie\":\"â§\",\n  \"nvinfin\":\"â§\",\n  \"eparsl\":\"â§£\",\n  \"smeparsl\":\"â§¤\",\n  \"eqvparsl\":\"â§¥\",\n  \"blacklozenge\":\"â§«\",\n  \"lozf\":\"â§«\",\n  \"ruledelayed\":\"â§´\",\n  \"dsol\":\"â§¶\",\n  \"bigodot\":\"â¨€\",\n  \"xodot\":\"â¨€\",\n  \"bigoplus\":\"â¨\",\n  \"xoplus\":\"â¨\",\n  \"bigotimes\":\"â¨‚\",\n  \"xotime\":\"â¨‚\",\n  \"biguplus\":\"â¨„\",\n  \"xuplus\":\"â¨„\",\n  \"bigsqcup\":\"â¨†\",\n  \"xsqcup\":\"â¨†\",\n  \"fpartint\":\"â¨\",\n  \"cirfnint\":\"â¨\",\n  \"awint\":\"â¨‘\",\n  \"rppolint\":\"â¨’\",\n  \"scpolint\":\"â¨“\",\n  \"npolint\":\"â¨”\",\n  \"pointint\":\"â¨•\",\n  \"quatint\":\"â¨–\",\n  \"intlarhk\":\"â¨—\",\n  \"pluscir\":\"â¨¢\",\n  \"plusacir\":\"â¨£\",\n  \"simplus\":\"â¨¤\",\n  \"plusdu\":\"â¨¥\",\n  \"plussim\":\"â¨¦\",\n  \"plustwo\":\"â¨§\",\n  \"mcomma\":\"â¨©\",\n  \"minusdu\":\"â¨ª\",\n  \"loplus\":\"â¨­\",\n  \"roplus\":\"â¨®\",\n  \"Cross\":\"â¨¯\",\n  \"timesd\":\"â¨°\",\n  \"timesbar\":\"â¨±\",\n  \"smashp\":\"â¨³\",\n  \"lotimes\":\"â¨´\",\n  \"rotimes\":\"â¨µ\",\n  \"otimesas\":\"â¨¶\",\n  \"Otimes\":\"â¨·\",\n  \"odiv\":\"â¨¸\",\n  \"triplus\":\"â¨¹\",\n  \"triminus\":\"â¨º\",\n  \"tritime\":\"â¨»\",\n  \"intprod\":\"â¨¼\",\n  \"iprod\":\"â¨¼\",\n  \"amalg\":\"â¨¿\",\n  \"capdot\":\"â©€\",\n  \"ncup\":\"â©‚\",\n  \"ncap\":\"â©ƒ\",\n  \"capand\":\"â©„\",\n  \"cupor\":\"â©…\",\n  \"cupcap\":\"â©†\",\n  \"capcup\":\"â©‡\",\n  \"cupbrcap\":\"â©ˆ\",\n  \"capbrcup\":\"â©‰\",\n  \"cupcup\":\"â©Š\",\n  \"capcap\":\"â©‹\",\n  \"ccups\":\"â©Œ\",\n  \"ccaps\":\"â©\",\n  \"ccupssm\":\"â©\",\n  \"And\":\"â©“\",\n  \"Or\":\"â©”\",\n  \"andand\":\"â©•\",\n  \"oror\":\"â©–\",\n  \"orslope\":\"â©—\",\n  \"andslope\":\"â©˜\",\n  \"andv\":\"â©š\",\n  \"orv\":\"â©›\",\n  \"andd\":\"â©œ\",\n  \"ord\":\"â©\",\n  \"wedbar\":\"â©Ÿ\",\n  \"sdote\":\"â©¦\",\n  \"simdot\":\"â©ª\",\n  \"congdot\":\"â©­\",\n  \"ncongdot\":\"â©­Ì¸\",\n  \"easter\":\"â©®\",\n  \"apacir\":\"â©¯\",\n  \"apE\":\"â©°\",\n  \"nape\":\"â©°Ì¸\",\n  \"eplus\":\"â©±\",\n  \"pluse\":\"â©²\",\n  \"Esim\":\"â©³\",\n  \"ddotseq\":\"â©·\",\n  \"eddot\":\"â©·\",\n  \"equivdd\":\"â©¸\",\n  \"ltcir\":\"â©¹\",\n  \"gtcir\":\"â©º\",\n  \"ltquest\":\"â©»\",\n  \"gtquest\":\"â©¼\",\n  \"leqslant\":\"â©½\",\n  \"les\":\"â©½\",\n  \"lessslantequal\":\"â©½\",\n  \"nleqslant\":\"â©½Ì¸\",\n  \"nles\":\"â©½Ì¸\",\n  \"notlessslantequal\":\"â©½Ì¸\",\n  \"geqslant\":\"â©¾\",\n  \"ges\":\"â©¾\",\n  \"greaterslantequal\":\"â©¾\",\n  \"ngeqslant\":\"â©¾Ì¸\",\n  \"nges\":\"â©¾Ì¸\",\n  \"notgreaterslantequal\":\"â©¾Ì¸\",\n  \"lesdot\":\"â©¿\",\n  \"gesdot\":\"âª€\",\n  \"lesdoto\":\"âª\",\n  \"gesdoto\":\"âª‚\",\n  \"lesdotor\":\"âªƒ\",\n  \"gesdotol\":\"âª„\",\n  \"lap\":\"âª…\",\n  \"lessapprox\":\"âª…\",\n  \"gap\":\"âª†\",\n  \"gtrapprox\":\"âª†\",\n  \"lne\":\"âª‡\",\n  \"lneq\":\"âª‡\",\n  \"gne\":\"âªˆ\",\n  \"gneq\":\"âªˆ\",\n  \"lnap\":\"âª‰\",\n  \"lnapprox\":\"âª‰\",\n  \"gnap\":\"âªŠ\",\n  \"gnapprox\":\"âªŠ\",\n  \"lEg\":\"âª‹\",\n  \"lesseqqgtr\":\"âª‹\",\n  \"gEl\":\"âªŒ\",\n  \"gtreqqless\":\"âªŒ\",\n  \"lsime\":\"âª\",\n  \"gsime\":\"âª\",\n  \"lsimg\":\"âª\",\n  \"gsiml\":\"âª\",\n  \"lge\":\"âª‘\",\n  \"gle\":\"âª’\",\n  \"lesges\":\"âª“\",\n  \"gesles\":\"âª”\",\n  \"els\":\"âª•\",\n  \"eqslantless\":\"âª•\",\n  \"egs\":\"âª–\",\n  \"eqslantgtr\":\"âª–\",\n  \"elsdot\":\"âª—\",\n  \"egsdot\":\"âª˜\",\n  \"el\":\"âª™\",\n  \"eg\":\"âªš\",\n  \"siml\":\"âª\",\n  \"simg\":\"âª\",\n  \"simle\":\"âªŸ\",\n  \"simge\":\"âª \",\n  \"lessless\":\"âª¡\",\n  \"notnestedlessless\":\"âª¡Ì¸\",\n  \"greatergreater\":\"âª¢\",\n  \"notnestedgreatergreater\":\"âª¢Ì¸\",\n  \"glj\":\"âª¤\",\n  \"gla\":\"âª¥\",\n  \"ltcc\":\"âª¦\",\n  \"gtcc\":\"âª§\",\n  \"lescc\":\"âª¨\",\n  \"gescc\":\"âª©\",\n  \"smt\":\"âªª\",\n  \"lat\":\"âª«\",\n  \"smte\":\"âª¬\",\n  \"smtes\":\"âª¬ï¸€\",\n  \"late\":\"âª­\",\n  \"lates\":\"âª­ï¸€\",\n  \"bumpE\":\"âª®\",\n  \"pre\":\"âª¯\",\n  \"precedesequal\":\"âª¯\",\n  \"preceq\":\"âª¯\",\n  \"notprecedesequal\":\"âª¯Ì¸\",\n  \"npre\":\"âª¯Ì¸\",\n  \"npreceq\":\"âª¯Ì¸\",\n  \"sce\":\"âª°\",\n  \"succeedsequal\":\"âª°\",\n  \"succeq\":\"âª°\",\n  \"notsucceedsequal\":\"âª°Ì¸\",\n  \"nsce\":\"âª°Ì¸\",\n  \"nsucceq\":\"âª°Ì¸\",\n  \"prE\":\"âª³\",\n  \"scE\":\"âª´\",\n  \"precneqq\":\"âªµ\",\n  \"prne\":\"âªµ\",\n  \"scne\":\"âª¶\",\n  \"succneqq\":\"âª¶\",\n  \"prap\":\"âª·\",\n  \"precapprox\":\"âª·\",\n  \"scap\":\"âª¸\",\n  \"succapprox\":\"âª¸\",\n  \"precnapprox\":\"âª¹\",\n  \"prnap\":\"âª¹\",\n  \"scnap\":\"âªº\",\n  \"succnapprox\":\"âªº\",\n  \"Pr\":\"âª»\",\n  \"Sc\":\"âª¼\",\n  \"subdot\":\"âª½\",\n  \"supdot\":\"âª¾\",\n  \"subplus\":\"âª¿\",\n  \"supplus\":\"â«€\",\n  \"submult\":\"â«\",\n  \"supmult\":\"â«‚\",\n  \"subedot\":\"â«ƒ\",\n  \"supedot\":\"â«„\",\n  \"subE\":\"â«…\",\n  \"subseteqq\":\"â«…\",\n  \"nsubE\":\"â«…Ì¸\",\n  \"nsubseteqq\":\"â«…Ì¸\",\n  \"supE\":\"â«†\",\n  \"supseteqq\":\"â«†\",\n  \"nsupE\":\"â«†Ì¸\",\n  \"nsupseteqq\":\"â«†Ì¸\",\n  \"subsim\":\"â«‡\",\n  \"supsim\":\"â«ˆ\",\n  \"subnE\":\"â«‹\",\n  \"subsetneqq\":\"â«‹\",\n  \"varsubsetneqq\":\"â«‹ï¸€\",\n  \"vsubnE\":\"â«‹ï¸€\",\n  \"supnE\":\"â«Œ\",\n  \"supsetneqq\":\"â«Œ\",\n  \"varsupsetneqq\":\"â«Œï¸€\",\n  \"vsupnE\":\"â«Œï¸€\",\n  \"csub\":\"â«\",\n  \"csup\":\"â«\",\n  \"csube\":\"â«‘\",\n  \"csupe\":\"â«’\",\n  \"subsup\":\"â«“\",\n  \"supsub\":\"â«”\",\n  \"subsub\":\"â«•\",\n  \"supsup\":\"â«–\",\n  \"suphsub\":\"â«—\",\n  \"supdsub\":\"â«˜\",\n  \"forkv\":\"â«™\",\n  \"topfork\":\"â«š\",\n  \"mlcp\":\"â«›\",\n  \"Dashv\":\"â«¤\",\n  \"doublelefttee\":\"â«¤\",\n  \"vdashl\":\"â«¦\",\n  \"barv\":\"â«§\",\n  \"vbar\":\"â«¨\",\n  \"vbarv\":\"â«©\",\n  \"Vbar\":\"â««\",\n  \"Not\":\"â«¬\",\n  \"bNot\":\"â«­\",\n  \"rnmid\":\"â«®\",\n  \"cirmid\":\"â«¯\",\n  \"midcir\":\"â«°\",\n  \"topcir\":\"â«±\",\n  \"nhpar\":\"â«²\",\n  \"parsim\":\"â«³\",\n  \"parsl\":\"â«½\",\n  \"nparsl\":\"â«½âƒ¥\",\n  \"flat\":\"â™­\",\n  \"natur\":\"â™®\",\n  \"natural\":\"â™®\",\n  \"sharp\":\"â™¯\",\n  \"curren\":\"Â¤\",\n  \"cent\":\"Â¢\",\n  \"dollar\":\"$\",\n  \"pound\":\"Â£\",\n  \"yen\":\"Â¥\",\n  \"euro\":\"â‚¬\",\n  \"sup1\":\"Â¹\",\n  \"frac12\":\"Â½\",\n  \"half\":\"Â½\",\n  \"frac13\":\"â…“\",\n  \"frac14\":\"Â¼\",\n  \"frac15\":\"â…•\",\n  \"frac16\":\"â…™\",\n  \"frac18\":\"â…›\",\n  \"sup2\":\"Â²\",\n  \"frac23\":\"â…”\",\n  \"frac25\":\"â…–\",\n  \"sup3\":\"Â³\",\n  \"frac34\":\"Â¾\",\n  \"frac35\":\"â…—\",\n  \"frac38\":\"â…œ\",\n  \"frac45\":\"â…˜\",\n  \"frac56\":\"â…š\",\n  \"frac58\":\"â…\",\n  \"frac78\":\"â…\",\n  \"afr\":\"ğ”\",\n  \"aopf\":\"ğ•’\",\n  \"ascr\":\"ğ’¶\",\n  \"Afr\":\"ğ”„\",\n  \"Aopf\":\"ğ”¸\",\n  \"Ascr\":\"ğ’œ\",\n  \"ordf\":\"Âª\",\n  \"aacute\":\"Ã¡\",\n  \"Aacute\":\"Ã\",\n  \"agrave\":\"Ã \",\n  \"Agrave\":\"Ã€\",\n  \"abreve\":\"Äƒ\",\n  \"Abreve\":\"Ä‚\",\n  \"acirc\":\"Ã¢\",\n  \"Acirc\":\"Ã‚\",\n  \"aring\":\"Ã¥\",\n  \"angst\":\"Ã…\",\n  \"Aring\":\"Ã…\",\n  \"auml\":\"Ã¤\",\n  \"Auml\":\"Ã„\",\n  \"atilde\":\"Ã£\",\n  \"Atilde\":\"Ãƒ\",\n  \"aogon\":\"Ä…\",\n  \"Aogon\":\"Ä„\",\n  \"amacr\":\"Ä\",\n  \"Amacr\":\"Ä€\",\n  \"aelig\":\"Ã†\",\n  \"AElig\":\"Ã†\",\n  \"bfr\":\"ğ”Ÿ\",\n  \"bopf\":\"ğ•“\",\n  \"bscr\":\"ğ’·\",\n  \"bernou\":\"â„¬\",\n  \"bernoullis\":\"â„¬\",\n  \"Bfr\":\"ğ”…\",\n  \"Bopf\":\"ğ”¹\",\n  \"Bscr\":\"â„¬\",\n  \"cfr\":\"ğ” \",\n  \"copf\":\"ğ•”\",\n  \"cscr\":\"ğ’¸\",\n  \"cayleys\":\"â„­\",\n  \"Cfr\":\"â„­\",\n  \"complexes\":\"â„‚\",\n  \"Copf\":\"â„‚\",\n  \"Cscr\":\"ğ’\",\n  \"cacute\":\"Ä‡\",\n  \"Cacute\":\"Ä†\",\n  \"ccirc\":\"Ä‰\",\n  \"Ccirc\":\"Äˆ\",\n  \"ccaron\":\"Ä\",\n  \"Ccaron\":\"ÄŒ\",\n  \"cdot\":\"Ä‹\",\n  \"Cdot\":\"ÄŠ\",\n  \"ccedil\":\"Ã§\",\n  \"Ccedil\":\"Ã‡\",\n  \"incare\":\"â„…\",\n  \"dfr\":\"ğ”¡\",\n  \"differentiald\":\"â…†\",\n  \"dopf\":\"ğ••\",\n  \"dscr\":\"ğ’¹\",\n  \"capitaldifferentiald\":\"â……\",\n  \"dd\":\"â……\",\n  \"DD\":\"â……\",\n  \"Dfr\":\"ğ”‡\",\n  \"Dopf\":\"ğ”»\",\n  \"Dscr\":\"ğ’Ÿ\",\n  \"dcaron\":\"Ä\",\n  \"Dcaron\":\"Ä\",\n  \"dstrok\":\"Ä‘\",\n  \"Dstrok\":\"Ä\",\n  \"eth\":\"Ã°\",\n  \"ETH\":\"Ã\",\n  \"ee\":\"â…‡\",\n  \"efr\":\"ğ”¢\",\n  \"eopf\":\"ğ•–\",\n  \"escr\":\"â„¯\",\n  \"exponentiale\":\"â…‡\",\n  \"Efr\":\"ğ”ˆ\",\n  \"Eopf\":\"ğ”¼\",\n  \"Escr\":\"â„°\",\n  \"expectation\":\"â„°\",\n  \"eacute\":\"Ã©\",\n  \"Eacute\":\"Ã‰\",\n  \"egrave\":\"Ã¨\",\n  \"Egrave\":\"Ãˆ\",\n  \"ecirc\":\"Ãª\",\n  \"Ecirc\":\"ÃŠ\",\n  \"ecaron\":\"Ä›\",\n  \"Ecaron\":\"Äš\",\n  \"euml\":\"Ã«\",\n  \"Euml\":\"Ã‹\",\n  \"edot\":\"Ä—\",\n  \"Edot\":\"Ä–\",\n  \"eogon\":\"Ä™\",\n  \"Eogon\":\"Ä˜\",\n  \"emacr\":\"Ä“\",\n  \"Emacr\":\"Ä’\",\n  \"ffr\":\"ğ”£\",\n  \"fopf\":\"ğ•—\",\n  \"fscr\":\"ğ’»\",\n  \"Ffr\":\"ğ”‰\",\n  \"Fopf\":\"ğ”½\",\n  \"fouriertrf\":\"â„±\",\n  \"Fscr\":\"â„±\",\n  \"fflig\":\"ï¬€\",\n  \"ffilig\":\"ï¬ƒ\",\n  \"ffllig\":\"ï¬„\",\n  \"filig\":\"ï¬\",\n  \"fjlig\":\"fj\",\n  \"fllig\":\"ï¬‚\",\n  \"fnof\":\"Æ’\",\n  \"gfr\":\"ğ”¤\",\n  \"gopf\":\"ğ•˜\",\n  \"gscr\":\"â„Š\",\n  \"Gfr\":\"ğ”Š\",\n  \"Gopf\":\"ğ”¾\",\n  \"Gscr\":\"ğ’¢\",\n  \"gacute\":\"Çµ\",\n  \"gbreve\":\"ÄŸ\",\n  \"Gbreve\":\"Ä\",\n  \"gcirc\":\"Ä\",\n  \"Gcirc\":\"Äœ\",\n  \"gdot\":\"Ä¡\",\n  \"Gdot\":\"Ä \",\n  \"gcedil\":\"Ä¢\",\n  \"hfr\":\"ğ”¥\",\n  \"hopf\":\"ğ•™\",\n  \"hscr\":\"ğ’½\",\n  \"planckh\":\"â„\",\n  \"hamilt\":\"â„‹\",\n  \"Hfr\":\"â„Œ\",\n  \"hilbertspace\":\"â„‹\",\n  \"Hopf\":\"â„\",\n  \"Hscr\":\"â„‹\",\n  \"poincareplane\":\"â„Œ\",\n  \"quaternions\":\"â„\",\n  \"hcirc\":\"Ä¥\",\n  \"Hcirc\":\"Ä¤\",\n  \"hbar\":\"â„\",\n  \"hslash\":\"â„\",\n  \"hstrok\":\"Ä§\",\n  \"planck\":\"â„\",\n  \"plankv\":\"â„\",\n  \"Hstrok\":\"Ä¦\",\n  \"ifr\":\"ğ”¦\",\n  \"ii\":\"â…ˆ\",\n  \"imaginaryi\":\"â…ˆ\",\n  \"iopf\":\"ğ•š\",\n  \"iscr\":\"ğ’¾\",\n  \"Ifr\":\"â„‘\",\n  \"im\":\"â„‘\",\n  \"image\":\"â„‘\",\n  \"imagline\":\"â„\",\n  \"imagpart\":\"â„‘\",\n  \"Iopf\":\"ğ•€\",\n  \"Iscr\":\"â„\",\n  \"iacute\":\"Ã­\",\n  \"Iacute\":\"Ã\",\n  \"igrave\":\"Ã¬\",\n  \"Igrave\":\"ÃŒ\",\n  \"icirc\":\"Ã®\",\n  \"Icirc\":\"Ã\",\n  \"iuml\":\"Ã¯\",\n  \"Iuml\":\"Ã\",\n  \"itilde\":\"Ä©\",\n  \"Itilde\":\"Ä¨\",\n  \"idot\":\"Ä°\",\n  \"iogon\":\"Ä¯\",\n  \"Iogon\":\"Ä®\",\n  \"imacr\":\"Ä«\",\n  \"Imacr\":\"Äª\",\n  \"ijlig\":\"Ä²\",\n  \"IJlig\":\"Ä²\",\n  \"imath\":\"Ä±\",\n  \"inodot\":\"Ä±\",\n  \"jfr\":\"ğ”§\",\n  \"jopf\":\"ğ•›\",\n  \"jscr\":\"ğ’¿\",\n  \"Jfr\":\"ğ”\",\n  \"Jopf\":\"ğ•\",\n  \"Jscr\":\"ğ’¥\",\n  \"jcirc\":\"Äµ\",\n  \"Jcirc\":\"Ä´\",\n  \"jmath\":\"È·\",\n  \"kfr\":\"ğ”¨\",\n  \"kopf\":\"ğ•œ\",\n  \"kscr\":\"ğ“€\",\n  \"Kfr\":\"ğ”\",\n  \"Kopf\":\"ğ•‚\",\n  \"Kscr\":\"ğ’¦\",\n  \"kcedil\":\"Ä·\",\n  \"Kcedil\":\"Ä¶\",\n  \"ell\":\"â„“\",\n  \"lfr\":\"ğ”©\",\n  \"lopf\":\"ğ•\",\n  \"lscr\":\"ğ“\",\n  \"lagran\":\"â„’\",\n  \"laplacetrf\":\"â„’\",\n  \"Lfr\":\"ğ”\",\n  \"Lopf\":\"ğ•ƒ\",\n  \"Lscr\":\"â„’\",\n  \"lacute\":\"Äº\",\n  \"Lacute\":\"Ä¹\",\n  \"lcaron\":\"Ä¾\",\n  \"Lcaron\":\"Ä½\",\n  \"lcedil\":\"Ä¼\",\n  \"Lcedil\":\"Ä»\",\n  \"lstrok\":\"Å‚\",\n  \"Lstrok\":\"Å\",\n  \"lmidot\":\"Å€\",\n  \"Lmidot\":\"Ä¿\",\n  \"mfr\":\"ğ”ª\",\n  \"mopf\":\"ğ•\",\n  \"mscr\":\"ğ“‚\",\n  \"mellintrf\":\"â„³\",\n  \"Mfr\":\"ğ”\",\n  \"Mopf\":\"ğ•„\",\n  \"Mscr\":\"â„³\",\n  \"phmmat\":\"â„³\",\n  \"nfr\":\"ğ”«\",\n  \"nopf\":\"ğ•Ÿ\",\n  \"nscr\":\"ğ“ƒ\",\n  \"naturals\":\"â„•\",\n  \"Nfr\":\"ğ”‘\",\n  \"Nopf\":\"â„•\",\n  \"Nscr\":\"ğ’©\",\n  \"nacute\":\"Å„\",\n  \"Nacute\":\"Åƒ\",\n  \"ncaron\":\"Åˆ\",\n  \"Ncaron\":\"Å‡\",\n  \"ntilde\":\"Ã±\",\n  \"Ntilde\":\"Ã‘\",\n  \"ncedil\":\"Å†\",\n  \"Ncedil\":\"Å…\",\n  \"numero\":\"â„–\",\n  \"eng\":\"Å‹\",\n  \"ENG\":\"ÅŠ\",\n  \"ofr\":\"ğ”¬\",\n  \"oopf\":\"ğ• \",\n  \"order\":\"â„´\",\n  \"orderof\":\"â„´\",\n  \"oscr\":\"â„´\",\n  \"Ofr\":\"ğ”’\",\n  \"Oopf\":\"ğ•†\",\n  \"Oscr\":\"ğ’ª\",\n  \"ordm\":\"Âº\",\n  \"oacute\":\"Ã³\",\n  \"Oacute\":\"Ã“\",\n  \"ograve\":\"Ã²\",\n  \"Ograve\":\"Ã’\",\n  \"ocirc\":\"Ã´\",\n  \"Ocirc\":\"Ã”\",\n  \"ouml\":\"Ã¶\",\n  \"Ouml\":\"Ã–\",\n  \"odblac\":\"Å‘\",\n  \"Odblac\":\"Å\",\n  \"otilde\":\"Ãµ\",\n  \"Otilde\":\"Ã•\",\n  \"oslash\":\"Ã¸\",\n  \"Oslash\":\"Ã˜\",\n  \"omacr\":\"Å\",\n  \"Omacr\":\"ÅŒ\",\n  \"oelig\":\"Å’\",\n  \"OElig\":\"Å’\",\n  \"pfr\":\"ğ”­\",\n  \"popf\":\"ğ•¡\",\n  \"pscr\":\"ğ“…\",\n  \"Pfr\":\"ğ”“\",\n  \"Popf\":\"â„™\",\n  \"primes\":\"â„™\",\n  \"Pscr\":\"ğ’«\",\n  \"qfr\":\"ğ”®\",\n  \"qopf\":\"ğ•¢\",\n  \"qscr\":\"ğ“†\",\n  \"Qfr\":\"ğ””\",\n  \"Qopf\":\"â„š\",\n  \"Qscr\":\"ğ’¬\",\n  \"rationals\":\"â„š\",\n  \"kgreen\":\"Ä¸\",\n  \"rfr\":\"ğ”¯\",\n  \"ropf\":\"ğ•£\",\n  \"rscr\":\"ğ“‡\",\n  \"re\":\"â„œ\",\n  \"real\":\"â„œ\",\n  \"realine\":\"â„›\",\n  \"realpart\":\"â„œ\",\n  \"reals\":\"â„\",\n  \"Rfr\":\"â„œ\",\n  \"Ropf\":\"â„\",\n  \"Rscr\":\"â„›\",\n  \"racute\":\"Å•\",\n  \"Racute\":\"Å”\",\n  \"rcaron\":\"Å™\",\n  \"Rcaron\":\"Å˜\",\n  \"rcedil\":\"Å—\",\n  \"Rcedil\":\"Å–\",\n  \"sfr\":\"ğ”°\",\n  \"sopf\":\"ğ•¤\",\n  \"sscr\":\"ğ“ˆ\",\n  \"Sfr\":\"ğ”–\",\n  \"Sopf\":\"ğ•Š\",\n  \"Sscr\":\"ğ’®\",\n  \"circleds\":\"â“ˆ\",\n  \"os\":\"â“ˆ\",\n  \"sacute\":\"Å›\",\n  \"Sacute\":\"Åš\",\n  \"scirc\":\"Å\",\n  \"Scirc\":\"Åœ\",\n  \"scaron\":\"Å¡\",\n  \"Scaron\":\"Å \",\n  \"scedil\":\"ÅŸ\",\n  \"Scedil\":\"Å\",\n  \"szlig\":\"ÃŸ\",\n  \"tfr\":\"ğ”±\",\n  \"topf\":\"ğ•¥\",\n  \"tscr\":\"ğ“‰\",\n  \"Tfr\":\"ğ”—\",\n  \"Topf\":\"ğ•‹\",\n  \"Tscr\":\"ğ’¯\",\n  \"tcaron\":\"Å¥\",\n  \"Tcaron\":\"Å¤\",\n  \"tcedil\":\"Å£\",\n  \"Tcedil\":\"Å¢\",\n  \"trade\":\"â„¢\",\n  \"tstrok\":\"Å§\",\n  \"Tstrok\":\"Å¦\",\n  \"ufr\":\"ğ”²\",\n  \"uopf\":\"ğ•¦\",\n  \"uscr\":\"ğ“Š\",\n  \"Ufr\":\"ğ”˜\",\n  \"Uopf\":\"ğ•Œ\",\n  \"Uscr\":\"ğ’°\",\n  \"uacute\":\"Ãº\",\n  \"Uacute\":\"Ãš\",\n  \"ugrave\":\"Ã¹\",\n  \"Ugrave\":\"Ã™\",\n  \"ubreve\":\"Å­\",\n  \"Ubreve\":\"Å¬\",\n  \"ucirc\":\"Ã»\",\n  \"Ucirc\":\"Ã›\",\n  \"uring\":\"Å¯\",\n  \"Uring\":\"Å®\",\n  \"uuml\":\"Ã¼\",\n  \"Uuml\":\"Ãœ\",\n  \"udblac\":\"Å±\",\n  \"Udblac\":\"Å°\",\n  \"utilde\":\"Å©\",\n  \"Utilde\":\"Å¨\",\n  \"uogon\":\"Å³\",\n  \"Uogon\":\"Å²\",\n  \"umacr\":\"Å«\",\n  \"Umacr\":\"Åª\",\n  \"vfr\":\"ğ”³\",\n  \"vopf\":\"ğ•§\",\n  \"vscr\":\"ğ“‹\",\n  \"Vfr\":\"ğ”™\",\n  \"Vopf\":\"ğ•\",\n  \"Vscr\":\"ğ’±\",\n  \"wfr\":\"ğ”´\",\n  \"wopf\":\"ğ•¨\",\n  \"wscr\":\"ğ“Œ\",\n  \"Wfr\":\"ğ”š\",\n  \"Wopf\":\"ğ•\",\n  \"Wscr\":\"ğ’²\",\n  \"wcirc\":\"Åµ\",\n  \"Wcirc\":\"Å´\",\n  \"xfr\":\"ğ”µ\",\n  \"xopf\":\"ğ•©\",\n  \"xscr\":\"ğ“\",\n  \"Xfr\":\"ğ”›\",\n  \"Xopf\":\"ğ•\",\n  \"Xscr\":\"ğ’³\",\n  \"yfr\":\"ğ”¶\",\n  \"yopf\":\"ğ•ª\",\n  \"yscr\":\"ğ“\",\n  \"Yfr\":\"ğ”œ\",\n  \"Yopf\":\"ğ•\",\n  \"Yscr\":\"ğ’´\",\n  \"yacute\":\"Ã½\",\n  \"Yacute\":\"Ã\",\n  \"ycirc\":\"Å·\",\n  \"Ycirc\":\"Å¶\",\n  \"yuml\":\"Ã¿\",\n  \"Yuml\":\"Å¸\",\n  \"zfr\":\"ğ”·\",\n  \"zopf\":\"ğ•«\",\n  \"zscr\":\"ğ“\",\n  \"integers\":\"â„¤\",\n  \"zeetrf\":\"â„¨\",\n  \"Zfr\":\"â„¨\",\n  \"Zopf\":\"â„¤\",\n  \"Zscr\":\"ğ’µ\",\n  \"zacute\":\"Åº\",\n  \"Zacute\":\"Å¹\",\n  \"zcaron\":\"Å¾\",\n  \"Zcaron\":\"Å½\",\n  \"zdot\":\"Å¼\",\n  \"Zdot\":\"Å»\",\n  \"imped\":\"Æµ\",\n  \"thorn\":\"Ã¾\",\n  \"THORN\":\"Ã\",\n  \"napos\":\"Å‰\",\n  \"alpha\":\"Î±\",\n  \"Alpha\":\"Î‘\",\n  \"beta\":\"Î²\",\n  \"Beta\":\"Î’\",\n  \"gamma\":\"Î³\",\n  \"Gamma\":\"Î“\",\n  \"delta\":\"Î´\",\n  \"Delta\":\"Î”\",\n  \"epsi\":\"Îµ\",\n  \"epsilon\":\"Îµ\",\n  \"epsiv\":\"Ïµ\",\n  \"straightepsilon\":\"Ïµ\",\n  \"varepsilon\":\"Ïµ\",\n  \"Epsilon\":\"Î•\",\n  \"digamma\":\"Ï\",\n  \"gammad\":\"Ï\",\n  \"Gammad\":\"Ïœ\",\n  \"zeta\":\"Î¶\",\n  \"Zeta\":\"Î–\",\n  \"eta\":\"Î·\",\n  \"Eta\":\"Î—\",\n  \"theta\":\"Î¸\",\n  \"thetasym\":\"Ï‘\",\n  \"thetav\":\"Ï‘\",\n  \"vartheta\":\"Ï‘\",\n  \"Theta\":\"Î˜\",\n  \"iota\":\"Î¹\",\n  \"Iota\":\"Î™\",\n  \"kappa\":\"Îº\",\n  \"kappav\":\"Ï°\",\n  \"varkappa\":\"Ï°\",\n  \"Kappa\":\"Îš\",\n  \"lambda\":\"Î»\",\n  \"Lambda\":\"Î›\",\n  \"mu\":\"Î¼\",\n  \"micro\":\"Âµ\",\n  \"Mu\":\"Îœ\",\n  \"nu\":\"Î½\",\n  \"Nu\":\"Î\",\n  \"xi\":\"Î¾\",\n  \"Xi\":\"Î\",\n  \"omicron\":\"Î¿\",\n  \"Omicron\":\"ÎŸ\",\n  \"pi\":\"Ï€\",\n  \"piv\":\"Ï–\",\n  \"varpi\":\"Ï–\",\n  \"Pi\":\"Î \",\n  \"rho\":\"Ï\",\n  \"rhov\":\"Ï±\",\n  \"varrho\":\"Ï±\",\n  \"Rho\":\"Î¡\",\n  \"sigma\":\"Ïƒ\",\n  \"Sigma\":\"Î£\",\n  \"sigmaf\":\"Ï‚\",\n  \"sigmav\":\"Ï‚\",\n  \"varsigma\":\"Ï‚\",\n  \"tau\":\"Ï„\",\n  \"Tau\":\"Î¤\",\n  \"upsi\":\"Ï…\",\n  \"upsilon\":\"Ï…\",\n  \"Upsilon\":\"Î¥\",\n  \"Upsi\":\"Ï’\",\n  \"upsih\":\"Ï’\",\n  \"phi\":\"Ï†\",\n  \"phiv\":\"Ï•\",\n  \"straightphi\":\"Ï•\",\n  \"varphi\":\"Ï•\",\n  \"Phi\":\"Î¦\",\n  \"chi\":\"Ï‡\",\n  \"Chi\":\"Î§\",\n  \"psi\":\"Ïˆ\",\n  \"Psi\":\"Î¨\",\n  \"omega\":\"Ï‰\",\n  \"ohm\":\"Î©\",\n  \"Omega\":\"Î©\",\n  \"acy\":\"Ğ°\",\n  \"Acy\":\"Ğ\",\n  \"bcy\":\"Ğ±\",\n  \"Bcy\":\"Ğ‘\",\n  \"vcy\":\"Ğ²\",\n  \"Vcy\":\"Ğ’\",\n  \"gcy\":\"Ğ³\",\n  \"Gcy\":\"Ğ“\",\n  \"gjcy\":\"Ğƒ\",\n  \"GJcy\":\"Ğƒ\",\n  \"dcy\":\"Ğ´\",\n  \"Dcy\":\"Ğ”\",\n  \"djcy\":\"Ğ‚\",\n  \"DJcy\":\"Ğ‚\",\n  \"iecy\":\"Ğ•\",\n  \"IEcy\":\"Ğ•\",\n  \"iocy\":\"Ğ\",\n  \"IOcy\":\"Ğ\",\n  \"jukcy\":\"Ñ”\",\n  \"Jukcy\":\"Ğ„\",\n  \"zhcy\":\"Ğ–\",\n  \"ZHcy\":\"Ğ–\",\n  \"zcy\":\"Ğ·\",\n  \"Zcy\":\"Ğ—\",\n  \"dscy\":\"Ğ…\",\n  \"DScy\":\"Ğ…\",\n  \"icy\":\"Ğ¸\",\n  \"Icy\":\"Ğ˜\",\n  \"iukcy\":\"Ñ–\",\n  \"Iukcy\":\"Ğ†\",\n  \"yicy\":\"Ğ‡\",\n  \"YIcy\":\"Ğ‡\",\n  \"jcy\":\"Ğ¹\",\n  \"Jcy\":\"Ğ™\",\n  \"jsercy\":\"Ñ˜\",\n  \"Jsercy\":\"Ğˆ\",\n  \"kcy\":\"Ğº\",\n  \"Kcy\":\"Ğš\",\n  \"kjcy\":\"ĞŒ\",\n  \"KJcy\":\"ĞŒ\",\n  \"lcy\":\"Ğ»\",\n  \"Lcy\":\"Ğ›\",\n  \"ljcy\":\"Ğ‰\",\n  \"LJcy\":\"Ğ‰\",\n  \"mcy\":\"Ğ¼\",\n  \"Mcy\":\"Ğœ\",\n  \"ncy\":\"Ğ½\",\n  \"Ncy\":\"Ğ\",\n  \"njcy\":\"ĞŠ\",\n  \"NJcy\":\"ĞŠ\",\n  \"ocy\":\"Ğ¾\",\n  \"Ocy\":\"Ğ\",\n  \"pcy\":\"Ğ¿\",\n  \"Pcy\":\"ĞŸ\",\n  \"rcy\":\"Ñ€\",\n  \"Rcy\":\"Ğ \",\n  \"scy\":\"Ñ\",\n  \"Scy\":\"Ğ¡\",\n  \"tcy\":\"Ñ‚\",\n  \"Tcy\":\"Ğ¢\",\n  \"tshcy\":\"Ñ›\",\n  \"TSHcy\":\"Ğ‹\",\n  \"ucy\":\"Ñƒ\",\n  \"Ucy\":\"Ğ£\",\n  \"ubrcy\":\"Ñ\",\n  \"Ubrcy\":\"Ğ\",\n  \"fcy\":\"Ñ„\",\n  \"Fcy\":\"Ğ¤\",\n  \"khcy\":\"Ğ¥\",\n  \"KHcy\":\"Ğ¥\",\n  \"tscy\":\"Ğ¦\",\n  \"TScy\":\"Ğ¦\",\n  \"chcy\":\"Ğ§\",\n  \"CHcy\":\"Ğ§\",\n  \"dzcy\":\"Ğ\",\n  \"DZcy\":\"Ğ\",\n  \"shcy\":\"Ğ¨\",\n  \"SHcy\":\"Ğ¨\",\n  \"shchcy\":\"Ñ‰\",\n  \"SHCHcy\":\"Ğ©\",\n  \"hardcy\":\"ÑŠ\",\n  \"HARDcy\":\"Ğª\",\n  \"ycy\":\"Ñ‹\",\n  \"Ycy\":\"Ğ«\",\n  \"softcy\":\"ÑŒ\",\n  \"SOFTcy\":\"Ğ¬\",\n  \"ecy\":\"Ñ\",\n  \"Ecy\":\"Ğ­\",\n  \"yucy\":\"Ğ®\",\n  \"YUcy\":\"Ğ®\",\n  \"yacy\":\"Ğ¯\",\n  \"YAcy\":\"Ğ¯\",\n  \"alefsym\":\"â„µ\",\n  \"aleph\":\"â„µ\",\n  \"beth\":\"â„¶\",\n  \"gimel\":\"â„·\",\n  \"daleth\":\"â„¸\"\n}\n\n/**\n * Decode a named entity using the lookup table.\n * Returns the decoded character or undefined if not found.\n * This function enables browser builds to swap in DOM-based decoding.\n */\nexport function decodeEntity(name: string): string | undefined {\n  return NAMED_CODES_TO_UNICODE[name] || NAMED_CODES_TO_UNICODE[name.toLowerCase()]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2121, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/react.tsx","file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/constants.ts","file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/types.ts","file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/utils.ts","file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/parse.ts"],"sourcesContent":["/** @jsxRuntime classic */\n/** @jsx h */\n\nimport * as React from 'react'\nimport * as $ from './constants'\nimport * as parse from './parse'\nimport { MarkdownToJSX, RuleType } from './types'\nimport * as util from './utils'\n\nexport { parser } from './parse'\n\nexport { RuleType, type MarkdownToJSX } from './types'\nexport { sanitizer, slugify } from './utils'\n\nconst TRIM_STARTING_NEWLINES = /^\\n+/\n\n/**\n * React context for sharing compiler options across Markdown components\n * @lang zh ç”¨äºåœ¨ Markdown ç»„ä»¶ä¹‹é—´å…±äº«ç¼–è¯‘å™¨é€‰é¡¹çš„ React ä¸Šä¸‹æ–‡\n * @lang hi Markdown à¤•à¤‚à¤ªà¥‹à¤¨à¥‡à¤‚à¤Ÿà¥à¤¸ à¤•à¥‡ à¤¬à¥€à¤š à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤µà¤¿à¤•à¤²à¥à¤ª à¤¸à¤¾à¤à¤¾ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ React à¤¸à¤‚à¤¦à¤°à¥à¤­\n *\n * Note: This is undefined in React Server Component environments where createContext is not available.\n * @lang zh æ³¨æ„ï¼šåœ¨ createContext ä¸å¯ç”¨çš„ React Server Component ç¯å¢ƒä¸­ï¼Œæ­¤å€¼ä¸º undefinedã€‚\n * @lang hi à¤¨à¥‹à¤Ÿ: React Server Component à¤µà¤¾à¤¤à¤¾à¤µà¤°à¤£ à¤®à¥‡à¤‚ à¤¯à¤¹ undefined à¤¹à¥ˆ à¤œà¤¹à¤¾à¤‚ createContext à¤‰à¤ªà¤²à¤¬à¥à¤§ à¤¨à¤¹à¥€à¤‚ à¤¹à¥ˆà¥¤\n */\nexport const MarkdownContext:\n  | React.Context<MarkdownToJSX.Options | undefined>\n  | undefined =\n  typeof React.createContext !== 'undefined'\n    ? React.createContext<MarkdownToJSX.Options | undefined>(undefined)\n    : undefined\n\n// Import shared HTML to JSX conversion utilities\nimport { htmlAttrsToJSXProps } from './utils'\n\n// Helper function for URL encoding backslashes and backticks per CommonMark spec\nfunction encodeUrlTarget(target: string): string {\n  // Fast path: check if encoding is needed\n  let needsEncoding = false\n  for (let i = 0; i < target.length; i++) {\n    const code = target.charCodeAt(i)\n    if (code > 127 || code === $.CHAR_BACKSLASH || code === $.CHAR_BACKTICK) {\n      needsEncoding = true\n      break\n    }\n  }\n  if (!needsEncoding) return target\n\n  // Encode character by character, preserving existing percent-encoded sequences\n  let result = ''\n  for (let i = 0; i < target.length; i++) {\n    const char = target[i]\n    if (\n      char === '%' &&\n      i + 2 < target.length &&\n      /[0-9A-Fa-f]/.test(target[i + 1]) &&\n      /[0-9A-Fa-f]/.test(target[i + 2])\n    ) {\n      // Preserve existing percent-encoded sequence\n      result += target[i] + target[i + 1] + target[i + 2]\n      i += 2\n    } else if (char.charCodeAt(0) === $.CHAR_BACKSLASH) {\n      result += '%5C'\n    } else if (char.charCodeAt(0) === $.CHAR_BACKTICK) {\n      result += '%60'\n    } else {\n      const code = char.charCodeAt(0)\n      result += code > 127 ? encodeURIComponent(char) : char\n    }\n  }\n  return result\n}\n\nfunction render(\n  node: MarkdownToJSX.ASTNode,\n  output: MarkdownToJSX.ASTRender,\n  state: MarkdownToJSX.State,\n  h: (tag: any, props: any, ...children: any[]) => any,\n  sanitize: (value: string, tag: string, attribute: string) => string | null,\n  slug: (input: string, defaultFn: (input: string) => string) => string,\n  refs: { [key: string]: { target: string; title: string } },\n  options: MarkdownToJSX.Options\n): React.ReactNode {\n  switch (node.type) {\n    case RuleType.blockQuote: {\n      const props = {\n        key: state.key,\n      } as Record<string, unknown>\n\n      if (node.alert) {\n        props.className =\n          'markdown-alert-' + slug(node.alert.toLowerCase(), util.slugify)\n\n        node.children.unshift({\n          attrs: {},\n          children: [{ type: RuleType.text, text: node.alert }],\n          verbatim: true,\n          type: RuleType.htmlBlock,\n          tag: 'header',\n        })\n      }\n\n      return h('blockquote', props, output(node.children, state))\n    }\n\n    case RuleType.breakLine:\n      return <br key={state.key} />\n\n    case RuleType.breakThematic:\n      return <hr key={state.key} />\n\n    case RuleType.frontmatter:\n      if (options.preserveFrontmatter) {\n        return <pre key={state.key}>{node.text}</pre>\n      }\n      return null\n\n    case RuleType.codeBlock:\n      // Decode entity references in language name (per CommonMark spec)\n      const decodedLang = node.lang\n        ? util.decodeEntityReferences(node.lang)\n        : ''\n      return (\n        <pre key={state.key}>\n          <code\n            {...htmlAttrsToJSXProps(node.attrs || {})}\n            className={\n              decodedLang ? `language-${decodedLang} lang-${decodedLang}` : ''\n            }\n          >\n            {node.text}\n          </code>\n        </pre>\n      )\n\n    case RuleType.codeInline:\n      return <code key={state.key}>{node.text}</code>\n\n    case RuleType.footnoteReference:\n      return (\n        <a key={state.key} href={sanitize(node.target, 'a', 'href')}>\n          <sup key={state.key}>{node.text}</sup>\n        </a>\n      )\n\n    case RuleType.gfmTask:\n      return (\n        <input\n          checked={node.completed}\n          key={state.key}\n          readOnly\n          type=\"checkbox\"\n        />\n      )\n\n    case RuleType.heading:\n      return h(\n        `h${node.level}`,\n        { id: node.id, key: state.key },\n        output(node.children, state)\n      )\n\n    case RuleType.htmlBlock: {\n      const htmlNode = node as MarkdownToJSX.HTMLNode\n\n      // Apply options.tagfilter: escape dangerous tags\n      if (options.tagfilter && util.shouldFilterTag(htmlNode.tag)) {\n        let tagText: string\n        if ('rawText' in htmlNode && typeof htmlNode.rawText === 'string') {\n          // Use raw text as-is, React will escape it\n          tagText = htmlNode.rawText\n        } else {\n          // Simple attribute formatting for filtered tags\n          let attrStr = ''\n          if (htmlNode.attrs) {\n            for (const [key, value] of Object.entries(htmlNode.attrs)) {\n              if (value === true) {\n                attrStr += ` ${key}`\n              } else if (\n                value !== undefined &&\n                value !== null &&\n                value !== false\n              ) {\n                attrStr += ` ${key}=\"${String(value)}\"`\n              }\n            }\n          }\n          tagText = `<${htmlNode.tag}${attrStr}>`\n        }\n        // Pass unescaped tag as text child - React will escape it automatically\n        return h('span', { key: state.key }, tagText)\n      }\n\n      if (htmlNode.rawText && htmlNode.verbatim) {\n        // For verbatim blocks, always use rawText for rendering (CommonMark compliance)\n        // Children are available for renderRule but default rendering uses rawText\n        const tagLower = (htmlNode.tag as string).toLowerCase()\n        const isType1Block = parse.isType1Block(tagLower)\n\n        const containsHTMLTags = /<[a-z][^>]{0,100}>/i.test(htmlNode.rawText)\n        const containsPreTags = /<\\/?pre\\b/i.test(htmlNode.rawText)\n\n        if (isType1Block && !containsHTMLTags) {\n          let textContent = htmlNode.rawText.replace(\n            new RegExp('\\\\s*</' + tagLower + '>\\\\s*$', 'i'),\n            ''\n          )\n          if (options.tagfilter) {\n            textContent = util.applyTagFilterToText(textContent)\n          }\n          return h(node.tag, { key: state.key, ...node.attrs }, textContent)\n        }\n\n        if (containsPreTags) {\n          const innerHtml = options.tagfilter\n            ? util.applyTagFilterToText(htmlNode.rawText)\n            : htmlNode.rawText\n          return h(node.tag, {\n            key: state.key,\n            ...node.attrs,\n            dangerouslySetInnerHTML: { __html: innerHtml },\n          })\n        }\n        // For other verbatim blocks, re-parse rawText for JSX compilation\n        // (children are available for renderRule but default uses rawText)\n        const parseOptions: parse.ParseOptions = {\n          slugify: (input: string) => slug(input, util.slugify),\n          sanitizer: sanitize,\n          tagfilter: true,\n        }\n        const cleanedText = htmlNode.rawText\n          .replace(/>\\s+</g, '><')\n          .replace(/\\n+/g, ' ')\n          .trim()\n\n        // Avoid infinite recursion: if cleanedText is just the same HTML tag we're processing,\n        // render as an empty element\n        const selfTagRegex = new RegExp(\n          `^<${htmlNode.tag}(\\\\s[^>]*)?>(\\\\s*</${htmlNode.tag}>)?$`,\n          'i'\n        )\n        if (selfTagRegex.test(cleanedText)) {\n          return h(node.tag, { key: state.key, ...node.attrs })\n        }\n\n        function processNode(\n          node: MarkdownToJSX.ASTNode\n        ): MarkdownToJSX.ASTNode[] {\n          if (\n            node.type === RuleType.htmlSelfClosing &&\n            'isClosingTag' in node &&\n            (\n              node as MarkdownToJSX.HTMLSelfClosingNode & {\n                isClosingTag?: boolean\n              }\n            ).isClosingTag\n          )\n            return []\n          if (node.type === RuleType.paragraph) {\n            const children = (node as MarkdownToJSX.ParagraphNode).children\n            return children ? children.flatMap(processNode) : []\n          }\n          if (node.type === RuleType.text) {\n            return (node as MarkdownToJSX.TextNode).text?.trim() ? [node] : []\n          }\n          if (\n            node.type === RuleType.htmlBlock &&\n            (node as MarkdownToJSX.HTMLNode).children\n          ) {\n            return [\n              {\n                ...node,\n                children: node.children?.flatMap(processNode),\n              } as MarkdownToJSX.HTMLNode,\n            ]\n          }\n          return [node]\n        }\n\n        const astNodes = parse.parseMarkdown(\n          cleanedText,\n          { inline: false, refs: refs, inHTML: false },\n          parseOptions\n        )\n\n        // Check if rawText represents the FULL outer block (starts with opening tag\n        // and ends with closing tag of the same element, with no content after)\n        // In this case, render the parsed nodes directly without adding another wrapper\n        const tagLowerCheck = (htmlNode.tag as string).toLowerCase()\n        const closingTag = '</' + tagLowerCheck + '>'\n        const startsWithOwnTag = new RegExp(\n          `^<${htmlNode.tag}(\\\\s|>)`,\n          'i'\n        ).test(cleanedText)\n        const endsWithClosingTag = cleanedText\n          .toLowerCase()\n          .trimEnd()\n          .endsWith(closingTag)\n        const isFullOuterBlock = startsWithOwnTag && endsWithClosingTag\n\n        const hasNoAttrs =\n          !htmlNode.attrs || Object.keys(htmlNode.attrs).length === 0\n        const hasChildren = htmlNode.children && htmlNode.children.length > 0\n\n        // Case 1: rawText contains full outer block AND no parsed attrs\n        // Skip wrapper and render the parsed nodes directly (attrs are in rawText)\n        if (isFullOuterBlock && hasNoAttrs) {\n          return output(astNodes.flatMap(processNode), state)\n        }\n\n        // Case 2: rawText contains full outer block AND we have parsed attrs (#781)\n        // Use children array instead of re-parsing rawText to avoid duplication\n        // The children contain the inner content without the outer tags\n        if (isFullOuterBlock && hasChildren) {\n          return h(\n            node.tag,\n            { key: state.key, ...node.attrs },\n            output(htmlNode.children, state)\n          )\n        }\n\n        return h(\n          node.tag,\n          { key: state.key, ...node.attrs },\n          output(astNodes.flatMap(processNode), state)\n        )\n      }\n      return h(\n        node.tag,\n        { key: state.key, ...node.attrs },\n        node.children ? output(node.children, state) : ''\n      )\n    }\n\n    case RuleType.htmlSelfClosing: {\n      const htmlNode = node as MarkdownToJSX.HTMLSelfClosingNode\n\n      // Apply options.tagfilter: escape dangerous self-closing tags\n      if (options.tagfilter && util.shouldFilterTag(htmlNode.tag)) {\n        let tagText: string\n        if ('rawText' in htmlNode && typeof htmlNode.rawText === 'string') {\n          // Use raw text as-is, React will escape it\n          tagText = htmlNode.rawText\n        } else {\n          // Simple attribute formatting for filtered self-closing tags\n          let attrStr = ''\n          if (htmlNode.attrs) {\n            for (const [key, value] of Object.entries(htmlNode.attrs)) {\n              if (value === true) {\n                attrStr += ` ${key}`\n              } else if (\n                value !== undefined &&\n                value !== null &&\n                value !== false\n              ) {\n                attrStr += ` ${key}=\"${String(value)}\"`\n              }\n            }\n          }\n          tagText = `<${htmlNode.tag}${attrStr} />`\n        }\n        // Pass unescaped tag as text child - React will escape it automatically\n        return h('span', { key: state.key }, tagText)\n      }\n\n      return h(node.tag, { key: state.key, ...node.attrs })\n    }\n\n    case RuleType.image: {\n      return (\n        <img\n          key={state.key}\n          alt={node.alt && node.alt.length > 0 ? node.alt : undefined}\n          title={node.title || undefined}\n          src={sanitize(node.target, 'img', 'src')}\n        />\n      )\n    }\n\n    case RuleType.link: {\n      const props: Record<string, unknown> = { key: state.key }\n      if (node.target != null) {\n        // Entity references are already decoded during parsing (per CommonMark spec)\n        // URL-encode backslashes and backticks (per CommonMark spec)\n        props.href = encodeUrlTarget(node.target)\n      }\n      if (node.title) {\n        // Entity references are already decoded during parsing (per CommonMark spec)\n        props.title = node.title\n      }\n      return h('a', props, output(node.children, state))\n    }\n\n    case RuleType.table: {\n      const table = node as MarkdownToJSX.TableNode\n      return (\n        <table key={state.key}>\n          <thead>\n            <tr>\n              {table.header.map(function generateHeaderCell(content, i) {\n                return (\n                  <th\n                    key={i}\n                    style={\n                      table.align[i] == null\n                        ? {}\n                        : { textAlign: table.align[i] }\n                    }\n                  >\n                    {output(content, state)}\n                  </th>\n                )\n              })}\n            </tr>\n          </thead>\n\n          <tbody>\n            {table.cells.map(function generateTableRow(row, i) {\n              return (\n                <tr key={i}>\n                  {row.map(function generateTableCell(content, c) {\n                    return (\n                      <td\n                        key={c}\n                        style={\n                          table.align[c] == null\n                            ? {}\n                            : { textAlign: table.align[c] }\n                        }\n                      >\n                        {output(content, state)}\n                      </td>\n                    )\n                  })}\n                </tr>\n              )\n            })}\n          </tbody>\n        </table>\n      )\n    }\n\n    case RuleType.text:\n      return node.text\n\n    case RuleType.textFormatted:\n      return h(\n        node.tag as MarkdownToJSX.HTMLTags,\n        { key: state.key },\n        output(node.children, state)\n      )\n\n    case RuleType.orderedList:\n    case RuleType.unorderedList: {\n      const Tag = node.type === RuleType.orderedList ? 'ol' : 'ul'\n\n      return (\n        <Tag\n          key={state.key}\n          start={node.type === RuleType.orderedList ? node.start : undefined}\n        >\n          {node.items.map(function generateListItem(item, i) {\n            return <li key={i}>{output(item, state)}</li>\n          })}\n        </Tag>\n      )\n    }\n\n    case RuleType.paragraph:\n      return <p key={state.key}>{output(node.children, state)}</p>\n\n    case RuleType.ref:\n      // Reference definitions should not be rendered (they're consumed during parsing)\n      return null\n\n    default:\n      return null\n  }\n}\n\nconst createRenderer = (\n  userRender: MarkdownToJSX.Options['renderRule'],\n  h: (\n    tag: string,\n    props: Parameters<MarkdownToJSX.CreateElement>[1] & {\n      className?: string\n      id?: string\n    },\n    ...children: any[]\n  ) => any,\n  sanitize: (value: string, tag: string, attribute: string) => string | null,\n  slug: (input: string, defaultFn: (input: string) => string) => string,\n  refs: { [key: string]: { target: string; title: string } },\n  options: MarkdownToJSX.Options\n) => {\n  const renderRule = (\n    node: MarkdownToJSX.ASTNode,\n    renderChildren: (children: MarkdownToJSX.ASTNode[]) => React.ReactNode,\n    state: MarkdownToJSX.State\n  ) => {\n    const defaultRender = () =>\n      render(node, renderChildren, state, h, sanitize, slug, refs, options)\n    return userRender\n      ? userRender(defaultRender, node, renderChildren, state)\n      : defaultRender()\n  }\n  const handleStackOverflow = (ast: MarkdownToJSX.ASTNode[]) =>\n    ast.map(node => ('text' in node ? node.text : ''))\n  const renderer = (\n    ast: MarkdownToJSX.ASTNode[],\n    state: MarkdownToJSX.State = {}\n  ) => {\n    const depth = (state.renderDepth || 0) + 1\n    if (depth > 2500) return handleStackOverflow(ast)\n    state.renderDepth = depth\n\n    const oldKey = state.key,\n      result: React.ReactNode[] = []\n    let lastWasString = false\n    for (let i = 0; i < ast.length; i++) {\n      state.key = i\n      const nodeOut = renderRule(ast[i], renderer, state),\n        isString = typeof nodeOut === 'string'\n      if (isString && lastWasString) {\n        // Concatenate consecutive strings\n        result[result.length - 1] += nodeOut\n      } else if (nodeOut !== null) {\n        if (Array.isArray(nodeOut)) {\n          // Use loop instead of spread for better performance\n          for (let j = 0; j < nodeOut.length; j++) {\n            result.push(nodeOut[j])\n          }\n        } else {\n          result.push(nodeOut)\n        }\n      }\n      lastWasString = isString\n    }\n    state.key = oldKey\n    state.renderDepth = depth - 1\n    return result\n  }\n  return renderer\n}\n\nconst cx = (...args) => args.filter(Boolean).join(' ')\n\nconst get = (source, path, fallback) => {\n  let result = source,\n    segments = path.split('.'),\n    i = 0\n  while (i < segments.length) {\n    result = result?.[segments[i]]\n    if (result === undefined) break\n    i++\n  }\n  return result || fallback\n}\n\nconst getTag = (tag, overrides) => {\n  const override = get(overrides, tag, undefined)\n  return !override\n    ? tag\n    : typeof override === 'function' ||\n        (typeof override === 'object' && 'render' in override)\n      ? override\n      : get(overrides, `${tag}.component`, tag)\n}\n\n/**\n * Convert AST nodes to React JSX elements\n * @lang zh å°† AST èŠ‚ç‚¹è½¬æ¢ä¸º React JSX å…ƒç´ \n * @lang hi AST à¤¨à¥‹à¤¡à¥à¤¸ à¤•à¥‹ React JSX à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿà¥à¤¸ à¤®à¥‡à¤‚ à¤¬à¤¦à¤²à¥‡à¤‚\n *\n * @param ast - Array of AST nodes to render\n * @lang zh @param ast - è¦æ¸²æŸ“çš„ AST èŠ‚ç‚¹æ•°ç»„\n * @lang hi @param ast - à¤°à¥‡à¤‚à¤¡à¤° à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ AST à¤¨à¥‹à¤¡à¥à¤¸ à¤•à¥€ à¤¸à¤°à¤£à¥€\n * @param options - Compiler options\n * @lang zh @param options - ç¼–è¯‘å™¨é€‰é¡¹\n * @lang hi @param options - à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤µà¤¿à¤•à¤²à¥à¤ª\n * @returns React JSX element(s)\n * @lang zh @returns React JSX å…ƒç´ \n * @lang hi @returns React JSX à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿ(s)\n */\nexport function astToJSX(\n  ast: MarkdownToJSX.ASTNode[],\n  options?: MarkdownToJSX.Options\n): React.ReactNode {\n  const opts = { ...(options || {}) }\n  opts.overrides = opts.overrides || {}\n\n  const slug = opts.slugify || util.slugify\n  const sanitize = opts.sanitizer || util.sanitizer\n  const createElement = opts.createElement || React.createElement\n\n  // Recursive compile function for HTML content\n  const compileHTML = (input: string) =>\n    compiler(input, { ...opts, wrapper: null })\n\n  // JSX custom pragma\n  // eslint-disable-next-line no-unused-vars\n  function h(\n    // locally we always will render a known string tag\n    tag: MarkdownToJSX.HTMLTags,\n    props: Parameters<MarkdownToJSX.CreateElement>[1] & {\n      className?: string\n      id?: string\n    },\n    ...children\n  ) {\n    const overrideProps = get(opts.overrides, `${tag}.props`, {})\n\n    // Convert HTML attributes to JSX props and compile any HTML content\n    const jsxProps = htmlAttrsToJSXProps(props || {})\n    if (compileHTML) {\n      for (const [key, value] of Object.entries(jsxProps)) {\n        if (\n          typeof value === 'string' &&\n          value.length > 0 &&\n          value[0] === '<' &&\n          (parse.HTML_BLOCK_ELEMENT_START_R_ATTR.test(value) ||\n            parse.UPPERCASE_TAG_R.test(value) ||\n            parse.parseHTMLTag(value, 0))\n        ) {\n          jsxProps[key] = compileHTML(value.trim())\n        }\n      }\n    }\n\n    return createElement(\n      getTag(tag, opts.overrides),\n      {\n        ...jsxProps,\n        ...overrideProps,\n        className:\n          cx(jsxProps?.className, overrideProps.className) || undefined,\n      },\n      ...children\n    )\n  }\n\n  // Post-process AST for JSX compatibility: combine HTML blocks with following paragraphs\n  // when the HTML block contains <pre> tags (to keep pre content as plain text)\n  const postProcessedAst: MarkdownToJSX.ASTNode[] = []\n  for (let i = 0; i < ast.length; i++) {\n    const node = ast[i]\n    if (\n      node.type === RuleType.htmlBlock &&\n      'rawText' in node &&\n      node.rawText &&\n      /<\\/?pre\\b/i.test(node.rawText) &&\n      i + 1 < ast.length &&\n      ast[i + 1].type === RuleType.paragraph &&\n      'removedClosingTags' in ast[i + 1] &&\n      (\n        ast[i + 1] as MarkdownToJSX.ParagraphNode & {\n          removedClosingTags?: MarkdownToJSX.ASTNode[]\n        }\n      ).removedClosingTags\n    ) {\n      const htmlNode = node as MarkdownToJSX.HTMLNode,\n        paragraphNode = ast[i + 1] as MarkdownToJSX.ParagraphNode & {\n          removedClosingTags?: MarkdownToJSX.ASTNode[]\n        }\n      function extractText(nodes: MarkdownToJSX.ASTNode[]): string {\n        let text = ''\n        for (const n of nodes) {\n          const type = n.type\n          if (type === RuleType.text) text += (n as MarkdownToJSX.TextNode).text\n          else if (\n            type === RuleType.htmlSelfClosing &&\n            'rawText' in n &&\n            (n as MarkdownToJSX.HTMLSelfClosingNode & { rawText?: string })\n              .rawText\n          )\n            text += (\n              n as MarkdownToJSX.HTMLSelfClosingNode & { rawText?: string }\n            ).rawText!\n          else if (type === RuleType.textFormatted) {\n            const formattedNode = n as MarkdownToJSX.FormattedTextNode\n            const marker =\n              formattedNode.tag === 'em'\n                ? '_'\n                : formattedNode.tag === 'strong'\n                  ? '**'\n                  : ''\n            text += marker + extractText(formattedNode.children) + marker\n          } else if ('children' in n && n.children)\n            text += extractText(n.children)\n        }\n        return text\n      }\n      let combinedText = extractText(paragraphNode.children)\n      if (paragraphNode.removedClosingTags) {\n        combinedText += paragraphNode.removedClosingTags\n          .filter(\n            (tag: MarkdownToJSX.ASTNode) =>\n              tag.type === RuleType.htmlSelfClosing &&\n              'rawText' in tag &&\n              (\n                tag as MarkdownToJSX.HTMLSelfClosingNode & {\n                  rawText?: string\n                }\n              ).rawText &&\n              (\n                tag as MarkdownToJSX.HTMLSelfClosingNode & {\n                  rawText?: string\n                }\n              ).rawText!.indexOf(`</${htmlNode.tag}>`) === -1\n          )\n          .map((tag: MarkdownToJSX.ASTNode) =>\n            tag.type === RuleType.htmlSelfClosing && 'rawText' in tag\n              ? (\n                  tag as MarkdownToJSX.HTMLSelfClosingNode & {\n                    rawText?: string\n                  }\n                ).rawText || ''\n              : ''\n          )\n          .join('')\n      }\n      htmlNode.rawText = (htmlNode.rawText || '') + '\\n' + combinedText\n      htmlNode.text = htmlNode.rawText // @deprecated - use rawText instead\n      i++ // Skip paragraph\n    }\n    postProcessedAst.push(node)\n  }\n  ast = postProcessedAst\n\n  const parseOptions: parse.ParseOptions = {\n    ...opts,\n    slugify: i => slug(i, util.slugify),\n    sanitizer: sanitize,\n    tagfilter: opts.tagfilter !== false,\n  }\n\n  const refs =\n    ast[0] && ast[0].type === RuleType.refCollection\n      ? (ast[0] as MarkdownToJSX.ReferenceCollectionNode).refs\n      : {}\n\n  const emitter = createRenderer(opts.renderRule, h, sanitize, slug, refs, opts)\n\n  const arr = emitter(ast, {\n    inline: opts.forceInline,\n    refs: refs,\n  }) as React.ReactNode[]\n\n  // Extract footnotes from refs (keys starting with '^')\n  const footnoteEntries: { identifier: string; footnote: string }[] = []\n  for (const key in refs) {\n    if (key.charCodeAt(0) === $.CHAR_CARET) {\n      footnoteEntries.push({ identifier: key, footnote: refs[key].target })\n    }\n  }\n\n  if (footnoteEntries.length) {\n    arr.push(\n      <footer key=\"footer\">\n        {footnoteEntries.map(function createFootnote(def) {\n          const identifierWithoutCaret =\n            def.identifier.charCodeAt(0) === $.CHAR_CARET\n              ? def.identifier.slice(1)\n              : def.identifier\n          const footnoteAstNodes = parse.parseMarkdown(\n            def.footnote,\n            { inline: true, refs: refs },\n            parseOptions\n          )\n          return h(\n            'div',\n            {\n              id: slug(identifierWithoutCaret, util.slugify),\n              key: def.identifier,\n            },\n            identifierWithoutCaret + ': ',\n            emitter(footnoteAstNodes, { inline: true, refs: refs })\n          )\n        })}\n      </footer>\n    )\n  }\n\n  if (opts.wrapper === null) {\n    return arr\n  }\n\n  const wrapper = opts.wrapper || (opts.forceInline ? 'span' : 'div')\n  let jsx: React.ReactNode\n\n  if (arr.length > 1 || opts.forceWrapper) {\n    jsx = arr\n  } else if (arr.length === 1) {\n    return arr[0]\n  } else {\n    return null\n  }\n\n  return createElement(\n    wrapper,\n    { key: 'outer', ...opts.wrapperProps },\n    jsx\n  ) as React.JSX.Element\n}\n\n/**\n * Compile markdown string to React JSX elements\n * @lang zh å°† Markdown å­—ç¬¦ä¸²ç¼–è¯‘ä¸º React JSX å…ƒç´ \n * @lang hi Markdown à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤— à¤•à¥‹ React JSX à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿà¥à¤¸ à¤®à¥‡à¤‚ à¤•à¤‚à¤ªà¤¾à¤‡à¤² à¤•à¤°à¥‡à¤‚\n *\n * @param markdown - Markdown string to compile\n * @lang zh @param markdown - è¦ç¼–è¯‘çš„ Markdown å­—ç¬¦ä¸²\n * @lang hi @param markdown - à¤•à¤‚à¤ªà¤¾à¤‡à¤² à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ Markdown à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤—\n * @param options - Compiler options\n * @lang zh @param options - ç¼–è¯‘å™¨é€‰é¡¹\n * @lang hi @param options - à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤µà¤¿à¤•à¤²à¥à¤ª\n * @returns React JSX element(s)\n * @lang zh @returns React JSX å…ƒç´ \n * @lang hi @returns React JSX à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿ(s)\n */\nexport function compiler(\n  markdown: string = '',\n  options: MarkdownToJSX.Options = {}\n): React.ReactNode {\n  const opts = { ...(options || {}) }\n  opts.overrides = opts.overrides || {}\n\n  const slug = opts.slugify || util.slugify\n  const sanitize = opts.sanitizer || util.sanitizer\n\n  function compile(input: string): React.ReactNode {\n    const inline =\n      opts.forceInline ||\n      (!opts.forceBlock && !util.SHOULD_RENDER_AS_BLOCK_R.test(input))\n    const parseOptions: parse.ParseOptions = {\n      ...opts,\n      slugify: i => slug(i, util.slugify),\n      sanitizer: sanitize,\n      tagfilter: opts.tagfilter !== false,\n    }\n\n    // First pass: collect all reference definitions\n    // This ensures refs are available during inline parsing, even when they appear after their usage\n    if (!inline) {\n      parse.collectReferenceDefinitions(input, refs, parseOptions)\n    }\n\n    // Inline trimEnd: trim trailing newlines and carriage returns\n    let processedInput = input\n    if (!inline) {\n      let e = processedInput.length\n      while (\n        e > 0 &&\n        (processedInput[e - 1] === '\\n' || processedInput[e - 1] === '\\r')\n      )\n        e--\n      processedInput = processedInput.slice(0, e)\n      processedInput = `${processedInput.replace(TRIM_STARTING_NEWLINES, '')}\\n\\n`\n    }\n\n    // In streaming mode, strip trailing incomplete HTML tags to prevent infinite recursion\n    if (opts.optimizeForStreaming) {\n      // Find last '<' that doesn't have a matching '>'\n      let lastLt = processedInput.lastIndexOf('<')\n      if (lastLt !== -1) {\n        let afterLt = processedInput.slice(lastLt)\n        // Check if there's a complete tag (has '>')\n        if (afterLt.indexOf('>') === -1) {\n          // Incomplete tag - truncate before it\n          processedInput = processedInput.slice(0, lastLt)\n        }\n      }\n    }\n\n    let astNodes = parse.parseMarkdown(\n      inline ? input : processedInput,\n      { inline: inline, refs: refs },\n      parseOptions\n    )\n\n    return astToJSX(astNodes, {\n      ...parseOptions,\n      forceInline: inline,\n    })\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof markdown !== 'string') {\n      throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`)\n    }\n\n    if (Object.prototype.toString.call(opts.overrides) !== '[object Object]') {\n      throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`)\n    }\n  }\n\n  const refs: { [key: string]: { target: string; title: string | undefined } } =\n    {}\n\n  const jsx = compile(markdown)\n\n  return jsx\n}\n\n/**\n * React context provider for sharing compiler options across Markdown components\n * @lang zh ç”¨äºåœ¨ Markdown ç»„ä»¶ä¹‹é—´å…±äº«ç¼–è¯‘å™¨é€‰é¡¹çš„ React ä¸Šä¸‹æ–‡æä¾›è€…\n * @lang hi Markdown à¤•à¤‚à¤ªà¥‹à¤¨à¥‡à¤‚à¤Ÿà¥à¤¸ à¤•à¥‡ à¤¬à¥€à¤š à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤µà¤¿à¤•à¤²à¥à¤ª à¤¸à¤¾à¤à¤¾ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ React à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤ªà¥à¤°à¤¦à¤¾à¤¤à¤¾\n *\n * @param options - Default compiler options to share\n * @lang zh @param options - è¦å…±äº«çš„é»˜è®¤ç¼–è¯‘å™¨é€‰é¡¹\n * @lang hi @param options - à¤¸à¤¾à¤à¤¾ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¡à¤¿à¤«à¤¼à¥‰à¤²à¥à¤Ÿ à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤µà¤¿à¤•à¤²à¥à¤ª\n * @param children - React children\n * @lang zh @param children - React å­å…ƒç´ \n * @lang hi @param children - React à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿà¥à¤¸\n */\nexport const MarkdownProvider: React.FC<{\n  options?: MarkdownToJSX.Options\n  children: React.ReactNode\n}> = ({ options, children }) => {\n  if (!MarkdownContext) {\n    return children as React.ReactElement\n  }\n  return React.createElement(\n    MarkdownContext.Provider,\n    { value: options },\n    children\n  )\n}\n\n/**\n * A React component for easy markdown rendering. Feed the markdown content as a direct child\n * and the rest is taken care of automatically. Supports memoization for optimal performance.\n * @lang zh ç”¨äºè½»æ¾æ¸²æŸ“ Markdown çš„ React ç»„ä»¶ã€‚å°† Markdown å†…å®¹ä½œä¸ºç›´æ¥å­å…ƒç´ æä¾›ï¼Œå…¶ä½™éƒ¨åˆ†ä¼šè‡ªåŠ¨å¤„ç†ã€‚æ”¯æŒè®°å¿†åŒ–ä»¥è·å¾—æœ€ä½³æ€§èƒ½ã€‚\n * @lang hi à¤†à¤¸à¤¾à¤¨ markdown à¤°à¥‡à¤‚à¤¡à¤°à¤¿à¤‚à¤— à¤•à¥‡ à¤²à¤¿à¤ à¤à¤• React à¤•à¤‚à¤ªà¥‹à¤¨à¥‡à¤‚à¤Ÿà¥¤ markdown à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤•à¥‹ à¤¸à¥€à¤§à¥‡ à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤ªà¥à¤°à¤¦à¤¾à¤¨ à¤•à¤°à¥‡à¤‚ à¤”à¤° à¤¬à¤¾à¤•à¥€ à¤¸à¥à¤µà¤šà¤¾à¤²à¤¿à¤¤ à¤°à¥‚à¤ª à¤¸à¥‡ à¤¸à¤‚à¤­à¤¾à¤²à¤¾ à¤œà¤¾à¤¤à¤¾ à¤¹à¥ˆà¥¤ à¤‡à¤·à¥à¤Ÿà¤¤à¤® à¤ªà¥à¤°à¤¦à¤°à¥à¤¶à¤¨ à¤•à¥‡ à¤²à¤¿à¤ à¤®à¥‡à¤®à¥‹à¤‡à¤œà¤¼à¥‡à¤¶à¤¨ à¤•à¤¾ à¤¸à¤®à¤°à¥à¤¥à¤¨ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆà¥¤\n *\n * @param children - Markdown string content\n * @lang zh @param children - Markdown å­—ç¬¦ä¸²å†…å®¹\n * @lang hi @param children - Markdown à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤— à¤¸à¤¾à¤®à¤—à¥à¤°à¥€\n * @param options - Compiler options\n * @lang zh @param options - ç¼–è¯‘å™¨é€‰é¡¹\n * @lang hi @param options - à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤µà¤¿à¤•à¤²à¥à¤ª\n * @param props - Additional HTML attributes for the wrapper element\n * @lang zh @param props - åŒ…è£…å…ƒç´ çš„é¢å¤– HTML å±æ€§\n * @lang hi @param props - à¤°à¥ˆà¤ªà¤° à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿ à¤•à¥‡ à¤²à¤¿à¤ à¤…à¤¤à¤¿à¤°à¤¿à¤•à¥à¤¤ HTML à¤à¤Ÿà¥à¤°à¤¿à¤¬à¥à¤¯à¥‚à¤Ÿà¥à¤¸\n */\nexport const Markdown: React.FC<\n  Omit<React.HTMLAttributes<Element>, 'children'> & {\n    children?: string | null\n    options?: MarkdownToJSX.Options\n  }\n> = ({ children: rawChildren, options, ...props }) => {\n  const hasHooks = typeof React.useContext !== 'undefined'\n\n  // RSC path: direct execution\n  if (!hasHooks) {\n    const mergedOptions = {\n      ...options,\n      overrides: {\n        ...options?.overrides,\n      },\n      wrapperProps: {\n        ...options?.wrapperProps,\n        ...props,\n      } as React.JSX.IntrinsicAttributes,\n    }\n    const content =\n      rawChildren === null || rawChildren === undefined ? '' : rawChildren\n    return compiler(content, mergedOptions) as React.ReactElement\n  }\n\n  // Client path: existing hook-based implementation\n  const contextOptions = React.useContext(MarkdownContext!)\n  const mergedOptions = React.useMemo(\n    () => ({\n      ...contextOptions,\n      ...options,\n      overrides: {\n        ...contextOptions?.overrides,\n        ...options?.overrides,\n      },\n      wrapperProps: {\n        ...contextOptions?.wrapperProps,\n        ...options?.wrapperProps,\n        ...props,\n      } as React.JSX.IntrinsicAttributes,\n    }),\n    [contextOptions, options, props]\n  )\n\n  const content =\n    rawChildren === null || rawChildren === undefined ? '' : rawChildren\n\n  const jsx = React.useMemo(\n    () => compiler(content, mergedOptions),\n    [content, mergedOptions]\n  )\n\n  return jsx as React.ReactElement\n}\n\n// MarkdownToJSX namespace moved to types.ts\n\nexport default Markdown\n","// Character codes\nexport const CHAR_SPACE = 32\nexport const CHAR_TAB = 9\nexport const CHAR_CR = 13\nexport const CHAR_NEWLINE = 10\nexport const CHAR_BACKTICK = 96\nexport const CHAR_TILDE = 126\nexport const CHAR_BRACKET_OPEN = 91\nexport const CHAR_CARET = 94\nexport const CHAR_GT = 62\nexport const CHAR_HASH = 35\nexport const CHAR_PERCENT = 37\nexport const CHAR_DASH = 45\nexport const CHAR_EQ = 61\nexport const CHAR_BACKSLASH = 92\nexport const CHAR_ASTERISK = 42\nexport const CHAR_UNDERSCORE = 95\nexport const CHAR_LT = 60\nexport const CHAR_AT = 64\nexport const CHAR_BRACKET_CLOSE = 93\nexport const CHAR_EXCLAMATION = 33\nexport const CHAR_AMPERSAND = 38\nexport const CHAR_COLON = 58\nexport const CHAR_F = 70\nexport const CHAR_f = 102\nexport const CHAR_H = 104\nexport const CHAR_W = 119\nexport const CHAR_t = 116\nexport const CHAR_p = 112\nexport const CHAR_s = 115\nexport const CHAR_NBSP = 160\nexport const CHAR_FF = 12\nexport const CHAR_COMMA = 44\nexport const CHAR_SEMICOLON = 59\nexport const CHAR_QUESTION = 63\nexport const CHAR_PERIOD = 46\nexport const CHAR_SLASH = 47\nexport const CHAR_SINGLE_QUOTE = 39\nexport const CHAR_DOUBLE_QUOTE = 34\nexport const CHAR_PLUS = 43\nexport const CHAR_PIPE = 124\nexport const CHAR_BRACE_OPEN = 123 // {\nexport const CHAR_BRACE_CLOSE = 125 // }\nexport const CHAR_PAREN_OPEN = 40 // (\nexport const CHAR_PAREN_CLOSE = 41 // )\nexport const CHAR_x = 120\nexport const CHAR_X = 88\n// Character code ranges for common character classes\nexport const CHAR_DIGIT_0 = 48\nexport const CHAR_DIGIT_9 = 57\nexport const CHAR_A = 65\nexport const CHAR_Z = 90\nexport const CHAR_a = 97\nexport const CHAR_z = 122\nexport const CHAR_ASCII_BOUNDARY = 128\n// Case conversion offset: difference between uppercase and lowercase ASCII letters\nexport const CHAR_CASE_OFFSET = 32 // 'A' (65) to 'a' (97) = 32\n","// Re-export React for convenience since types reference it\nimport * as React from 'react'\n\n/**\n * Analogous to `node.type`. Please note that the values here may change at any time,\n * so do not hard code against the value directly.\n */\nconst RuleTypeConst = {\n  blockQuote: 0,\n  breakLine: 1,\n  breakThematic: 2,\n  codeBlock: 3,\n  codeInline: 4,\n  footnote: 5,\n  footnoteReference: 6,\n  frontmatter: 7,\n  gfmTask: 8,\n  heading: 9,\n  htmlBlock: 10,\n  htmlComment: 11,\n  htmlSelfClosing: 12,\n  image: 13,\n  link: 14,\n  orderedList: 15,\n  paragraph: 16,\n  ref: 17,\n  refCollection: 18,\n  table: 19,\n  text: 20,\n  textFormatted: 21,\n  unorderedList: 22,\n} as const\n\nif (process.env.NODE_ENV === 'test') {\n  // In test mode, use strings for better debugging\n  Object.keys(RuleTypeConst).forEach(key => (RuleTypeConst[key] = key))\n}\n\ntype RuleTypeValue = (typeof RuleTypeConst)[keyof typeof RuleTypeConst]\n\n/**\n * markdown-to-jsx types and interfaces\n * @lang zh markdown-to-jsx ç±»å‹å’Œæ¥å£\n * @lang hi markdown-to-jsx à¤ªà¥à¤°à¤•à¤¾à¤° à¤”à¤° à¤‡à¤‚à¤Ÿà¤°à¤«à¤¼à¥‡à¤¸\n */\ndeclare namespace MarkdownToJSX {\n  /**\n   * RequireAtLeastOne<{ ... }> <- only requires at least one key\n   * @lang zh RequireAtLeastOne<{ ... }> <- åªéœ€è¦è‡³å°‘ä¸€ä¸ªé”®\n   * @lang hi RequireAtLeastOne<{ ... }> <- à¤•à¥‡à¤µà¤² à¤•à¤® à¤¸à¥‡ à¤•à¤® à¤à¤• à¤•à¥à¤‚à¤œà¥€ à¤•à¥€ à¤†à¤µà¤¶à¥à¤¯à¤•à¤¤à¤¾ à¤¹à¥ˆ\n   */\n  type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n    T,\n    Exclude<keyof T, Keys>\n  > &\n    {\n      [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n  /**\n   * React.createElement function type\n   * @lang zh React.createElement å‡½æ•°ç±»å‹\n   * @lang hi React.createElement à¤«à¤¼à¤‚à¤•à¥à¤¶à¤¨ à¤ªà¥à¤°à¤•à¤¾à¤°\n   */\n  export type CreateElement = typeof React.createElement\n\n  /**\n   * HTML tag names that can be used in JSX\n   * @lang zh å¯åœ¨ JSX ä¸­ä½¿ç”¨çš„ HTML æ ‡ç­¾åç§°\n   * @lang hi HTML à¤Ÿà¥ˆà¤— à¤¨à¤¾à¤® à¤œà¥‹ JSX à¤®à¥‡à¤‚ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤¿à¤ à¤œà¤¾ à¤¸à¤•à¤¤à¥‡ à¤¹à¥ˆà¤‚\n   */\n  export type HTMLTags = keyof React.JSX.IntrinsicElements & (string & {})\n\n  /**\n   * Parser and renderer state\n   * @lang zh è§£æå™¨å’Œæ¸²æŸ“å™¨çŠ¶æ€\n   * @lang hi à¤ªà¤¾à¤°à¥à¤¸à¤° à¤”à¤° à¤°à¥‡à¤‚à¤¡à¤°à¤° à¤¸à¥à¤¥à¤¿à¤¤à¤¿\n   */\n  export type State = {\n    /** true if the current content is inside anchor link grammar */\n    /** @lang zh å¦‚æœå½“å‰å†…å®¹åœ¨é”šç‚¹é“¾æ¥è¯­æ³•å†…ï¼Œåˆ™ä¸º true */\n    /** @lang hi true à¤¯à¤¦à¤¿ à¤µà¤°à¥à¤¤à¤®à¤¾à¤¨ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤à¤‚à¤•à¤° à¤²à¤¿à¤‚à¤• à¤µà¥à¤¯à¤¾à¤•à¤°à¤£ à¤•à¥‡ à¤…à¤‚à¤¦à¤° à¤¹à¥ˆ */\n    inAnchor?: boolean\n    /** true if inside a blockquote */\n    /** @lang zh å¦‚æœåœ¨å¼•ç”¨å—å†…ï¼Œåˆ™ä¸º true */\n    /** @lang hi true à¤¯à¤¦à¤¿ à¤¬à¥à¤²à¥‰à¤•à¤•à¥‹à¤Ÿ à¤•à¥‡ à¤…à¤‚à¤¦à¤° à¤¹à¥ˆ */\n    inBlockQuote?: boolean\n    /** true if parsing in an HTML context */\n    /** @lang zh å¦‚æœåœ¨ HTML ä¸Šä¸‹æ–‡ä¸­è§£æï¼Œåˆ™ä¸º true */\n    /** @lang hi true à¤¯à¤¦à¤¿ HTML à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤®à¥‡à¤‚ à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤° à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚ */\n    inHTML?: boolean\n    /** true if in a list */\n    /** @lang zh å¦‚æœåœ¨åˆ—è¡¨ä¸­ï¼Œåˆ™ä¸º true */\n    /** @lang hi true à¤¯à¤¦à¤¿ à¤¸à¥‚à¤šà¥€ à¤®à¥‡à¤‚ à¤¹à¥ˆ */\n    inList?: boolean\n    /** true if parsing in an inline context (subset of rules around formatting and links) */\n    /** @lang zh å¦‚æœåœ¨å†…è”ä¸Šä¸‹æ–‡ä¸­è§£æï¼ˆå›´ç»•æ ¼å¼å’Œé“¾æ¥çš„è§„åˆ™å­é›†ï¼‰ï¼Œåˆ™ä¸º true */\n    /** @lang hi true à¤¯à¤¦à¤¿ à¤‡à¤¨à¤²à¤¾à¤‡à¤¨ à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤®à¥‡à¤‚ à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤° à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚ (à¤«à¤¼à¥‰à¤°à¥à¤®à¥‡à¤Ÿà¤¿à¤‚à¤— à¤”à¤° à¤²à¤¿à¤‚à¤• à¤•à¥‡ à¤†à¤¸à¤ªà¤¾à¤¸ à¤•à¥‡ à¤¨à¤¿à¤¯à¤®à¥‹à¤‚ à¤•à¤¾ à¤‰à¤ªà¤¸à¤®à¥à¤šà¥à¤šà¤¯) */\n    inline?: boolean\n\n    /** use this for the `key` prop */\n    /** @lang zh ç”¨äº `key` å±æ€§ */\n    /** @lang hi `key` prop à¤•à¥‡ à¤²à¤¿à¤ à¤‡à¤¸à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚ */\n    key?: string | number\n    /** reference definitions (footnotes are stored with '^' prefix) */\n    /** @lang zh å¼•ç”¨å®šä¹‰ï¼ˆè„šæ³¨ä»¥ '^' å‰ç¼€å­˜å‚¨ï¼‰ */\n    /** @lang hi à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤ªà¤°à¤¿à¤­à¤¾à¤·à¤¾à¤à¤‚ (à¤«à¤¼à¥à¤Ÿà¤¨à¥‹à¤Ÿà¥à¤¸ '^' à¤‰à¤ªà¤¸à¤°à¥à¤— à¤•à¥‡ à¤¸à¤¾à¤¥ à¤¸à¤‚à¤—à¥à¤°à¤¹à¥€à¤¤ à¤¹à¥ˆà¤‚) */\n    refs?: { [key: string]: { target: string; title: string | undefined } }\n    /** current recursion depth during rendering */\n    /** @lang zh æ¸²æŸ“æœŸé—´çš„å½“å‰é€’å½’æ·±åº¦ */\n    /** @lang hi à¤°à¥‡à¤‚à¤¡à¤°à¤¿à¤‚à¤— à¤•à¥‡ à¤¦à¥Œà¤°à¤¾à¤¨ à¤µà¤°à¥à¤¤à¤®à¤¾à¤¨ à¤ªà¥à¤¨à¤°à¤¾à¤µà¥ƒà¤¤à¥à¤¤à¤¿ à¤—à¤¹à¤°à¤¾à¤ˆ */\n    renderDepth?: number\n  }\n\n  /**\n   * Blockquote node in the AST\n   * @lang zh AST ä¸­çš„å¼•ç”¨å—èŠ‚ç‚¹\n   * @lang hi AST à¤®à¥‡à¤‚ à¤¬à¥à¤²à¥‰à¤•à¤•à¥‹à¤Ÿ à¤¨à¥‹à¤¡\n   */\n  export interface BlockQuoteNode {\n    /** Optional alert type (Note, Tip, Warning, etc.) */\n    /** @lang zh å¯é€‰çš„è­¦å‘Šç±»å‹ (Note, Tip, Warning ç­‰) */\n    /** @lang hi à¤µà¥ˆà¤•à¤²à¥à¤ªà¤¿à¤• à¤…à¤²à¤°à¥à¤Ÿ à¤ªà¥à¤°à¤•à¤¾à¤° (Note, Tip, Warning, à¤†à¤¦à¤¿) */\n    alert?: string\n    /** Child nodes within the blockquote */\n    /** @lang zh å¼•ç”¨å—ä¸­çš„å­èŠ‚ç‚¹ */\n    /** @lang hi à¤¬à¥à¤²à¥‰à¤•à¤•à¥‹à¤Ÿ à¤•à¥‡ à¤­à¥€à¤¤à¤° à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤¨à¥‹à¤¡à¥à¤¸ */\n    children: MarkdownToJSX.ASTNode[]\n    type: typeof RuleType.blockQuote\n  }\n\n  /**\n   * Hard line break node\n   * @lang zh ç¡¬æ¢è¡ŒèŠ‚ç‚¹\n   * @lang hi à¤¹à¤¾à¤°à¥à¤¡ à¤²à¤¾à¤‡à¤¨ à¤¬à¥à¤°à¥‡à¤• à¤¨à¥‹à¤¡\n   */\n  export interface BreakLineNode {\n    type: typeof RuleType.breakLine\n  }\n\n  /**\n   * Thematic break (horizontal rule) node\n   * @lang zh åˆ†éš”çº¿ï¼ˆæ°´å¹³çº¿ï¼‰èŠ‚ç‚¹\n   * @lang hi à¤¥à¥€à¤®à¥ˆà¤Ÿà¤¿à¤• à¤¬à¥à¤°à¥‡à¤• (à¤•à¥à¤·à¥ˆà¤¤à¤¿à¤œ à¤¨à¤¿à¤¯à¤®) à¤¨à¥‹à¤¡\n   */\n  export interface BreakThematicNode {\n    type: typeof RuleType.breakThematic\n  }\n\n  /**\n   * Code block node (fenced code blocks)\n   * @lang zh ä»£ç å—èŠ‚ç‚¹ï¼ˆå›´æ ä»£ç å—ï¼‰\n   * @lang hi à¤•à¥‹à¤¡ à¤¬à¥à¤²à¥‰à¤• à¤¨à¥‹à¤¡ (à¤«à¤¼à¥‡à¤‚à¤¸à¥à¤¡ à¤•à¥‹à¤¡ à¤¬à¥à¤²à¥‰à¤•à¥à¤¸)\n   */\n  export interface CodeBlockNode {\n    type: typeof RuleType.codeBlock\n    /** HTML attributes for the code block */\n    /** @lang zh ä»£ç å—çš„ HTML å±æ€§ */\n    /** @lang hi à¤•à¥‹à¤¡ à¤¬à¥à¤²à¥‰à¤• à¤•à¥‡ à¤²à¤¿à¤ HTML à¤à¤Ÿà¥à¤°à¤¿à¤¬à¥à¤¯à¥‚à¤Ÿà¥à¤¸ */\n    attrs?: React.JSX.IntrinsicAttributes\n    /** Programming language identifier */\n    /** @lang zh ç¼–ç¨‹è¯­è¨€æ ‡è¯†ç¬¦ */\n    /** @lang hi à¤ªà¥à¤°à¥‹à¤—à¥à¤°à¤¾à¤®à¤¿à¤‚à¤— à¤­à¤¾à¤·à¤¾ à¤ªà¤¹à¤šà¤¾à¤¨à¤•à¤°à¥à¤¤à¤¾ */\n    lang?: string\n    /** Code content */\n    /** @lang zh ä»£ç å†…å®¹ */\n    /** @lang hi à¤•à¥‹à¤¡ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ */\n    text: string\n  }\n\n  /**\n   * Inline code node\n   * @lang zh å†…è”ä»£ç èŠ‚ç‚¹\n   * @lang hi à¤‡à¤¨à¤²à¤¾à¤‡à¤¨ à¤•à¥‹à¤¡ à¤¨à¥‹à¤¡\n   */\n  export interface CodeInlineNode {\n    type: typeof RuleType.codeInline\n    /** Code text */\n    /** @lang zh ä»£ç æ–‡æœ¬ */\n    /** @lang hi à¤•à¥‹à¤¡ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ */\n    text: string\n  }\n\n  /**\n   * Footnote definition node (not rendered, stored in refCollection)\n   * @lang zh è„šæ³¨å®šä¹‰èŠ‚ç‚¹ï¼ˆä¸æ¸²æŸ“ï¼Œå­˜å‚¨åœ¨ refCollection ä¸­ï¼‰\n   * @lang hi à¤«à¤¼à¥à¤Ÿà¤¨à¥‹à¤Ÿ à¤ªà¤°à¤¿à¤­à¤¾à¤·à¤¾ à¤¨à¥‹à¤¡ (à¤°à¥‡à¤‚à¤¡à¤° à¤¨à¤¹à¥€à¤‚ à¤•à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾, refCollection à¤®à¥‡à¤‚ à¤¸à¤‚à¤—à¥à¤°à¤¹à¥€à¤¤)\n   */\n  export interface FootnoteNode {\n    type: typeof RuleType.footnote\n  }\n\n  /**\n   * Footnote reference node\n   * @lang zh è„šæ³¨å¼•ç”¨èŠ‚ç‚¹\n   * @lang hi à¤«à¤¼à¥à¤Ÿà¤¨à¥‹à¤Ÿ à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤¨à¥‹à¤¡\n   */\n  export interface FootnoteReferenceNode {\n    type: typeof RuleType.footnoteReference\n    /** Link target (anchor) */\n    /** @lang zh é“¾æ¥ç›®æ ‡ï¼ˆé”šç‚¹ï¼‰ */\n    /** @lang hi à¤²à¤¿à¤‚à¤• à¤²à¤•à¥à¤·à¥à¤¯ (à¤à¤‚à¤•à¤°) */\n    target: string\n    /** Display text */\n    /** @lang zh æ˜¾ç¤ºæ–‡æœ¬ */\n    /** @lang hi à¤ªà¥à¤°à¤¦à¤°à¥à¤¶à¤¨ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ */\n    text: string\n  }\n\n  /**\n   * YAML frontmatter node\n   * @lang zh YAML å‰ç½®å…ƒæ•°æ®èŠ‚ç‚¹\n   * @lang hi YAML à¤«à¥à¤°à¤‚à¤Ÿà¤®à¥ˆà¤Ÿà¤° à¤¨à¥‹à¤¡\n   */\n  export interface FrontmatterNode {\n    type: typeof RuleType.frontmatter\n    /** Frontmatter content */\n    /** @lang zh å‰ç½®å…ƒæ•°æ®å†…å®¹ */\n    /** @lang hi à¤«à¥à¤°à¤‚à¤Ÿà¤®à¥ˆà¤Ÿà¤° à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ */\n    text: string\n  }\n\n  /**\n   * GFM task list item node\n   * @lang zh GFM ä»»åŠ¡åˆ—è¡¨é¡¹èŠ‚ç‚¹\n   * @lang hi GFM à¤Ÿà¤¾à¤¸à¥à¤• à¤²à¤¿à¤¸à¥à¤Ÿ à¤†à¤‡à¤Ÿà¤® à¤¨à¥‹à¤¡\n   */\n  export interface GFMTaskNode {\n    type: typeof RuleType.gfmTask\n    /** Whether the task is completed */\n    /** @lang zh ä»»åŠ¡æ˜¯å¦å·²å®Œæˆ */\n    /** @lang hi à¤•à¥à¤¯à¤¾ à¤Ÿà¤¾à¤¸à¥à¤• à¤ªà¥‚à¤°à¥à¤£ à¤¹à¥ˆ */\n    completed: boolean\n  }\n\n  /**\n   * Heading node\n   * @lang zh æ ‡é¢˜èŠ‚ç‚¹\n   * @lang hi à¤¹à¥‡à¤¡à¤¿à¤‚à¤— à¤¨à¥‹à¤¡\n   */\n  export interface HeadingNode {\n    type: typeof RuleType.heading\n    /** Child nodes (text content) */\n    /** @lang zh å­èŠ‚ç‚¹ï¼ˆæ–‡æœ¬å†…å®¹ï¼‰ */\n    /** @lang hi à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤¨à¥‹à¤¡à¥à¤¸ (à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€) */\n    children: MarkdownToJSX.ASTNode[]\n    /** Generated HTML ID for anchor linking */\n    /** @lang zh ç”¨äºé”šç‚¹é“¾æ¥çš„ç”Ÿæˆçš„ HTML ID */\n    /** @lang hi à¤à¤‚à¤•à¤° à¤²à¤¿à¤‚à¤•à¤¿à¤‚à¤— à¤•à¥‡ à¤²à¤¿à¤ à¤œà¥‡à¤¨à¤°à¥‡à¤Ÿ à¤•à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾ HTML ID */\n    id: string\n    /** Heading level (1-6) */\n    /** @lang zh æ ‡é¢˜çº§åˆ« (1-6) */\n    /** @lang hi à¤¹à¥‡à¤¡à¤¿à¤‚à¤— à¤¸à¥à¤¤à¤° (1-6) */\n    level: 1 | 2 | 3 | 4 | 5 | 6\n  }\n\n  /**\n   * HTML comment node\n   * @lang zh HTML æ³¨é‡ŠèŠ‚ç‚¹\n   * @lang hi HTML à¤•à¤®à¥‡à¤‚à¤Ÿ à¤¨à¥‹à¤¡\n   */\n  export interface HTMLCommentNode {\n    type: typeof RuleType.htmlComment\n    /** Comment text */\n    /** @lang zh æ³¨é‡Šæ–‡æœ¬ */\n    /** @lang hi à¤•à¤®à¥‡à¤‚à¤Ÿ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ */\n    text: string\n  }\n\n  /**\n   * Image node\n   * @lang zh å›¾åƒèŠ‚ç‚¹\n   * @lang hi à¤›à¤µà¤¿ à¤¨à¥‹à¤¡\n   */\n  export interface ImageNode {\n    type: typeof RuleType.image\n    /** Alt text */\n    /** @lang zh æ›¿ä»£æ–‡æœ¬ */\n    /** @lang hi Alt à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ */\n    alt?: string\n    /** Image URL */\n    /** @lang zh å›¾åƒ URL */\n    /** @lang hi à¤›à¤µà¤¿ URL */\n    target: string\n    /** Title attribute */\n    /** @lang zh æ ‡é¢˜å±æ€§ */\n    /** @lang hi à¤¶à¥€à¤°à¥à¤·à¤• à¤à¤Ÿà¥à¤°à¤¿à¤¬à¥à¤¯à¥‚à¤Ÿ */\n    title?: string\n  }\n\n  /**\n   * Link node\n   * @lang zh é“¾æ¥èŠ‚ç‚¹\n   * @lang hi à¤²à¤¿à¤‚à¤• à¤¨à¥‹à¤¡\n   */\n  export interface LinkNode {\n    type: typeof RuleType.link\n    /** Child nodes (link text) */\n    /** @lang zh å­èŠ‚ç‚¹ï¼ˆé“¾æ¥æ–‡æœ¬ï¼‰ */\n    /** @lang hi à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤¨à¥‹à¤¡à¥à¤¸ (à¤²à¤¿à¤‚à¤• à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ) */\n    children: MarkdownToJSX.ASTNode[]\n    /** Link URL (null for reference links without definition) */\n    /** @lang zh é“¾æ¥ URLï¼ˆå¯¹äºæ²¡æœ‰å®šä¹‰çš„å¼•ç”¨é“¾æ¥ä¸º nullï¼‰ */\n    /** @lang hi à¤²à¤¿à¤‚à¤• URL (à¤ªà¤°à¤¿à¤­à¤¾à¤·à¤¾ à¤•à¥‡ à¤¬à¤¿à¤¨à¤¾ à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤²à¤¿à¤‚à¤• à¤•à¥‡ à¤²à¤¿à¤ null) */\n    target: string | null\n    /** Title attribute */\n    /** @lang zh æ ‡é¢˜å±æ€§ */\n    /** @lang hi à¤¶à¥€à¤°à¥à¤·à¤• à¤à¤Ÿà¥à¤°à¤¿à¤¬à¥à¤¯à¥‚à¤Ÿ */\n    title?: string\n  }\n\n  /**\n   * Ordered list node\n   * @lang zh æœ‰åºåˆ—è¡¨èŠ‚ç‚¹\n   * @lang hi à¤•à¥à¤°à¤®à¤¬à¤¦à¥à¤§ à¤¸à¥‚à¤šà¥€ à¤¨à¥‹à¤¡\n   */\n  export interface OrderedListNode {\n    type: typeof RuleType.orderedList\n    /** Array of list items, each item is an array of nodes */\n    /** @lang zh åˆ—è¡¨é¡¹æ•°ç»„ï¼Œæ¯ä¸ªé¡¹æ˜¯èŠ‚ç‚¹æ•°ç»„ */\n    /** @lang hi à¤¸à¥‚à¤šà¥€ à¤†à¤‡à¤Ÿà¤®à¥à¤¸ à¤•à¥€ à¤¸à¤°à¤£à¥€, à¤ªà¥à¤°à¤¤à¥à¤¯à¥‡à¤• à¤†à¤‡à¤Ÿà¤® à¤¨à¥‹à¤¡à¥à¤¸ à¤•à¥€ à¤à¤• à¤¸à¤°à¤£à¥€ à¤¹à¥ˆ */\n    items: MarkdownToJSX.ASTNode[][]\n    /** Starting number for the list */\n    /** @lang zh åˆ—è¡¨çš„èµ·å§‹ç¼–å· */\n    /** @lang hi à¤¸à¥‚à¤šà¥€ à¤•à¥‡ à¤²à¤¿à¤ à¤ªà¥à¤°à¤¾à¤°à¤‚à¤­à¤¿à¤• à¤¸à¤‚à¤–à¥à¤¯à¤¾ */\n    start?: number\n  }\n\n  /**\n   * Unordered list node\n   * @lang zh æ— åºåˆ—è¡¨èŠ‚ç‚¹\n   * @lang hi à¤…à¤•à¥à¤°à¤®à¤¬à¤¦à¥à¤§ à¤¸à¥‚à¤šà¥€ à¤¨à¥‹à¤¡\n   */\n  export interface UnorderedListNode {\n    type: typeof RuleType.unorderedList\n    /** Array of list items, each item is an array of nodes */\n    /** @lang zh åˆ—è¡¨é¡¹æ•°ç»„ï¼Œæ¯ä¸ªé¡¹æ˜¯èŠ‚ç‚¹æ•°ç»„ */\n    /** @lang hi à¤¸à¥‚à¤šà¥€ à¤†à¤‡à¤Ÿà¤®à¥à¤¸ à¤•à¥€ à¤¸à¤°à¤£à¥€, à¤ªà¥à¤°à¤¤à¥à¤¯à¥‡à¤• à¤†à¤‡à¤Ÿà¤® à¤¨à¥‹à¤¡à¥à¤¸ à¤•à¥€ à¤à¤• à¤¸à¤°à¤£à¥€ à¤¹à¥ˆ */\n    items: MarkdownToJSX.ASTNode[][]\n  }\n\n  /**\n   * Paragraph node\n   * @lang zh æ®µè½èŠ‚ç‚¹\n   * @lang hi à¤ªà¥ˆà¤°à¤¾à¤—à¥à¤°à¤¾à¤« à¤¨à¥‹à¤¡\n   */\n  export interface ParagraphNode {\n    type: typeof RuleType.paragraph\n    /** Child nodes */\n    /** @lang zh å­èŠ‚ç‚¹ */\n    /** @lang hi à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤¨à¥‹à¤¡à¥à¤¸ */\n    children: MarkdownToJSX.ASTNode[]\n  }\n\n  /**\n   * Reference definition node (not rendered, stored in refCollection)\n   * @lang zh å¼•ç”¨å®šä¹‰èŠ‚ç‚¹ï¼ˆä¸æ¸²æŸ“ï¼Œå­˜å‚¨åœ¨ refCollection ä¸­ï¼‰\n   * @lang hi à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤ªà¤°à¤¿à¤­à¤¾à¤·à¤¾ à¤¨à¥‹à¤¡ (à¤°à¥‡à¤‚à¤¡à¤° à¤¨à¤¹à¥€à¤‚ à¤•à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾, refCollection à¤®à¥‡à¤‚ à¤¸à¤‚à¤—à¥à¤°à¤¹à¥€à¤¤)\n   */\n  export interface ReferenceNode {\n    type: typeof RuleType.ref\n  }\n\n  /**\n   * Reference collection node (appears at AST root, includes footnotes with '^' prefix)\n   * @lang zh å¼•ç”¨é›†åˆèŠ‚ç‚¹ï¼ˆå‡ºç°åœ¨ AST æ ¹éƒ¨ï¼ŒåŒ…æ‹¬ä»¥ '^' å‰ç¼€çš„è„šæ³¨ï¼‰\n   * @lang hi à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤¸à¤‚à¤—à¥à¤°à¤¹ à¤¨à¥‹à¤¡ (AST à¤°à¥‚à¤Ÿ à¤ªà¤° à¤¦à¤¿à¤–à¤¾à¤ˆ à¤¦à¥‡à¤¤à¤¾ à¤¹à¥ˆ, '^' à¤‰à¤ªà¤¸à¤°à¥à¤— à¤•à¥‡ à¤¸à¤¾à¤¥ à¤«à¤¼à¥à¤Ÿà¤¨à¥‹à¤Ÿà¥à¤¸ à¤¶à¤¾à¤®à¤¿à¤² à¤¹à¥ˆà¤‚)\n   */\n  export interface ReferenceCollectionNode {\n    type: typeof RuleType.refCollection\n    /** Map of reference labels to their definitions */\n    /** @lang zh å¼•ç”¨æ ‡ç­¾åˆ°å…¶å®šä¹‰çš„æ˜ å°„ */\n    /** @lang hi à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤²à¥‡à¤¬à¤²à¥à¤¸ à¤¸à¥‡ à¤‰à¤¨à¤•à¥€ à¤ªà¤°à¤¿à¤­à¤¾à¤·à¤¾à¤“à¤‚ à¤•à¤¾ à¤®à¥ˆà¤ª */\n    refs: { [key: string]: { target: string; title: string | undefined } }\n  }\n\n  /**\n   * Table node\n   * @lang zh è¡¨æ ¼èŠ‚ç‚¹\n   * @lang hi à¤Ÿà¥‡à¤¬à¤² à¤¨à¥‹à¤¡\n   */\n  export interface TableNode {\n    type: typeof RuleType.table\n    /**\n     * alignment for each table column\n     * @lang zh æ¯ä¸ªè¡¨æ ¼åˆ—çš„å¯¹é½æ–¹å¼\n     * @lang hi à¤ªà¥à¤°à¤¤à¥à¤¯à¥‡à¤• à¤Ÿà¥‡à¤¬à¤² à¤•à¥‰à¤²à¤® à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤‚à¤°à¥‡à¤–à¤£\n     */\n    align: ('left' | 'right' | 'center')[]\n    /** Table cells (3D array: rows -> cells -> nodes) */\n    /** @lang zh è¡¨æ ¼å•å…ƒæ ¼ï¼ˆä¸‰ç»´æ•°ç»„ï¼šè¡Œ -> å•å…ƒæ ¼ -> èŠ‚ç‚¹ï¼‰ */\n    /** @lang hi à¤Ÿà¥‡à¤¬à¤² à¤¸à¥‡à¤²à¥à¤¸ (3D à¤¸à¤°à¤£à¥€: à¤ªà¤‚à¤•à¥à¤¤à¤¿à¤¯à¤¾à¤ -> à¤¸à¥‡à¤²à¥à¤¸ -> à¤¨à¥‹à¤¡à¥à¤¸) */\n    cells: MarkdownToJSX.ASTNode[][][]\n    /** Table header row */\n    /** @lang zh è¡¨æ ¼æ ‡é¢˜è¡Œ */\n    /** @lang hi à¤Ÿà¥‡à¤¬à¤² à¤¹à¥‡à¤¡à¤° à¤ªà¤‚à¤•à¥à¤¤à¤¿ */\n    header: MarkdownToJSX.ASTNode[][]\n  }\n\n  /**\n   * Plain text node\n   * @lang zh çº¯æ–‡æœ¬èŠ‚ç‚¹\n   * @lang hi à¤¸à¤¾à¤¦à¤¾ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤¨à¥‹à¤¡\n   */\n  export interface TextNode {\n    type: typeof RuleType.text\n    /** Text content */\n    /** @lang zh æ–‡æœ¬å†…å®¹ */\n    /** @lang hi à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ */\n    text: string\n  }\n\n  /**\n   * Formatted text node (bold, italic, etc.)\n   * @lang zh æ ¼å¼åŒ–æ–‡æœ¬èŠ‚ç‚¹ï¼ˆåŠ ç²—ã€æ–œä½“ç­‰ï¼‰\n   * @lang hi à¤«à¤¼à¥‰à¤°à¥à¤®à¥‡à¤Ÿ à¤•à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤¨à¥‹à¤¡ (à¤¬à¥‹à¤²à¥à¤¡, à¤‡à¤Ÿà¥ˆà¤²à¤¿à¤•, à¤†à¤¦à¤¿)\n   */\n  export interface FormattedTextNode {\n    type: typeof RuleType.textFormatted\n    /**\n     * the corresponding html tag\n     * @lang zh å¯¹åº”çš„ HTML æ ‡ç­¾\n     * @lang hi à¤¸à¤‚à¤¬à¤‚à¤§à¤¿à¤¤ HTML à¤Ÿà¥ˆà¤—\n     */\n    tag: string\n    /** Child nodes */\n    /** @lang zh å­èŠ‚ç‚¹ */\n    /** @lang hi à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤¨à¥‹à¤¡à¥à¤¸ */\n    children: MarkdownToJSX.ASTNode[]\n  }\n\n  /**\n   * HTML block node (includes JSX components)\n   * @lang zh HTML å—èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ JSX ç»„ä»¶ï¼‰\n   * @lang hi HTML à¤¬à¥à¤²à¥‰à¤• à¤¨à¥‹à¤¡ (JSX à¤•à¤‚à¤ªà¥‹à¤¨à¥‡à¤‚à¤Ÿà¥à¤¸ à¤¶à¤¾à¤®à¤¿à¤² à¤¹à¥ˆà¤‚)\n   */\n  export interface HTMLNode {\n    type: typeof RuleType.htmlBlock\n    /** Parsed HTML attributes */\n    /** @lang zh è§£æåçš„ HTML å±æ€§ */\n    /** @lang hi à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤¿à¤ à¤—à¤ HTML à¤à¤Ÿà¥à¤°à¤¿à¤¬à¥à¤¯à¥‚à¤Ÿà¥à¤¸ */\n    attrs?: Record<string, any>\n    /** Parsed child nodes (always parsed, even for verbatim blocks) */\n    /** @lang zh è§£æåçš„å­èŠ‚ç‚¹ï¼ˆå§‹ç»ˆè§£æï¼Œå³ä½¿æ˜¯é€å­—å—ï¼‰ */\n    /** @lang hi à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤¿à¤ à¤—à¤ à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤¨à¥‹à¤¡à¥à¤¸ (à¤¹à¤®à¥‡à¤¶à¤¾ à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤¿à¤ à¤œà¤¾à¤¤à¥‡ à¤¹à¥ˆà¤‚, à¤¯à¤¹à¤¾à¤‚ à¤¤à¤• à¤•à¤¿ verbatim à¤¬à¥à¤²à¥‰à¤•à¥à¤¸ à¤•à¥‡ à¤²à¤¿à¤ à¤­à¥€) */\n    children?: ASTNode[] | undefined\n    /** Whether this is a verbatim block (script, style, pre, etc.) */\n    /** @lang zh è¿™æ˜¯å¦æ˜¯é€å­—å—ï¼ˆscriptã€styleã€pre ç­‰ï¼‰ */\n    /** @lang hi à¤•à¥à¤¯à¤¾ à¤¯à¤¹ à¤à¤• verbatim à¤¬à¥à¤²à¥‰à¤• à¤¹à¥ˆ (script, style, pre, à¤†à¤¦à¤¿) */\n    verbatim?: boolean\n    /** Original raw attribute string */\n    /** @lang zh åŸå§‹å±æ€§å­—ç¬¦ä¸² */\n    /** @lang hi à¤®à¥‚à¤² raw à¤à¤Ÿà¥à¤°à¤¿à¤¬à¥à¤¯à¥‚à¤Ÿ à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤— */\n    rawAttrs?: string\n    /** Original raw HTML content (for verbatim blocks) */\n    /** @lang zh åŸå§‹ HTML å†…å®¹ï¼ˆç”¨äºé€å­—å—ï¼‰ */\n    /** @lang hi à¤®à¥‚à¤² raw HTML à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ (verbatim à¤¬à¥à¤²à¥‰à¤•à¥à¤¸ à¤•à¥‡ à¤²à¤¿à¤) */\n    rawText?: string | undefined\n    /** @deprecated Use `rawText` instead. This property will be removed in a future major version. */\n    /** @lang zh @deprecated è¯·ä½¿ç”¨ `rawText` ä»£æ›¿ã€‚æ­¤å±æ€§å°†åœ¨æœªæ¥çš„ä¸»è¦ç‰ˆæœ¬ä¸­ç§»é™¤ã€‚ */\n    /** @lang hi @deprecated à¤•à¥ƒà¤ªà¤¯à¤¾ à¤‡à¤¸à¤•à¥‡ à¤¬à¤œà¤¾à¤¯ `rawText` à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚à¥¤ à¤¯à¤¹ à¤ªà¥à¤°à¥‰à¤ªà¤°à¥à¤Ÿà¥€ à¤­à¤µà¤¿à¤·à¥à¤¯ à¤•à¥‡ à¤ªà¥à¤°à¤®à¥à¤– à¤¸à¤‚à¤¸à¥à¤•à¤°à¤£ à¤®à¥‡à¤‚ à¤¹à¤Ÿà¤¾ à¤¦à¥€ à¤œà¤¾à¤à¤—à¥€à¥¤ */\n    text?: string | undefined\n    /** HTML tag name */\n    /** @lang zh HTML æ ‡ç­¾åç§° */\n    /** @lang hi HTML à¤Ÿà¥ˆà¤— à¤¨à¤¾à¤® */\n    tag: string\n  }\n\n  /**\n   * Self-closing HTML tag node\n   * @lang zh è‡ªé—­åˆ HTML æ ‡ç­¾èŠ‚ç‚¹\n   * @lang hi à¤¸à¥à¤µ-à¤¬à¤‚à¤¦ à¤¹à¥‹à¤¨à¥‡ à¤µà¤¾à¤²à¤¾ HTML à¤Ÿà¥ˆà¤— à¤¨à¥‹à¤¡\n   */\n  export interface HTMLSelfClosingNode {\n    type: typeof RuleType.htmlSelfClosing\n    /** Parsed HTML attributes */\n    /** @lang zh è§£æåçš„ HTML å±æ€§ */\n    /** @lang hi à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤¿à¤ à¤—à¤ HTML à¤à¤Ÿà¥à¤°à¤¿à¤¬à¥à¤¯à¥‚à¤Ÿà¥à¤¸ */\n    attrs?: Record<string, any>\n    /** Whether this is a closing tag */\n    /** @lang zh è¿™æ˜¯å¦æ˜¯é—­åˆæ ‡ç­¾ */\n    /** @lang hi à¤•à¥à¤¯à¤¾ à¤¯à¤¹ à¤à¤• à¤¬à¤‚à¤¦ à¤•à¤°à¤¨à¥‡ à¤µà¤¾à¤²à¤¾ à¤Ÿà¥ˆà¤— à¤¹à¥ˆ */\n    isClosingTag?: boolean\n    /** HTML tag name */\n    /** @lang zh HTML æ ‡ç­¾åç§° */\n    /** @lang hi HTML à¤Ÿà¥ˆà¤— à¤¨à¤¾à¤® */\n    tag: string\n    /** Original raw HTML content */\n    /** @lang zh åŸå§‹ HTML å†…å®¹ */\n    /** @lang hi à¤®à¥‚à¤² raw HTML à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ */\n    rawText?: string\n  }\n\n  /**\n   * Union type of all possible AST node types\n   * @lang zh æ‰€æœ‰å¯èƒ½çš„ AST èŠ‚ç‚¹ç±»å‹çš„è”åˆç±»å‹\n   * @lang hi à¤¸à¤­à¥€ à¤¸à¤‚à¤­à¤¾à¤µà¤¿à¤¤ AST à¤¨à¥‹à¤¡ à¤ªà¥à¤°à¤•à¤¾à¤°à¥‹à¤‚ à¤•à¤¾ à¤¸à¤‚à¤˜ à¤ªà¥à¤°à¤•à¤¾à¤°\n   */\n  export type ASTNode =\n    | BlockQuoteNode\n    | BreakLineNode\n    | BreakThematicNode\n    | CodeBlockNode\n    | CodeInlineNode\n    | FootnoteNode\n    | FootnoteReferenceNode\n    | FrontmatterNode\n    | GFMTaskNode\n    | HeadingNode\n    | HTMLCommentNode\n    | ImageNode\n    | LinkNode\n    | OrderedListNode\n    | UnorderedListNode\n    | ParagraphNode\n    | ReferenceNode\n    | ReferenceCollectionNode\n    | TableNode\n    | TextNode\n    | FormattedTextNode\n    | HTMLNode\n    | HTMLSelfClosingNode\n\n  /**\n   * Function type for rendering AST nodes\n   * @lang zh ç”¨äºæ¸²æŸ“ AST èŠ‚ç‚¹çš„å‡½æ•°ç±»å‹\n   * @lang hi AST à¤¨à¥‹à¤¡à¥à¤¸ à¤•à¥‹ à¤°à¥‡à¤‚à¤¡à¤° à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤«à¤¼à¤‚à¤•à¥à¤¶à¤¨ à¤ªà¥à¤°à¤•à¤¾à¤°\n   */\n  export type ASTRender = (\n    ast: MarkdownToJSX.ASTNode | MarkdownToJSX.ASTNode[],\n    state: MarkdownToJSX.State\n  ) => React.ReactNode\n\n  /**\n   * Override configuration for HTML tags or custom components\n   * @lang zh HTML æ ‡ç­¾æˆ–è‡ªå®šä¹‰ç»„ä»¶çš„è¦†ç›–é…ç½®\n   * @lang hi HTML à¤Ÿà¥ˆà¤—à¥à¤¸ à¤¯à¤¾ à¤•à¤¸à¥à¤Ÿà¤® à¤•à¤‚à¤ªà¥‹à¤¨à¥‡à¤‚à¤Ÿà¥à¤¸ à¤•à¥‡ à¤²à¤¿à¤ à¤“à¤µà¤°à¤°à¤¾à¤‡à¤¡ à¤•à¥‰à¤¨à¥à¤«à¤¼à¤¿à¤—à¤°à¥‡à¤¶à¤¨\n   */\n  export type Override =\n    | RequireAtLeastOne<{\n        component: React.ElementType\n        props: Object\n      }>\n    | React.ElementType\n\n  /**\n   * Map of HTML tags and custom components to their override configurations\n   * @lang zh HTML æ ‡ç­¾å’Œè‡ªå®šä¹‰ç»„ä»¶åˆ°å…¶è¦†ç›–é…ç½®çš„æ˜ å°„\n   * @lang hi HTML à¤Ÿà¥ˆà¤—à¥à¤¸ à¤”à¤° à¤•à¤¸à¥à¤Ÿà¤® à¤•à¤‚à¤ªà¥‹à¤¨à¥‡à¤‚à¤Ÿà¥à¤¸ à¤¸à¥‡ à¤‰à¤¨à¤•à¥€ à¤“à¤µà¤°à¤°à¤¾à¤‡à¤¡ à¤•à¥‰à¤¨à¥à¤«à¤¼à¤¿à¤—à¤°à¥‡à¤¶à¤¨ à¤•à¤¾ à¤®à¥ˆà¤ª\n   */\n  export type Overrides = {\n    [tag in HTMLTags]?: Override\n  } & {\n    [customComponent: string]: Override\n  }\n\n  /**\n   * Compiler options\n   * @lang zh ç¼–è¯‘å™¨é€‰é¡¹\n   * @lang hi à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤µà¤¿à¤•à¤²à¥à¤ª\n   */\n  export type Options = Partial<{\n    /**\n     * Ultimate control over the output of all rendered JSX.\n     * @lang zh å¯¹æ‰€æœ‰æ¸²æŸ“çš„ JSX è¾“å‡ºçš„æœ€ç»ˆæ§åˆ¶ã€‚\n     * @lang hi à¤¸à¤­à¥€ à¤°à¥‡à¤‚à¤¡à¤° à¤•à¤¿à¤ à¤—à¤ JSX à¤†à¤‰à¤Ÿà¤ªà¥à¤Ÿ à¤ªà¤° à¤…à¤‚à¤¤à¤¿à¤® à¤¨à¤¿à¤¯à¤‚à¤¤à¥à¤°à¤£à¥¤\n     */\n    createElement: (\n      tag: Parameters<CreateElement>[0],\n      props: React.JSX.IntrinsicAttributes,\n      ...children: React.ReactNode[]\n    ) => React.ReactNode\n\n    /**\n     * The library automatically generates an anchor tag for bare URLs included in the markdown\n     * document, but this behavior can be disabled if desired.\n     * @lang zh åº“ä¼šè‡ªåŠ¨ä¸º Markdown æ–‡æ¡£ä¸­åŒ…å«çš„è£¸ URL ç”Ÿæˆé”šç‚¹æ ‡ç­¾ï¼Œä½†å¯ä»¥æ ¹æ®éœ€è¦ç¦ç”¨æ­¤è¡Œä¸ºã€‚\n     * @lang hi à¤²à¤¾à¤‡à¤¬à¥à¤°à¥‡à¤°à¥€ markdown à¤¦à¤¸à¥à¤¤à¤¾à¤µà¥‡à¤œà¤¼ à¤®à¥‡à¤‚ à¤¶à¤¾à¤®à¤¿à¤² à¤¨à¤‚à¤—à¥‡ URLs à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¥à¤µà¤šà¤¾à¤²à¤¿à¤¤ à¤°à¥‚à¤ª à¤¸à¥‡ à¤à¤• à¤à¤‚à¤•à¤° à¤Ÿà¥ˆà¤— à¤œà¥‡à¤¨à¤°à¥‡à¤Ÿ à¤•à¤°à¤¤à¥€ à¤¹à¥ˆ, à¤²à¥‡à¤•à¤¿à¤¨ à¤¯à¤¦à¤¿ à¤µà¤¾à¤‚à¤›à¤¿à¤¤ à¤¹à¥‹ à¤¤à¥‹ à¤‡à¤¸ à¤µà¥à¤¯à¤µà¤¹à¤¾à¤° à¤•à¥‹ à¤…à¤•à¥à¤·à¤® à¤•à¤¿à¤¯à¤¾ à¤œà¤¾ à¤¸à¤•à¤¤à¤¾ à¤¹à¥ˆà¥¤\n     */\n    disableAutoLink: boolean\n\n    /**\n     * Disable the compiler's best-effort transcription of provided raw HTML\n     * into JSX-equivalent. This is the functionality that prevents the need to\n     * use `dangerouslySetInnerHTML` in React.\n     * @lang zh ç¦ç”¨ç¼–è¯‘å™¨å°†æä¾›çš„åŸå§‹ HTML è½¬æ¢ä¸º JSX ç­‰æ•ˆé¡¹çš„æœ€ä½³åŠªåŠ›ã€‚æ­¤åŠŸèƒ½å¯é¿å…åœ¨ React ä¸­ä½¿ç”¨ `dangerouslySetInnerHTML`ã€‚\n     * @lang hi à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤•à¥‡ à¤ªà¥à¤°à¤¦à¤¾à¤¨ à¤•à¤¿à¤ à¤—à¤ raw HTML à¤•à¥‹ JSX-à¤¸à¤®à¤¤à¥à¤²à¥à¤¯ à¤®à¥‡à¤‚ à¤Ÿà¥à¤°à¤¾à¤‚à¤¸à¤•à¥à¤°à¤¾à¤‡à¤¬ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤¸à¤°à¥à¤µà¥‹à¤¤à¥à¤¤à¤® à¤ªà¥à¤°à¤¯à¤¾à¤¸ à¤•à¥‹ à¤…à¤•à¥à¤·à¤® à¤•à¤°à¥‡à¤‚à¥¤ à¤¯à¤¹ à¤µà¤¹ à¤•à¤¾à¤°à¥à¤¯à¤•à¥à¤·à¤®à¤¤à¤¾ à¤¹à¥ˆ à¤œà¥‹ React à¤®à¥‡à¤‚ `dangerouslySetInnerHTML` à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¤¨à¥‡ à¤•à¥€ à¤†à¤µà¤¶à¥à¤¯à¤•à¤¤à¤¾ à¤•à¥‹ à¤°à¥‹à¤•à¤¤à¥€ à¤¹à¥ˆà¥¤\n     */\n    disableParsingRawHTML: boolean\n\n    /**\n     * Enable GFM tagfilter extension to filter potentially dangerous HTML tags.\n     * When enabled, the following tags are escaped: title, textarea, style, xmp,\n     * iframe, noembed, noframes, script, plaintext.\n     * https://github.github.com/gfm/#disallowed-raw-html-extension-\n     * @lang zh å¯ç”¨ GFM tagfilter æ‰©å±•ä»¥è¿‡æ»¤æ½œåœ¨å±é™©çš„ HTML æ ‡ç­¾ã€‚å¯ç”¨åï¼Œä»¥ä¸‹æ ‡ç­¾å°†è¢«è½¬ä¹‰ï¼štitleã€textareaã€styleã€xmpã€iframeã€noembedã€noframesã€scriptã€plaintextã€‚\n     * @lang hi à¤¸à¤‚à¤­à¤¾à¤µà¤¿à¤¤ à¤–à¤¤à¤°à¤¨à¤¾à¤• HTML à¤Ÿà¥ˆà¤—à¥à¤¸ à¤•à¥‹ à¤«à¤¼à¤¿à¤²à¥à¤Ÿà¤° à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ GFM tagfilter à¤à¤•à¥à¤¸à¤Ÿà¥‡à¤‚à¤¶à¤¨ à¤¸à¤•à¥à¤·à¤® à¤•à¤°à¥‡à¤‚à¥¤ à¤¸à¤•à¥à¤·à¤® à¤¹à¥‹à¤¨à¥‡ à¤ªà¤°, à¤¨à¤¿à¤®à¥à¤¨à¤²à¤¿à¤–à¤¿à¤¤ à¤Ÿà¥ˆà¤—à¥à¤¸ à¤à¤¸à¥à¤•à¥‡à¤ª à¤•à¤¿à¤ à¤œà¤¾à¤¤à¥‡ à¤¹à¥ˆà¤‚: title, textarea, style, xmp, iframe, noembed, noframes, script, plaintextà¥¤\n     * @default true\n     */\n    tagfilter?: boolean\n\n    /**\n     * Forces the compiler to have space between hash sign and the header text which\n     * is explicitly stated in the most of the markdown specs.\n     * https://github.github.com/gfm/#atx-heading\n     * `The opening sequence of # characters must be followed by a space or by the end of line.`\n     * @lang zh å¼ºåˆ¶ç¼–è¯‘å™¨åœ¨äº•å·å’Œæ ‡é¢˜æ–‡æœ¬ä¹‹é—´æœ‰ç©ºæ ¼ï¼Œè¿™åœ¨å¤§å¤šæ•° Markdown è§„èŒƒä¸­éƒ½æœ‰æ˜ç¡®è§„å®šã€‚\n     * @lang hi à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤•à¥‹ à¤¹à¥ˆà¤¶ à¤šà¤¿à¤¹à¥à¤¨ à¤”à¤° à¤¹à¥‡à¤¡à¤° à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤•à¥‡ à¤¬à¥€à¤š à¤¸à¥à¤¥à¤¾à¤¨ à¤°à¤–à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¬à¤¾à¤§à¥à¤¯ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ, à¤œà¥‹ à¤…à¤§à¤¿à¤•à¤¾à¤‚à¤¶ markdown à¤µà¤¿à¤¨à¤¿à¤°à¥à¤¦à¥‡à¤¶à¥‹à¤‚ à¤®à¥‡à¤‚ à¤¸à¥à¤ªà¤·à¥à¤Ÿ à¤°à¥‚à¤ª à¤¸à¥‡ à¤•à¤¹à¤¾ à¤—à¤¯à¤¾ à¤¹à¥ˆã€‚\n     */\n    enforceAtxHeadings: boolean\n\n    /**\n     * **âš ï¸ SECURITY WARNING: STRONGLY DISCOURAGED FOR USER INPUTS**\n     *\n     * When enabled, attempts to eval expressions in JSX props that cannot be serialized\n     * as JSON (functions, variables, complex expressions). This uses `eval()` which can\n     * execute arbitrary code.\n     *\n     * **ONLY use this option when:**\n     * - The markdown source is completely trusted (e.g., your own documentation)\n     * - You control all JSX components and their props\n     * - The content is NOT user-generated or user-editable\n     *\n     * **DO NOT use this option when:**\n     * - Processing user-submitted markdown\n     * - Rendering untrusted content\n     * - Building public-facing applications with user content\n     *\n     * Example unsafe input: `<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     * When disabled (default), unserializable expressions remain as strings that can be\n     * safely inspected or handled on a case-by-case basis via custom renderRule logic.\n     *\n     * @lang zh **âš ï¸ å®‰å…¨è­¦å‘Šï¼šå¼ºçƒˆå»ºè®®ä¸è¦ç”¨äºç”¨æˆ·è¾“å…¥**\n     *\n     * å¯ç”¨åï¼Œå°è¯•è®¡ç®— JSX å±æ€§ä¸­æ— æ³•åºåˆ—åŒ–ä¸º JSON çš„è¡¨è¾¾å¼ï¼ˆå‡½æ•°ã€å˜é‡ã€å¤æ‚è¡¨è¾¾å¼ï¼‰ã€‚è¿™ä½¿ç”¨ `eval()`ï¼Œå¯èƒ½ä¼šæ‰§è¡Œä»»æ„ä»£ç ã€‚\n     *\n     * **ä»…åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä½¿ç”¨æ­¤é€‰é¡¹ï¼š**\n     * - Markdown æºå®Œå…¨å¯ä¿¡ï¼ˆä¾‹å¦‚ï¼Œæ‚¨è‡ªå·±çš„æ–‡æ¡£ï¼‰\n     * - æ‚¨æ§åˆ¶æ‰€æœ‰ JSX ç»„ä»¶åŠå…¶å±æ€§\n     * - å†…å®¹ä¸æ˜¯ç”¨æˆ·ç”Ÿæˆæˆ–ç”¨æˆ·å¯ç¼–è¾‘çš„\n     *\n     * **åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä¸è¦ä½¿ç”¨æ­¤é€‰é¡¹ï¼š**\n     * - å¤„ç†ç”¨æˆ·æäº¤çš„ Markdown\n     * - æ¸²æŸ“ä¸å¯ä¿¡å†…å®¹\n     * - æ„å»ºé¢å‘å…¬ä¼—çš„ç”¨æˆ·å†…å®¹åº”ç”¨ç¨‹åº\n     *\n     * ä¸å®‰å…¨çš„è¾“å…¥ç¤ºä¾‹ï¼š`<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     * ç¦ç”¨æ—¶ï¼ˆé»˜è®¤ï¼‰ï¼Œä¸å¯åºåˆ—åŒ–çš„è¡¨è¾¾å¼ä¿æŒä¸ºå­—ç¬¦ä¸²ï¼Œå¯ä»¥é€šè¿‡è‡ªå®šä¹‰ renderRule é€»è¾‘å®‰å…¨åœ°æ£€æŸ¥æˆ–é€ä¾‹å¤„ç†ã€‚\n     *\n     * @lang hi **âš ï¸ à¤¸à¥à¤°à¤•à¥à¤·à¤¾ à¤šà¥‡à¤¤à¤¾à¤µà¤¨à¥€: à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾ à¤‡à¤¨à¤ªà¥à¤Ÿ à¤•à¥‡ à¤²à¤¿à¤ à¤…à¤¤à¥à¤¯à¤§à¤¿à¤• à¤¹à¤¤à¥‹à¤¤à¥à¤¸à¤¾à¤¹à¤¿à¤¤**\n     *\n     * à¤¸à¤•à¥à¤·à¤® à¤¹à¥‹à¤¨à¥‡ à¤ªà¤°, JSX props à¤®à¥‡à¤‚ expressions à¤•à¥‹ eval à¤•à¤°à¤¨à¥‡ à¤•à¤¾ à¤ªà¥à¤°à¤¯à¤¾à¤¸ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ à¤œà¤¿à¤¨à¥à¤¹à¥‡à¤‚ JSON à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤¸à¥€à¤°à¤¿à¤¯à¤²à¤¾à¤‡à¤œà¤¼ à¤¨à¤¹à¥€à¤‚ à¤•à¤¿à¤¯à¤¾ à¤œà¤¾ à¤¸à¤•à¤¤à¤¾ à¤¹à¥ˆ (à¤«à¤¼à¤‚à¤•à¥à¤¶à¤¨, à¤µà¥‡à¤°à¤¿à¤à¤¬à¤², à¤œà¤Ÿà¤¿à¤² expressions)à¥¤ à¤¯à¤¹ `eval()` à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ à¤œà¥‹ à¤®à¤¨à¤®à¤¾à¤¨à¥‡ à¤•à¥‹à¤¡ à¤•à¥‹ à¤¨à¤¿à¤·à¥à¤ªà¤¾à¤¦à¤¿à¤¤ à¤•à¤° à¤¸à¤•à¤¤à¤¾ à¤¹à¥ˆà¥¤\n     *\n     * **à¤•à¥‡à¤µà¤² à¤¨à¤¿à¤®à¥à¤¨à¤²à¤¿à¤–à¤¿à¤¤ à¤¸à¥à¤¥à¤¿à¤¤à¤¿à¤¯à¥‹à¤‚ à¤®à¥‡à¤‚ à¤‡à¤¸ à¤µà¤¿à¤•à¤²à¥à¤ª à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚:**\n     * - Markdown à¤¸à¥à¤°à¥‹à¤¤ à¤ªà¥‚à¤°à¥€ à¤¤à¤°à¤¹ à¤¸à¥‡ à¤µà¤¿à¤¶à¥à¤µà¤¸à¤¨à¥€à¤¯ à¤¹à¥ˆ (à¤‰à¤¦à¤¾à¤¹à¤°à¤£ à¤•à¥‡ à¤²à¤¿à¤, à¤†à¤ªà¤•à¤¾ à¤…à¤ªà¤¨à¤¾ à¤¦à¤¸à¥à¤¤à¤¾à¤µà¥‡à¤œà¤¼à¥€à¤•à¤°à¤£)\n     * - à¤†à¤ª à¤¸à¤­à¥€ JSX à¤•à¤‚à¤ªà¥‹à¤¨à¥‡à¤‚à¤Ÿà¥à¤¸ à¤”à¤° à¤‰à¤¨à¤•à¥‡ props à¤•à¥‹ à¤¨à¤¿à¤¯à¤‚à¤¤à¥à¤°à¤¿à¤¤ à¤•à¤°à¤¤à¥‡ à¤¹à¥ˆà¤‚\n     * - à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾-à¤œà¤¨à¤¿à¤¤ à¤¯à¤¾ à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾-à¤¸à¤‚à¤ªà¤¾à¤¦à¤¨ à¤¯à¥‹à¤—à¥à¤¯ à¤¨à¤¹à¥€à¤‚ à¤¹à¥ˆ\n     *\n     * **à¤¨à¤¿à¤®à¥à¤¨à¤²à¤¿à¤–à¤¿à¤¤ à¤¸à¥à¤¥à¤¿à¤¤à¤¿à¤¯à¥‹à¤‚ à¤®à¥‡à¤‚ à¤‡à¤¸ à¤µà¤¿à¤•à¤²à¥à¤ª à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤¨ à¤•à¤°à¥‡à¤‚:**\n     * - à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾-à¤¸à¤¬à¤®à¤¿à¤Ÿ à¤•à¤¿à¤ à¤—à¤ markdown à¤•à¥‹ à¤ªà¥à¤°à¥‹à¤¸à¥‡à¤¸ à¤•à¤° à¤°à¤¹à¥‡ à¤¹à¥‹à¤‚\n     * - à¤…à¤µà¤¿à¤¶à¥à¤µà¤¸à¤¨à¥€à¤¯ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤°à¥‡à¤‚à¤¡à¤° à¤•à¤° à¤°à¤¹à¥‡ à¤¹à¥‹à¤‚\n     * - à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤µà¤¾à¤²à¥‡ à¤¸à¤¾à¤°à¥à¤µà¤œà¤¨à¤¿à¤•-à¤¸à¤¾à¤®à¤¨à¤¾ à¤•à¤°à¤¨à¥‡ à¤µà¤¾à¤²à¥‡ à¤à¤ªà¥à¤²à¤¿à¤•à¥‡à¤¶à¤¨ à¤¬à¤¨à¤¾ à¤°à¤¹à¥‡ à¤¹à¥‹à¤‚\n     *\n     * à¤…à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ à¤‡à¤¨à¤ªà¥à¤Ÿ à¤‰à¤¦à¤¾à¤¹à¤°à¤£: `<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     * à¤…à¤•à¥à¤·à¤® à¤¹à¥‹à¤¨à¥‡ à¤ªà¤° (à¤¡à¤¿à¤«à¤¼à¥‰à¤²à¥à¤Ÿ), à¤…à¤¨à¤¸à¥€à¤°à¤¿à¤¯à¤²à¤¾à¤‡à¤œà¤¼à¥‡à¤¬à¤² expressions à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤—à¥à¤¸ à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤°à¤¹à¤¤à¥‡ à¤¹à¥ˆà¤‚ à¤œà¤¿à¤¨à¥à¤¹à¥‡à¤‚ à¤•à¤¸à¥à¤Ÿà¤® renderRule à¤²à¥‰à¤œà¤¿à¤• à¤•à¥‡ à¤®à¤¾à¤§à¥à¤¯à¤® à¤¸à¥‡ à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ à¤°à¥‚à¤ª à¤¸à¥‡ à¤œà¤¾à¤‚à¤šà¤¾ à¤œà¤¾ à¤¸à¤•à¤¤à¤¾ à¤¹à¥ˆ à¤¯à¤¾ à¤•à¥‡à¤¸-à¤¬à¤¾à¤ˆ-à¤•à¥‡à¤¸ à¤¹à¥ˆà¤‚à¤¡à¤² à¤•à¤¿à¤¯à¤¾ à¤œà¤¾ à¤¸à¤•à¤¤à¤¾ à¤¹à¥ˆà¥¤\n     *\n     * @default false\n     */\n    evalUnserializableExpressions?: boolean\n\n    /**\n     * Forces the compiler to always output content with a block-level wrapper\n     * (`<p>` or any block-level syntax your markdown already contains.)\n     * @lang zh å¼ºåˆ¶ç¼–è¯‘å™¨å§‹ç»ˆä½¿ç”¨å—çº§åŒ…è£…å™¨è¾“å‡ºå†…å®¹ï¼ˆ`<p>` æˆ–æ‚¨çš„ Markdown å·²åŒ…å«çš„ä»»ä½•å—çº§è¯­æ³•ï¼‰ã€‚\n     * @lang hi à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤•à¥‹ à¤¹à¤®à¥‡à¤¶à¤¾ à¤¬à¥à¤²à¥‰à¤•-à¤¸à¥à¤¤à¤°à¥€à¤¯ à¤°à¥ˆà¤ªà¤° à¤•à¥‡ à¤¸à¤¾à¤¥ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤†à¤‰à¤Ÿà¤ªà¥à¤Ÿ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¬à¤¾à¤§à¥à¤¯ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ (`<p>` à¤¯à¤¾ à¤†à¤ªà¤•à¥‡ markdown à¤®à¥‡à¤‚ à¤ªà¤¹à¤²à¥‡ à¤¸à¥‡ à¤®à¥Œà¤œà¥‚à¤¦ à¤•à¥‹à¤ˆ à¤­à¥€ à¤¬à¥à¤²à¥‰à¤•-à¤¸à¥à¤¤à¤°à¥€à¤¯ à¤¸à¤¿à¤‚à¤Ÿà¥ˆà¤•à¥à¤¸)à¥¤\n     */\n    forceBlock: boolean\n\n    /**\n     * Forces the compiler to always output content with an inline wrapper (`<span>`)\n     * @lang zh å¼ºåˆ¶ç¼–è¯‘å™¨å§‹ç»ˆä½¿ç”¨å†…è”åŒ…è£…å™¨ï¼ˆ`<span>`ï¼‰è¾“å‡ºå†…å®¹\n     * @lang hi à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤•à¥‹ à¤¹à¤®à¥‡à¤¶à¤¾ à¤‡à¤¨à¤²à¤¾à¤‡à¤¨ à¤°à¥ˆà¤ªà¤° (`<span>`) à¤•à¥‡ à¤¸à¤¾à¤¥ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤†à¤‰à¤Ÿà¤ªà¥à¤Ÿ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¬à¤¾à¤§à¥à¤¯ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ\n     */\n    forceInline: boolean\n\n    /**\n     * Forces the compiler to wrap results, even if there is only a single\n     * child or no children.\n     * @lang zh å¼ºåˆ¶ç¼–è¯‘å™¨åŒ…è£…ç»“æœï¼Œå³ä½¿åªæœ‰ä¸€ä¸ªå­å…ƒç´ æˆ–æ²¡æœ‰å­å…ƒç´ ã€‚\n     * @lang hi à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤•à¥‹ à¤ªà¤°à¤¿à¤£à¤¾à¤®à¥‹à¤‚ à¤•à¥‹ à¤°à¥ˆà¤ª à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¬à¤¾à¤§à¥à¤¯ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ, à¤­à¤²à¥‡ à¤¹à¥€ à¤•à¥‡à¤µà¤² à¤à¤• à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤¹à¥‹ à¤¯à¤¾ à¤•à¥‹à¤ˆ à¤šà¤¾à¤‡à¤²à¥à¤¡ à¤¨ à¤¹à¥‹à¥¤\n     */\n    forceWrapper: boolean\n\n    /**\n     * Selectively control the output of particular HTML tags as they would be\n     * emitted by the compiler.\n     * @lang zh é€‰æ‹©æ€§åœ°æ§åˆ¶ç‰¹å®š HTML æ ‡ç­¾çš„è¾“å‡ºï¼Œå°±åƒç¼–è¯‘å™¨ä¼šå‘å‡ºçš„ä¸€æ ·ã€‚\n     * @lang hi à¤šà¥à¤¨à¤¿à¤‚à¤¦à¤¾ à¤°à¥‚à¤ª à¤¸à¥‡ à¤µà¤¿à¤¶à¤¿à¤·à¥à¤Ÿ HTML à¤Ÿà¥ˆà¤—à¥à¤¸ à¤•à¥‡ à¤†à¤‰à¤Ÿà¤ªà¥à¤Ÿ à¤•à¥‹ à¤¨à¤¿à¤¯à¤‚à¤¤à¥à¤°à¤¿à¤¤ à¤•à¤°à¥‡à¤‚ à¤œà¥ˆà¤¸à¤¾ à¤•à¤¿ à¤•à¤‚à¤ªà¤¾à¤‡à¤²à¤° à¤¦à¥à¤µà¤¾à¤°à¤¾ à¤‰à¤¤à¥à¤¸à¤°à¥à¤œà¤¿à¤¤ à¤•à¤¿à¤¯à¤¾ à¤œà¤¾à¤à¤—à¤¾à¥¤\n     */\n    overrides: Overrides\n\n    /**\n     * Allows for full control over rendering of particular rules.\n     * For example, to implement a LaTeX renderer such as `react-katex`:\n     *\n     * ```\n     * renderRule(next, node, renderChildren, state) {\n     *   if (node.type === RuleType.codeBlock && node.lang === 'latex') {\n     *     return (\n     *       <TeX as=\"div\" key={state.key}>\n     *         {String.raw`${node.text}`}\n     *       </TeX>\n     *     )\n     *   }\n     *\n     *   return next();\n     * }\n     * ```\n     *\n     * Thar be dragons obviously, but you can do a lot with this\n     * (have fun!) To see how things work internally, check the `render`\n     * method in source for a particular rule.\n     * @lang zh å…è®¸å®Œå…¨æ§åˆ¶ç‰¹å®šè§„åˆ™çš„æ¸²æŸ“ã€‚ä¾‹å¦‚ï¼Œè¦å®ç°åƒ `react-katex` è¿™æ ·çš„ LaTeX æ¸²æŸ“å™¨ï¼š\n     *\n     * æ˜¾ç„¶æœ‰é£é™©ï¼Œä½†æ‚¨å¯ä»¥ç”¨å®ƒåšå¾ˆå¤šäº‹æƒ…ï¼ˆç©å¾—å¼€å¿ƒï¼ï¼‰è¦äº†è§£å†…éƒ¨å·¥ä½œåŸç†ï¼Œè¯·æŸ¥çœ‹æºä»£ç ä¸­ç‰¹å®šè§„åˆ™çš„ `render` æ–¹æ³•ã€‚\n     * @lang hi à¤µà¤¿à¤¶à¤¿à¤·à¥à¤Ÿ à¤¨à¤¿à¤¯à¤®à¥‹à¤‚ à¤•à¥‡ à¤°à¥‡à¤‚à¤¡à¤°à¤¿à¤‚à¤— à¤ªà¤° à¤ªà¥‚à¤°à¥à¤£ à¤¨à¤¿à¤¯à¤‚à¤¤à¥à¤°à¤£ à¤•à¥€ à¤…à¤¨à¥à¤®à¤¤à¤¿ à¤¦à¥‡à¤¤à¤¾ à¤¹à¥ˆà¥¤ à¤‰à¤¦à¤¾à¤¹à¤°à¤£ à¤•à¥‡ à¤²à¤¿à¤, `react-katex` à¤œà¥ˆà¤¸à¥‡ LaTeX à¤°à¥‡à¤‚à¤¡à¤°à¤° à¤•à¥‹ à¤²à¤¾à¤—à¥‚ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤:\n     *\n     * à¤¸à¥à¤ªà¤·à¥à¤Ÿ à¤°à¥‚à¤ª à¤¸à¥‡ à¤œà¥‹à¤–à¤¿à¤® à¤¹à¥ˆà¤‚, à¤²à¥‡à¤•à¤¿à¤¨ à¤†à¤ª à¤‡à¤¸à¤•à¥‡ à¤¸à¤¾à¤¥ à¤¬à¤¹à¥à¤¤ à¤•à¥à¤› à¤•à¤° à¤¸à¤•à¤¤à¥‡ à¤¹à¥ˆà¤‚ (à¤®à¤œà¤¼à¥‡ à¤•à¤°à¥‡à¤‚!) à¤†à¤‚à¤¤à¤°à¤¿à¤• à¤°à¥‚à¤ª à¤¸à¥‡ à¤šà¥€à¤œà¥‡à¤‚ à¤•à¥ˆà¤¸à¥‡ à¤•à¤¾à¤® à¤•à¤°à¤¤à¥€ à¤¹à¥ˆà¤‚ à¤¯à¤¹ à¤¦à¥‡à¤–à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤, à¤•à¤¿à¤¸à¥€ à¤µà¤¿à¤¶à¤¿à¤·à¥à¤Ÿ à¤¨à¤¿à¤¯à¤® à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¥à¤°à¥‹à¤¤ à¤®à¥‡à¤‚ `render` à¤µà¤¿à¤§à¤¿ à¤¦à¥‡à¤–à¥‡à¤‚à¥¤\n     */\n    renderRule: (\n      /** Resume normal processing, call this function as a fallback if you are not returning custom JSX. */\n      /** @lang zh æ¢å¤æ­£å¸¸å¤„ç†ï¼Œå¦‚æœæ‚¨ä¸è¿”å›è‡ªå®šä¹‰ JSXï¼Œè¯·è°ƒç”¨æ­¤å‡½æ•°ä½œä¸ºåå¤‡ã€‚ */\n      /** @lang hi à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯ à¤ªà¥à¤°à¥‹à¤¸à¥‡à¤¸à¤¿à¤‚à¤— à¤«à¤¿à¤° à¤¸à¥‡ à¤¶à¥à¤°à¥‚ à¤•à¤°à¥‡à¤‚, à¤¯à¤¦à¤¿ à¤†à¤ª à¤•à¤¸à¥à¤Ÿà¤® JSX à¤µà¤¾à¤ªà¤¸ à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚ à¤¤à¥‹ à¤‡à¤¸ à¤«à¤¼à¤‚à¤•à¥à¤¶à¤¨ à¤•à¥‹ à¤«à¤¼à¥‰à¤²à¤¬à¥ˆà¤• à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤•à¥‰à¤² à¤•à¤°à¥‡à¤‚à¥¤ */\n      next: () => React.ReactNode,\n      /** the current AST node, use `RuleType` against `node.type` for identification */\n      /** @lang zh å½“å‰çš„ AST èŠ‚ç‚¹ï¼Œä½¿ç”¨ `RuleType` ä¸ `node.type` è¿›è¡Œæ¯”è¾ƒä»¥è¿›è¡Œè¯†åˆ« */\n      /** @lang hi à¤µà¤°à¥à¤¤à¤®à¤¾à¤¨ AST à¤¨à¥‹à¤¡, à¤ªà¤¹à¤šà¤¾à¤¨ à¤•à¥‡ à¤²à¤¿à¤ `node.type` à¤•à¥‡ à¤–à¤¿à¤²à¤¾à¤« `RuleType` à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚ */\n      node: ASTNode,\n      /** use as `renderChildren(node.children)` for block nodes */\n      /** @lang zh å¯¹äºå—èŠ‚ç‚¹ï¼Œä½¿ç”¨ `renderChildren(node.children)` */\n      /** @lang hi à¤¬à¥à¤²à¥‰à¤• à¤¨à¥‹à¤¡à¥à¤¸ à¤•à¥‡ à¤²à¤¿à¤ `renderChildren(node.children)` à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚ */\n      renderChildren: ASTRender,\n      /** contains `key` which should be supplied to the topmost JSX element */\n      /** @lang zh åŒ…å«åº”æä¾›ç»™æœ€é¡¶å±‚ JSX å…ƒç´ çš„ `key` */\n      /** @lang hi `key` à¤¶à¤¾à¤®à¤¿à¤² à¤¹à¥ˆ à¤œà¥‹ à¤¸à¤¬à¤¸à¥‡ à¤Šà¤ªà¤°à¥€ JSX à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿ à¤•à¥‹ à¤ªà¥à¤°à¤¦à¤¾à¤¨ à¤•à¤¿à¤¯à¤¾ à¤œà¤¾à¤¨à¤¾ à¤šà¤¾à¤¹à¤¿à¤ */\n      state: State\n    ) => React.ReactNode\n\n    /**\n     * Override the built-in sanitizer function for URLs, etc if desired. The built-in version is available as a library\n     export called `sanitizer`.\n     * @lang zh å¦‚æœéœ€è¦ï¼Œè¦†ç›–å†…ç½®çš„ URL æ¸…ç†å‡½æ•°ç­‰ã€‚å†…ç½®ç‰ˆæœ¬å¯ä½œä¸ºåä¸º `sanitizer` çš„åº“å¯¼å‡ºä½¿ç”¨ã€‚\n     * @lang hi à¤¯à¤¦à¤¿ à¤µà¤¾à¤‚à¤›à¤¿à¤¤ à¤¹à¥‹ à¤¤à¥‹ URLs à¤†à¤¦à¤¿ à¤•à¥‡ à¤²à¤¿à¤ à¤¬à¤¿à¤²à¥à¤Ÿ-à¤‡à¤¨ à¤¸à¥ˆà¤¨à¤¿à¤Ÿà¤¾à¤‡à¤œà¤¼à¤° à¤«à¤¼à¤‚à¤•à¥à¤¶à¤¨ à¤•à¥‹ à¤“à¤µà¤°à¤°à¤¾à¤‡à¤¡ à¤•à¤°à¥‡à¤‚à¥¤ à¤¬à¤¿à¤²à¥à¤Ÿ-à¤‡à¤¨ à¤¸à¤‚à¤¸à¥à¤•à¤°à¤£ `sanitizer` à¤¨à¤¾à¤®à¤• à¤²à¤¾à¤‡à¤¬à¥à¤°à¥‡à¤°à¥€ export à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤‰à¤ªà¤²à¤¬à¥à¤§ à¤¹à¥ˆà¥¤\n     */\n    sanitizer: (value: string, tag: string, attribute: string) => string | null\n\n    /**\n     * Override normalization of non-URI-safe characters for use in generating\n     * HTML IDs for anchor linking purposes.\n     * @lang zh è¦†ç›–é URI å®‰å…¨å­—ç¬¦çš„è§„èŒƒåŒ–ï¼Œç”¨äºç”Ÿæˆç”¨äºé”šç‚¹é“¾æ¥çš„ HTML IDã€‚\n     * @lang hi à¤à¤‚à¤•à¤° à¤²à¤¿à¤‚à¤•à¤¿à¤‚à¤— à¤‰à¤¦à¥à¤¦à¥‡à¤¶à¥à¤¯à¥‹à¤‚ à¤•à¥‡ à¤²à¤¿à¤ HTML IDs à¤œà¥‡à¤¨à¤°à¥‡à¤Ÿ à¤•à¤°à¤¨à¥‡ à¤®à¥‡à¤‚ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¥‡ à¤²à¤¿à¤ à¤—à¥ˆà¤°-URI-à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ à¤µà¤°à¥à¤£à¥‹à¤‚ à¤•à¥‡ à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯à¥€à¤•à¤°à¤£ à¤•à¥‹ à¤“à¤µà¤°à¤°à¤¾à¤‡à¤¡ à¤•à¤°à¥‡à¤‚à¥¤\n     */\n    slugify: (input: string, defaultFn: (input: string) => string) => string\n\n    /**\n     * Declare the type of the wrapper to be used when there are multiple\n     * children to render. Set to `null` to get an array of children back\n     * without any wrapper, or use `React.Fragment` to get a React element\n     * that won't show up in the DOM.\n     * @lang zh å£°æ˜åœ¨æœ‰å¤šä¸ªå­å…ƒç´ è¦æ¸²æŸ“æ—¶ä½¿ç”¨çš„åŒ…è£…å™¨ç±»å‹ã€‚è®¾ç½®ä¸º `null` ä»¥åœ¨æ²¡æœ‰åŒ…è£…å™¨çš„æƒ…å†µä¸‹è¿”å›å­å…ƒç´ æ•°ç»„ï¼Œæˆ–ä½¿ç”¨ `React.Fragment` è·å–ä¸ä¼šå‡ºç°åœ¨ DOM ä¸­çš„ React å…ƒç´ ã€‚\n     * @lang hi à¤°à¥ˆà¤ªà¤° à¤•à¥‡ à¤ªà¥à¤°à¤•à¤¾à¤° à¤•à¥‹ à¤˜à¥‹à¤·à¤¿à¤¤ à¤•à¤°à¥‡à¤‚ à¤œà¤¬ à¤•à¤ˆ children à¤•à¥‹ à¤°à¥‡à¤‚à¤¡à¤° à¤•à¤°à¤¨à¤¾ à¤¹à¥‹à¥¤ à¤¬à¤¿à¤¨à¤¾ à¤•à¤¿à¤¸à¥€ à¤°à¥ˆà¤ªà¤° à¤•à¥‡ children à¤•à¥€ à¤à¤• à¤¸à¤°à¤£à¥€ à¤µà¤¾à¤ªà¤¸ à¤ªà¤¾à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ `null` à¤ªà¤° à¤¸à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚, à¤¯à¤¾ DOM à¤®à¥‡à¤‚ à¤¦à¤¿à¤–à¤¾à¤ˆ à¤¨ à¤¦à¥‡à¤¨à¥‡ à¤µà¤¾à¤²à¤¾ React à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿ à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ `React.Fragment` à¤•à¤¾ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¤°à¥‡à¤‚à¥¤\n     */\n    wrapper: React.ElementType | null\n\n    /**\n     * Props to apply to the wrapper element.\n     * @lang zh åº”ç”¨äºåŒ…è£…å…ƒç´ çš„å±æ€§ã€‚\n     * @lang hi à¤°à¥ˆà¤ªà¤° à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿ à¤ªà¤° à¤²à¤¾à¤—à¥‚ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ propsà¥¤\n     */\n    wrapperProps?: React.JSX.IntrinsicAttributes\n\n    /**\n     * Preserve frontmatter in the output by rendering it as a <pre> element.\n     * By default, frontmatter is parsed but not rendered.\n     * @lang zh é€šè¿‡å°†å…¶æ¸²æŸ“ä¸º <pre> å…ƒç´ æ¥ä¿ç•™è¾“å‡ºä¸­çš„å‰ç½®å…ƒæ•°æ®ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå‰ç½®å…ƒæ•°æ®ä¼šè¢«è§£æä½†ä¸ä¼šæ¸²æŸ“ã€‚\n     * @lang hi à¤‡à¤¸à¥‡ <pre> à¤à¤²à¤¿à¤®à¥‡à¤‚à¤Ÿ à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤°à¥‡à¤‚à¤¡à¤° à¤•à¤°à¤•à¥‡ à¤†à¤‰à¤Ÿà¤ªà¥à¤Ÿ à¤®à¥‡à¤‚ à¤«à¥à¤°à¤‚à¤Ÿà¤®à¥ˆà¤Ÿà¤° à¤•à¥‹ à¤¸à¤‚à¤°à¤•à¥à¤·à¤¿à¤¤ à¤•à¤°à¥‡à¤‚à¥¤ à¤¡à¤¿à¤«à¤¼à¥‰à¤²à¥à¤Ÿ à¤°à¥‚à¤ª à¤¸à¥‡, à¤«à¥à¤°à¤‚à¤Ÿà¤®à¥ˆà¤Ÿà¤° à¤•à¥‹ à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤¿à¤¯à¤¾ à¤œà¤¾à¤¤à¤¾ à¤¹à¥ˆ à¤²à¥‡à¤•à¤¿à¤¨ à¤°à¥‡à¤‚à¤¡à¤° à¤¨à¤¹à¥€à¤‚ à¤•à¤¿à¤¯à¤¾ à¤œà¤¾à¤¤à¤¾ à¤¹à¥ˆà¥¤\n     * @default false\n     */\n    preserveFrontmatter?: boolean\n\n    /**\n     * Optimize rendering for streaming scenarios where markdown content arrives\n     * incrementally (e.g., from LLM APIs). When enabled, incomplete inline syntax\n     * is suppressed to avoid displaying raw markdown characters while waiting\n     * for the closing delimiter to arrive.\n     *\n     * Fenced code blocks render normally with content visible as it streams.\n     *\n     * @lang zh ä¼˜åŒ–æµå¼åœºæ™¯ä¸‹çš„æ¸²æŸ“ï¼Œé€‚ç”¨äº Markdown å†…å®¹å¢é‡åˆ°è¾¾çš„æƒ…å†µï¼ˆå¦‚ LLM APIï¼‰ã€‚å¯ç”¨æ—¶ï¼Œä¸å®Œæ•´çš„è¡Œå†…è¯­æ³•å°†è¢«æŠ‘åˆ¶ï¼Œé¿å…åœ¨ç­‰å¾…é—­åˆåˆ†éš”ç¬¦æ—¶æ˜¾ç¤ºåŸå§‹ Markdown å­—ç¬¦ã€‚\n     *\n     * å›´æ ä»£ç å—æ­£å¸¸æ¸²æŸ“ï¼Œå†…å®¹åœ¨æµå¼ä¼ è¾“æ—¶å¯è§ã€‚\n     *\n     * @lang hi à¤¸à¥à¤Ÿà¥à¤°à¥€à¤®à¤¿à¤‚à¤— à¤ªà¤°à¤¿à¤¦à¥ƒà¤¶à¥à¤¯à¥‹à¤‚ à¤•à¥‡ à¤²à¤¿à¤ à¤°à¥‡à¤‚à¤¡à¤°à¤¿à¤‚à¤— à¤•à¥‹ à¤…à¤¨à¥à¤•à¥‚à¤²à¤¿à¤¤ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ à¤œà¤¹à¤¾à¤ markdown à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤•à¥à¤°à¤®à¤¿à¤• à¤°à¥‚à¤ª à¤¸à¥‡ à¤†à¤¤à¥€ à¤¹à¥ˆ (à¤œà¥ˆà¤¸à¥‡, LLM API à¤¸à¥‡)à¥¤ à¤¸à¤•à¥à¤·à¤® à¤¹à¥‹à¤¨à¥‡ à¤ªà¤°, à¤…à¤ªà¥‚à¤°à¥à¤£ à¤‡à¤¨à¤²à¤¾à¤‡à¤¨ à¤¸à¤¿à¤‚à¤Ÿà¥ˆà¤•à¥à¤¸ à¤•à¥‹ à¤¦à¤¬à¤¾ à¤¦à¤¿à¤¯à¤¾ à¤œà¤¾à¤¤à¤¾ à¤¹à¥ˆ à¤¤à¤¾à¤•à¤¿ à¤¬à¤‚à¤¦ à¤•à¤°à¤¨à¥‡ à¤µà¤¾à¤²à¥‡ à¤¡à¥‡à¤²à¤¿à¤®à¥€à¤Ÿà¤° à¤•à¥€ à¤ªà¥à¤°à¤¤à¥€à¤•à¥à¤·à¤¾ à¤•à¤°à¤¤à¥‡ à¤¸à¤®à¤¯ à¤•à¤šà¥à¤šà¥‡ markdown à¤µà¤°à¥à¤£ à¤ªà¥à¤°à¤¦à¤°à¥à¤¶à¤¿à¤¤ à¤¨ à¤¹à¥‹à¤‚à¥¤\n     *\n     * à¤«à¤¼à¥‡à¤‚à¤¸à¥à¤¡ à¤•à¥‹à¤¡ à¤¬à¥à¤²à¥‰à¤•à¥à¤¸ à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯ à¤°à¥‚à¤ª à¤¸à¥‡ à¤°à¥‡à¤‚à¤¡à¤° à¤¹à¥‹à¤¤à¥‡ à¤¹à¥ˆà¤‚ à¤”à¤° à¤¸à¥à¤Ÿà¥à¤°à¥€à¤®à¤¿à¤‚à¤— à¤•à¥‡ à¤¦à¥Œà¤°à¤¾à¤¨ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤¦à¤¿à¤–à¤¾à¤ˆ à¤¦à¥‡à¤¤à¥€ à¤¹à¥ˆà¥¤\n     *\n     * @default false\n     *\n     * @example\n     * ```tsx\n     * // Streaming markdown example\n     * function StreamingMarkdown({ content }) {\n     *   return (\n     *     <Markdown options={{ optimizeForStreaming: true }}>\n     *       {content}\n     *     </Markdown>\n     *   )\n     * }\n     * ```\n     */\n    optimizeForStreaming?: boolean\n  }>\n}\n\nexport const RuleType: typeof RuleTypeConst = RuleTypeConst\nexport type RuleType = RuleTypeValue\n\nexport type RequireAtLeastOne<\n  T,\n  Keys extends keyof T = keyof T,\n> = MarkdownToJSX.RequireAtLeastOne<T, Keys>\n\nexport { MarkdownToJSX }\n","import { NAMED_CODES_TO_UNICODE as util, decodeEntity } from '#entities'\nimport * as $ from './constants'\n\n/**\n * Parse frontmatter bounds and validate YAML\n *\n * @param input - Input string to parse\n * @returns Object with end position and YAML validity, or null if no frontmatter\n */\nexport function parseFrontmatterBounds(\n  input: string\n): { endPos: number; hasValidYaml: boolean } | null {\n  if (!startsWith(input, '---')) return null\n  let pos = 3\n  while (pos < input.length && (input[pos] === ' ' || input[pos] === '\\t'))\n    pos++\n  // Handle both LF and CRLF line endings\n  if (pos < input.length && input[pos] === '\\r') pos++\n  if (pos >= input.length || input[pos] !== '\\n') return null\n  pos++\n\n  let hasValidYaml = false\n  while (pos < input.length) {\n    const lineStart = pos\n    // Find line end, handling CRLF\n    while (pos < input.length && input[pos] !== '\\n' && input[pos] !== '\\r')\n      pos++\n    if (pos >= input.length) break\n    const lineEnd = pos\n    // Skip CR if present\n    if (input[pos] === '\\r') pos++\n    // Skip LF\n    if (pos < input.length && input[pos] === '\\n') pos++\n    if (startsWith(input, '---', lineStart))\n      return { endPos: pos, hasValidYaml }\n    // Check if line contains ':' anywhere\n    // OPTIMIZATION: Use indexOf directly to avoid slice allocation\n    const colonIndex = input.indexOf(':', lineStart)\n    if (colonIndex !== -1 && colonIndex < lineEnd) hasValidYaml = true\n  }\n  return null\n}\n\n/**\n * Named HTML entity codes to unicode character mapping\n * Pre-computed from generated entity set\n * Numeric references (&#123; and &#xAB;) are fully supported without any mapping.\n * Unknown named entities pass through as literal text (CommonMark-compliant).\n * @lang zh å‘½åçš„ HTML å®ä½“ä»£ç åˆ° Unicode å­—ç¬¦çš„æ˜ å°„\n * ä»ç”Ÿæˆçš„å®ä½“é›†é¢„è®¡ç®—\n * æ•°å­—å¼•ç”¨ï¼ˆ&#123; å’Œ &#xAB;ï¼‰å®Œå…¨æ”¯æŒï¼Œæ— éœ€æ˜ å°„ã€‚\n * æœªçŸ¥çš„å‘½åå®ä½“ä½œä¸ºå­—é¢æ–‡æœ¬ä¼ é€’ï¼ˆç¬¦åˆ CommonMarkï¼‰ã€‚\n * @lang hi à¤¨à¤¾à¤®à¤¿à¤¤ HTML à¤à¤‚à¤Ÿà¤¿à¤Ÿà¥€ à¤•à¥‹à¤¡ à¤¸à¥‡ Unicode à¤µà¤°à¥à¤£à¥‹à¤‚ à¤•à¤¾ à¤®à¥ˆà¤ªà¤¿à¤‚à¤—\n * à¤œà¥‡à¤¨à¤°à¥‡à¤Ÿ à¤•à¤¿à¤ à¤—à¤ à¤à¤‚à¤Ÿà¤¿à¤Ÿà¥€ à¤¸à¥‡à¤Ÿ à¤¸à¥‡ à¤ªà¥‚à¤°à¥à¤µ-à¤—à¤£à¤¨à¤¾ à¤•à¥€ à¤—à¤ˆ\n * à¤¸à¤‚à¤–à¥à¤¯à¤¾à¤¤à¥à¤®à¤• à¤¸à¤‚à¤¦à¤°à¥à¤­ (&#123; à¤”à¤° &#xAB;) à¤¬à¤¿à¤¨à¤¾ à¤•à¤¿à¤¸à¥€ à¤®à¥ˆà¤ªà¤¿à¤‚à¤— à¤•à¥‡ à¤ªà¥‚à¤°à¥€ à¤¤à¤°à¤¹ à¤¸à¥‡ à¤¸à¤®à¤°à¥à¤¥à¤¿à¤¤ à¤¹à¥ˆà¤‚à¥¤\n * à¤…à¤œà¥à¤à¤¾à¤¤ à¤¨à¤¾à¤®à¤¿à¤¤ à¤à¤‚à¤Ÿà¤¿à¤Ÿà¥€à¤œà¤¼ à¤¶à¤¾à¤¬à¥à¤¦à¤¿à¤• à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤ªà¤¾à¤¸ à¤¹à¥‹à¤¤à¥€ à¤¹à¥ˆà¤‚ (CommonMark-à¤…à¤¨à¥à¤°à¥‚à¤ª)à¥¤\n */\nexport const NAMED_CODES_TO_UNICODE: Record<string, string> = util\n\n/**\n * Regex for matching HTML character references (&entity; or &#123; or &#xAB;)\n * Matches: & followed by entity name or # followed by decimal or hex digits, ending with ;\n * @lang zh ç”¨äºåŒ¹é… HTML å­—ç¬¦å¼•ç”¨çš„æ­£åˆ™è¡¨è¾¾å¼ï¼ˆ&entity; æˆ– &#123; æˆ– &#xAB;ï¼‰\n * åŒ¹é…ï¼š& åè·Ÿå®ä½“åç§°æˆ– # åè·Ÿåè¿›åˆ¶æˆ–åå…­è¿›åˆ¶æ•°å­—ï¼Œä»¥ ; ç»“å°¾\n * @lang hi HTML à¤µà¤°à¥à¤£ à¤¸à¤‚à¤¦à¤°à¥à¤­à¥‹à¤‚ à¤¸à¥‡ à¤®à¤¿à¤²à¤¾à¤¨ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤°à¥‡à¤—à¥‡à¤•à¥à¤¸ (&entity; à¤¯à¤¾ &#123; à¤¯à¤¾ &#xAB;)\n * à¤®à¥ˆà¤š: & à¤•à¥‡ à¤¬à¤¾à¤¦ à¤à¤‚à¤Ÿà¤¿à¤Ÿà¥€ à¤¨à¤¾à¤® à¤¯à¤¾ # à¤•à¥‡ à¤¬à¤¾à¤¦ à¤¦à¤¶à¤®à¤²à¤µ à¤¯à¤¾ à¤¹à¥‡à¤•à¥à¤¸ à¤…à¤‚à¤•, ; à¤•à¥‡ à¤¸à¤¾à¤¥ à¤¸à¤®à¤¾à¤ªà¥à¤¤ à¤¹à¥‹à¤¤à¤¾ à¤¹à¥ˆ\n */\nexport const HTML_CHAR_CODE_R: RegExp =\n  /&([a-zA-Z0-9]+|#[0-9]{1,7}|#x[0-9a-fA-F]{1,6});/gi\n\n/**\n * Regex for determining if markdown content should be rendered as block-level\n * Matches: newlines, list items, headings, indented content, thematic breaks, blockquotes\n * @lang zh ç”¨äºç¡®å®š Markdown å†…å®¹æ˜¯å¦åº”æ¸²æŸ“ä¸ºå—çº§çš„æ­£åˆ™è¡¨è¾¾å¼\n * åŒ¹é…ï¼šæ¢è¡Œç¬¦ã€åˆ—è¡¨é¡¹ã€æ ‡é¢˜ã€ç¼©è¿›å†…å®¹ã€åˆ†éš”çº¿ã€å¼•ç”¨å—\n * @lang hi à¤¯à¤¹ à¤¨à¤¿à¤°à¥à¤§à¤¾à¤°à¤¿à¤¤ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤°à¥‡à¤—à¥‡à¤•à¥à¤¸ à¤•à¤¿ markdown à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤•à¥‹ à¤¬à¥à¤²à¥‰à¤•-à¤¸à¥à¤¤à¤°à¥€à¤¯ à¤•à¥‡ à¤°à¥‚à¤ª à¤®à¥‡à¤‚ à¤°à¥‡à¤‚à¤¡à¤° à¤•à¤¿à¤¯à¤¾ à¤œà¤¾à¤¨à¤¾ à¤šà¤¾à¤¹à¤¿à¤\n * à¤®à¥ˆà¤š: à¤¨à¤ˆ à¤²à¤¾à¤‡à¤¨à¥‡à¤‚, à¤¸à¥‚à¤šà¥€ à¤†à¤‡à¤Ÿà¤®à¥à¤¸, à¤¹à¥‡à¤¡à¤¿à¤‚à¤—à¥à¤¸, à¤‡à¤‚à¤¡à¥‡à¤‚à¤Ÿà¥‡à¤¡ à¤¸à¤¾à¤®à¤—à¥à¤°à¥€, à¤¥à¥€à¤®à¥ˆà¤Ÿà¤¿à¤• à¤¬à¥à¤°à¥‡à¤•à¥à¤¸, à¤¬à¥à¤²à¥‰à¤•à¤•à¥‹à¤Ÿà¥à¤¸\n */\n// Mapping of lowercase HTML attributes to JSX prop names\n// Shared between React and Solid renderers (Vue uses HTML attributes directly)\nexport const HTML_TO_JSX_MAP: Record<string, string> = {\n  class: 'className',\n  for: 'htmlFor',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  autocomplete: 'autoComplete',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  charset: 'charSet',\n  classid: 'classId',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  crossorigin: 'crossOrigin',\n  enctype: 'encType',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formmethod: 'formMethod',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  hreflang: 'hrefLang',\n  inputmode: 'inputMode',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  marginheight: 'marginHeight',\n  marginwidth: 'marginWidth',\n  maxlength: 'maxLength',\n  mediagroup: 'mediaGroup',\n  minlength: 'minLength',\n  novalidate: 'noValidate',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  spellcheck: 'spellCheck',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  tabindex: 'tabIndex',\n  usemap: 'useMap',\n}\n\n/**\n * Convert HTML attributes to JSX props\n * Maps HTML attribute names (e.g., \"class\", \"for\") to JSX prop names (e.g., \"className\", \"htmlFor\")\n *\n * @param attrs - HTML attributes object\n * @returns JSX props object\n */\nexport function htmlAttrsToJSXProps(\n  attrs: Record<string, any>\n): Record<string, any> {\n  var jsxProps: Record<string, any> = {}\n\n  for (var key in attrs) {\n    var keyLower = key.toLowerCase()\n    var mappedKey = HTML_TO_JSX_MAP[keyLower]\n    jsxProps[mappedKey || key] = attrs[key]\n  }\n\n  return jsxProps\n}\n\nexport const SHOULD_RENDER_AS_BLOCK_R: RegExp =\n  /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/\n\n/**\n * Decode HTML entity references to Unicode characters\n *\n * @param text - The text containing HTML entities\n * @returns The decoded text\n */\nexport function decodeEntityReferences(text: string): string {\n  if (text.indexOf('&') === -1) return text\n\n  return text.replace(HTML_CHAR_CODE_R, (full, inner) => {\n    // Named entity lookup via swappable decoder\n    // In browser builds, this uses DOM; in Node, uses lookup table\n    var entity = decodeEntity(inner)\n    if (entity) return entity\n\n    // Numeric entities (always computed, no lookup needed)\n    if (inner[0] === '#') {\n      var code =\n        inner[1] === 'x' || inner[1] === 'X'\n          ? parseInt(inner.slice(2), 16)\n          : parseInt(inner.slice(1), 10)\n\n      if (code === 0 || (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff) {\n        return '\\uFFFD'\n      }\n      return code <= 0xffff\n        ? String.fromCharCode(code)\n        : String.fromCharCode(\n            0xd800 + ((code - 0x10000) >> 10),\n            0xdc00 + ((code - 0x10000) & 0x3ff)\n          )\n    }\n\n    return full\n  })\n}\n\nexport const SANITIZE_R: RegExp = /(javascript|vbscript|data(?!:image)):/i\n\n/**\n * Sanitize URLs and other input values to prevent XSS attacks.\n * Filters out javascript:, vbscript:, and data: URLs (except data:image).\n *\n * @lang zh æ¸…ç† URL å’Œå…¶ä»–è¾“å…¥å€¼ä»¥é˜²æ­¢ XSS æ”»å‡»ã€‚è¿‡æ»¤æ‰ javascript:ã€vbscript: å’Œ data: URLï¼ˆdata:image é™¤å¤–ï¼‰ã€‚\n * @lang hi XSS à¤¹à¤®à¤²à¥‹à¤‚ à¤•à¥‹ à¤°à¥‹à¤•à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ URLs à¤”à¤° à¤…à¤¨à¥à¤¯ à¤‡à¤¨à¤ªà¥à¤Ÿ à¤®à¤¾à¤¨à¥‹à¤‚ à¤•à¥‹ à¤¸à¥ˆà¤¨à¤¿à¤Ÿà¤¾à¤‡à¤œà¤¼ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆà¥¤ javascript:, vbscript:, à¤”à¤° data: URLs à¤•à¥‹ à¤«à¤¼à¤¿à¤²à¥à¤Ÿà¤° à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ (data:image à¤•à¥‹ à¤›à¥‹à¤¡à¤¼à¤•à¤°)à¥¤\n *\n * @param input - The URL or value to sanitize\n * @lang zh @param input - è¦æ¸…ç†çš„ URL æˆ–å€¼\n * @lang hi @param input - à¤¸à¥ˆà¤¨à¤¿à¤Ÿà¤¾à¤‡à¤œà¤¼ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ URL à¤¯à¤¾ à¤®à¤¾à¤¨\n * @returns Sanitized value, or null if unsafe\n * @lang zh @returns æ¸…ç†åçš„å€¼ï¼Œå¦‚æœä¸å®‰å…¨åˆ™è¿”å› null\n * @lang hi @returns à¤¸à¥ˆà¤¨à¤¿à¤Ÿà¤¾à¤‡à¤œà¤¼ à¤•à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾ à¤®à¤¾à¤¨, à¤¯à¤¾ à¤…à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ à¤¹à¥‹à¤¨à¥‡ à¤ªà¤° null\n */\nexport function sanitizer(input: string): string | null {\n  if (SANITIZE_R.test(input)) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Input contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n        input\n      )\n    }\n    return null\n  }\n\n  if (input.indexOf('%') === -1) return input\n\n  try {\n    const decoded = decodeURIComponent(input).replace(/[^A-Za-z0-9/:]/g, '')\n    if (SANITIZE_R.test(decoded)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'Input contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n          decoded\n        )\n      }\n      return null\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Input could not be decoded due to malformed syntax or characters, it will not be rendered.',\n        input\n      )\n    }\n    return null\n  }\n\n  return input\n}\n\n// Character replacement lookup table for slugify (Unicode to ASCII)\nvar slugifyReplaceTable: Record<number, string> = {}\nvar codes: number[], i: number\ncodes = [192, 193, 194, 195, 196, 197, 224, 225, 226, 227, 228, 229, 230, 198]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'a'\nslugifyReplaceTable[231] = slugifyReplaceTable[199] = 'c'\nslugifyReplaceTable[240] = slugifyReplaceTable[208] = 'd'\ncodes = [200, 201, 202, 203, 233, 232, 234, 235]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'e'\ncodes = [207, 239, 206, 238, 205, 237, 204, 236]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'i'\nslugifyReplaceTable[209] = slugifyReplaceTable[241] = 'n'\ncodes = [248, 216, 339, 338, 213, 245, 212, 244, 211, 243, 210, 242]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'o'\ncodes = [220, 252, 219, 251, 218, 250, 217, 249]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'u'\nslugifyReplaceTable[376] =\n  slugifyReplaceTable[255] =\n  slugifyReplaceTable[221] =\n  slugifyReplaceTable[253] =\n    'y'\n\n/**\n * Check if a character code is alphanumeric (0-9, A-Z, a-z)\n *\n * @param code - Character code to check\n * @returns True if alphanumeric\n */\nexport function isAlnumCode(code: number): boolean {\n  return (\n    (code >= $.CHAR_DIGIT_0 && code <= $.CHAR_DIGIT_9) ||\n    (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n    (code >= $.CHAR_a && code <= $.CHAR_z)\n  )\n}\n\n/**\n * Convert a string to a URL-safe slug by normalizing characters and replacing spaces with hyphens.\n * Based on https://stackoverflow.com/a/18123682/1141611\n * Not complete, but probably good enough.\n *\n * @lang zh é€šè¿‡è§„èŒƒåŒ–å­—ç¬¦å¹¶ç”¨è¿å­—ç¬¦æ›¿æ¢ç©ºæ ¼ï¼Œå°†å­—ç¬¦ä¸²è½¬æ¢ä¸º URL å®‰å…¨çš„åˆ«åã€‚ä¸å®Œæ•´ï¼Œä½†å¯èƒ½è¶³å¤Ÿå¥½ã€‚\n * @lang hi à¤µà¤°à¥à¤£à¥‹à¤‚ à¤•à¥‹ à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯à¥€à¤•à¥ƒà¤¤ à¤•à¤°à¤•à¥‡ à¤”à¤° à¤°à¤¿à¤•à¥à¤¤ à¤¸à¥à¤¥à¤¾à¤¨ à¤•à¥‹ à¤¹à¤¾à¤‡à¤«à¤¼à¤¨ à¤¸à¥‡ à¤¬à¤¦à¤²à¤•à¤° à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤— à¤•à¥‹ URL-à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ slug à¤®à¥‡à¤‚ à¤¬à¤¦à¤²à¤¤à¤¾ à¤¹à¥ˆà¥¤ à¤ªà¥‚à¤°à¥à¤£ à¤¨à¤¹à¥€à¤‚ à¤¹à¥ˆ, à¤²à¥‡à¤•à¤¿à¤¨ à¤¶à¤¾à¤¯à¤¦ à¤ªà¤°à¥à¤¯à¤¾à¤ªà¥à¤¤ à¤¹à¥ˆà¥¤\n *\n * @param str - String to slugify\n * @lang zh @param str - è¦è½¬æ¢ä¸ºåˆ«åçš„å­—ç¬¦ä¸²\n * @lang hi @param str - slugify à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤—\n * @returns URL-safe slug\n * @lang zh @returns URL å®‰å…¨çš„åˆ«å\n * @lang hi @returns URL-à¤¸à¥à¤°à¤•à¥à¤·à¤¿à¤¤ slug\n */\nexport function slugify(str: string): string {\n  var parts: string[] = []\n  for (var i = 0; i < str.length; i++) {\n    var code = str.charCodeAt(i)\n    if (isAlnumCode(code)) {\n      if (code >= $.CHAR_A && code <= $.CHAR_Z) {\n        parts.push(String.fromCharCode(code + $.CHAR_CASE_OFFSET))\n      } else {\n        parts.push(str[i])\n      }\n    } else if (code === $.CHAR_SPACE || code === $.CHAR_DASH) {\n      parts.push('-')\n    } else {\n      var replacement = slugifyReplaceTable[code]\n      if (replacement) parts.push(replacement)\n    }\n  }\n  return parts.join('')\n}\n\n/**\n * Check if a string includes a substring\n *\n * @param str - String to search in\n * @param search - Substring to search for\n * @returns True if substring is found\n */\nexport function includes(str: string, search: string): boolean {\n  return str.indexOf(search) !== -1\n}\n\n/**\n * Check if a string starts with a prefix\n *\n * @param str - String to check\n * @param prefix - Prefix to check for\n * @param pos - Optional starting position\n * @returns True if string starts with prefix\n */\nexport function startsWith(str: string, prefix: string, pos?: number): boolean {\n  return str.startsWith(prefix, pos)\n}\n\n/**\n * Check if a string ends with a suffix\n *\n * @param str - String to check\n * @param suffix - Suffix to check for\n * @param pos - Optional ending position\n * @returns True if string ends with suffix\n */\nexport function endsWith(str: string, suffix: string, pos?: number): boolean {\n  return str.startsWith(\n    suffix,\n    (pos === undefined ? str.length : pos) - suffix.length\n  )\n}\n\n// Known void elements (HTML5 and SVG) that don't require closing tag or />\n// Use Set for O(1) lookups instead of O(n) array.includes()\nexport const VOID_ELEMENTS: Set<string> = new Set([\n  // HTML5 void elements\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  // SVG void elements\n  'circle',\n  'ellipse',\n  'line',\n  'path',\n  'polygon',\n  'polyline',\n  'rect',\n  'use',\n  'stop',\n  'animate',\n  'animateTransform',\n  'set',\n])\n\n/**\n * Check if an element is a void element (doesn't require closing tag)\n *\n * @param tagName - HTML tag name\n * @returns True if void element\n */\nexport function isVoidElement(tagName: string): boolean {\n  let lowerTag = tagName.toLowerCase()\n  if (VOID_ELEMENTS.has(lowerTag)) return true\n  // Handle SVG namespace prefixes like svg:circle\n  const colonIndex = lowerTag.indexOf(':')\n  if (colonIndex !== -1) {\n    lowerTag = lowerTag.slice(colonIndex + 1)\n    return VOID_ELEMENTS.has(lowerTag)\n  }\n  return false\n}\n\n/** Attributes that should be sanitized for security */\nexport const ATTRIBUTES_TO_SANITIZE: readonly string[] = [\n  'src',\n  'href',\n  'data',\n  'formAction',\n  'srcDoc',\n  'action',\n]\n\n// Character classification flags (bitfield)\nconst CHAR_WHITESPACE = 1\nconst CHAR_PUNCTUATION = 2\n\n// Inline character type constants\n// const INLINE_CHAR_TYPE_NORMAL = 0\nconst INLINE_CHAR_TYPE_SPECIAL = 1\nconst INLINE_CHAR_TYPE_ESCAPE = 2\nconst INLINE_CHAR_TYPE_DELIMITER = 3\nconst INLINE_CHAR_TYPE_LINK = 4\n\n// Lookup table for ASCII characters (0-127)\nexport const charClassTable: Uint8Array = (function () {\n  const t = new Uint8Array(128)\n  let i\n  t[$.CHAR_TAB] =\n    t[$.CHAR_NEWLINE] =\n    t[$.CHAR_FF] =\n    t[$.CHAR_CR] =\n    t[$.CHAR_SPACE] =\n      CHAR_WHITESPACE\n  for (i = $.CHAR_EXCLAMATION; i <= $.CHAR_SLASH; i++) t[i] = CHAR_PUNCTUATION\n  for (i = $.CHAR_COLON; i <= $.CHAR_AT; i++) t[i] = CHAR_PUNCTUATION\n  for (i = $.CHAR_BRACKET_OPEN; i <= $.CHAR_BACKTICK; i++)\n    t[i] = CHAR_PUNCTUATION\n  for (i = $.CHAR_BRACE_OPEN; i <= $.CHAR_TILDE; i++) t[i] = CHAR_PUNCTUATION\n  return t\n})()\n\n// Lookup table for inline character types (0-127): 0=normal, 1=special, 2=escape, 3=delimiter, 4=link\nexport const inlineCharTypeTable: Uint8Array = (function () {\n  const t = new Uint8Array(128)\n  t[$.CHAR_BACKSLASH] = INLINE_CHAR_TYPE_ESCAPE\n  t[$.CHAR_BRACKET_OPEN] = INLINE_CHAR_TYPE_LINK\n  t[$.CHAR_ASTERISK] =\n    t[$.CHAR_UNDERSCORE] =\n    t[$.CHAR_TILDE] =\n    t[$.CHAR_EQ] =\n      INLINE_CHAR_TYPE_DELIMITER\n  t[$.CHAR_BACKTICK] =\n    t[$.CHAR_LT] =\n    t[$.CHAR_AT] =\n    t[$.CHAR_BRACKET_CLOSE] =\n    t[$.CHAR_NEWLINE] =\n    t[$.CHAR_SPACE] =\n    t[$.CHAR_EXCLAMATION] =\n      INLINE_CHAR_TYPE_SPECIAL\n  t[$.CHAR_f] = t[$.CHAR_H] = t[$.CHAR_W] = INLINE_CHAR_TYPE_SPECIAL\n  return t\n})()\n\nexport function isASCIIPunctuation(code: number): boolean {\n  return (\n    code < $.CHAR_ASCII_BOUNDARY &&\n    (charClassTable[code] & CHAR_PUNCTUATION) !== 0\n  )\n}\n\nexport function isASCIIWhitespace(code: number): boolean {\n  return (\n    code < $.CHAR_ASCII_BOUNDARY &&\n    (charClassTable[code] & CHAR_WHITESPACE) !== 0\n  )\n}\n\n// Unicode property escapes for spec-compliant character classification\n// Per GFM spec Section 2.1: \"A punctuation character is a character in the general Unicode categories\n// Pc, Pd, Pe, Pf, Pi, Po, or Ps\" - this is \\p{P}\n// BUT also includes some currency symbols and other symbols per the spec's explicit list\nconst UNICODE_PUNCT_R = /[\\p{P}\\p{S}]/u\nconst UNICODE_WHITESPACE_R = /\\p{Zs}/u\n\nexport function isUnicodeWhitespace(c: string): boolean {\n  if (!c) return true\n  const code = c.charCodeAt(0)\n  return code < $.CHAR_ASCII_BOUNDARY\n    ? (charClassTable[code] & CHAR_WHITESPACE) !== 0\n    : UNICODE_WHITESPACE_R.test(c)\n}\n\nexport function isUnicodePunctuation(c: string | number): boolean {\n  if (typeof c === 'number')\n    return (\n      c < $.CHAR_ASCII_BOUNDARY && (charClassTable[c] & CHAR_PUNCTUATION) !== 0\n    )\n  if (!c) return false\n  const code = c.charCodeAt(0)\n  return code < $.CHAR_ASCII_BOUNDARY\n    ? (charClassTable[code] & CHAR_PUNCTUATION) !== 0\n    : UNICODE_PUNCT_R.test(c)\n}\n\n/**\n * Find the end of the current line\n * Optimized: Pure indexOf is faster than hybrid approach - JS engine optimizes it better\n * Handles CRLF by returning position before \\r when followed by \\n\n */\nexport function findLineEnd(source: string, startPos: number): number {\n  const newlinePos = source.indexOf('\\n', startPos)\n  if (newlinePos === -1) return source.length\n  if (newlinePos > 0 && source.charCodeAt(newlinePos - 1) === $.CHAR_CR) {\n    return newlinePos - 1\n  }\n  return newlinePos\n}\n\nvar crlfParts: string[] = []\n\n/**\n * Normalize input text for parsing:\n * - Replace CRLF and CR line endings with LF\n * - Replace null bytes (U+0000) with replacement character (U+FFFD) per CommonMark spec\n * Returns original string if no transformations needed (fast path)\n */\nexport function normalizeInput(text: string): string {\n  var firstCR = text.indexOf('\\r')\n  var firstNull = text.indexOf('\\x00')\n\n  if (firstCR === -1 && firstNull === -1) return text\n\n  var len = text.length\n  crlfParts.length = 0\n  var start = 0\n  var i = 0\n\n  if (firstCR === -1) {\n    i = firstNull\n  } else if (firstNull === -1) {\n    i = firstCR\n  } else {\n    i = firstCR < firstNull ? firstCR : firstNull\n  }\n\n  for (; i < len; i++) {\n    var code = text.charCodeAt(i)\n    if (code === $.CHAR_CR) {\n      if (start < i) crlfParts.push(text.slice(start, i))\n      if (i + 1 < len && text.charCodeAt(i + 1) === $.CHAR_NEWLINE) {\n        i++\n      }\n      crlfParts.push('\\n')\n      start = i + 1\n    } else if (code === 0) {\n      if (start < i) crlfParts.push(text.slice(start, i))\n      crlfParts.push('\\uFFFD')\n      start = i + 1\n    }\n  }\n  if (start < len) crlfParts.push(text.slice(start))\n  return crlfParts.join('')\n}\n\n/**\n * @deprecated Use normalizeInput instead\n * Normalize CRLF and CR line endings to LF\n * Returns original string if no CR characters are present (fast path)\n */\nexport function normalizeCRLF(text: string): string {\n  return normalizeInput(text)\n}\n\n/**\n * Skip whitespace characters\n */\nexport function skipWhitespace(\n  source: string,\n  pos: number,\n  maxPos?: number\n): number {\n  const end = maxPos ?? source.length\n  while (pos < end && (source[pos] === ' ' || source[pos] === '\\t')) pos++\n  return pos\n}\n\n/**\n * Fast check if object has any enumerable properties\n * Optimized alternative to Object.keys(obj).length > 0\n */\nexport function hasKeys(obj: Record<string, any> | null | undefined): boolean {\n  if (!obj) return false\n  for (var key in obj) {\n    return true\n  }\n  return false\n}\n\n/**\n * Extract plain text from AST nodes (for image alt text, heading slugs, etc.)\n * Shared between JSX and HTML renderers\n */\n/**\n * Get nested property from object using dot notation path\n */\nexport function get(source: any, path: string, fallback: any): any {\n  var result = source\n  var segments = path.split('.')\n  var i = 0\n  while (i < segments.length) {\n    result = result?.[segments[i]]\n    if (result === undefined) break\n    i++\n  }\n  return result || fallback\n}\n\n/**\n * Get tag name from override object, supporting both string and component object overrides\n */\nexport function getTag<\n  T extends string | { component?: string; props?: Record<string, any> },\n>(tag: string, overrides?: Record<string, T>): string {\n  if (!overrides) return tag\n  const override = get(overrides, tag, undefined)\n  if (typeof override === 'string') return override\n  if (typeof override === 'object' && override.component)\n    return override.component\n  return tag\n}\n\n/**\n * Get override props from override object\n */\nexport function getOverrideProps<\n  T extends string | { component?: string; props?: Record<string, any> },\n>(\n  tag: string,\n  overrides?: Record<string, T>\n): Record<string, string | number | boolean> {\n  if (!overrides) return {}\n  const override = get(overrides, tag, undefined)\n  return typeof override === 'object' && override.props ? override.props : {}\n}\n\nexport function extractPlainText(nodes: Array<any>, RuleType: any): string {\n  var result = ''\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var node = nodes[i],\n      type = node.type\n    if (type === RuleType.text || type === RuleType.codeInline) {\n      var text = node.text\n      if (text) result += text\n    } else if (type === RuleType.textFormatted || type === RuleType.link) {\n      if (node.children) result += extractPlainText(node.children, RuleType)\n    } else if (type === RuleType.image) {\n      if (node.alt) {\n        result += node.alt\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Check if tag should be filtered per GFM tagfilter extension\n */\nexport function shouldFilterTag(tagName: string): boolean {\n  var lowerTag = tagName.toLowerCase()\n  return (\n    lowerTag === 'title' ||\n    lowerTag === 'textarea' ||\n    lowerTag === 'style' ||\n    lowerTag === 'xmp' ||\n    lowerTag === 'iframe' ||\n    lowerTag === 'noembed' ||\n    lowerTag === 'noframes' ||\n    lowerTag === 'script' ||\n    lowerTag === 'plaintext'\n  )\n}\n\n/**\n * Apply tagfilter to text content - escape dangerous tags\n */\nexport function applyTagFilterToText(text: string): string {\n  // Escape dangerous tags in raw HTML text\n  // Matches opening tags like <tag> or <tag attr=\"val\">\n  return text.replace(\n    /<(\\/?)(title|textarea|style|xmp|iframe|noembed|noframes|script|plaintext)(\\s|>|\\/)/gi,\n    function (match, slash, tagName, after) {\n      // Only escape the opening <\n      return '&lt;' + slash + tagName + after\n    }\n  )\n}\n\n","import { RuleType, type MarkdownToJSX } from './types'\nimport * as $ from './constants'\nimport * as util from './utils'\n\n// NOTE: All debug and tracking functions are automatically removed by build-plugins.ts\n\n// Global parseMetrics - accessible via global.parseMetrics from all files\ndeclare global {\n  var parseMetrics: {\n    blockParsers: {\n      [key: string]: {\n        attempts: number\n        hits: number\n        hitTimings: number[]\n      }\n    }\n    inlineParsers: {\n      [key: string]: {\n        attempts: number\n        hits: number\n        hitTimings: number[]\n      }\n    }\n    totalOperations: number\n    blockParseIterations: number\n    inlineParseIterations: number\n  } | null\n  var parseMetricsStartTimes: Map<string, number> | null\n}\n\nexport {};\n\nfunction warn(message: string): void {\n  console.warn(message)\n}\n\nfunction countConsecutiveChars(\n  source: string,\n  pos: number,\n  targetChar: string,\n  maxCount?: number\n): number {\n  var targetCode = charCode(targetChar)\n  var len = source.length\n  var max = maxCount ?? len - pos\n  var count = 0\n  while (\n    count < max &&\n    pos + count < len &&\n    charCode(source, pos + count) === targetCode\n  )\n    count++\n  return count\n}\n\n// Unified flanking check: dir=0 for left, dir=1 for right\nfunction checkFlanking(\n  source: string,\n  delimiterStart: number,\n  delimiterEnd: number,\n  bound: number,\n  dir: number\n): boolean {\n  if (dir === 0 ? delimiterEnd >= bound : delimiterStart <= bound) return false\n\n  const adjacentChar =\n    dir === 0 ? source[delimiterEnd] : source[delimiterStart - 1]\n  const oppositeChar =\n    dir === 0\n      ? delimiterStart > 0\n        ? source[delimiterStart - 1]\n        : null\n      : delimiterEnd < source.length\n        ? source[delimiterEnd]\n        : null\n\n  var adjacentCode = charCode(adjacentChar)\n\n  if (\n    adjacentCode < $.CHAR_ASCII_BOUNDARY\n      ? util.isASCIIWhitespace(adjacentCode)\n      : util.isUnicodeWhitespace(adjacentChar)\n  ) {\n    return false\n  }\n\n  var oppositeCode = oppositeChar ? charCode(oppositeChar) : null\n  var isOppositeWS =\n    oppositeChar === null ||\n    oppositeChar === '\\n' ||\n    oppositeChar === '\\r' ||\n    (oppositeCode !== null\n      ? oppositeCode < $.CHAR_ASCII_BOUNDARY\n        ? util.isASCIIWhitespace(oppositeCode)\n        : util.isUnicodeWhitespace(oppositeChar)\n      : true)\n\n  var isAdjacentPunct = isPunctuation(adjacentCode, adjacentChar)\n\n  if (!isAdjacentPunct) return true\n  if (isOppositeWS) return true\n\n  return oppositeChar\n    ? isPunctuation(charCode(oppositeChar), oppositeChar)\n    : false\n}\n\n// Per CommonMark spec: backslashes escape ASCII punctuation characters in link destinations\n// For non-punctuation characters, the backslash is preserved as a literal backslash\n// Per CommonMark spec: backslash unescaping and entity reference decoding for URLs and titles\n// Any ASCII punctuation character may be backslash-escaped\n// Entity references are recognized and decoded to Unicode\nfunction unescapeUrlOrTitle(str: string): string {\n  var result = '',\n    i = 0\n  while (i < str.length) {\n    if (str[i] === '\\\\' && i + 1 < str.length) {\n      var next = str[i + 1]\n      result += util.isUnicodePunctuation(charCode(next)) ? next : '\\\\' + next\n      i += 2\n    } else {\n      result += str[i++]\n    }\n  }\n  return util.decodeEntityReferences(result)\n}\n\nfunction skipToNextLine(source: string, lineEnd: number): number {\n  if (lineEnd >= source.length) return lineEnd\n  if (\n    source.charCodeAt(lineEnd) === $.CHAR_CR &&\n    lineEnd + 1 < source.length &&\n    source.charCodeAt(lineEnd + 1) === $.CHAR_NEWLINE\n  ) {\n    return lineEnd + 2\n  }\n  if (source.charCodeAt(lineEnd) === $.CHAR_NEWLINE) {\n    return lineEnd + 1\n  }\n  return lineEnd + 1\n}\n\nfunction getCharType(code: number, skipAutoLink: boolean): number {\n  if (code >= $.CHAR_ASCII_BOUNDARY) return 0\n  var type = util.inlineCharTypeTable[code]\n  if (\n    skipAutoLink &&\n    type === 1 &&\n    (code === $.CHAR_f || code === $.CHAR_H || code === $.CHAR_W)\n  ) {\n    return 0\n  }\n  return type\n}\n\nfunction tryMergeBlockquoteContinuation(\n  source: string,\n  currentPos: number,\n  lastItem: MarkdownToJSX.ASTNode[],\n  continuationContent: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): number | null {\n  if (\n    !lastItem.length ||\n    lastItem[lastItem.length - 1].type !== RuleType.blockQuote\n  )\n    return null\n  const checkPos = util.skipWhitespace(\n    continuationContent,\n    0,\n    continuationContent.length\n  )\n  if (\n    checkPos >= continuationContent.length ||\n    continuationContent[checkPos] !== '>'\n  )\n    return null\n  // We've already verified it starts with '>', so try blockquote directly\n  // (parseBlock might match fenced code blocks first due to indentation)\n  const cont = parseBlockQuote(source, currentPos, state, options)\n  if (!cont) return null\n  const lastBlockQuote = lastItem[\n    lastItem.length - 1\n  ] as MarkdownToJSX.BlockQuoteNode\n  const contBlockQuote = cont as MarkdownToJSX.BlockQuoteNode & {\n    endPos: number\n  }\n  if (contBlockQuote.children)\n    lastBlockQuote.children.push(...contBlockQuote.children)\n  return contBlockQuote.endPos\n}\n\nfunction createHeading(\n  level: number,\n  children: MarkdownToJSX.ASTNode[],\n  content: string,\n  slugify: (str: string) => string\n): MarkdownToJSX.HeadingNode {\n  return {\n    type: RuleType.heading,\n    level,\n    children,\n    id: slugify(content),\n  } as MarkdownToJSX.HeadingNode\n}\n\n// Static regex patterns for performance\nexport const UNESCAPE_R: RegExp = /\\\\(.)/g\nconst HEADING_TRAILING_HASHES_R = /\\s+#+\\s*$/\n// Unified regex for all list item patterns: ordered (digit + delimiter + content) or unordered (marker + content)\n// Groups: 1=ordered_num, 2=ordered_delim, 3=ordered_content, 4=ordered_empty_num, 5=ordered_empty_delim, 6=unordered_marker, 7=unordered_content, 8=unordered_empty_marker\nconst LIST_ITEM_R =\n  /^(?:(\\d{1,9})([.)])\\s+(.*)$|(\\d{1,9})([.)])\\s*$|([-*+])\\s+(.*)$|([-*+])\\s*$)/\n// List items with content (marker + whitespace + content or end of line) - for continuation matching\nconst ORDERED_LIST_ITEM_WITH_CONTENT_R = /^(\\d{1,9})([.)])(\\s+|$)/\nconst UNORDERED_LIST_ITEM_WITH_CONTENT_R = /^([*+\\-])(\\s+|$)/\nexport const HTML_BLOCK_ELEMENT_START_R: RegExp =\n  /^<([a-z][^ >/\\n\\r]*) ?([^>]*?)>/i\nexport const HTML_BLOCK_ELEMENT_START_R_ATTR: RegExp =\n  /^<([a-z][^ >/]*) ?(?:[^>/]+[^/]|)>/i\n\nvar charCode = function (c: string, pos: number = 0) {\n  return c.charCodeAt(pos)\n}\nvar isAlnum = function (c: string): boolean {\n  return util.isAlnumCode(charCode(c))\n}\nvar isWS = function (c: string) {\n  return util.isASCIIWhitespace(charCode(c))\n}\nvar isSpaceOrTab = function (c: string): boolean {\n  return c === ' ' || c === '\\t'\n}\nvar isAttrWhitespace = function (c: string): boolean {\n  return c === ' ' || c === '\\t' || c === '\\n' || c === '\\r'\n}\nvar isPunctuation = function (code: number, char: string): boolean {\n  return util.isUnicodePunctuation(code < $.CHAR_ASCII_BOUNDARY ? code : char)\n}\nvar isNameChar = function (c: string) {\n  var n = charCode(c)\n  return (\n    isAlnum(c) ||\n    n === $.CHAR_DASH ||\n    n === $.CHAR_UNDERSCORE ||\n    n === $.CHAR_COLON ||\n    n === $.CHAR_PERIOD\n  )\n}\n\n// HTML validation functions removed - parser only recognizes boundaries, not validates syntax\n// Per GFM spec: parser's job is to identify HTML boundaries and pass content opaquely\n\nfunction parseHTMLTagName(\n  source: string,\n  pos: number\n): { tagName: string; tagLower: string; nextPos: number } | null {\n  var sourceLen = source.length\n  if (pos >= sourceLen) return null\n  var firstCharCode = charCode(source[pos])\n  if (!isAlphaCode(firstCharCode)) return null\n  var tagNameStart = pos\n  var tagNameEnd = pos\n  while (tagNameEnd < sourceLen) {\n    var code = charCode(source[tagNameEnd])\n    if (\n      (code >= $.CHAR_a && code <= $.CHAR_z) ||\n      (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n      (code >= $.CHAR_DIGIT_0 && code <= $.CHAR_DIGIT_9) ||\n      code === $.CHAR_DASH\n    ) {\n      tagNameEnd++\n    } else {\n      var tagEndCode = charCode(source[tagNameEnd])\n      if (\n        tagEndCode === $.CHAR_SPACE ||\n        tagEndCode === $.CHAR_TAB ||\n        tagEndCode === $.CHAR_NEWLINE ||\n        tagEndCode === $.CHAR_CR ||\n        tagEndCode === $.CHAR_GT ||\n        tagEndCode === $.CHAR_SLASH\n      ) {\n        break\n      } else {\n        return null\n      }\n    }\n  }\n  if (tagNameEnd === tagNameStart) return null\n  var tagName = source.slice(tagNameStart, tagNameEnd)\n\n  // Validate tag name according to spec: only ASCII letters, digits, hyphens\n  for (var i = 0; i < tagName.length; i++) {\n    var code = charCode(tagName[i])\n    if (\n      !(\n        (code >= $.CHAR_a && code <= $.CHAR_z) ||\n        (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n        (code >= $.CHAR_DIGIT_0 && code <= $.CHAR_DIGIT_9) ||\n        code === $.CHAR_DASH\n      )\n    ) {\n      return null\n    }\n  }\n\n  return { tagName, tagLower: tagName.toLowerCase(), nextPos: tagNameEnd }\n}\n\n/** Unified HTML tag parser that handles opening, closing, and self-closing tags */\nexport function parseHTMLTag(\n  source: string,\n  pos: number\n): {\n  tagName: string\n  tagLower: string\n  attrs: string\n  endPos: number\n  isClosing: boolean\n  isSelfClosing: boolean\n  hasNewline: boolean\n  hasSpaceBeforeSlash: boolean\n  whitespaceBeforeAttrs: string\n} | null {\n  var token = scanRawHTML(source, pos)\n  if (!token || token.kind !== 'tag') return null\n\n  // Note: hasSpaceBeforeSlash is already validated in scanner (returns null if invalid)\n  return {\n    tagName: token.tagName || '',\n    tagLower: token.tagNameLower || '',\n    attrs: token.attrs || '',\n    endPos: token.endPos,\n    isClosing: token.isClosing || false,\n    isSelfClosing: token.isSelfClosing || false,\n    hasNewline: token.hasNewline,\n    hasSpaceBeforeSlash: false,\n    whitespaceBeforeAttrs: token.whitespaceBeforeAttrs || '',\n  }\n}\n\n/** Find matching closing tag position for inline HTML tags. Returns [contentEnd, closingTagEnd] or null */\nfunction findInlineClosingTag(\n  source: string,\n  startPos: number,\n  tagNameLower: string\n): [number, number] | null {\n  var depth = 1\n  var searchPos = startPos\n  while (depth > 0 && searchPos < source.length) {\n    var tagIdx = source.indexOf('<', searchPos)\n    if (tagIdx === -1) return null\n    var tagParseResult = parseHTMLTag(source, tagIdx)\n    if (!tagParseResult) {\n      searchPos = tagIdx + 1\n      continue\n    }\n    if (\n      tagParseResult.isClosing &&\n      tagParseResult.tagLower === tagNameLower &&\n      --depth === 0\n    )\n      return [tagIdx, tagParseResult.endPos]\n    if (\n      !tagParseResult.isClosing &&\n      !tagParseResult.isSelfClosing &&\n      tagParseResult.tagLower === tagNameLower\n    )\n      depth++\n    searchPos = tagParseResult.endPos\n  }\n  return null\n}\n\nexport const INTERPOLATION_R: RegExp = /^\\{.*\\}$/\nconst DOUBLE_NEWLINE_R = /\\n\\n/\nconst BLOCK_SYNTAX_R =\n  /^(\\s{0,3}#[#\\s]|\\s{0,3}[-*+]\\s|\\s{0,3}\\d+\\.\\s|\\s{0,3}>\\s|\\s{0,3}```)/m\nconst TYPE1_TAG_R = /<\\/?(?:pre|script|style|textarea)\\b/i\nexport const UPPERCASE_TAG_R: RegExp = /^<[A-Z]/\nconst TRAILING_NEWLINE_R = /\\n$/\nconst BLOCK_START_CHARS_SET = new Set([\n  '#',\n  '>',\n  '-',\n  '*',\n  '+',\n  '`',\n  '|',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n])\n\n/** Find the next occurrence of a character, ignoring escaped versions */\nfunction findUnescapedChar(\n  source: string,\n  startPos: number,\n  endPos: number,\n  targetChar: string\n): number {\n  let i = startPos\n  while (i < endPos) {\n    if (source[i] === '\\\\' && i + 1 < endPos) {\n      i += 2\n      continue\n    }\n    if (source[i] === targetChar) return i\n    i++\n  }\n  return -1\n}\n\ntype StyleTuple = [key: string, value: string]\n\nfunction addStyleToCollection(styles: StyleTuple[], buffer: string): void {\n  var colonIndex = buffer.indexOf(':')\n  if (colonIndex > 0) {\n    var value = buffer.slice(colonIndex + 1).trim()\n    var len = value.length\n    if (len >= 2) {\n      var first = value[0]\n      if ((first === '\"' || first === \"'\") && value[len - 1] === first) {\n        value = value.slice(1, -1)\n      }\n    }\n    styles.push([buffer.slice(0, colonIndex).trim(), value])\n  }\n}\n\nexport function parseStyleAttribute(styleString: string): StyleTuple[] {\n  var styles: StyleTuple[] = []\n  if (!styleString) return styles\n\n  var buffer = ''\n  var depth = 0\n  var quoteChar = ''\n\n  for (var i = 0; i < styleString.length; i++) {\n    var char = styleString[i]\n\n    if (char === '\"' || char === \"'\") {\n      if (!quoteChar) {\n        quoteChar = char\n        depth++\n      } else if (char === quoteChar) {\n        quoteChar = ''\n        depth--\n      }\n    } else if (char === '(' && util.endsWith(buffer, 'url')) {\n      depth++\n    } else if (char === ')' && depth > 0) {\n      depth--\n    } else if (char === ';' && depth === 0) {\n      addStyleToCollection(styles, buffer)\n      buffer = ''\n      continue\n    }\n\n    buffer += char\n  }\n\n  addStyleToCollection(styles, buffer)\n\n  return styles\n}\n\nfunction attributeValueToJSXPropValue(\n  tag: MarkdownToJSX.HTMLTags,\n  key: string,\n  value: string,\n  sanitizeUrlFn: (\n    value: string,\n    tag: string,\n    attribute: string\n  ) => string | null,\n  options: ParseOptions\n): any {\n  if (key === 'style') {\n    return parseStyleAttribute(value).reduce(\n      function (styles, [k, v]) {\n        const sanitized = sanitizeUrlFn(v, tag, k)\n        if (sanitized != null) {\n          styles[k.replace(/(-[a-z])/g, substr => substr[1].toUpperCase())] =\n            sanitized\n        }\n        return styles\n      },\n      {} as { [key: string]: any }\n    );\n  }\n\n  // Handle JSX expressions (braces) before sanitization\n  // This allows parsing of arrays/objects in JSX props\n  if (value.match(INTERPOLATION_R)) {\n    value = value.slice(1, value.length - 1)\n    value = value ? value.replace(UNESCAPE_R, '$1') : value\n\n    // Try to parse as JSON for arrays/objects (best effort)\n    // Keep as raw string for functions and complex expressions\n    if (value.length > 0) {\n      const firstChar = value[0]\n      // Check if it looks like an array or object literal\n      if (firstChar === '[' || firstChar === '{') {\n        try {\n          return JSON.parse(value)\n        } catch (e) {\n          // Not valid JSON, keep as string (e.g., functions, JSX expressions)\n          return value\n        }\n      }\n    }\n    // For other expressions (functions, variables, etc.), keep as string by default\n    // Only eval if explicitly opted-in (NOT recommended for user inputs)\n    if (value === 'true') return true\n    if (value === 'false') return false\n\n    // Attempt to eval unserializable expressions only if explicitly enabled\n    // âš ï¸ WARNING: This uses eval() and should only be used with trusted content\n    if (options.evalUnserializableExpressions) {\n      try {\n        // Try to evaluate as an expression (function, variable, etc.)\n        // eslint-disable-next-line no-eval\n        return eval(`(${value})`)\n      } catch (e) {\n        // If eval fails, return as string\n        return value\n      }\n    }\n\n    // Don't apply sanitization to JSX expressions\n    // Keep as string - can be handled via renderRule on a case-by-case basis\n    return value\n  }\n\n  if (util.ATTRIBUTES_TO_SANITIZE.indexOf(key) !== -1) {\n    return sanitizeUrlFn(\n      value ? value.replace(UNESCAPE_R, '$1') : value,\n      tag,\n      key\n    )\n  }\n\n  return value === 'true' ? true : value === 'false' ? false : value\n}\n\nfunction parseHTMLAttributes(\n  attrs: string,\n  tagName: string,\n  tagNameOriginal: string,\n  options: ParseOptions\n): { [key: string]: any } {\n  const result: { [key: string]: any } = {}\n  if (!attrs || !attrs.trim()) return result\n\n  const attrMatches: string[] = []\n  let i = 0\n  const len = attrs.length\n  while (i < len) {\n    while (i < len && isAttrWhitespace(attrs[i])) i++\n    if (i >= len) break\n    const nameStart = i\n    while (i < len && isNameChar(attrs[i])) i++\n    if (i === nameStart) {\n      i++\n      continue\n    }\n    const name = attrs.slice(nameStart, i)\n    while (i < len && isAttrWhitespace(attrs[i])) i++\n    if (i >= len || attrs[i] !== '=') {\n      attrMatches.push(name)\n      continue\n    }\n    i++\n    while (i < len && isAttrWhitespace(attrs[i])) i++\n    if (i >= len) {\n      attrMatches.push(name + '=')\n      break\n    }\n    const valueStart = i\n    const q = attrs[i]\n    if (q === '\"' || q === \"'\") {\n      i++\n      while (i < len) {\n        if (attrs[i] === q) {\n          if (i + 1 >= len) {\n            i++\n            break\n          }\n          const nextChar = attrs[i + 1]\n          if (isAttrWhitespace(nextChar) || nextChar === '/') {\n            i++\n            break\n          }\n        }\n        i++\n      }\n    } else if (q === '{') {\n      let depth = 1\n      i++\n      while (i < len && depth > 0) {\n        if (attrs[i] === '{') depth++\n        else if (attrs[i] === '}') {\n          depth--\n          if (depth === 0) {\n            i++\n            break\n          }\n        }\n        i++\n      }\n    } else {\n      while (i < len && !isAttrWhitespace(attrs[i])) i++\n    }\n    attrMatches.push(name + '=' + attrs.slice(valueStart, i))\n  }\n\n  if (!attrMatches?.length) return result\n  const tagNameLower = tagName.toLowerCase()\n  for (let i = 0; i < attrMatches.length; i++) {\n    const rawAttr = attrMatches[i],\n      delimiterIdx = rawAttr.indexOf('=')\n    if (delimiterIdx !== -1) {\n      const key = rawAttr.slice(0, delimiterIdx).trim(),\n        keyLower = key.toLowerCase()\n      if (keyLower === 'ref') continue\n      const rawValue = rawAttr.slice(delimiterIdx + 1).trim(),\n        value = ((str: string) => {\n          const first = str[0]\n          if (\n            (first === '\"' || first === \"'\") &&\n            str.length >= 2 &&\n            str[str.length - 1] === first\n          )\n            return str.slice(1, -1)\n          return str\n        })(rawValue)\n\n      if (\n        (keyLower === 'href' && tagNameLower === 'a') ||\n        (keyLower === 'src' && tagNameLower === 'img')\n      ) {\n        const safe = options.sanitizer(\n          value,\n          tagNameLower as MarkdownToJSX.HTMLTags,\n          keyLower\n        )\n        if (safe == null) {\n          warn(`Stripped unsafe ${keyLower} on <${tagNameOriginal}>`)\n          continue\n        }\n        result[key] = safe\n      } else {\n        const normalizedValue = attributeValueToJSXPropValue(\n          tagNameLower as MarkdownToJSX.HTMLTags,\n          keyLower,\n          value,\n          options.sanitizer,\n          options\n        )\n        result[key] = normalizedValue\n      }\n    } else if (rawAttr !== 'style')\n      result[rawAttr] = true\n  }\n  // Check for URI-encoded malicious content in the raw attributes string\n  // Only decode if % is present (performance optimization)\n  if (attrs.indexOf('%') !== -1) {\n    try {\n      if (util.SANITIZE_R.test(decodeURIComponent(attrs)))\n        for (var key in result) delete result[key]\n    } catch (e) {\n      // Invalid URI encoding (e.g., \"100%\") - skip the check\n      // Individual attributes were already sanitized above\n    }\n  } else if (util.SANITIZE_R.test(attrs)) {\n    for (var key in result) delete result[key]\n  }\n  return result\n}\n\nexport type ParseResult = (MarkdownToJSX.ASTNode & { endPos: number }) | null\n\n/** Options passed to parsers */\nexport type ParseOptions = Omit<MarkdownToJSX.Options, 'slugify'> & {\n  slugify: (input: string) => string\n}\n\nvar isBlockStartChar = function (c: string): boolean {\n  return BLOCK_START_CHARS_SET.has(c)\n}\n\ninterface BracketEntry {\n  type: 'link' | 'image'\n  pos: number\n  resultIdx: number\n  inAnchor: boolean\n}\n\n// Check if an invalid reference definition should be skipped per CommonMark Examples 208 and 210\nfunction shouldSkipInvalidReferenceDefinition(\n  input: string,\n  refCheckPos: number,\n  isAtDocumentStart: boolean\n): { shouldSkip: boolean; newPos: number } {\n  // Find closing ']' handling escapes\n  let bracketEnd = refCheckPos + 1\n  while (bracketEnd < input.length && input[bracketEnd] !== ']') {\n    if (input[bracketEnd] === '\\\\' && bracketEnd + 1 < input.length) {\n      bracketEnd += 2\n      continue\n    }\n    bracketEnd++\n  }\n  if (bracketEnd >= input.length) return { shouldSkip: false, newPos: 0 }\n\n  // Check if label starts/ends with newline (Example 208 pattern)\n  const labelStart = refCheckPos + 1\n  const labelEnd = bracketEnd\n  const labelStartsWithNewline =\n    labelStart < labelEnd &&\n    (input[labelStart] === '\\n' || input[labelStart] === '\\r')\n  const labelEndsWithNewline =\n    labelEnd > labelStart &&\n    (input[labelEnd - 1] === '\\n' || input[labelEnd - 1] === '\\r')\n\n  let afterBracket = bracketEnd + 1\n  // Skip whitespace after ']'\n  afterBracket = util.skipWhitespace(input, afterBracket)\n\n  // Check for colon\n  if (afterBracket >= input.length || input[afterBracket] !== ':') {\n    return { shouldSkip: false, newPos: 0 }\n  }\n\n  // Found colon - check for Example 208 pattern (label starts/ends with newline at document start)\n  if ((labelStartsWithNewline || labelEndsWithNewline) && isAtDocumentStart) {\n    // Invalid ref definition per Example 208 - skip to next line after URL\n    let skipPos = afterBracket + 1\n    skipPos = util.skipWhitespace(input, skipPos)\n    // Skip optional newline\n    if (skipPos < input.length && input[skipPos] === '\\n') {\n      skipPos = util.skipWhitespace(input, skipPos + 1)\n    }\n    // Find end of URL line (next newline)\n    while (skipPos < input.length && input[skipPos] !== '\\n') {\n      skipPos++\n    }\n    if (skipPos < input.length) {\n      skipPos++\n    }\n    return { shouldSkip: true, newPos: skipPos }\n  }\n\n  // Check for Example 210 pattern (trailing text after title)\n  return checkExample210Pattern(input, afterBracket)\n}\n\n// Helper for Example 210: trailing text after title\nfunction checkExample210Pattern(\n  input: string,\n  colonPos: number\n): { shouldSkip: boolean; newPos: number } {\n  let urlEnd = colonPos + 1\n  urlEnd = util.skipWhitespace(input, urlEnd)\n  // Skip optional newline\n  if (urlEnd < input.length && input[urlEnd] === '\\n') {\n    urlEnd = util.skipWhitespace(input, urlEnd + 1)\n  }\n  // Find end of URL (next newline)\n  while (urlEnd < input.length && input[urlEnd] !== '\\n') {\n    urlEnd++\n  }\n  if (urlEnd >= input.length) return { shouldSkip: false, newPos: 0 }\n\n  urlEnd++\n  // Check for title delimiter on next line\n  let titleLineStart = util.skipWhitespace(input, urlEnd)\n  if (\n    titleLineStart >= input.length ||\n    (input[titleLineStart] !== '\"' && input[titleLineStart] !== \"'\")\n  ) {\n    return { shouldSkip: false, newPos: 0 }\n  }\n\n  // Has title delimiter - check for trailing text (Example 210)\n  const titleChar = input[titleLineStart]\n  let titleEnd = titleLineStart + 1\n  while (\n    titleEnd < input.length &&\n    input[titleEnd] !== titleChar &&\n    input[titleEnd] !== '\\n'\n  ) {\n    if (input[titleEnd] === '\\\\' && titleEnd + 1 < input.length) {\n      titleEnd += 2\n      continue\n    }\n    titleEnd++\n  }\n  if (titleEnd >= input.length || input[titleEnd] !== titleChar) {\n    return { shouldSkip: false, newPos: 0 }\n  }\n\n  // Found closing quote - check for trailing text\n  let afterTitle = util.skipWhitespace(input, titleEnd + 1)\n  if (\n    afterTitle < input.length &&\n    input[afterTitle] !== '\\n' &&\n    input[afterTitle] !== '\\r'\n  ) {\n    // Trailing text found - invalid ref definition per Example 210\n    return { shouldSkip: true, newPos: urlEnd }\n  }\n\n  return { shouldSkip: false, newPos: 0 }\n}\n\n// Check if nodes contain a link (prevents nested links per CommonMark)\nfunction containsLink(nodes: MarkdownToJSX.ASTNode[]): boolean {\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i]\n    if (node.type === RuleType.link) return true\n    if (node.type === RuleType.textFormatted) {\n      var formattedNode = node as MarkdownToJSX.FormattedTextNode\n      if (formattedNode.children && containsLink(formattedNode.children))\n        return true\n    }\n  }\n  return false\n}\n\nfunction extractAllTextFromNodes(nodes: MarkdownToJSX.ASTNode[]): string {\n  var text = ''\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var node = nodes[i]\n    var type = node.type\n    if (type === RuleType.text) {\n      text += (node as MarkdownToJSX.TextNode).text\n    } else if (type === RuleType.image) {\n      var imgNode = node as MarkdownToJSX.ImageNode\n      if (imgNode.alt) text += imgNode.alt\n    } else if (type === RuleType.textFormatted) {\n      var formattedNode = node as MarkdownToJSX.FormattedTextNode\n      if (formattedNode.children) {\n        text += extractAllTextFromNodes(formattedNode.children)\n      }\n    } else if (type === RuleType.link) {\n      var linkNode = node as MarkdownToJSX.LinkNode\n      if (linkNode.children) {\n        text += extractAllTextFromNodes(linkNode.children)\n      }\n    }\n  }\n  return text\n}\n\nconst WHITESPACE_CHARS = new Set([' ', '\\t', '\\r', '\\n', '\\f', '\\v'])\n\n/**\n * Single pass, no recursion, eliminates parseLink/parseImage/parseRefLink/parseRefImage functions\n */\nfunction parseInlineSpan(\n  source: string,\n  start: number,\n  end: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  var result: MarkdownToJSX.ASTNode[] = []\n  var delimiterStack: DelimiterEntry[] = []\n  var bracketStack: BracketEntry[] = []\n\n  var pos = start\n  var textStart = start\n  var skipAutoLink = options.disableAutoLink || state.inAnchor\n  var hasAmpersand = false\n  var inAnchor = !!state.inAnchor\n  var disableParsingRawHTML = !!options.disableParsingRawHTML\n  var isStreaming = options.optimizeForStreaming\n\n  // Track incomplete syntax for streaming mode\n  var incompleteBacktickPos = -1\n  var incompleteHTMLPos = -1\n  var htmlElementIndices: number[] = []\n\n  // Helper: handle HTML tag parsing (angle brace autolinks, comments, tags, type 7 blocks)\n  var handleHTMLTag = function (\n    checkType7Block: boolean,\n    respectDisableAutoLink: boolean\n  ): boolean {\n    // In streaming mode, skip all HTML-related parsing when already inside HTML to avoid infinite recursion\n    if (isStreaming && state.inHTML) {\n      return false\n    }\n\n    if (!inAnchor && (!respectDisableAutoLink || !options.disableAutoLink)) {\n      var angleBraceResult = parseLinkOrImage(source, pos, state, options, '<')\n      if (angleBraceResult) {\n        flushText(pos)\n        result.push(angleBraceResult)\n        pos = angleBraceResult.endPos\n        textStart = pos\n        return true\n      }\n    }\n\n    // Skip HTML parsing if disableParsingRawHTML is enabled\n    if (disableParsingRawHTML) {\n      return false\n    }\n\n    var htmlResult = parseHTML(source, pos, state, options)\n    if (htmlResult) {\n      flushText(pos)\n      var htmlNodeIdx = result.length\n      result.push(htmlResult)\n      // Track HTML elements for streaming mode incomplete tag detection\n      if (htmlElementIndices) {\n        htmlElementIndices.push(htmlNodeIdx)\n      }\n      pos = htmlResult.endPos\n      textStart = pos\n      return true\n    }\n\n    // Track incomplete HTML for streaming mode\n    if (isStreaming && incompleteHTMLPos === -1) {\n      // Check if this looks like the start of an HTML tag\n      if (pos + 1 < end) {\n        var nextChar = charCode(source, pos + 1)\n        if (\n          (nextChar >= $.CHAR_A && nextChar <= $.CHAR_Z) ||\n          (nextChar >= $.CHAR_a && nextChar <= $.CHAR_z) ||\n          nextChar === $.CHAR_SLASH ||\n          nextChar === $.CHAR_EXCLAMATION\n        ) {\n          incompleteHTMLPos = pos\n        }\n      }\n    }\n\n    if (!checkType7Block) return false\n    var tagCheckResult = parseHTMLTag(source, pos)\n    if (!tagCheckResult) return false\n    var tagNameStart = pos + (tagCheckResult.isClosing ? 2 : 1)\n    if (tagNameStart >= source.length || isSpaceOrTab(source[tagNameStart]))\n      return false\n    var closeIdx = source.indexOf('>', pos + 1)\n    if (closeIdx !== -1) {\n      var contentStart = pos + 1\n      var contentLen = closeIdx - contentStart\n      if (contentLen >= 7) {\n        var isHttp = util.startsWith(source, 'http://', contentStart)\n        if (isHttp || util.startsWith(source, 'https://', contentStart)) {\n          for (var j = contentStart; j < closeIdx; j++) {\n            if (isSpaceOrTab(source[j])) return false\n          }\n        }\n      }\n    }\n    var tagFirstCharCode = charCode(source, tagNameStart)\n    if (\n      isAlphaCode(tagFirstCharCode) &&\n      tagNameStart + 1 < source.length &&\n      source[tagNameStart + 1] === ':'\n    )\n      return false\n    if (tagCheckResult.isClosing && tagCheckResult.attrs.trim().length)\n      return false\n\n    if (tagCheckResult.attrs.length) {\n      var inQuotes = false\n      var quoteChar = ''\n      for (var i = 0; i < tagCheckResult.attrs.length; i++) {\n        var ch = tagCheckResult.attrs[i]\n        if (inQuotes && ch === quoteChar) {\n          inQuotes = false\n        } else if (!inQuotes && (ch === '\"' || ch === \"'\")) {\n          inQuotes = true\n          quoteChar = ch\n        } else if (ch === '*' || ch === '#' || ch === '!') {\n          var checkAhead = i + 1\n          while (\n            checkAhead < tagCheckResult.attrs.length &&\n            tagCheckResult.attrs[checkAhead] !== '=' &&\n            tagCheckResult.attrs[checkAhead] !== ' ' &&\n            tagCheckResult.attrs[checkAhead] !== '\\t'\n          )\n            checkAhead++\n          if (\n            checkAhead < tagCheckResult.attrs.length &&\n            tagCheckResult.attrs[checkAhead] === '='\n          )\n            return false\n        }\n      }\n    }\n\n    // Valid tag with newline - type 7 block, preserve as raw HTML\n    // But still parse content into children\n    var rawText = source.slice(pos, tagCheckResult.endPos)\n    var tagName = tagCheckResult.tagName.toLowerCase()\n    var contentToParse = rawText\n    // Extract content if rawText includes opening tag\n    var tagEnd = contentToParse.indexOf('>')\n    if (tagEnd !== -1) {\n      contentToParse = contentToParse.slice(tagEnd + 1)\n      var closingTag = '</' + tagName + '>'\n      var closingIdx = contentToParse.indexOf(closingTag)\n      if (closingIdx !== -1) {\n        contentToParse = contentToParse.slice(0, closingIdx)\n      }\n    }\n    var children: MarkdownToJSX.ASTNode[] = []\n    if (contentToParse.trim() && options) {\n      var parseState: MarkdownToJSX.State = {\n        ...state,\n        inline: false,\n        inHTML: true,\n      }\n      var trimmed = contentToParse.trim()\n      if (\n        DOUBLE_NEWLINE_R.test(trimmed) ||\n        BLOCK_SYNTAX_R.test(trimmed) ||\n        HTML_BLOCK_ELEMENT_START_R.test(trimmed)\n      ) {\n        children = parseBlocksInHTML(trimmed, parseState, options)\n      } else if (trimmed) {\n        parseState.inline = true\n        children = parseInlineSpan(\n          trimmed,\n          0,\n          trimmed.length,\n          parseState,\n          options\n        )\n      }\n    }\n    // Parse attributes from the tag (#781 fix for multi-line attributes)\n    var rawAttrs = tagCheckResult.whitespaceBeforeAttrs + tagCheckResult.attrs\n    var parsedAttrs = parseHTMLAttributes(\n      rawAttrs,\n      tagName,\n      tagCheckResult.tagName,\n      options\n    )\n    var htmlBlockResult = {\n      type: RuleType.htmlBlock,\n      tag: tagCheckResult.tagName as MarkdownToJSX.HTMLTags,\n      attrs: parsedAttrs,\n      children: children,\n      rawText: rawText,\n      text: contentToParse, // @deprecated - cleaned up content without tags, use rawText for full raw HTML\n      verbatim: true,\n      endPos: tagCheckResult.endPos,\n    } as MarkdownToJSX.HTMLNode & { endPos: number }\n    flushText(pos)\n    result.push(htmlBlockResult)\n    pos = htmlBlockResult.endPos\n    textStart = pos\n    return true\n  }\n\n  var flushText = function (endPos: number) {\n    if (endPos > textStart) {\n      var text = source.slice(textStart, endPos)\n      result.push({\n        type: RuleType.text,\n        text: hasAmpersand ? util.decodeEntityReferences(text) : text,\n      } as MarkdownToJSX.TextNode)\n      textStart = endPos\n      hasAmpersand = false\n    }\n  }\n\n  while (pos < end) {\n    var code = charCode(source, pos)\n    var charType = getCharType(code, skipAutoLink)\n\n    if (charType === 0) {\n      if (code === $.CHAR_AMPERSAND) hasAmpersand = true\n      pos++\n      // Fast path for ASCII text - avoid repeated charCode calls and lookups\n      while (pos < end) {\n        code = charCode(source, pos)\n        if (code >= $.CHAR_ASCII_BOUNDARY) break\n        if (code === $.CHAR_AMPERSAND) hasAmpersand = true\n        var lookupCharType = util.inlineCharTypeTable[code]\n        if (lookupCharType !== 0) {\n          // Check for autolink exception\n          if (\n            skipAutoLink &&\n            lookupCharType === 1 &&\n            (code === $.CHAR_f || code === $.CHAR_H || code === $.CHAR_W)\n          ) {\n            pos++\n            continue\n          }\n          break\n        }\n        pos++\n      }\n      continue\n    }\n\n    // CODE SPANS (highest priority, no nesting)\n    if (code === $.CHAR_BACKTICK) {\n      var backtickStart = pos\n      var backtickCount = 0\n      while (pos + backtickCount < end) {\n        if (charCode(source, pos + backtickCount) !== $.CHAR_BACKTICK) break\n        backtickCount++\n      }\n\n      if (backtickCount > 0) {\n        var contentStart = pos + backtickCount\n        var contentEnd = -1\n        var i = contentStart\n        // Scan character by character for closing backticks - faster than indexOf\n        while (i < end) {\n          // Find next backtick\n          while (i < end && charCode(source, i) !== $.CHAR_BACKTICK) i++\n          if (i >= end) break\n\n          // Count consecutive backticks\n          var closingCount = 0\n          while (\n            i + closingCount < end &&\n            charCode(source, i + closingCount) === $.CHAR_BACKTICK\n          ) {\n            closingCount++\n          }\n          if (closingCount > backtickCount) closingCount = backtickCount\n          var j = i + closingCount\n\n          // Check if this is a valid closing sequence\n          if (\n            closingCount === backtickCount &&\n            (i <= contentStart ||\n              charCode(source, i - 1) !== $.CHAR_BACKTICK) &&\n            (j >= end || charCode(source, j) !== $.CHAR_BACKTICK)\n          ) {\n            contentEnd = i\n            i = j\n            break\n          }\n          i++\n        }\n\n        if (contentEnd !== -1) {\n          var rawContent = source.slice(contentStart, contentEnd)\n          var hasNewline = false\n          for (var k = 0; k < rawContent.length; k++) {\n            var nlCode = charCode(rawContent, k)\n            if (nlCode === $.CHAR_NEWLINE || nlCode === $.CHAR_CR) {\n              hasNewline = true\n              break\n            }\n          }\n          var content = rawContent\n          if (hasNewline) {\n            // Optimize newline replacement by avoiding regex\n            content = rawContent\n              .replace(/\\r\\n/g, ' ')\n              .replace(/\\r/g, ' ')\n              .replace(/\\n/g, ' ')\n          }\n          if (content.length > 0) {\n            var firstChar = charCode(content, 0)\n            var lastChar = charCode(content, content.length - 1)\n            if (firstChar === $.CHAR_SPACE && lastChar === $.CHAR_SPACE) {\n              for (var idx = 1; idx < content.length - 1; idx++) {\n                if (charCode(content, idx) !== $.CHAR_SPACE) {\n                  content = content.slice(1, content.length - 1)\n                  break\n                }\n              }\n            }\n          }\n\n          flushText(backtickStart)\n          result.push({\n            type: RuleType.codeInline,\n            text: content,\n          } as MarkdownToJSX.CodeInlineNode)\n          pos = i\n          textStart = pos\n          continue\n        }\n        // Track incomplete backticks for streaming mode\n        if (isStreaming && incompleteBacktickPos === -1) {\n          incompleteBacktickPos = backtickStart\n          // In streaming mode, stop processing at incomplete backtick\n          // Flush any text before the backtick and exit\n          flushText(backtickStart)\n          end = backtickStart\n          break\n        }\n        pos = contentStart\n        continue\n      }\n    }\n\n    // AUTOLINKS: BARE URLS AND EMAIL (check BEFORE escapes to preserve backslashes in URLs)\n    if (\n      !inAnchor &&\n      !skipAutoLink &&\n      (code === $.CHAR_f || code === $.CHAR_H || code === $.CHAR_W)\n    ) {\n      var autolinkType: 'h' | 'w' | 'f' | null = null\n      // Cache character codes to avoid repeated function calls\n      var c1 = pos + 1 < end ? charCode(source, pos + 1) : 0\n      var c2 = pos + 2 < end ? charCode(source, pos + 2) : 0\n      var c3 = pos + 3 < end ? charCode(source, pos + 3) : 0\n      var c4 = pos + 4 < end ? charCode(source, pos + 4) : 0\n      var c5 = pos + 5 < end ? charCode(source, pos + 5) : 0\n\n      if (\n        code === $.CHAR_H &&\n        c1 === $.CHAR_t &&\n        c2 === $.CHAR_t &&\n        c3 === $.CHAR_p\n      ) {\n        autolinkType = 'h'\n      } else if (\n        code === $.CHAR_W &&\n        c1 === $.CHAR_W &&\n        c2 === $.CHAR_W &&\n        c3 === $.CHAR_PERIOD\n      ) {\n        autolinkType = 'w'\n      } else if (\n        code === $.CHAR_f &&\n        c1 === $.CHAR_t &&\n        c2 === $.CHAR_p &&\n        c3 === $.CHAR_COLON &&\n        c4 === $.CHAR_SLASH &&\n        c5 === $.CHAR_SLASH\n      ) {\n        autolinkType = 'f'\n      }\n      if (autolinkType) {\n        var bareUrlResult = parseLinkOrImage(\n          source,\n          pos,\n          state,\n          options,\n          autolinkType\n        )\n        if (bareUrlResult) {\n          flushText(pos)\n          result.push(bareUrlResult)\n          pos = bareUrlResult.endPos\n          textStart = pos\n          continue\n        }\n      }\n    }\n\n    if (!inAnchor && !skipAutoLink && code === $.CHAR_AT) {\n      var emailResult = parseLinkOrImage(source, pos, state, options, '@')\n      if (emailResult && 'emailStart' in emailResult) {\n        var emailStart = (\n          emailResult as MarkdownToJSX.LinkNode & {\n            endPos: number\n            emailStart: number\n          }\n        ).emailStart\n        var emailEnd = emailResult.endPos\n        var removedIndices: number[] = []\n        for (var j = delimiterStack.length - 1; j >= 0; j--) {\n          var delim = delimiterStack[j]\n          if (delim.sourcePos >= emailStart && delim.sourcePos < emailEnd) {\n            if (delim.nodeIndex >= 0 && delim.nodeIndex < result.length) {\n              result.splice(delim.nodeIndex, 1)\n              removedIndices.push(delim.nodeIndex)\n            }\n            delimiterStack.splice(j, 1)\n          }\n        }\n        if (emailStart < textStart) {\n          for (var i = result.length - 1; i >= 0; i--) {\n            if (result[i].type === RuleType.text) {\n              result.splice(i, 1)\n              removedIndices.push(i)\n              break\n            }\n          }\n          textStart = emailStart\n        }\n        // Batch update delimiter indices after all removals (O(n+m) instead of O(n*m))\n        if (removedIndices.length) {\n          removedIndices.sort(function (a, b) {\n            return a - b\n          })\n          var removedIdx = 0\n          for (var m = 0; m < delimiterStack.length; m++) {\n            var delim = delimiterStack[m]\n            while (\n              removedIdx < removedIndices.length &&\n              removedIndices[removedIdx] < delim.nodeIndex\n            )\n              removedIdx++\n            delim.nodeIndex -= removedIdx\n          }\n        }\n        flushText(emailStart)\n        result.push(emailResult)\n        pos = emailEnd\n        textStart = pos\n        continue\n      }\n    }\n\n    // HTML TAGS AND AUTOLINKS (check BEFORE escapes to preserve backslashes in autolinks)\n    if (code === $.CHAR_LT) {\n      if (handleHTMLTag(true, false)) continue\n    }\n\n    // BACKSLASH ESCAPES\n    if (code === $.CHAR_BACKSLASH) {\n      if (pos + 1 < end && charCode(source, pos + 1) === $.CHAR_NEWLINE) {\n        var afterNewline = pos + 2\n        while (\n          afterNewline < end &&\n          charCode(source, afterNewline) === $.CHAR_SPACE\n        )\n          afterNewline++\n        if (afterNewline >= end) {\n          pos++\n          continue\n        }\n        flushText(pos)\n        result.push({ type: RuleType.breakLine } as MarkdownToJSX.BreakLineNode)\n        pos += 2\n        while (pos < end && charCode(source, pos) === $.CHAR_SPACE) pos++\n        textStart = pos\n        continue\n      }\n\n      var nextChar = pos + 1 < end ? source[pos + 1] : ''\n      if (\n        nextChar &&\n        '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'.indexOf(nextChar) !== -1\n      ) {\n        flushText(pos)\n        result.push({\n          type: RuleType.text,\n          text: nextChar === '&' ? '&\\u200B' : nextChar,\n        } as MarkdownToJSX.TextNode)\n        pos += 2\n        textStart = pos\n        continue\n      }\n    }\n\n    // LINKS AND IMAGES - OPENING BRACKET\n    if (code === $.CHAR_BRACKET_OPEN) {\n      if (!inAnchor) {\n        if (pos + 1 < end && source[pos + 1] === '^') {\n          var footnoteEndPos = pos + 2\n          while (footnoteEndPos < end && source[footnoteEndPos] !== ']')\n            footnoteEndPos++\n          if (footnoteEndPos < end) {\n            var identifier = source.slice(pos + 2, footnoteEndPos)\n            flushText(pos)\n            result.push({\n              type: RuleType.footnoteReference,\n              target: `#${options.slugify(identifier)}`,\n              text: identifier,\n            } as MarkdownToJSX.FootnoteReferenceNode)\n            pos = footnoteEndPos + 1\n            textStart = pos\n            continue\n          }\n        }\n\n        if (\n          state.inList &&\n          pos + 2 < end &&\n          charCode(source, pos + 2) === $.CHAR_BRACKET_CLOSE\n        ) {\n          var nextCode = charCode(source, pos + 1)\n          if (\n            nextCode === $.CHAR_SPACE ||\n            nextCode === $.CHAR_x ||\n            nextCode === $.CHAR_X\n          ) {\n            flushText(pos)\n            result.push({\n              type: RuleType.gfmTask,\n              completed: nextCode === $.CHAR_x || nextCode === $.CHAR_X,\n            } as MarkdownToJSX.GFMTaskNode)\n            pos += 3\n            textStart = pos\n            continue\n          }\n        }\n      }\n\n      var isImage = false\n      if (pos > start && source[pos - 1] === '!') {\n        var backslashCount = 0\n        for (\n          var checkPos = pos - 2;\n          checkPos >= start && source[checkPos] === '\\\\';\n          checkPos--\n        )\n          backslashCount++\n        if ((backslashCount & 1) === 0) {\n          isImage = true\n          if (textStart < pos - 1) flushText(pos - 1)\n          if (\n            result.length > 0 &&\n            result[result.length - 1].type === RuleType.text\n          ) {\n            var lastText = result[result.length - 1] as MarkdownToJSX.TextNode\n            if (lastText.text.endsWith('!')) {\n              lastText.text = lastText.text.slice(0, -1)\n              if (!lastText.text) result.pop()\n            }\n          }\n        }\n      }\n      if (!isImage) flushText(pos)\n      textStart = pos + 1\n      if (!inAnchor || isImage) {\n        bracketStack.push({\n          type: isImage ? 'image' : 'link',\n          pos: isImage ? pos - 1 : pos,\n          resultIdx: result.length,\n          inAnchor: inAnchor,\n        })\n      }\n\n      pos++\n      continue\n    }\n\n    // LINKS AND IMAGES - CLOSING BRACKET\n    if (code === $.CHAR_BRACKET_CLOSE && bracketStack.length > 0) {\n      var bracket = bracketStack[bracketStack.length - 1]\n      var linkTextStart = bracket.pos + (bracket.type === 'image' ? 2 : 1)\n      var linkTextEnd = pos\n      flushText(pos)\n      var afterBracket = pos + 1\n      var linkChildren = buildLinkChildren(result, bracket)\n      var hasNestedLink = bracket.type === 'link' && containsLink(linkChildren)\n      var foundRefBrackets = false\n\n      if (\n        !hasNestedLink &&\n        afterBracket < end &&\n        source[afterBracket] === '('\n      ) {\n        var urlResult = parseUrlAndTitle(source, afterBracket + 1, true)\n        if (urlResult) {\n          finalizeLinkOrImageNode(\n            result,\n            delimiterStack,\n            bracketStack,\n            bracket,\n            linkTextStart,\n            linkTextEnd,\n            options.sanitizer(\n              unescapeUrlOrTitle(urlResult.target),\n              'a',\n              'href'\n            ),\n            urlResult.title ? unescapeUrlOrTitle(urlResult.title) : undefined\n          )\n          pos = urlResult.endPos\n          textStart = pos\n          continue\n        }\n      }\n\n      var refs = state.refs || {}\n      util.hasKeys(refs);\n      var refLabel: string | null = null\n      var refEnd = pos\n      if (afterBracket < end && source[afterBracket] === '[') {\n        var refStart = afterBracket + 1\n        var i = refStart\n        while (i < end && source[i] !== ']') i++\n        if (i < end) {\n          refLabel = source.slice(refStart, i)\n          refEnd = i\n          foundRefBrackets = true\n        }\n      }\n      if (!foundRefBrackets || refLabel === '')\n        refLabel = source.slice(linkTextStart, linkTextEnd)\n      var normalizedRef = normalizeReferenceLabel(refLabel)\n      if (!hasNestedLink && refs && refs[normalizedRef]) {\n        var ref = refs[normalizedRef]\n        finalizeLinkOrImageNode(\n          result,\n          delimiterStack,\n          bracketStack,\n          bracket,\n          linkTextStart,\n          linkTextEnd,\n          ref.target,\n          ref.title\n        )\n        pos = refEnd + 1\n        textStart = pos\n        continue\n      }\n\n      var bracketResultIdx = bracket.resultIdx\n      bracketStack.pop()\n      result.length = bracketResultIdx\n\n      if (isStreaming) {\n        // Streaming mode: keep link children without brackets\n        result.push(...linkChildren)\n        // If there was a ( after ], this is an incomplete link - truncate here\n        if (afterBracket < end && source[afterBracket] === '(') {\n          // Don't process anything after the incomplete link syntax\n          return result\n        }\n      } else {\n        // Normal mode: insert brackets and content as text\n        if (bracket.type === 'image')\n          result.push({\n            type: RuleType.text,\n            text: '!',\n          } as MarkdownToJSX.TextNode)\n        result.push(\n          { type: RuleType.text, text: '[' } as MarkdownToJSX.TextNode,\n          ...linkChildren,\n          { type: RuleType.text, text: ']' } as MarkdownToJSX.TextNode\n        )\n      }\n\n      for (var k = 0; k < delimiterStack.length; k++) {\n        if (delimiterStack[k].nodeIndex >= bracketResultIdx)\n          delimiterStack[k].nodeIndex++\n      }\n      pos++\n      textStart = pos\n      continue\n    }\n\n    // ========================================\n    // EMPHASIS AND STRIKETHROUGH DELIMITERS (*, _, ~~, ==)\n    // ========================================\n    if (\n      code === $.CHAR_ASTERISK ||\n      code === $.CHAR_UNDERSCORE ||\n      code === $.CHAR_TILDE ||\n      code === $.CHAR_EQ\n    ) {\n      var delimChar = source[pos]\n      var delimStart = pos\n      var delimCount = countConsecutiveChars(source, pos, delimChar)\n\n      // GFM strikethrough (~~) and marked text (==) require exactly 2 delimiters\n      if ((delimChar === '~' || delimChar === '=') && delimCount !== 2) {\n        pos++\n        continue\n      }\n\n      var delimiterEnd = delimStart + delimCount\n      var leftFlanking = checkFlanking(source, delimStart, delimiterEnd, end, 0)\n      var rightFlanking = checkFlanking(\n        source,\n        delimStart,\n        delimiterEnd,\n        start,\n        1\n      )\n      var canOpen = leftFlanking\n      var canClose = rightFlanking\n      if (delimChar === '_' && leftFlanking && rightFlanking) {\n        if (delimStart > 0) {\n          var precedingChar = source[delimStart - 1]\n          var precedingCode = charCode(precedingChar)\n          canOpen = isPunctuation(precedingCode, precedingChar)\n        }\n        if (delimiterEnd < end) {\n          var followingChar = source[delimiterEnd]\n          var followingCode = charCode(followingChar)\n          canClose = isPunctuation(followingCode, followingChar)\n        }\n      }\n      flushText(delimStart)\n      delimiterStack.push({\n        nodeIndex: result.length,\n        type: delimChar as '*' | '_' | '~' | '=',\n        length: delimCount,\n        canOpen: canOpen,\n        canClose: canClose,\n        active: true,\n        sourcePos: delimStart,\n        inAnchor: inAnchor,\n      })\n      result.push({\n        type: RuleType.text,\n        text: source.slice(delimStart, delimStart + delimCount),\n      } as MarkdownToJSX.TextNode)\n\n      pos = delimStart + delimCount\n      textStart = pos\n      continue\n    }\n\n    // ========================================\n    // LINE BREAKS\n    // ========================================\n    if (code === $.CHAR_NEWLINE) {\n      var checkPos = pos - 1\n      var spaceCount = 0\n      while (\n        checkPos >= textStart &&\n        charCode(source, checkPos) === $.CHAR_SPACE\n      ) {\n        spaceCount++\n        checkPos--\n      }\n      if (spaceCount >= 2) {\n        var afterNewline = pos + 1\n        while (\n          afterNewline < end &&\n          charCode(source, afterNewline) === $.CHAR_SPACE\n        )\n          afterNewline++\n        if (afterNewline >= end) {\n          flushText(checkPos + 1)\n          pos = end\n          textStart = end\n          continue\n        }\n        flushText(checkPos + 1)\n        result.push({ type: RuleType.breakLine } as MarkdownToJSX.BreakLineNode)\n        pos++\n        while (pos < end && charCode(source, pos) === $.CHAR_SPACE) pos++\n        textStart = pos\n        continue\n      }\n\n      var prevCode = pos > textStart ? charCode(source, pos - 1) : 0\n      var nextCode = pos + 1 < end ? charCode(source, pos + 1) : 0\n      var flushPos =\n        pos > textStart &&\n        prevCode === $.CHAR_SPACE &&\n        nextCode === $.CHAR_SPACE\n          ? pos - 1\n          : pos\n      flushText(flushPos)\n      result.push({ type: RuleType.text, text: '\\n' } as MarkdownToJSX.TextNode)\n      textStart = pos + 1\n      if (\n        pos > start &&\n        prevCode === $.CHAR_SPACE &&\n        textStart < end &&\n        charCode(source, textStart) === $.CHAR_SPACE\n      )\n        textStart++\n      pos = textStart\n      continue\n    }\n\n    if (code === $.CHAR_AMPERSAND) hasAmpersand = true\n    pos++\n    while (pos < end) {\n      var code = charCode(source, pos)\n      if (code >= $.CHAR_ASCII_BOUNDARY) break\n      if (code === $.CHAR_AMPERSAND) hasAmpersand = true\n      var lookupCharType = util.inlineCharTypeTable[code]\n      if (lookupCharType === 0) {\n        pos++\n        continue\n      }\n      if (\n        lookupCharType === 1 &&\n        (code === $.CHAR_f || code === $.CHAR_H || code === $.CHAR_W) &&\n        skipAutoLink\n      ) {\n        pos++\n        continue\n      }\n      break\n    }\n  }\n\n  flushText(pos)\n\n  // Process emphasis using delimiter stack algorithm\n  if (delimiterStack.length) {\n    processEmphasis(result, delimiterStack, null)\n  }\n\n  // Streaming optimization: remove unclosed syntax markers while keeping content\n  if (isStreaming) {\n    var cutoffIdx = result.length\n\n    // Check for unclosed non-void HTML elements and remove them (reverse order)\n    for (var hi = htmlElementIndices.length - 1; hi >= 0; hi--) {\n      var htmlIdx = htmlElementIndices[hi]\n      if (\n        htmlIdx < result.length &&\n        result[htmlIdx].type === RuleType.htmlBlock\n      ) {\n        var htmlNode = result[htmlIdx] as MarkdownToJSX.HTMLNode\n        // Check if this is a non-void element with no children (likely unclosed)\n        if (\n          !util.isVoidElement(htmlNode.tag) &&\n          (!htmlNode.children || htmlNode.children.length === 0)\n        ) {\n          // Remove just the HTML element, keeping content after\n          result.splice(htmlIdx, 1)\n          // Adjust other tracking indices\n          if (htmlIdx < cutoffIdx) cutoffIdx--\n          for (var k = 0; k < delimiterStack.length; k++) {\n            if (delimiterStack[k].nodeIndex > htmlIdx) {\n              delimiterStack[k].nodeIndex--\n            }\n          }\n          for (var k = hi + 1; k < htmlElementIndices.length; k++) {\n            if (htmlElementIndices[k] > htmlIdx) {\n              htmlElementIndices[k]--\n            }\n          }\n        }\n      }\n    }\n\n    // Find earliest incomplete syntax position\n    if (incompleteBacktickPos !== -1 && incompleteBacktickPos < cutoffIdx) {\n      // Find the result node index at this source position\n      for (var ri = result.length - 1; ri >= 0; ri--) {\n        if (result[ri].type === RuleType.text) {\n          // Approximate - if this text node might contain the backticks, truncate here\n          cutoffIdx = ri\n          break\n        }\n      }\n    }\n\n    if (incompleteHTMLPos !== -1 && incompleteHTMLPos < cutoffIdx) {\n      // Find the result node index at this source position\n      for (var ri = result.length - 1; ri >= 0; ri--) {\n        if (result[ri].type === RuleType.text) {\n          // Approximate - if this text node might contain the HTML start, truncate here\n          cutoffIdx = ri\n          break\n        }\n      }\n    }\n\n    // Remove unmatched delimiter text nodes (reverse order to preserve indices)\n    for (var i = delimiterStack.length - 1; i >= 0; i--) {\n      if (delimiterStack[i].active && delimiterStack[i].nodeIndex < cutoffIdx) {\n        result.splice(delimiterStack[i].nodeIndex, 1)\n        // Adjust cutoff and other indices\n        if (delimiterStack[i].nodeIndex < cutoffIdx) cutoffIdx--\n        // Adjust indices for remaining delimiters\n        for (var j = 0; j < i; j++) {\n          if (delimiterStack[j].nodeIndex > delimiterStack[i].nodeIndex) {\n            delimiterStack[j].nodeIndex--\n          }\n        }\n      }\n    }\n\n    // Truncate at incomplete syntax if found\n    if (cutoffIdx < result.length) {\n      result.length = cutoffIdx\n    }\n\n    // Skip bracket insertion entirely - content is already in result\n    return result\n  }\n\n  // Insert bracket text nodes in forward order (more efficient than reverse splices)\n  if (bracketStack.length) {\n    bracketStack.sort(function (a, b) {\n      return a.resultIdx - b.resultIdx\n    })\n    for (var i = 0; i < bracketStack.length; i++) {\n      result.splice(bracketStack[i].resultIdx + i, 0, {\n        type: RuleType.text,\n        text: bracketStack[i].type === 'image' ? '![' : '[',\n      } as MarkdownToJSX.TextNode)\n    }\n  }\n\n  return result\n}\n\n// Helper: Process emphasis within link/image text and update delimiter stack\nfunction processEmphasisInLinkText(\n  result: MarkdownToJSX.ASTNode[],\n  delimiterStack: DelimiterEntry[],\n  bracket: BracketEntry,\n  linkTextStart: number,\n  linkTextEnd: number\n): void {\n  var hasDelims = false\n  for (var di = 0; di < delimiterStack.length; di++) {\n    if (\n      delimiterStack[di].sourcePos >= linkTextStart &&\n      delimiterStack[di].sourcePos < linkTextEnd\n    ) {\n      hasDelims = true\n      break\n    }\n  }\n  if (!hasDelims) return\n\n  var tempNodes = buildLinkChildren(result, bracket)\n  var tempDelims: DelimiterEntry[] = []\n  for (var di = 0; di < delimiterStack.length; di++) {\n    var delim = delimiterStack[di]\n    if (delim.sourcePos >= linkTextStart && delim.sourcePos < linkTextEnd) {\n      tempDelims.push({\n        nodeIndex: delim.nodeIndex - bracket.resultIdx,\n        type: delim.type,\n        length: delim.length,\n        canOpen: delim.canOpen,\n        canClose: delim.canClose,\n        active: delim.active,\n        sourcePos: delim.sourcePos,\n        inAnchor: delim.inAnchor,\n      })\n    }\n  }\n  processEmphasis(tempNodes, tempDelims, null)\n  result.length = bracket.resultIdx\n  for (var i = 0; i < tempNodes.length; i++) result.push(tempNodes[i])\n  var newDelimStack: DelimiterEntry[] = []\n  for (var di = 0; di < delimiterStack.length; di++) {\n    if (\n      delimiterStack[di].sourcePos < linkTextStart ||\n      delimiterStack[di].sourcePos >= linkTextEnd\n    ) {\n      newDelimStack.push(delimiterStack[di])\n    }\n  }\n  delimiterStack.length = 0\n  for (var i = 0; i < newDelimStack.length; i++)\n    delimiterStack.push(newDelimStack[i])\n}\n\n// Helper: Create link or image node from children and target/title\nfunction createLinkOrImageNode(\n  bracket: BracketEntry,\n  linkChildren: MarkdownToJSX.ASTNode[],\n  target: string | null,\n  title: string | undefined\n): MarkdownToJSX.ASTNode {\n  if (bracket.type === 'link') {\n    return {\n      type: RuleType.link,\n      target: target,\n      title: title,\n      children: linkChildren,\n    } as MarkdownToJSX.LinkNode\n  }\n  return {\n    type: RuleType.image,\n    target: target || '',\n    alt: extractAllTextFromNodes(linkChildren),\n    title: title,\n  } as MarkdownToJSX.ImageNode\n}\n\nfunction buildLinkChildren(\n  result: MarkdownToJSX.ASTNode[],\n  bracket: BracketEntry\n): MarkdownToJSX.ASTNode[] {\n  return result.slice(bracket.resultIdx)\n}\n\nfunction finalizeLinkOrImageNode(\n  result: MarkdownToJSX.ASTNode[],\n  delimiterStack: DelimiterEntry[],\n  bracketStack: BracketEntry[],\n  bracket: BracketEntry,\n  linkTextStart: number,\n  linkTextEnd: number,\n  target: string | null,\n  title: string | undefined\n): void {\n  processEmphasisInLinkText(\n    result,\n    delimiterStack,\n    bracket,\n    linkTextStart,\n    linkTextEnd\n  )\n  var linkChildren = buildLinkChildren(result, bracket)\n  bracketStack.pop()\n  result.length = bracket.resultIdx\n  result.push(createLinkOrImageNode(bracket, linkChildren, target, title))\n}\n\n/** Parse URL and optional title from parentheses: (url \"title\") */\n// Parse link destination (URL) - handles angle brackets and regular URLs\nfunction parseLinkDestination(\n  source: string,\n  start: number,\n  allowNestedParens: boolean\n): { target: string; endPos: number; hadSpace: boolean } | null {\n  let i = util.skipWhitespace(source, start)\n  const hasAngleBrackets = i < source.length && source[i] === '<'\n  if (hasAngleBrackets) i++\n  const actualUrlStart = i\n\n  // Handle empty angle brackets <>\n  if (hasAngleBrackets && i < source.length && source[i] === '>') {\n    return { target: '', endPos: i + 1, hadSpace: false }\n  }\n\n  let target: string\n  let urlEnd: number\n  var foundSpace = false\n\n  if (hasAngleBrackets) {\n    // For angle bracket URLs, parse until '>', allowing spaces and handling escapes\n    urlEnd = i\n    while (urlEnd < source.length && source[urlEnd] !== '>') {\n      const c = source[urlEnd]\n      if (c === '\\n' || c === '\\r' || c === '<') return null\n      if (c === '\\\\') {\n        urlEnd += 2\n        continue\n      }\n      urlEnd++\n    }\n    if (urlEnd >= source.length || source[urlEnd] !== '>') return null\n    urlEnd++\n    // Trim leading and trailing whitespace inside < >\n    let actualStart = actualUrlStart\n    while (actualStart < urlEnd - 1 && isSpaceOrTab(source[actualStart]))\n      actualStart++\n    let actualEnd = urlEnd - 1\n    while (actualEnd > actualStart && isSpaceOrTab(source[actualEnd - 1]))\n      actualEnd--\n    target = source.slice(actualStart, actualEnd)\n    i = urlEnd\n  } else {\n    // Non-angle bracket URL: break on whitespace, newline\n    let parenDepth = 0\n    urlEnd = i\n    while (urlEnd < source.length) {\n      const c = source[urlEnd]\n      if (c === ' ' || c === '\\t' || c === '\\n') {\n        foundSpace = true\n        break\n      }\n      if (!allowNestedParens && c === ')') break\n      if (allowNestedParens && c === '(') {\n        if (urlEnd > 0 && source[urlEnd - 1] === '\\\\') {\n          urlEnd++\n          continue\n        }\n        parenDepth++\n        urlEnd++\n        continue\n      }\n      if (allowNestedParens && c === ')') {\n        if (urlEnd > 0 && source[urlEnd - 1] === '\\\\') {\n          urlEnd++\n          continue\n        }\n        if (parenDepth === 0) break\n        parenDepth--\n        urlEnd++\n        continue\n      }\n      urlEnd++\n    }\n    target = source.slice(actualUrlStart, urlEnd)\n    i = urlEnd\n  }\n\n  return { target, endPos: i, hadSpace: foundSpace }\n}\n\n// Parse link title - handles quoted and parenthesized titles\nfunction parseLinkTitle(\n  source: string,\n  start: number,\n  hadSpaceInUrl: boolean,\n  hasAngleBrackets: boolean\n): { title: string | undefined; endPos: number } {\n  let i = start\n  // Skip whitespace after URL\n  let newlineCount = 0\n  while (i < source.length) {\n    const c = source[i]\n    if (isSpaceOrTab(c)) {\n      i++\n    } else if (c === '\\n') {\n      if (newlineCount >= 1) break\n      newlineCount++\n      i++\n    } else if (util.isUnicodeWhitespace(c)) {\n      break\n    } else {\n      break\n    }\n  }\n\n  // If URL contained spaces and there's no title delimiter, the link is invalid\n  if (hadSpaceInUrl && !hasAngleBrackets) {\n    if (\n      i >= source.length ||\n      (source[i] !== '\"' && source[i] !== \"'\" && source[i] !== '(')\n    ) {\n      return { title: undefined, endPos: i }\n    }\n  }\n  let title: string | undefined = undefined\n  if (i < source.length) {\n    const titleChar = source[i]\n    if (titleChar === '\"' || titleChar === \"'\") {\n      i++\n      const titleStart = i\n      while (i < source.length && source[i] !== titleChar) {\n        if (source[i] === '\\\\') i++\n        i++\n      }\n      if (i < source.length) {\n        title = source.slice(titleStart, i)\n        i++\n      }\n    } else if (titleChar === '(') {\n      i++\n      const titleStart = i\n      let parenDepth = 1\n      while (i < source.length && parenDepth > 0) {\n        if (source[i] === '\\\\' && i + 1 < source.length) i++\n        else if (source[i] === '(') parenDepth++\n        else if (source[i] === ')') parenDepth--\n        i++\n      }\n      if (parenDepth === 0) {\n        title = source.slice(titleStart, i - 1)\n      }\n    }\n  }\n\n  i = util.skipWhitespace(source, i)\n  return { title, endPos: i }\n}\n\nfunction parseUrlAndTitle(\n  source: string,\n  urlStart: number,\n  allowNestedParens: boolean\n): { target: string; title: string | undefined; endPos: number } | null {\n  const destResult = parseLinkDestination(source, urlStart, allowNestedParens)\n  if (!destResult) return null\n\n  let i = urlStart\n  i = util.skipWhitespace(source, i)\n  const hasAngleBrackets = i < source.length && source[i] === '<'\n\n  // Handle empty angle brackets <>\n  if (\n    hasAngleBrackets &&\n    destResult.target === '' &&\n    destResult.endPos === i + 2\n  ) {\n    const titleResult = parseLinkTitle(\n      source,\n      destResult.endPos,\n      false,\n      hasAngleBrackets\n    )\n    if (\n      titleResult.endPos >= source.length ||\n      source[titleResult.endPos] !== ')'\n    )\n      return null\n    return {\n      target: '',\n      title: titleResult.title,\n      endPos: titleResult.endPos + 1,\n    }\n  }\n\n  const titleResult = parseLinkTitle(\n    source,\n    destResult.endPos,\n    destResult.hadSpace,\n    hasAngleBrackets\n  )\n  if (titleResult.endPos >= source.length || source[titleResult.endPos] !== ')')\n    return null\n\n  return {\n    target: destResult.target,\n    title: titleResult.title,\n    endPos: titleResult.endPos + 1,\n  }\n}\n\nenum AutolinkMode {\n  URI,\n  EMAIL,\n  ANGLE,\n}\n\nfunction isAlphaCode(code: number): boolean {\n  return (\n    (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n    (code >= $.CHAR_a && code <= $.CHAR_z)\n  )\n}\n\nfunction isValidUriScheme(content: string): boolean {\n  const colonPos = content.indexOf(':')\n  if (colonPos < 2 || colonPos > 32) return false\n\n  const firstCharCode = charCode(content)\n  if (!isAlphaCode(firstCharCode)) {\n    return false\n  }\n\n  // Check if all chars before colon are valid scheme chars\n  for (let j = 1; j < colonPos; j++) {\n    const c = content[j]\n    const cCode = charCode(c)\n    if (!isAlnum(c) && c !== '+' && c !== '.' && c !== '-') {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isValidAutolinkContext(\n  source: string,\n  start: number,\n  includeCR: boolean\n): boolean {\n  if (start === 0) return true\n  let validChars = includeCR ? ' \\t\\n\\r*_~(' : ' \\t\\n*_~('\n  return validChars.indexOf(source[start - 1]) !== -1\n}\n\nfunction sanitizeAndCreate(\n  target: string,\n  linkText: string,\n  endPos: number,\n  sanitizer: (url: string, tag: string, attr: string) => string | null,\n  emailStart?: number\n): ParseResult | null {\n  let safe = sanitizer(target, 'a', 'href')\n  if (!safe) return null\n  return {\n    type: RuleType.link,\n    target: safe,\n    children: [{ type: RuleType.text, text: linkText }],\n    endPos: endPos,\n    ...(emailStart !== undefined ? { emailStart } : {}),\n  } as MarkdownToJSX.LinkNode & { endPos: number; emailStart?: number }\n}\n\nfunction parseAutolink(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  mode: AutolinkMode\n): ParseResult | null {\n  if (\n    state.inAnchor ||\n    (mode !== AutolinkMode.ANGLE && options.disableAutoLink)\n  )\n    return null\n\n  if (mode === AutolinkMode.ANGLE) {\n    if (source[pos] !== '<') return null\n    let end = pos + 1\n    while (end < source.length && source[end] !== '>') {\n      const endCode = charCode(source, end)\n      if (\n        endCode === $.CHAR_SPACE ||\n        endCode === $.CHAR_TAB ||\n        endCode === $.CHAR_NEWLINE ||\n        endCode === $.CHAR_CR ||\n        endCode < $.CHAR_SPACE\n      )\n        return null\n      end++\n    }\n    if (end >= source.length || source[end] !== '>') return null\n    let content = source.slice(pos + 1, end)\n    if (!content.length) return null\n\n    let hasBackslash = content.indexOf('\\\\') !== -1\n    let hasValidUriScheme = isValidUriScheme(content)\n    let isHttp =\n      util.startsWith(content, 'http://') ||\n      util.startsWith(content, 'https://')\n    let isMailto = false\n    if (!hasValidUriScheme && !isHttp && content.length >= 7) {\n      const firstChar = content[0]\n      if (firstChar === 'm' || firstChar === 'M') {\n        const contentLower = content.toLowerCase()\n        if (util.startsWith(contentLower, 'mailto:')) {\n          isMailto = true\n          let colonPos = contentLower.indexOf(':')\n          let mailtoText = content.slice(colonPos + 1)\n          return sanitizeAndCreate(\n            'mailto:' + mailtoText,\n            content,\n            end + 1,\n            options.sanitizer\n          )\n        }\n      }\n    }\n    let isEmailLike =\n      !hasBackslash &&\n      content.indexOf('@') !== -1 &&\n      content.indexOf('//') === -1 &&\n      !hasValidUriScheme\n\n    if (!isHttp && !isMailto && !isEmailLike && !hasValidUriScheme) return null\n\n    let target = content,\n      linkText = content\n    if (!isMailto && !hasValidUriScheme && !isHttp && isEmailLike) {\n      target = 'mailto:' + content\n    }\n\n    return sanitizeAndCreate(target, linkText, end + 1, options.sanitizer)\n  }\n\n  if (mode === AutolinkMode.EMAIL) {\n    let emailStart = pos\n    while (\n      emailStart > 0 &&\n      (isAlnum(source[emailStart - 1]) ||\n        '.+-_'.indexOf(source[emailStart - 1]) !== -1)\n    )\n      emailStart--\n    if (emailStart >= pos || !isValidAutolinkContext(source, emailStart, true))\n      return null\n\n    let emailEnd = pos + 1\n    let hasDot = false\n    while (emailEnd < source.length) {\n      let c = source[emailEnd]\n      if (c === '.') {\n        hasDot = true\n        emailEnd++\n      } else if (isAlnum(c) || c === '-' || c === '_') emailEnd++\n      else break\n    }\n\n    if (!hasDot || emailEnd <= pos + 1) return null\n    while (emailEnd > pos + 1 && source[emailEnd - 1] === '.') emailEnd--\n    if (\n      emailEnd > pos + 1 &&\n      (source[emailEnd - 1] === '-' || source[emailEnd - 1] === '_')\n    )\n      return null\n    // Check if email contains at least one dot\n    // For large documents, prefer slice+includes to avoid scanning entire document\n    const emailLength = emailEnd - (pos + 1)\n    if (emailLength < 10000) {\n      if (\n        source.indexOf('.', pos + 1) >= emailEnd ||\n        source.indexOf('.', pos + 1) === -1\n      )\n        return null\n    } else {\n      if (source.slice(pos + 1, emailEnd).indexOf('.') === -1) return null\n    }\n\n    let email = source.slice(emailStart, emailEnd)\n    return sanitizeAndCreate(\n      'mailto:' + email,\n      email,\n      emailEnd,\n      options.sanitizer,\n      emailStart\n    )\n  }\n\n  let isHttp =\n    util.startsWith(source, 'http://', pos) ||\n    util.startsWith(source, 'https://', pos)\n  let isFtp = !isHttp && util.startsWith(source, 'ftp://', pos)\n  let isWww = !isHttp && !isFtp && util.startsWith(source, 'www.', pos)\n  if (\n    !(isHttp || isFtp || isWww) ||\n    !isValidAutolinkContext(source, pos, false)\n  )\n    return null\n\n  var urlEnd =\n    pos +\n    (isHttp ? (charCode(source, pos + 4) === $.CHAR_s ? 8 : 7) : isFtp ? 6 : 4)\n  var domainStart = urlEnd\n  // Inline scanDomain\n  while (urlEnd < source.length) {\n    const code = charCode(source, urlEnd)\n    if (\n      code === $.CHAR_SPACE ||\n      code === $.CHAR_TAB ||\n      code === $.CHAR_NEWLINE ||\n      code === $.CHAR_LT ||\n      code === $.CHAR_GT\n    )\n      break\n    urlEnd++\n  }\n  if (urlEnd <= domainStart) return null\n  // Inline trimTrailingPunct\n  let trimmed = urlEnd\n  while (trimmed > domainStart) {\n    let lastChar = source[trimmed - 1]\n    if (trimmed > domainStart + 1 && source[trimmed - 2] === '\\\\') break\n    if (\n      lastChar === '?' ||\n      lastChar === '!' ||\n      lastChar === '.' ||\n      lastChar === ',' ||\n      lastChar === ':' ||\n      lastChar === '*' ||\n      lastChar === '_' ||\n      lastChar === '~'\n    ) {\n      trimmed--\n    } else if (lastChar === ';') {\n      let ampPos = trimmed - 2\n      while (\n        ampPos >= domainStart &&\n        source[ampPos] !== '&' &&\n        source[ampPos] !== ' '\n      )\n        ampPos--\n      if (ampPos >= domainStart && source[ampPos] === '&') {\n        let entityName = source.slice(ampPos + 1, trimmed - 1)\n        if (\n          entityName.length >= 2 &&\n          entityName.length <= 10 &&\n          /^[a-zA-Z0-9]+$/.test(entityName) &&\n          (entityName === 'lt' ||\n            entityName === 'gt' ||\n            (entityName.length >= 3 &&\n              (util.startsWith(entityName, 'amp') ||\n                util.startsWith(entityName, 'apos') ||\n                util.startsWith(entityName, 'quot') ||\n                util.startsWith(entityName, 'nbsp') ||\n                /^[a-z]{3,10}$/.test(entityName))))\n        )\n          break\n        trimmed = ampPos\n        break\n      }\n      trimmed--\n    } else if (lastChar === ')') {\n      let openCount = 0,\n        closeCount = 0\n      for (let i = domainStart; i < trimmed; i++) {\n        if (source[i] === '(') openCount++\n        if (source[i] === ')') closeCount++\n      }\n      if (closeCount > openCount) trimmed--\n      else break\n    } else break\n  }\n  urlEnd = trimmed\n  if (urlEnd <= domainStart) return null\n\n  var domainEnd = domainStart\n  var lastDot = -1\n  var secondLastDot = -1\n  while (domainEnd < urlEnd) {\n    const domainCode = charCode(source, domainEnd)\n    if (\n      (domainCode >= $.CHAR_A && domainCode <= $.CHAR_Z) ||\n      (domainCode >= $.CHAR_a && domainCode <= $.CHAR_z) ||\n      (domainCode >= $.CHAR_DIGIT_0 && domainCode <= $.CHAR_DIGIT_9) ||\n      domainCode === $.CHAR_DASH ||\n      domainCode === $.CHAR_UNDERSCORE ||\n      domainCode === $.CHAR_PERIOD\n    ) {\n      if (domainCode === $.CHAR_PERIOD) {\n        secondLastDot = lastDot\n        lastDot = domainEnd\n      }\n      domainEnd++\n      continue\n    }\n    break\n  }\n  if (domainEnd === domainStart || lastDot === -1) return null\n  if (secondLastDot === -1) secondLastDot = domainStart - 1\n  for (let i = secondLastDot + 1; i < lastDot; i++) {\n    if (source[i] === '_') return null\n  }\n  for (let i = lastDot + 1; i < domainEnd; i++) {\n    if (source[i] === '_') return null\n  }\n\n  let linkText = source.slice(pos, urlEnd)\n  return sanitizeAndCreate(\n    isWww ? 'http://' + linkText : linkText,\n    linkText,\n    urlEnd,\n    options.sanitizer\n  )\n}\n\n// Unified link/image parser - handles all link/image types based on starting character\nfunction parseLinkOrImage(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  startChar: '[' | '!' | '<' | 'h' | 'f' | 'w' | '@'\n): ParseResult | null {\n  // Angle brace autolink: <url>\n  if (startChar === '<') {\n    return parseAutolink(\n      source,\n      pos,\n      state,\n      options,\n      AutolinkMode.ANGLE\n    ) as ParseResult\n  }\n\n  // Bare URL autolink: http://, https://, ftp://, www.\n  if (startChar === 'h' || startChar === 'f' || startChar === 'w') {\n    return parseAutolink(\n      source,\n      pos,\n      state,\n      options,\n      AutolinkMode.URI\n    ) as ParseResult\n  }\n\n  // Email autolink: @example.com\n  if (startChar === '@') {\n    return parseAutolink(\n      source,\n      pos,\n      state,\n      options,\n      AutolinkMode.EMAIL\n    ) as ParseResult | null\n  }\n\n  // Bracket-based links/images are handled inline in parseInlineSpan\n  // This function only handles autolinks\n  return null\n}\n\nfunction normalizeReferenceLabel(label: string): string {\n  var trimmed = label.trim()\n  var normalized = trimmed.replace(/[\\s\\t\\n\\r]+/g, ' ')\n  if (normalized.indexOf('\\u1E9E') !== -1) {\n    return normalized.replace(/\\u1E9E/g, 'ss').toLowerCase();\n  }\n  return normalized.toLowerCase()\n}\n\nfunction parseGFMTask(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State\n): ParseResult {\n  if (pos + 3 >= source.length || source[pos] !== '[') return null\n  const marker = source[pos + 1]\n  if (marker !== ' ' && marker !== 'x' && marker !== 'X') return null\n  if (source[pos + 2] !== ']') return null\n  return {\n    type: RuleType.gfmTask,\n    completed: marker.toLowerCase() === 'x',\n    endPos: pos + 3,\n  } as MarkdownToJSX.GFMTaskNode & { endPos: number }\n}\n\nfunction parseBlocksWithState(\n  content: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  config: { inline?: boolean; list?: boolean; inBlockQuote?: boolean }\n): MarkdownToJSX.ASTNode[] {\n  const originalInline = state.inline\n  const originalList = state.inList\n  const originalInBlockQuote = state.inBlockQuote\n  if (config.inline !== undefined) state.inline = config.inline\n  if (config.list !== undefined) state.inList = config.list\n  if (config.inBlockQuote !== undefined)\n    state.inBlockQuote = config.inBlockQuote\n  const blocks = parseBlocksInHTML(content, state, options)\n  state.inline = originalInline\n  state.inList = originalList\n  state.inBlockQuote = originalInBlockQuote\n  return blocks\n}\n\nfunction parseInlineWithState(\n  content: string,\n  start: number,\n  end: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  return parseWithInlineMode(state, true, () =>\n    parseInlineSpan(content, start, end, state, options)\n  )\n}\n\ntype BlockParserFn = (\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n) => ParseResult | null\n\nfunction parseBlock(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult | null {\n  var char = source[pos]\n  if (char === undefined) return null\n  var effectivePos = pos\n  var indentInfo: ReturnType<typeof calculateIndent> | null = null\n  var firstChar = char\n  var lineEnd: number | null = null\n\n  var charCodeVal = charCode(char)\n  var isIndentChar = charCodeVal === $.CHAR_SPACE || charCodeVal === $.CHAR_TAB\n  if (isIndentChar) {\n    lineEnd = util.findLineEnd(source, pos)\n    indentInfo = calculateIndent(source, pos, lineEnd)\n    effectivePos = pos + indentInfo.charCount\n    if (effectivePos >= source.length) return parseCodeBlock(source, pos, state)\n    firstChar = source[effectivePos]\n  }\n  var spaceEquivalent = indentInfo ? indentInfo.spaceEquivalent : 0\n  if (spaceEquivalent >= 4) {\n    if (isIndentChar) return parseCodeBlock(source, pos, state)\n    return null\n  }\n  var firstCharCode = charCode(firstChar)\n  if (firstCharCode === $.CHAR_GT) {\n    var blockQuoteResult = parseBlockQuote(source, pos, state, options)\n    if (blockQuoteResult) return blockQuoteResult\n  } else if (firstCharCode === $.CHAR_UNDERSCORE) {\n    return parseBreakThematic(source, pos, state, options)\n  } else if (\n    firstCharCode === $.CHAR_DASH ||\n    firstCharCode === $.CHAR_ASTERISK ||\n    firstCharCode === $.CHAR_PLUS\n  ) {\n    var thematicBreakResult = parseBreakThematic(source, pos, state, options)\n    if (thematicBreakResult) return thematicBreakResult\n    var listResult = parseList(source, pos, state, options)\n    if (listResult) return listResult\n  } else if (\n    firstCharCode >= $.CHAR_DIGIT_0 &&\n    firstCharCode <= $.CHAR_DIGIT_9\n  ) {\n    var listResult = parseList(source, pos, state, options)\n    if (listResult) return listResult\n  } else if (firstCharCode === $.CHAR_HASH) {\n    return parseHeading(source, effectivePos, state, options)\n  } else if (firstCharCode === $.CHAR_BRACKET_OPEN) {\n    return parseDefinition(\n      source,\n      effectivePos,\n      state,\n      options,\n      effectivePos + 1 < source.length &&\n        charCode(source, effectivePos + 1) === $.CHAR_CARET\n    )\n  } else if (firstCharCode === $.CHAR_LT && !options.disableParsingRawHTML) {\n    return parseHTML(source, effectivePos, state, options)\n  } else if (\n    firstCharCode === $.CHAR_BACKTICK ||\n    firstCharCode === $.CHAR_TILDE\n  ) {\n    if (!lineEnd) lineEnd = util.findLineEnd(source, pos)\n    if (!indentInfo) indentInfo = calculateIndent(source, pos, lineEnd)\n    if (indentInfo.spaceEquivalent <= 3)\n      return parseCodeFenced(source, effectivePos, state, options)\n  } else if (firstCharCode === $.CHAR_PIPE) {\n    return parseTable(source, pos, state, options)\n  }\n  if (isIndentChar) return parseCodeBlock(source, pos, state)\n  return null\n}\n\n/** Parse blocks inside HTML content */\nfunction parseBlocksInHTML(\n  input: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  const result: MarkdownToJSX.ASTNode[] = []\n  let pos = 0\n\n  while (pos < input.length) {\n    while (pos < input.length && input[pos] === '\\n') {\n      pos++\n    }\n\n    if (pos >= input.length) break\n\n    var char = input[pos]\n\n    // Fast path: check for setext heading in list context\n    // Per CommonMark: setext headings take precedence over thematic breaks\n    if (state.inList && result.length > 0) {\n      var lastBlock = result[result.length - 1]\n      if (lastBlock?.type === RuleType.paragraph) {\n        var paragraph = lastBlock as MarkdownToJSX.ParagraphNode\n        // Quick check for potential setext underline characters\n        var code = charCode(char)\n        if (\n          code === $.CHAR_DASH ||\n          code === $.CHAR_EQ ||\n          code === $.CHAR_SPACE ||\n          code === $.CHAR_TAB\n        ) {\n          var lineEnd = util.findLineEnd(input, pos)\n          var lineContent = input.slice(pos, lineEnd)\n\n          // Check indentation (up to 3 spaces allowed for setext headings)\n          var indentInfo = calculateIndent(input, pos, lineEnd)\n          if (indentInfo.spaceEquivalent < 4) {\n            var trimmed = lineContent.slice(indentInfo.charCount).trim()\n            // Use convertSetextHeadingInListItem helper to check and convert\n            if (convertSetextHeadingInListItem(result, trimmed, options)) {\n              pos =\n                lineEnd +\n                (lineEnd < input.length && input[lineEnd] === '\\n' ? 1 : 0)\n              continue\n            }\n          }\n        }\n      }\n    }\n\n    // Try parseBlock first (handles most block types)\n    var blockResult = parseBlock(input, pos, state, options)\n    if (blockResult) {\n      result.push(blockResult)\n      pos = blockResult.endPos\n      continue\n    }\n\n    // Try setext heading (not handled by parseBlock)\n    var setextResult = parseHeadingSetext(input, pos, state, options)\n    if (setextResult) {\n      result.push(setextResult)\n      pos = setextResult.endPos\n      continue\n    }\n\n    var remaining = input.slice(pos).trim()\n    if (remaining) {\n      // Per CommonMark spec example 293: Before parsing a paragraph, check if there's\n      // a blockquote ending with a paragraph in recent blocks that this should merge into\n      if (state.inBlockQuote && result.length > 0) {\n        // Find the deepest blockquote ending with a paragraph in recent blocks\n        // (may be nested inside list items)\n        function findBlockquoteWithParagraphEnd(\n          node: MarkdownToJSX.ASTNode\n        ): MarkdownToJSX.ParagraphNode | null {\n          if (node.type === RuleType.blockQuote) {\n            var blockQuote = node as MarkdownToJSX.BlockQuoteNode\n            if (blockQuote.children && blockQuote.children.length > 0) {\n              var lastChild =\n                blockQuote.children[blockQuote.children.length - 1]\n              if (lastChild.type === RuleType.paragraph) {\n                return lastChild as MarkdownToJSX.ParagraphNode\n              }\n            }\n          } else if (\n            node.type === RuleType.orderedList ||\n            node.type === RuleType.unorderedList\n          ) {\n            var list = node as\n              | MarkdownToJSX.OrderedListNode\n              | MarkdownToJSX.UnorderedListNode\n            if (list.items && list.items.length > 0) {\n              var lastItem = list.items[list.items.length - 1]\n              if (lastItem && lastItem.length > 0) {\n                var lastItemChild = lastItem[lastItem.length - 1]\n                var found = findBlockquoteWithParagraphEnd(lastItemChild)\n                if (found) return found\n              }\n            }\n          }\n          return null\n        }\n\n        // Check recent blocks (from end) for blockquote ending with paragraph\n        for (var i = result.length - 1; i >= 0; i--) {\n          var paragraph = findBlockquoteWithParagraphEnd(result[i])\n          if (paragraph) {\n            var parseResult = parseParagraph(input, pos, state, options)\n            if (parseResult) {\n              var newParagraph = parseResult as MarkdownToJSX.ParagraphNode\n              // Merge the new paragraph's children into the blockquote's paragraph\n              if (paragraph.children && newParagraph.children) {\n                paragraph.children.push(\n                  { type: RuleType.text, text: '\\n' } as MarkdownToJSX.TextNode,\n                  ...newParagraph.children\n                )\n              }\n              pos = parseResult.endPos\n              continue\n            }\n          }\n        }\n      }\n\n      var parseResult = parseParagraph(input, pos, state, options)\n      if (parseResult) {\n        result.push(parseResult)\n        pos = parseResult.endPos\n        continue\n      }\n    }\n\n    pos++\n  }\n\n  return result\n}\n\nfunction parseHeading(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline) return null\n\n  // Find line end to limit expensive indentation scan\n  const lineEnd = util.findLineEnd(source, pos)\n  const indentResult = calculateIndent(source, pos, lineEnd, 3)\n  if (indentResult.spaceEquivalent > 3 && !state.inList) return null\n  var i = pos + indentResult.charCount\n\n  if (i >= source.length || source[i] !== '#') return null\n\n  const level = countConsecutiveChars(source, i, '#', 6)\n  i += level\n\n  if (i >= source.length) return null\n  const afterHash = source[i]\n  if (afterHash === '\\n' || afterHash === '\\r') {\n    const lineEnd = util.findLineEnd(source, i)\n    return {\n      ...createHeading(level, [], '', options.slugify),\n      endPos: lineEnd + (lineEnd < source.length ? 1 : 0),\n    } as MarkdownToJSX.HeadingNode & { endPos: number }\n  }\n  if (afterHash !== ' ' && afterHash !== '\\t') return null\n\n  const contentStart = i\n  const contentEnd = util.findLineEnd(source, contentStart)\n  var content = source\n    .slice(contentStart, contentEnd)\n    .replace(HEADING_TRAILING_HASHES_R, '')\n    .trim()\n\n  const children = parseInlineWithState(\n    content,\n    0,\n    content.length,\n    state,\n    options\n  )\n\n  return {\n    ...createHeading(level, children, content, options.slugify),\n    endPos: contentEnd + (contentEnd < source.length ? 1 : 0),\n  } as MarkdownToJSX.HeadingNode & { endPos: number }\n}\n\nfunction parseHeadingSetext(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline || state.inBlockQuote || state.inList) return null\n\n  const firstLineEnd = util.findLineEnd(source, pos)\n  if (firstLineEnd >= source.length) return null\n\n  // Find underline pattern first, then validate backwards\n  let underlineLineStart = skipToNextLine(source, firstLineEnd),\n    underlineLineEnd = -1,\n    underlineChar: string | null = null\n\n  // Scan forward for underline (= or - with up to 3 spaces indentation)\n  for (\n    var linesScanned = 0;\n    underlineLineStart < source.length && linesScanned < 10;\n    linesScanned++\n  ) {\n    const lineEnd = util.findLineEnd(source, underlineLineStart)\n    if (lineEnd >= source.length) break\n\n    // Check if blank line (stops setext headings)\n    var i = underlineLineStart\n    while (\n      i < lineEnd &&\n      (charCode(source, i) === $.CHAR_SPACE ||\n        charCode(source, i) === $.CHAR_TAB ||\n        charCode(source, i) === $.CHAR_CR)\n    )\n      i++\n    if (i >= lineEnd) break\n\n    // Check indentation (up to 3 spaces) and first char\n    var indentCount = 0,\n      checkPos = underlineLineStart\n    while (\n      checkPos < lineEnd &&\n      indentCount < 3 &&\n      charCode(source, checkPos) === $.CHAR_SPACE\n    ) {\n      indentCount++\n      checkPos++\n    }\n\n    if (checkPos < lineEnd) {\n      const code = charCode(source, checkPos)\n      if (code === $.CHAR_EQ || code === $.CHAR_DASH) {\n        // Validate underline: only = or - with optional trailing spaces, no internal spaces\n        const char = source[checkPos]\n        var underlineCount = 0,\n          hasSeenWS = false,\n          p = checkPos\n        while (p < lineEnd) {\n          const c = charCode(source, p)\n          if (c === code) {\n            if (hasSeenWS) {\n              underlineCount = 0\n              break\n            }\n            underlineCount++\n          } else if (c === $.CHAR_SPACE || c === $.CHAR_TAB) {\n            hasSeenWS = true\n          } else {\n            underlineCount = 0\n            break\n          }\n          p++\n        }\n\n        if (underlineCount >= 1) {\n          underlineLineEnd = lineEnd\n          underlineChar = char\n          break\n        }\n      }\n    }\n\n    underlineLineStart = skipToNextLine(source, lineEnd)\n  }\n\n  if (!underlineChar) return null\n\n  // Quick validation: content cannot start with certain block characters\n  const firstCharCode = charCode(source, pos)\n  if (\n    firstCharCode === $.CHAR_HASH ||\n    firstCharCode === $.CHAR_GT ||\n    source[pos] === '|'\n  )\n    return null\n\n  // Collect content lines forward to underline\n  let contentEnd = pos\n  var currentPos = pos,\n    hasContent = false\n\n  while (currentPos < underlineLineStart) {\n    const lineEnd = util.findLineEnd(source, currentPos)\n    if (lineEnd >= underlineLineStart) break\n\n    // Check if line has non-whitespace content\n    var j = currentPos\n    while (\n      j < lineEnd &&\n      (charCode(source, j) === $.CHAR_SPACE ||\n        charCode(source, j) === $.CHAR_TAB ||\n        charCode(source, j) === $.CHAR_CR)\n    )\n      j++\n    if (j < lineEnd) {\n      // Line has content\n      hasContent = true\n      contentEnd = lineEnd\n    }\n\n    currentPos = skipToNextLine(source, lineEnd)\n  }\n\n  if (!hasContent) return null\n\n  // Extract and trim content\n  const rawContent = source.slice(pos, contentEnd)\n  var startTrim = 0,\n    endTrim = rawContent.length\n  while (\n    startTrim < endTrim &&\n    (rawContent.charCodeAt(startTrim) === $.CHAR_SPACE ||\n      rawContent.charCodeAt(startTrim) === $.CHAR_TAB ||\n      rawContent.charCodeAt(startTrim) === $.CHAR_CR ||\n      rawContent.charCodeAt(startTrim) === $.CHAR_NEWLINE)\n  )\n    startTrim++\n  while (\n    endTrim > startTrim &&\n    (rawContent.charCodeAt(endTrim - 1) === $.CHAR_SPACE ||\n      rawContent.charCodeAt(endTrim - 1) === $.CHAR_TAB ||\n      rawContent.charCodeAt(endTrim - 1) === $.CHAR_CR ||\n      rawContent.charCodeAt(endTrim - 1) === $.CHAR_NEWLINE)\n  )\n    endTrim--\n  const content = rawContent.slice(startTrim, endTrim)\n\n  if (!content) return null\n\n  const level = underlineChar === '=' ? 1 : 2\n  const children = parseInlineWithState(\n    content,\n    0,\n    content.length,\n    state,\n    options\n  )\n\n  return {\n    ...createHeading(level, children, content, options.slugify),\n    endPos: underlineLineEnd + (underlineLineEnd < source.length ? 1 : 0),\n  } as MarkdownToJSX.HeadingNode & { endPos: number }\n}\n\nfunction parseParagraph(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  // Note: We don't check isBlockStartChar here because this is called as a fallback\n  // after other block parsers have already tried and failed\n  if (state.inline) return null\n\n  if (options.optimizeForStreaming && source[pos] === '|') {\n    var checkLen = Math.min(500, source.length - pos)\n    var checkContent = source.substr(pos, checkLen)\n    var streamPipeCount = 0\n    var streamHasSeparator = false\n    for (var streamIdx = 0; streamIdx < checkContent.length; streamIdx++) {\n      if (checkContent[streamIdx] === '|') streamPipeCount++\n      if (checkContent[streamIdx] === '-' || checkContent[streamIdx] === ':') streamHasSeparator = true\n    }\n    if (streamPipeCount >= 3 && streamHasSeparator) {\n      var streamEndPos = util.findLineEnd(source, pos)\n      while (streamEndPos < source.length) {\n        var nextStart = skipToNextLine(source, streamEndPos)\n        if (nextStart >= source.length) break\n        var nextEnd = util.findLineEnd(source, nextStart)\n        var nextLine = source.slice(nextStart, nextEnd)\n        if (nextLine.indexOf('|') === -1 && nextLine.indexOf('-') === -1) break\n        streamEndPos = nextEnd\n        if (nextEnd >= source.length) break\n      }\n      return {\n        type: RuleType.paragraph,\n        children: [],\n        endPos: skipToNextLine(source, streamEndPos),\n      } as MarkdownToJSX.ParagraphNode & { endPos: number }\n    }\n  }\n\n  let endPos = pos\n  const sourceLen = source.length\n\n  while (endPos < sourceLen) {\n    let lineEnd = util.findLineEnd(source, endPos)\n    let isEmptyLine = true\n\n    for (let i = endPos; i < lineEnd; i++) {\n      const code = charCode(source, i)\n      if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB && code !== $.CHAR_CR) {\n        isEmptyLine = false\n        break\n      }\n    }\n\n    if (isEmptyLine) {\n      endPos = lineEnd\n      break\n    }\n\n    if (lineEnd >= sourceLen) {\n      endPos = sourceLen\n      break\n    }\n\n    const nextLineStart = skipToNextLine(source, lineEnd)\n    if (nextLineStart >= sourceLen) {\n      endPos = sourceLen\n      break\n    }\n\n    let nextLineEnd = util.findLineEnd(source, nextLineStart)\n    let nextLineIsEmpty = true\n    let nextLineFirstChar = ''\n\n    for (let i = nextLineStart; i < nextLineEnd; i++) {\n      const code = charCode(source, i)\n      if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB && code !== $.CHAR_CR) {\n        nextLineIsEmpty = false\n        if (nextLineFirstChar === '') nextLineFirstChar = source[i]\n        break\n      }\n    }\n\n    if (nextLineIsEmpty) {\n      endPos = lineEnd\n      break\n    }\n\n    // Check if next line starts with a block element\n    // BUT: per CommonMark, lines indented by exactly 4 spaces are paragraph continuation,\n    // not code blocks or other blocks, even if they start with block-starting characters.\n    let shouldBreak = false\n    const nextIndentInfo = calculateIndent(source, nextLineStart, nextLineEnd)\n    const isExact4SpaceIndent =\n      nextIndentInfo.spaceEquivalent === 4 && nextIndentInfo.charCount === 4\n\n    // Check for HTML blocks first (types 1-6 can interrupt paragraphs)\n    // Per CommonMark spec: HTML blocks of types 1-6 can interrupt paragraphs\n    if (\n      nextLineFirstChar === '<' &&\n      !isExact4SpaceIndent &&\n      !options.disableParsingRawHTML\n    ) {\n      const htmlCheckPos = nextLineStart\n      let htmlLineStart = htmlCheckPos\n      let htmlIndent = 0\n      while (htmlLineStart < nextLineEnd && htmlIndent < 3) {\n        const code = charCode(source, htmlLineStart)\n        if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n          htmlIndent++\n          htmlLineStart++\n        } else {\n          break\n        }\n      }\n      if (htmlLineStart < nextLineEnd && source[htmlLineStart] === '<') {\n        var htmlResult = parseHTML(\n          source,\n          htmlLineStart,\n          { ...state, inline: false },\n          options\n        )\n        if (htmlResult) {\n          shouldBreak =\n            !('canInterruptParagraph' in htmlResult) ||\n            (htmlResult.canInterruptParagraph as boolean)\n        }\n      }\n    }\n\n    // In list context, lines indented to the content start column are also continuation\n    // For now, treat 4-space indented lines as continuation regardless of context\n    if (isExact4SpaceIndent) {\n      // Line is indented exactly 4 spaces - this is paragraph continuation\n      // Per CommonMark spec: lines indented by exactly 4 spaces are paragraph continuation,\n      // not code blocks or other blocks, even if they start with block-starting characters.\n      // Don't break, continue paragraph across this line\n      shouldBreak = false\n    } else if (\n      !shouldBreak &&\n      nextLineFirstChar &&\n      isBlockStartChar(nextLineFirstChar)\n    ) {\n      // Reference definitions don't break paragraphs - skip them\n      if (nextLineFirstChar === '[') {\n        // Check if it's a reference definition (not a footnote)\n        const checkPos = nextLineStart\n        if (checkPos + 1 >= sourceLen || source[checkPos + 1] !== '^') {\n          // Could be a reference definition - don't break paragraph\n          shouldBreak = false\n        } else {\n          // Footnote definition - break paragraph\n          shouldBreak = true\n        }\n      } else if (nextLineFirstChar === '*' || nextLineFirstChar === '+') {\n        // Asterisk/plus is only a block start for lists (*/+ followed by space/tab) or thematic breaks (3+ alone)\n        // But thematic breaks can have up to 3 spaces indentation, so check for thematic break first\n        const thematicBreakResult = parseBreakThematic(\n          source,\n          nextLineStart,\n          state,\n          options\n        )\n        if (thematicBreakResult) {\n          shouldBreak = true\n        } else {\n          // Check if it's a list (followed by space/tab)\n          const secondChar =\n            nextLineStart + 1 < sourceLen ? source[nextLineStart + 1] : ''\n          if (secondChar && isSpaceOrTab(secondChar)) {\n            shouldBreak = true\n          } else {\n            // Not a list or thematic break - don't break paragraph\n            shouldBreak = false\n          }\n        }\n      } else {\n        // Use parseBlock to check if next line starts a block\n        // Special handling needed for setext headings and ordered lists\n        const blockResult = parseBlock(source, nextLineStart, state, options)\n\n        if (blockResult) {\n          // Check if it's a code block from 4+ space indentation (paragraph continuation)\n          if (blockResult.type === RuleType.codeBlock) {\n            const blockIndentInfo = calculateIndent(\n              source,\n              nextLineStart,\n              nextLineEnd\n            )\n            if (blockIndentInfo.spaceEquivalent >= 4) {\n              // 4+ space indentation is paragraph continuation, not a block start\n              shouldBreak = false\n            } else {\n              // Fenced code block - break paragraph\n              shouldBreak = true\n            }\n          } else if (\n            blockResult.type === RuleType.unorderedList ||\n            blockResult.type === RuleType.orderedList\n          ) {\n            // Lists can interrupt paragraphs, but ordered lists starting with numbers other than 1 cannot\n            if (blockResult.type === RuleType.orderedList) {\n              const orderedList = blockResult as MarkdownToJSX.OrderedListNode\n              // Only ordered lists starting with 1 can interrupt paragraphs\n              shouldBreak = orderedList.start === 1\n            } else {\n              shouldBreak = true\n            }\n          } else if (nextLineFirstChar === '-') {\n            // Dash could be setext heading underline if preceded by content\n            // Per CommonMark: setext headings take precedence over thematic breaks\n            if (endPos > pos) {\n              // We have content - break paragraph to let setext heading parser check\n              shouldBreak = true\n            } else {\n              // No content - use the block result (thematic break or list)\n              shouldBreak = true\n            }\n          } else if (blockResult.type === RuleType.ref) {\n            // Reference definitions don't break paragraphs\n            shouldBreak = false\n          } else {\n            // Other block types break paragraphs\n            shouldBreak = true\n          }\n        }\n      }\n    } else {\n      // Next line doesn't start with a block-starting character\n      // Per CommonMark: in paragraph context, lines indented by exactly 4 spaces\n      // are paragraph continuation, not code blocks. Only 4+ spaces at document\n      // start (not in paragraph) are code blocks.\n      // So we don't break on 4-space indentation in paragraph continuation.\n    }\n\n    if (shouldBreak) {\n      endPos = lineEnd\n      break\n    }\n\n    // Continue paragraph across single newline\n    endPos = skipToNextLine(source, lineEnd)\n  }\n\n  if (endPos <= pos) return null\n\n  // Per CommonMark: lines indented by exactly 4 spaces in paragraph context\n  // are continuation, not code blocks. We need to remove the 4-space indentation\n  // from continuation lines but preserve them as part of the paragraph.\n  var contentStart = pos\n  var contentEnd = endPos\n\n  while (contentStart < contentEnd) {\n    const code = charCode(source, contentStart)\n    if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n      contentStart++\n    } else {\n      break\n    }\n  }\n\n  // Fast path: if no newlines, use content directly (common case)\n  // Check if there's a newline between contentStart and contentEnd\n  // We can optimize by checking if contentEnd is beyond the first line\n  const firstLineEnd = util.findLineEnd(source, contentStart)\n  var hasNewline = contentEnd > firstLineEnd\n\n  var processedContent\n  if (!hasNewline) {\n    // Single line - no processing needed\n    processedContent = source.slice(contentStart, contentEnd)\n  } else {\n    // Multi-line: process 4-space indentation\n    var processedParts: string[] = []\n    var lineStart = contentStart\n    var lineIndex = 0\n\n    while (lineStart < contentEnd) {\n      var lineEnd = util.findLineEnd(source, lineStart)\n      if (lineEnd > contentEnd) lineEnd = contentEnd\n\n      if (lineIndex === 0) {\n        processedParts.push(source.slice(lineStart, lineEnd))\n      } else {\n        // Check for exactly 4 leading spaces\n        var spaceCount = 0\n        while (spaceCount < 4 && lineStart + spaceCount < lineEnd) {\n          if (charCode(source, lineStart + spaceCount) === $.CHAR_SPACE) {\n            spaceCount++\n          } else {\n            break\n          }\n        }\n        var start = spaceCount === 4 ? lineStart + 4 : lineStart\n        processedParts.push(source.slice(start, lineEnd))\n      }\n\n      if (lineEnd < contentEnd) {\n        const charAtEnd = charCode(source, lineEnd)\n        if (charAtEnd === $.CHAR_CR || charAtEnd === $.CHAR_NEWLINE) {\n          processedParts.push('\\n')\n          lineStart = skipToNextLine(source, lineEnd)\n        } else {\n          lineStart = contentEnd\n        }\n      } else {\n        lineStart = contentEnd\n      }\n      lineIndex++\n    }\n    processedContent = processedParts.join('')\n  }\n\n  var processedContentEnd = processedContent.length\n  while (processedContentEnd > 0) {\n    var c = processedContent.charCodeAt(processedContentEnd - 1)\n    if (c === $.CHAR_SPACE || c === $.CHAR_TAB) {\n      processedContentEnd--\n    } else {\n      break\n    }\n  }\n  if (processedContentEnd < processedContent.length) {\n    processedContent = processedContent.slice(0, processedContentEnd)\n  }\n\n  // Check if processed content has actual content\n  let hasProcessedContent = false\n  for (let i = 0; i < processedContent.length; i++) {\n    const code = processedContent.charCodeAt(i)\n    if (\n      code !== $.CHAR_SPACE &&\n      code !== $.CHAR_TAB &&\n      code !== $.CHAR_NEWLINE &&\n      code !== $.CHAR_CR\n    ) {\n      hasProcessedContent = true\n      break\n    }\n  }\n  if (!hasProcessedContent) return null\n\n  // Per CommonMark spec: Extract link reference definitions from paragraph content\n  // Reference definitions can appear at the end of paragraph content\n  // They should be extracted and stored, not parsed as inline content\n  // Scan backwards from endPos in source to find reference definitions\n  var extractedContent = processedContent\n  var extractedEndPos = endPos\n  // Find the last newline in the source before endPos (optimized: manual scan instead of lastIndexOf)\n  var lastNewlinePos = -1\n  var searchPos = endPos - 1\n  while (searchPos >= contentStart) {\n    if (charCode(source, searchPos) === $.CHAR_NEWLINE) {\n      lastNewlinePos = searchPos\n      break\n    }\n    searchPos--\n  }\n  if (lastNewlinePos >= 0) {\n    // Per CommonMark spec: \"A link reference definition cannot interrupt a paragraph.\"\n    // Only extract reference definitions if they're at the START of the paragraph (no content before them)\n    // Check if there's any non-whitespace content before the last newline\n    var hasContentBeforeNewline = false\n    for (var checkPos = contentStart; checkPos < lastNewlinePos; checkPos++) {\n      const code = charCode(source, checkPos)\n      if (\n        code !== $.CHAR_SPACE &&\n        code !== $.CHAR_TAB &&\n        code !== $.CHAR_NEWLINE &&\n        code !== $.CHAR_CR\n      ) {\n        hasContentBeforeNewline = true\n        break\n      }\n    }\n\n    // Only extract reference definition if there's no content before the newline\n    // (i.e., it's at the start of the paragraph)\n    if (!hasContentBeforeNewline) {\n      // Check if the content after the last newline is a reference definition\n      var refDefStartPos = lastNewlinePos + 1\n      // Skip any leading whitespace\n      while (refDefStartPos < source.length) {\n        const code = charCode(source, refDefStartPos)\n        if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n          refDefStartPos++\n        } else {\n          break\n        }\n      }\n      // Check indentation - reference definitions can't be indented 4+ spaces\n      var refDefIndent = refDefStartPos - (lastNewlinePos + 1)\n      if (\n        refDefIndent < 4 &&\n        refDefStartPos < source.length &&\n        source[refDefStartPos] === '['\n      ) {\n        var refDefState = { ...state, inline: false }\n        var refDefResult = parseDefinition(\n          source,\n          refDefStartPos,\n          refDefState,\n          options,\n          false\n        )\n        if (refDefResult) {\n          // Reference definition was successfully parsed - exclude it from paragraph content\n          // Find the corresponding position in processedContent\n          // Count newlines from contentStart to lastNewlinePos\n          var newlineCount = 0\n          var searchPos = contentStart\n          while (searchPos <= lastNewlinePos) {\n            const nlPos = source.indexOf('\\n', searchPos)\n            if (nlPos === -1 || nlPos > lastNewlinePos) break\n            newlineCount++\n            searchPos = nlPos + 1\n          }\n          // Find the corresponding position in processedContent\n          var newlinePosInProcessed = 0\n          var newlinesFound = 0\n          searchPos = 0\n          while (searchPos < processedContent.length) {\n            const nlPos = processedContent.indexOf('\\n', searchPos)\n            if (nlPos === -1) break\n            newlinesFound++\n            if (newlinesFound === newlineCount) {\n              newlinePosInProcessed = nlPos + 1\n              break\n            }\n            searchPos = nlPos + 1\n          }\n          if (newlinePosInProcessed > 0) {\n            extractedContent = processedContent.slice(\n              0,\n              newlinePosInProcessed - 1\n            )\n          }\n          extractedEndPos = refDefResult.endPos\n          // Update state.refs from the parsed reference\n          state.refs = refDefState.refs\n        }\n      }\n    }\n  }\n\n  // Parse as inline (newlines are preserved by default)\n  const children = parseInlineWithState(\n    extractedContent,\n    0,\n    extractedContent.length,\n    state,\n    options\n  )\n\n  var result: MarkdownToJSX.ParagraphNode & {\n    endPos: number\n    removedClosingTags?: MarkdownToJSX.ASTNode[]\n  } = {\n    type: RuleType.paragraph,\n    children,\n    endPos: extractedEndPos,\n  }\n\n  // Per CommonMark spec Example 148: when paragraphs contain multiple closing tags at the end,\n  // only the first closing tag should be kept in the paragraph, the rest should be removed\n  // This handles cases where closing tags are part of HTML block structures\n  // Heuristic: if there are 3+ consecutive closing tags, remove all but the first one\n  // Example 148: <p><em>world</em>.</pre></p> should keep </pre> but remove </td>, </tr>, </table> (4 tags)\n  // Example 623: <p></a></foo ></p> should keep both </a> and </foo > (2 tags, not removed)\n  if (children.length > 0) {\n    // Find closing tags at the end of paragraph children (ignoring whitespace-only text nodes)\n    // Keep the first closing tag but remove the rest\n    var closingTagIndices: number[] = []\n    for (var i = children.length - 1; i >= 0; i--) {\n      var child = children[i]\n      if (\n        child.type === RuleType.htmlSelfClosing &&\n        child.isClosingTag === true\n      ) {\n        closingTagIndices.push(i)\n      } else if (child.type === RuleType.text) {\n        var textNode = child as MarkdownToJSX.TextNode\n        // Skip whitespace-only text nodes when looking for consecutive closing tags\n        if (textNode.text && textNode.text.trim().length > 0) {\n          break\n        }\n      } else {\n        // Stop at first non-closing-tag, non-whitespace node\n        break\n      }\n    }\n    // If we found 3+ consecutive closing tags at the end, remove all but the first one\n    // Store the removed closing tags on the paragraph node so html() can render them separately\n    // Heuristic: 3+ tags indicates HTML block structure (like </pre></td></tr></table>)\n    // 2 tags might be standalone (like </a></foo >) - keep both\n    if (closingTagIndices.length >= 3) {\n      // Keep only the first closing tag (earliest in array), remove the rest\n      var firstClosingTagIdx = closingTagIndices[closingTagIndices.length - 1]\n      var removedClosingTags = children.slice(firstClosingTagIdx + 1)\n      children.splice(firstClosingTagIdx + 1)\n      result.removedClosingTags = removedClosingTags\n    }\n  }\n\n  return result\n}\n\nfunction parseFrontmatter(source: string, pos: number): ParseResult {\n  if (pos !== 0) return null\n  const bounds = util.parseFrontmatterBounds(source)\n  if (!bounds?.hasValidYaml) return null\n  let sliceEnd = bounds.endPos - 1\n  if (sliceEnd > 0 && source[sliceEnd - 1] === '\\r') sliceEnd--\n  let text = util.normalizeInput(source.slice(0, sliceEnd))\n  return {\n    type: RuleType.frontmatter,\n    text,\n    endPos: bounds.endPos,\n  } as MarkdownToJSX.FrontmatterNode & { endPos: number }\n}\n\nfunction parseBreakThematic(\n  source: string,\n  pos: number,\n  state?: MarkdownToJSX.State,\n  options?: ParseOptions\n): ParseResult {\n  // Find the end of the line\n  const lineEnd = util.findLineEnd(source, pos)\n\n  // Per CommonMark: up to 3 spaces of indentation allowed\n  // Count indentation, checking if it exceeds 3 spaces\n  // OPTIMIZATION: Work directly on source string to avoid slice allocation\n  const indentResult = calculateIndent(source, pos, lineEnd, 3)\n  if (indentResult.spaceEquivalent > 3) return null\n  var checkPos = pos + indentResult.charCount\n\n  // Now check for thematic break character (-, *, or _)\n  if (checkPos >= lineEnd) return null\n  const startChar = source[checkPos]\n  if (startChar !== '-' && startChar !== '*' && startChar !== '_') return null\n\n  // OPTIMIZATION: Fast path - count matching characters before full validation\n  // This eliminates 96% of failed attempts (102 attempts -> ~4 attempts)\n  // Thematic break requires 3+ matching chars per CommonMark spec\n  var charCount = 0\n  var scanPos = checkPos\n  while (scanPos < lineEnd) {\n    var char = source[scanPos]\n    if (char === startChar) {\n      charCount++\n    } else if (char !== ' ' && char !== '\\t') {\n      // Non-matching non-whitespace character - not a thematic break\n      return null\n    }\n    scanPos++\n  }\n\n  if (charCount < 3) {\n    return null // Need at least 3 matching characters per CommonMark spec\n  }\n\n  return {\n    type: RuleType.breakThematic,\n    endPos: skipToNextLine(source, lineEnd),\n  } as MarkdownToJSX.BreakThematicNode & { endPos: number }\n}\n\n/** Calculate the space-equivalent indentation at a position (tabs = 4 spaces) */\nexport function calculateIndent(\n  source: string,\n  pos: number,\n  maxPos: number,\n  maxSpaces?: number\n): { spaceEquivalent: number; charCount: number } {\n  let spaceEquivalent = 0\n  let charCount = 0\n  let i = pos\n  while (i < maxPos) {\n    var iCode = charCode(source, i)\n    if (iCode !== $.CHAR_SPACE && iCode !== $.CHAR_TAB) break\n    if (maxSpaces !== undefined && spaceEquivalent >= maxSpaces) break\n    if (iCode === $.CHAR_TAB) {\n      spaceEquivalent += 4 - (spaceEquivalent % 4)\n    } else {\n      spaceEquivalent += 1\n    }\n    charCount++\n    i++\n  }\n  return { spaceEquivalent, charCount }\n}\n\nfunction extractCodeBlockLineContent(\n  source: string,\n  lineStart: number,\n  lineEnd: number,\n  startColumn: number\n): string {\n  let indentChars = 0\n  let indentSpaceEquivalent = 0\n  let currentColumn = startColumn\n  for (let i = lineStart; i < lineEnd && indentSpaceEquivalent < 4; i++) {\n    var iCode = charCode(source, i)\n    if (iCode === $.CHAR_TAB) {\n      const spaces = 4 - (currentColumn % 4)\n      indentSpaceEquivalent += spaces\n      indentChars++\n      currentColumn += spaces\n      if (indentSpaceEquivalent >= 4) break\n    } else if (iCode === $.CHAR_SPACE) {\n      indentSpaceEquivalent++\n      indentChars++\n      currentColumn++\n      if (indentSpaceEquivalent >= 4) break\n    } else {\n      break\n    }\n  }\n\n  let content = source.slice(lineStart + indentChars, lineEnd)\n  var tabCount = 0\n  for (var tc = lineStart; tc < lineEnd; tc++) {\n    if (source[tc] === '\\t') tabCount++\n    if (tabCount >= 2) break\n  }\n  if (tabCount >= 2 && util.startsWith(content, '\\t') && startColumn > 0) {\n    content = '  ' + content.slice(1)\n  }\n  return content\n}\n\nfunction parseCodeBlock(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State\n): ParseResult {\n  // Limit indentation scan to current line\n  const lineEndForIndent = util.findLineEnd(source, pos)\n  const indentInfo = calculateIndent(source, pos, lineEndForIndent)\n  if (indentInfo.spaceEquivalent < 4) return null\n\n  const initialIndent = indentInfo.spaceEquivalent\n  const lineEnd = util.findLineEnd(source, pos + indentInfo.charCount)\n  const lineStart = pos\n\n  let column = 0\n  var i = lineStart - 1\n  while (i >= 0 && source[i] !== '\\n' && source[i] !== '\\r') {\n    i--\n  }\n  i++\n  while (i < lineStart) {\n    if (source[i] === '\\t') {\n      column = column + 4 - (column % 4)\n    } else {\n      column++\n    }\n    i++\n  }\n\n  let firstLineContent = extractCodeBlockLineContent(\n    source,\n    lineStart,\n    lineEnd,\n    column\n  )\n  const contentStart = skipToNextLine(source, lineEnd)\n  if (contentStart >= source.length) {\n    if (!firstLineContent.trim()) return null\n    return {\n      type: RuleType.codeBlock,\n      text: firstLineContent,\n      endPos: contentStart,\n    } as MarkdownToJSX.CodeBlockNode & { endPos: number }\n  }\n\n  var parts: string[] = []\n  parts.push(firstLineContent)\n  let endPos = contentStart\n\n  while (endPos < source.length) {\n    const nextLineEnd = util.findLineEnd(source, endPos)\n    if (isBlankLineCheck(source, endPos, nextLineEnd)) {\n      const nextLinePos = nextLineEnd + 1\n      if (nextLinePos < source.length) {\n        const nextLineEnd = util.findLineEnd(source, nextLinePos)\n        const nextIndentInfo = calculateIndent(source, nextLinePos, nextLineEnd)\n        const nextChar = source[nextLinePos + nextIndentInfo.charCount]\n        if (\n          nextChar &&\n          nextChar !== '\\n' &&\n          (nextIndentInfo.spaceEquivalent < 4 ||\n            (nextChar === '>' &&\n              nextIndentInfo.spaceEquivalent < initialIndent))\n        ) {\n          break\n        }\n      }\n      parts.push('\\n')\n    } else {\n      const currentIndentInfo = calculateIndent(source, endPos, nextLineEnd)\n      if (currentIndentInfo.spaceEquivalent < 4) {\n        break\n      }\n\n      let lineContent = extractCodeBlockLineContent(\n        source,\n        endPos,\n        nextLineEnd,\n        0\n      )\n      parts.push('\\n')\n      parts.push(lineContent)\n    }\n\n    endPos = skipToNextLine(source, nextLineEnd)\n  }\n\n  let content = parts.join('')\n  content = content.replace(TRAILING_NEWLINE_R, '')\n  if (!content.trim()) return null\n\n  return {\n    type: RuleType.codeBlock,\n    text: content,\n    endPos,\n  } as MarkdownToJSX.CodeBlockNode & { endPos: number }\n}\n\nexport function parseCodeFenced(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  const fenceChar = source[pos]\n  if (fenceChar !== '`' && fenceChar !== '~') return null\n\n  // Fast check: must have at least 3 consecutive fence chars\n  const fenceLength = countConsecutiveChars(source, pos, fenceChar)\n  if (fenceLength < 3) return null\n\n  // Find line start for indentation calculation\n  let lineStart = pos\n  while (lineStart > 0 && charCode(source, lineStart - 1) !== $.CHAR_NEWLINE)\n    lineStart--\n\n  // Calculate indentation (caller already verified <= 3, but we need exact value)\n  const indentInfo = calculateIndent(source, lineStart, pos)\n  let openingIndent = indentInfo.spaceEquivalent\n  let contentIndentToRemove = openingIndent\n\n  // Handle 4-space indentation special case (simplified)\n  if (openingIndent === 4 && indentInfo.charCount === 4) {\n    // All 4 chars before pos are spaces/tabs, so this is indented code block\n    openingIndent = 0\n    contentIndentToRemove = 4\n  }\n\n  // Should not happen since caller checks indent <= 3, but keep for safety\n  if (openingIndent >= 4) return null\n\n  let i = util.skipWhitespace(source, pos + fenceLength)\n  const lineEnd = util.findLineEnd(source, i)\n  let langAndAttrs = source.slice(i, lineEnd).trim()\n\n  if (fenceChar === '`' && langAndAttrs.indexOf('`') !== -1) return null\n\n  langAndAttrs = langAndAttrs.replace(UNESCAPE_R, '$1')\n  const langSpaceIdx = langAndAttrs.indexOf(' ')\n  const lang =\n    langSpaceIdx > 0 ? langAndAttrs.slice(0, langSpaceIdx) : langAndAttrs\n  const attrsString =\n    langSpaceIdx > 0 ? langAndAttrs.slice(langSpaceIdx + 1).trim() : ''\n  const attrs =\n    attrsString && /=\\s*[\"']/.test(attrsString)\n      ? parseHTMLAttributes(attrsString, 'code', 'code', options)\n      : undefined\n\n  let contentStart = skipToNextLine(source, lineEnd)\n  let endPos = contentStart\n  // Track whether we found an explicit closing fence or an implicit close\n  // (when encountering a new opening fence with info string)\n  let foundExplicitClose = false\n\n  while (endPos < source.length) {\n    let lineEndPos = util.findLineEnd(source, endPos)\n\n    let fenceStart = endPos\n    let indentCount = 0\n    while (fenceStart < lineEndPos) {\n      const code = charCode(source, fenceStart)\n      if (code === $.CHAR_SPACE) {\n        indentCount++\n        fenceStart++\n        if (indentCount >= 4) break\n      } else if (code === $.CHAR_TAB) {\n        indentCount += 4 - (indentCount % 4)\n        fenceStart++\n        if (indentCount >= 4) break\n      } else {\n        break\n      }\n    }\n\n    if (indentCount < 4) {\n      let closeLen = countConsecutiveChars(\n        source,\n        fenceStart,\n        fenceChar,\n        lineEndPos - fenceStart\n      )\n      if (closeLen >= fenceLength) {\n        let afterFence = fenceStart + closeLen\n        while (afterFence < lineEndPos) {\n          const code = charCode(source, afterFence)\n          if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n            afterFence++\n          } else {\n            break\n          }\n        }\n        if (afterFence === lineEndPos) {\n          // Valid closing fence (only whitespace after fence chars)\n          foundExplicitClose = true\n          break\n        }\n        // Check if this looks like an opening fence with an info string\n        // Per issue: a fence with a language (e.g., ```python) should be treated\n        // as a new opening fence, implicitly closing the current code block\n        // This happens BEFORE this line (we don't include this line in content)\n        // Only treat as new opening if info string immediately follows fence (no space)\n        // This ensures ``` aaa (with space) is not treated as new opening per CommonMark\n        if (closeLen >= 3 && afterFence < lineEndPos) {\n          // Check if there's whitespace immediately after the fence chars\n          let posAfterFence = fenceStart + closeLen\n          let hasWhitespaceAfterFence =\n            posAfterFence < lineEndPos &&\n            (charCode(source, posAfterFence) === $.CHAR_SPACE ||\n              charCode(source, posAfterFence) === $.CHAR_TAB)\n\n          // Only treat as new opening if NO space between fence and info string\n          if (!hasWhitespaceAfterFence) {\n            // There's non-whitespace immediately after the fence - looks like ```python\n            // Info strings cannot contain backticks for backtick fences\n            let isValidInfoString = true\n            if (fenceChar === '`') {\n              // Check if there's a backtick in the info string\n              let lineContent = source.slice(posAfterFence, lineEndPos)\n              if (lineContent.indexOf('`') !== -1) {\n                isValidInfoString = false\n              }\n            }\n            if (isValidInfoString) {\n              // This is a new opening fence - current code block ends before this line\n              // endPos is already at the start of this line, so content won't include it\n              // foundExplicitClose stays false - we don't skip past this line\n              break\n            }\n          }\n        }\n      }\n    } else if (\n      contentIndentToRemove === 4 &&\n      openingIndent === 0 &&\n      indentCount === 4\n    ) {\n      let closeLen = countConsecutiveChars(\n        source,\n        fenceStart,\n        fenceChar,\n        lineEndPos - fenceStart\n      )\n      if (\n        closeLen >= fenceLength &&\n        isBlankLineCheck(source, fenceStart + closeLen, lineEndPos)\n      ) {\n        foundExplicitClose = true\n        break\n      }\n    }\n\n    endPos = skipToNextLine(source, lineEndPos)\n  }\n\n  let contentEnd =\n    endPos > contentStart && source[endPos - 1] === '\\n' ? endPos - 1 : endPos\n  if (contentEnd > contentStart && source[contentEnd - 1] === '\\r') {\n    contentEnd--\n  }\n  let rawContent = util.normalizeInput(source.slice(contentStart, contentEnd))\n  if (contentIndentToRemove) {\n    rawContent = removeExtraIndentFromCodeBlock(\n      rawContent,\n      contentIndentToRemove\n    )\n  }\n\n  // If we found an explicit closing fence, skip past it\n  // If we found an implicit close (new opening fence), endPos should stay at the start\n  // of that line so the next parse can handle the new code block\n  let finalEndPos =\n    foundExplicitClose && endPos < source.length\n      ? skipToNextLine(source, util.findLineEnd(source, endPos))\n      : endPos\n\n  return {\n    type: RuleType.codeBlock,\n    text: rawContent,\n    lang: lang,\n    attrs: attrs,\n    endPos: finalEndPos,\n  } as MarkdownToJSX.CodeBlockNode & { endPos: number }\n}\n\nfunction parseBlockQuoteChildren(\n  content: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  // Fast check: if content is empty or only whitespace, return early\n  for (var i = 0; i < content.length; i++) {\n    if (!isWS(content[i])) {\n      // Parse all blocks using parseBlocksWithState (which uses parseBlock via parseBlocksInHTML)\n      const blockChildren = parseBlocksWithState(content, state, options, {\n        inline: false,\n        inBlockQuote: true,\n      })\n      // Remove endPos property efficiently without creating intermediate objects\n      for (var j = 0; j < blockChildren.length; j++) {\n        const node = blockChildren[j] as MarkdownToJSX.ASTNode & {\n          endPos?: number\n        }\n        if ('endPos' in node) {\n          delete node.endPos\n        }\n      }\n      return blockChildren\n    }\n  }\n  return []\n}\n\nfunction parseBlockQuote(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline) return null\n\n  let checkPos = pos\n  while (\n    checkPos < source.length &&\n    (source[checkPos] === ' ' || source[checkPos] === '\\t')\n  ) {\n    checkPos++\n  }\n  if (checkPos >= source.length || source[checkPos] !== '>') return null\n\n  // Find the end of the blockquote and process content in single pass\n  let endPos = pos\n  var processedParts: string[] = []\n  var alertType: string | undefined = undefined\n  var hasContent = false\n  var firstLineStart = -1\n\n  // Track if we're currently in a code block (indented or fenced) that requires > prefix\n  var inCodeBlock = false\n  var codeBlockType: 'indented' | 'fenced' | null = null\n  var fencedFenceChar: string | null = null\n  var fencedFenceLength = 0\n  var previousLineWasEmpty = false\n\n  while (endPos < source.length) {\n    const lineEnd = util.findLineEnd(source, endPos)\n\n    // Check if this line starts a blockquote\n    let lineStart = endPos\n    // Skip leading whitespace\n    while (\n      lineStart < lineEnd &&\n      (source[lineStart] === ' ' || source[lineStart] === '\\t')\n    ) {\n      lineStart++\n    }\n\n    // If line starts with '>', it's part of the blockquote\n    if (lineStart < lineEnd && source[lineStart] === '>') {\n      let contentStart = lineStart + 1\n      if (contentStart < lineEnd && source[contentStart] === ' ') contentStart++\n\n      // Inline code block detection (was detectCodeBlockInBlockQuote)\n      const indentInfo = calculateIndent(source, contentStart, lineEnd)\n      const isIndented = indentInfo.spaceEquivalent >= 4\n      let isFenced = false\n      let fenceChar: string | null = null\n      let fenceLen = 0\n      if (contentStart < lineEnd) {\n        const firstChar = source[contentStart]\n        if (firstChar === '`' || firstChar === '~') {\n          let len = 0\n          let i = contentStart\n          while (i < lineEnd && source[i] === firstChar && len < 20) {\n            len++\n            i++\n          }\n          if (len >= 3) {\n            isFenced = true\n            fenceChar = firstChar\n            fenceLen = len\n          }\n        }\n      }\n\n      // Update code block state\n      if (\n        inCodeBlock &&\n        codeBlockType === 'fenced' &&\n        fenceChar === fencedFenceChar &&\n        fenceLen >= fencedFenceLength\n      ) {\n        inCodeBlock = false\n        codeBlockType = null\n        fencedFenceChar = null\n        fencedFenceLength = 0\n      } else if (isIndented || isFenced) {\n        inCodeBlock = true\n        codeBlockType = isIndented ? 'indented' : 'fenced'\n        fencedFenceChar = fenceChar\n        fencedFenceLength = fenceLen\n      }\n\n      // Inline blank line check (was isBlankLineCheck)\n      var isBlankLine = !isIndented && !isFenced\n      if (isBlankLine) {\n        for (var i = contentStart; i < lineEnd; i++) {\n          if (!isWS(source[i])) {\n            isBlankLine = false\n            break\n          }\n        }\n      }\n      previousLineWasEmpty = isBlankLine\n\n      // Track first line for alert extraction\n      if (firstLineStart === -1 && !isBlankLine) {\n        firstLineStart = processedParts.length\n      }\n      if (!isBlankLine) hasContent = true\n\n      // Process line content: remove > marker and optional space, handle tabs\n      const afterMarkerStart = lineStart + 1\n\n      // Check if first char after > is a tab (needs special handling)\n      if (afterMarkerStart < lineEnd && source[afterMarkerStart] === '\\t') {\n        // Expand tabs to spaces\n        processedParts.push('  ') // First tab after > becomes 2 spaces\n        let col = 4\n        for (let k = afterMarkerStart + 1; k < lineEnd; k++) {\n          const char = source[k]\n          var code = charCode(char)\n          if (code === $.CHAR_TAB) {\n            const spaces = 4 - (col % 4)\n            // Use fixed strings for common cases\n            if (spaces === 1) processedParts.push(' ')\n            else if (spaces === 2) processedParts.push('  ')\n            else if (spaces === 3) processedParts.push('   ')\n            else processedParts.push(' '.repeat(spaces))\n            col += spaces\n          } else {\n            processedParts.push(char)\n            col++\n          }\n        }\n        if (lineEnd < source.length) processedParts.push('\\n')\n      } else {\n        // Fast path: no tab immediately after > (common case)\n        let processedContentStart = afterMarkerStart\n        if (\n          processedContentStart < lineEnd &&\n          source[processedContentStart] === ' '\n        ) {\n          processedContentStart++\n        }\n        processedParts.push(source.slice(processedContentStart, lineEnd))\n        if (lineEnd < source.length) processedParts.push('\\n')\n      }\n    } else {\n      // Check for lazy continuation line (line without > that continues blockquote)\n      // Inline blank line check\n      var isEmptyLine = true\n      for (var i = endPos; i < lineEnd; i++) {\n        if (!isWS(source[i])) {\n          isEmptyLine = false\n          break\n        }\n      }\n\n      // Stop blockquote if: empty line, or in code block (code blocks require > prefix)\n      if (isEmptyLine || inCodeBlock) {\n        break\n      }\n\n      const lazyIndentInfo = calculateIndent(source, endPos, lineEnd)\n      if (lazyIndentInfo.spaceEquivalent === 0) {\n        // Check if this line starts a block (excluding reference definitions which don't break blockquotes)\n        const blockResult = parseBlock(source, endPos, state, options)\n        if (\n          blockResult &&\n          blockResult.type !== RuleType.ref &&\n          blockResult.type !== RuleType.codeBlock\n        ) {\n          break\n        }\n        if (previousLineWasEmpty) {\n          break\n        }\n      }\n      processedParts.push(source.slice(endPos, lineEnd))\n      if (lineEnd < source.length) processedParts.push('\\n')\n    }\n\n    endPos = skipToNextLine(source, lineEnd)\n  }\n\n  // Empty blockquotes are valid (e.g., \">\\n\" or \">\\n>  \\n> \\n\")\n  // Only reject if we didn't process any lines at all\n  if (endPos === pos) return null\n\n  // Remove trailing newline if present (avoid endsWith check by tracking)\n  if (\n    processedParts.length > 0 &&\n    processedParts[processedParts.length - 1] === '\\n'\n  ) {\n    processedParts.pop()\n  }\n\n  let processedContent = processedParts.join('')\n\n  // Extract alert type (check start of content for [!...]\\n pattern)\n  if (\n    processedContent.length >= 4 &&\n    processedContent.charCodeAt(0) === $.CHAR_BRACKET_OPEN &&\n    processedContent.charCodeAt(1) === $.CHAR_EXCLAMATION\n  ) {\n    const alertEnd = processedContent.indexOf(']\\n', 2)\n    if (alertEnd > 2) {\n      alertType = processedContent.slice(2, alertEnd)\n      processedContent = processedContent.slice(alertEnd + 2)\n    }\n  }\n\n  const children = parseBlockQuoteChildren(processedContent, state, options)\n\n  const result: MarkdownToJSX.BlockQuoteNode & { endPos: number } = {\n    type: RuleType.blockQuote,\n    children,\n    endPos,\n  }\n  if (alertType) {\n    result.alert = alertType\n  }\n  return result\n}\n\n/** Remove extra indentation from code block text when used in list items */\nfunction removeExtraIndentFromCodeBlock(\n  codeBlockText: string,\n  extraIndent: number\n): string {\n  return codeBlockText\n    .split('\\n')\n    .map(function (line) {\n      if (line.length === 0) return line\n      let toRemove = extraIndent\n      let removed = 0\n      let i = 0\n      let currentColumn = 0\n      while (i < line.length && removed < toRemove) {\n        if (line[i] === ' ') {\n          removed++\n          currentColumn++\n          i++\n        } else if (line[i] === '\\t') {\n          const spacesFromTab = 4 - (currentColumn % 4)\n          if (removed + spacesFromTab <= toRemove) {\n            removed += spacesFromTab\n            currentColumn += spacesFromTab\n            i++\n          } else {\n            const remainingToRemove = toRemove - removed\n            const spacesToKeep = Math.max(0, spacesFromTab - remainingToRemove)\n            return ' '.repeat(spacesToKeep) + line.slice(i + 1)\n          }\n        } else {\n          break\n        }\n      }\n      return line.slice(i)\n    })\n    .join('\\n')\n}\n\nfunction appendListContinuation(\n  continuationContent: string,\n  lastItem: MarkdownToJSX.ASTNode[],\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  addNewline: boolean = true\n): void {\n  const sourceToParse = (addNewline ? '\\n' : '') + continuationContent\n  const continuationInline = parseInlineWithState(\n    sourceToParse,\n    0,\n    sourceToParse.length,\n    state,\n    options\n  )\n  if (\n    lastItem.length > 0 &&\n    lastItem[lastItem.length - 1].type === RuleType.paragraph\n  ) {\n    ;(\n      lastItem[lastItem.length - 1] as MarkdownToJSX.ParagraphNode\n    ).children.push(...continuationInline)\n  } else {\n    lastItem.push(...continuationInline)\n  }\n}\n\n// Helper: Check if list item contains block-level content\nfunction listItemHasBlockContent(item: MarkdownToJSX.ASTNode[]): boolean {\n  return item.some(function (node) {\n    return (\n      node.type === RuleType.codeBlock ||\n      node.type === RuleType.paragraph ||\n      node.type === RuleType.blockQuote ||\n      node.type === RuleType.orderedList ||\n      node.type === RuleType.unorderedList ||\n      node.type === RuleType.heading\n    )\n  })\n}\n\n// Helper: Check if line matches any list item pattern\nfunction isLineListItem(line: string): boolean {\n  return !!line.match(LIST_ITEM_R)\n}\n\n// Helper: Find deepest nested list parent in item hierarchy\nfunction findNestedListParent(\n  item: MarkdownToJSX.ASTNode[]\n): MarkdownToJSX.ASTNode[] {\n  if (item.length === 0) return item\n  var lastBlock = item[item.length - 1]\n  if (\n    (lastBlock.type === RuleType.orderedList ||\n      lastBlock.type === RuleType.unorderedList) &&\n    (\n      lastBlock as\n        | MarkdownToJSX.OrderedListNode\n        | MarkdownToJSX.UnorderedListNode\n    ).items?.length > 0\n  ) {\n    return findNestedListParent(\n      (\n        lastBlock as\n          | MarkdownToJSX.OrderedListNode\n          | MarkdownToJSX.UnorderedListNode\n      ).items.slice(-1)[0]\n    )\n  }\n  return item\n}\n\n// Helper: Skip link reference definition if present\nfunction skipLinkReferenceDefinition(\n  source: string,\n  linePos: number,\n  lineEnd: number,\n  indentInfo: ReturnType<typeof calculateIndent>,\n  lineWithoutIndent: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): number | null {\n  if (!util.startsWith(lineWithoutIndent, '[')) return null\n  var refCheckState = { inline: false, list: false, refs: state.refs || {} }\n  var refResult = parseDefinition(\n    source,\n    linePos + indentInfo.charCount,\n    refCheckState,\n    options,\n    false\n  )\n  return refResult ? refResult.endPos : null\n}\n\n// Helper: Check if we should break list due to empty item after blank line\nfunction shouldBreakForEmptyItem(\n  items: MarkdownToJSX.ASTNode[][],\n  isEmptyItem: boolean,\n  prevLineWasBlank: boolean,\n  firstItemContent: string\n): boolean {\n  if (items.length !== 1 || !prevLineWasBlank) return false\n  const lastItem = items[0] // Since items.length === 1, this is the only item\n  if (lastItem.length !== 0) return false\n  if (isEmptyItem) return true\n  if (!isEmptyItem && firstItemContent.trim() === '') return true\n  return false\n}\n\n// Helper: Calculate content start column for a list item\n// Helper: Calculate marker end position from match\nfunction calculateMarkerEnd(match: RegExpMatchArray, ordered: boolean): number {\n  var markerStart = match.index || 0\n  return ordered\n    ? markerStart + match[1].length + match[2].length + 1\n    : markerStart + match[1].length + 1\n}\n\nfunction calculateListItemContentColumn(\n  source: string,\n  contentStartInSource: number,\n  lineEnd: number,\n  baseIndent: number,\n  markerEndInLine: number\n): { contentStartColumn: number; contentStartPos: number } {\n  var spacesAfterMarker = 0\n  var col = baseIndent + markerEndInLine\n  var contentCheckPos = contentStartInSource\n  while (contentCheckPos < lineEnd && spacesAfterMarker < 4) {\n    var code = charCode(source, contentCheckPos)\n    if (code === $.CHAR_SPACE) {\n      spacesAfterMarker++\n      col++\n    } else if (code === $.CHAR_TAB) {\n      var spaces = 4 - (col % 4)\n      if (spacesAfterMarker + spaces > 4) break\n      spacesAfterMarker += spaces\n      col += spaces\n    } else {\n      break\n    }\n    contentCheckPos++\n  }\n  return { contentStartColumn: col, contentStartPos: contentCheckPos }\n}\n\nfunction matchListItem(\n  lineWithoutIndent: string\n): { match: RegExpMatchArray; ordered: boolean; listItemRegex: RegExp } | null {\n  var match = lineWithoutIndent.match(LIST_ITEM_R)\n  if (!match) return null\n\n  // Groups: 1=ordered_num, 2=ordered_delim, 3=ordered_content, 4=ordered_empty_num, 5=ordered_empty_delim, 6=unordered_marker, 7=unordered_content, 8=unordered_empty_marker\n  if (match[1]) {\n    // Ordered with content: (\\d{1,9})([.)])\\s+(.*)\n    return {\n      match: [lineWithoutIndent, match[1], match[2], match[3]],\n      ordered: true,\n      listItemRegex: ORDERED_LIST_ITEM_WITH_CONTENT_R,\n    }\n  }\n  if (match[4]) {\n    // Ordered empty: (\\d{1,9})([.)])\\s*\n    return {\n      match: [lineWithoutIndent, match[4], match[5], ''],\n      ordered: true,\n      listItemRegex: ORDERED_LIST_ITEM_WITH_CONTENT_R,\n    }\n  }\n  if (match[6]) {\n    // Unordered with content: ([-*+])\\s+(.*)\n    return {\n      match: [lineWithoutIndent, match[6], match[7]],\n      ordered: false,\n      listItemRegex: UNORDERED_LIST_ITEM_WITH_CONTENT_R,\n    }\n  }\n  if (match[8]) {\n    // Unordered empty: ([-*+])\\s*\n    return {\n      match: [lineWithoutIndent, match[8], ''],\n      ordered: false,\n      listItemRegex: UNORDERED_LIST_ITEM_WITH_CONTENT_R,\n    }\n  }\n  return null\n}\n\n// Helper: Check if a line is a matching list item for the current list\nfunction isMatchingListItem(\n  lineWithoutIndent: string,\n  indentInfo: ReturnType<typeof calculateIndent>,\n  ordered: boolean,\n  marker: string | undefined,\n  delimiter: string | undefined,\n  baseIndent: number,\n  listItemRegex: RegExp\n): boolean {\n  if (indentInfo.spaceEquivalent !== baseIndent) return false\n  var match = lineWithoutIndent.match(listItemRegex)\n  if (match) {\n    return ordered ? match[2] === delimiter : match[1] === marker\n  }\n  var emptyMatch = lineWithoutIndent.match(LIST_ITEM_R)\n  if (!emptyMatch) return false\n  if (ordered) {\n    return emptyMatch[4] && emptyMatch[5] === delimiter\n  } else {\n    return emptyMatch[8] === marker\n  }\n}\n\n// Helper: Handle fenced code blocks that span multiple lines in list items\nfunction expandMultilineFencedCodeBlock(\n  source: string,\n  itemContent: string,\n  startPos: number,\n  markerWidth: number\n): { content: string; endPos: number } {\n  var content = itemContent\n  var pos = startPos\n  var fenceChar = itemContent[0]\n  while (pos < source.length) {\n    var lineEnd = util.findLineEnd(source, pos)\n    var line = source.slice(pos, lineEnd)\n    var processedLine = util.startsWith(line, ' '.repeat(markerWidth))\n      ? line.slice(markerWidth)\n      : line\n    if (\n      util.startsWith(processedLine.trim(), fenceChar) &&\n      countConsecutiveChars(processedLine.trim(), 0, fenceChar) >= 3\n    ) {\n      return { content: content, endPos: skipToNextLine(source, lineEnd) }\n    }\n    content += '\\n' + processedLine\n    pos = skipToNextLine(source, lineEnd)\n  }\n  return { content: content, endPos: pos }\n}\n\n// Helper function to add a new list item with all standard processing\nfunction addListItem(\n  source: string,\n  items: MarkdownToJSX.ASTNode[][],\n  itemContentStartColumns: number[],\n  itemContent: string,\n  startPos: number,\n  nextLineEnd: number,\n  nextIndent: number,\n  nextIndentChars: number,\n  nextMatch: RegExpMatchArray,\n  ordered: boolean,\n  hasBlankLines: boolean,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): { newCurrentPos: number; itemHasBlankLine: boolean } {\n  // Derive marker/delimiter/regex (cheap to recompute vs passing 3 extra params)\n  var marker = ordered ? undefined : nextMatch[1]\n  var delimiter = ordered ? nextMatch[2] : undefined\n  var listItemRegex = ordered\n    ? ORDERED_LIST_ITEM_WITH_CONTENT_R\n    : UNORDERED_LIST_ITEM_WITH_CONTENT_R\n\n  // Check if item has blank lines\n  var itemHasBlankLine = hasBlankLines\n  if (!hasBlankLines) {\n    var startCheckPos = skipToNextLine(source, nextLineEnd)\n    var checkItemPos = startCheckPos\n    while (checkItemPos < source.length) {\n      var checkLineEnd = util.findLineEnd(source, checkItemPos)\n      var checkLine = source.slice(checkItemPos, checkLineEnd)\n      var checkIndentInfo = calculateIndent(source, checkItemPos, checkLineEnd)\n      var checkIndent = checkIndentInfo.spaceEquivalent\n      if (isBlankLineCheck(source, checkItemPos, checkLineEnd)) {\n        var afterBlank = skipToNextLine(source, checkLineEnd)\n        if (afterBlank < source.length) {\n          var afterBlankLineEnd = util.findLineEnd(source, afterBlank)\n          var afterBlankIndentInfo = calculateIndent(\n            source,\n            afterBlank,\n            afterBlankLineEnd\n          )\n          var afterBlankIndent = afterBlankIndentInfo.spaceEquivalent\n          var thisItemMarkerEnd = calculateMarkerEnd(nextMatch, ordered)\n          var thisItemContentStartInSource =\n            startPos + nextIndentChars + thisItemMarkerEnd\n          var thisItemResult = calculateListItemContentColumn(\n            source,\n            thisItemContentStartInSource,\n            nextLineEnd,\n            nextIndent,\n            thisItemMarkerEnd\n          )\n          var thisItemContentStartColumn = thisItemResult.contentStartColumn\n          if (afterBlankIndent + 1 > thisItemContentStartColumn) {\n            itemHasBlankLine = true\n            break\n          }\n        }\n        break\n      } else if (checkIndent <= nextIndent) {\n        var checkLineWithoutIndent = checkLine.slice(checkIndentInfo.charCount)\n        var checkMatch = checkLineWithoutIndent.match(listItemRegex)\n        if (\n          checkMatch &&\n          (ordered ? checkMatch[2] === delimiter : checkMatch[1] === marker)\n        ) {\n          break\n        }\n      }\n      checkItemPos = skipToNextLine(source, checkLineEnd)\n    }\n  }\n\n  // Calculate content start column\n  var thisItemMarkerEnd = calculateMarkerEnd(nextMatch, ordered)\n  var thisItemContentStartInSource =\n    startPos + nextIndentChars + thisItemMarkerEnd\n  var thisItemResult = calculateListItemContentColumn(\n    source,\n    thisItemContentStartInSource,\n    nextLineEnd,\n    nextIndent,\n    thisItemMarkerEnd\n  )\n  var thisItemContentStartColumn = thisItemResult.contentStartColumn\n\n  // Handle fenced code blocks\n  var actualItemContent = itemContent\n  var newCurrentPos = skipToNextLine(source, nextLineEnd)\n  if (\n    util.startsWith(itemContent, '```') ||\n    util.startsWith(itemContent, '~~~')\n  ) {\n    var markerWidth = ordered\n      ? nextMatch[1].length + nextMatch[2].length + 1\n      : nextMatch[1].length + 1\n    var expandedResult = expandMultilineFencedCodeBlock(\n      source,\n      itemContent,\n      newCurrentPos,\n      markerWidth\n    )\n    actualItemContent = expandedResult.content\n    newCurrentPos = expandedResult.endPos\n  }\n\n  // Build and add item with GFM task support\n  items.push(\n    buildListItemContent(actualItemContent, itemHasBlankLine, state, options)\n  )\n  itemContentStartColumns.push(thisItemContentStartColumn)\n\n  return { newCurrentPos, itemHasBlankLine }\n}\n\n// Helper function to process list item continuation lines\nfunction checkHTMLTagInterruptsList(\n  source: string,\n  pos: number,\n  indentChars: number,\n  baseIndent: number,\n  indent: number,\n  options: ParseOptions\n): boolean {\n  if (indent > baseIndent || options.disableParsingRawHTML) return false\n  const lineStartPos = pos + indentChars\n  if (lineStartPos >= source.length || source[lineStartPos] !== '<')\n    return false\n  return isValidHTMLTagStart(source, lineStartPos)\n}\n\n// Lightweight check for HTML tag validity without full parsing\nfunction isValidHTMLTagStart(source: string, pos: number): boolean {\n  if (pos >= source.length || source[pos] !== '<') return false\n  const len = source.length\n  let i = pos + 1\n\n  // Handle closing tags\n  if (i < len && source[i] === '/') {\n    i++\n  }\n\n  // Must have at least one character for tag name\n  if (i >= len) return false\n\n  // First character of tag name must be letter\n  const firstChar = charCode(source, i)\n  if (!isAlphaCode(firstChar)) return false\n  i++\n\n  // Rest of tag name can be letters, digits, hyphens, underscores\n  // Use early return to avoid nested conditionals\n  while (i < len) {\n    const ch = source[i]\n    const code = charCode(source, i)\n\n    // Break conditions (valid tag name terminators)\n    if (\n      ch === '>' ||\n      ch === ' ' ||\n      ch === '\\t' ||\n      ch === '\\n' ||\n      ch === '\\r' ||\n      ch === '/'\n    ) {\n      break\n    }\n\n    // Valid tag name characters - continue\n    if (\n      ch === '-' ||\n      ch === '_' ||\n      isAlphaCode(code) ||\n      (code >= 48 && code <= 57)\n    ) {\n      i++\n    } else {\n      return false // Invalid character in tag name\n    }\n  }\n\n  // Find the end of the tag - use state machine approach to reduce branching\n  let state = 0 // 0: normal, 1: in double quotes, 2: in single quotes\n  while (i < len) {\n    const ch = source[i]\n    const code = charCode(source, i)\n\n    // State machine for quote handling\n    if (state === 1) {\n      // in double quotes\n      if (ch === '\"') state = 0\n      i++\n    } else if (state === 2) {\n      // in single quotes\n      if (ch === \"'\") state = 0\n      i++\n    } else if (ch === '\"') {\n      state = 1\n      i++\n    } else if (ch === \"'\") {\n      state = 2\n      i++\n    } else if (ch === '>') {\n      return true // Found valid closing >\n    } else if (ch === '/' && i + 1 < len && source[i + 1] === '>') {\n      return true // Found valid self-closing />\n    } else if (code === 10 || code === 13) {\n      // \\n or \\r\n      return false // No multiline tags in this context\n    } else {\n      i++\n    }\n  }\n\n  return false // No closing > found\n}\n\nfunction processContinuation(\n  source: string,\n  item: MarkdownToJSX.ASTNode[],\n  contentStartColumn: number,\n  startPos: number,\n  baseIndent: number,\n  ordered: boolean,\n  marker: string | undefined,\n  delimiter: string | undefined,\n  listItemRegex: RegExp,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  allowLinkRefs?: boolean\n): number {\n  let pos = startPos\n  let prevLineWasBlank = false\n  while (pos < source.length) {\n    const lineEnd = util.findLineEnd(source, pos)\n    const indentInfo = calculateIndent(source, pos, lineEnd)\n    const indent = indentInfo.spaceEquivalent\n\n    if (isBlankLineCheck(source, pos, lineEnd)) {\n      prevLineWasBlank = true\n      pos = skipToNextLine(source, lineEnd)\n      continue\n    }\n\n    const lineWithoutIndent = source.slice(pos + indentInfo.charCount, lineEnd)\n\n    if (\n      indent <= baseIndent &&\n      isMatchingListItem(\n        lineWithoutIndent,\n        indentInfo,\n        ordered,\n        marker,\n        delimiter,\n        baseIndent,\n        listItemRegex\n      )\n    ) {\n      break\n    }\n\n    if (indent >= contentStartColumn) {\n      // Check for link reference definitions (only for first item)\n      if (allowLinkRefs && prevLineWasBlank) {\n        const refEndPos = skipLinkReferenceDefinition(\n          source,\n          pos,\n          lineEnd,\n          indentInfo,\n          lineWithoutIndent,\n          state,\n          options\n        )\n        if (refEndPos) {\n          pos = refEndPos\n          prevLineWasBlank = false\n          continue\n        }\n      }\n\n      const result = processListContinuationLine(\n        source,\n        pos,\n        lineEnd,\n        indentInfo,\n        contentStartColumn - 1,\n        contentStartColumn,\n        item,\n        prevLineWasBlank,\n        state,\n        options,\n        undefined,\n        baseIndent\n      )\n      if (result.processed) {\n        pos = result.newPos\n        prevLineWasBlank = result.wasBlank\n        continue\n      }\n    } else {\n      break\n    }\n  }\n  return pos\n}\n\n// Helper: Parse content with paragraph wrapping for tight/loose lists\nfunction parseContentWithParagraphHandling(\n  content: string,\n  wrapInParagraph: boolean,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  const blocks = parseBlocksWithState(content, state, options, {\n    inline: false,\n    list: true,\n  })\n  if (blocks.length > 0) {\n    // Unwrap single paragraph for tight lists\n    return !wrapInParagraph &&\n      blocks.length === 1 &&\n      blocks[0].type === RuleType.paragraph\n      ? (blocks[0] as MarkdownToJSX.ParagraphNode).children\n      : blocks\n  }\n  // Fallback to inline parsing\n  const inline = parseWithInlineMode(state, true, () =>\n    parseInlineSpan(content, 0, content.length, state, options)\n  )\n  return wrapInParagraph && inline.length > 0\n    ? [\n        {\n          type: RuleType.paragraph,\n          children: inline,\n        } as MarkdownToJSX.ParagraphNode,\n      ]\n    : inline\n}\n\nfunction buildListItemContent(\n  itemContent: string,\n  itemHasBlankLine: boolean,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  const task = parseGFMTask(itemContent, 0, state)\n  const hasTask =\n    task &&\n    (task.endPos >= itemContent.length || itemContent[task.endPos] === ' ')\n  if (!hasTask) {\n    return parseContentWithParagraphHandling(\n      itemContent,\n      itemHasBlankLine,\n      state,\n      options\n    )\n  }\n  const afterTask =\n    task.endPos < itemContent.length ? task.endPos + 1 : task.endPos\n  const restContent = itemContent.slice(afterTask)\n  const restNodes = parseContentWithParagraphHandling(\n    restContent,\n    itemHasBlankLine,\n    state,\n    options\n  )\n  const nodes: MarkdownToJSX.ASTNode[] = [task]\n  if (task.endPos < itemContent.length) {\n    nodes.push({ type: RuleType.text, text: ' ' } as MarkdownToJSX.TextNode)\n  }\n  nodes.push(...restNodes)\n  return nodes\n}\n\nfunction checkUnicodeWhitespaceAfterMarker(\n  match: RegExpMatchArray,\n  marker: string\n): boolean {\n  if (!match[0]) return false\n  const markerInMatch = match[0].indexOf(marker)\n  if (markerInMatch === -1) return false\n  const afterMarkerInMatch = markerInMatch + marker.length\n  if (afterMarkerInMatch >= match[0].length) return false\n  const afterMarkerChar = match[0][afterMarkerInMatch]\n  return afterMarkerChar ? charCode(afterMarkerChar) === $.CHAR_NBSP : false\n}\n\nfunction convertSetextHeadingInListItem(\n  lastItem: MarkdownToJSX.ASTNode[],\n  underlineLine: string,\n  options: ParseOptions\n): boolean {\n  if (lastItem.length === 0) return false\n  const lastBlock = lastItem[lastItem.length - 1]\n  const trimmed = underlineLine.trim()\n  if (\n    (!util.startsWith(trimmed, '=') && !util.startsWith(trimmed, '-')) ||\n    trimmed.length < 1 ||\n    !/^[=-]+[ \\t]*$/.test(trimmed)\n  ) {\n    return false\n  }\n\n  let headingChildren: MarkdownToJSX.ASTNode[] = []\n  let headingContent = ''\n  if (lastBlock.type === RuleType.paragraph) {\n    const paragraph = lastBlock as MarkdownToJSX.ParagraphNode\n    headingChildren = paragraph.children\n    headingContent = paragraph.children\n      .map(child =>\n        child.type === RuleType.text\n          ? (child as MarkdownToJSX.TextNode).text\n          : ''\n      )\n      .join('')\n      .trim()\n  } else if (lastBlock.type === RuleType.text) {\n    const textNodes: MarkdownToJSX.TextNode[] = []\n    let i = lastItem.length - 1\n    while (i >= 0 && lastItem[i].type === RuleType.text) {\n      textNodes.unshift(lastItem[i] as MarkdownToJSX.TextNode)\n      i--\n    }\n    if (textNodes.length > 0) {\n      headingChildren = textNodes\n      headingContent = textNodes\n        .map(node => (node as MarkdownToJSX.TextNode).text)\n        .join('')\n        .trim()\n    }\n  }\n\n  if (!headingContent) return false\n\n  const underlineChar = trimmed[0]\n  const level = underlineChar === '=' ? 1 : 2\n  if (lastBlock.type === RuleType.paragraph) {\n    lastItem.pop()\n  } else if (lastBlock.type === RuleType.text) {\n    while (\n      lastItem.length > 0 &&\n      lastItem[lastItem.length - 1].type === RuleType.text\n    ) {\n      lastItem.pop()\n    }\n  }\n  lastItem.push(\n    createHeading(level, headingChildren, headingContent, options.slugify)\n  )\n  return true\n}\n\nfunction processListContinuationLine(\n  source: string,\n  currentPos: number,\n  nextLineEnd: number,\n  nextIndentInfo: ReturnType<typeof calculateIndent>,\n  continuationColumn: number,\n  contentStartColumn: number,\n  lastItem: MarkdownToJSX.ASTNode[],\n  prevLineWasBlank: boolean,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  unwrapParagraphs?: boolean,\n  baseIndent?: number\n): { processed: boolean; newPos: number; wasBlank: boolean } {\n  const nextIndent = nextIndentInfo.spaceEquivalent\n  const continuationContent = source.slice(\n    currentPos + nextIndentInfo.charCount,\n    nextLineEnd\n  )\n\n  if (nextIndent >= continuationColumn + 4) {\n    const blockResult = parseCodeBlock(source, currentPos, state)\n    if (blockResult) {\n      const codeBlockNode = blockResult as MarkdownToJSX.CodeBlockNode & {\n        endPos: number\n      }\n      const adjustedText = removeExtraIndentFromCodeBlock(\n        codeBlockNode.text || '',\n        contentStartColumn\n      )\n      lastItem.push({\n        ...codeBlockNode,\n        text: adjustedText,\n      } as MarkdownToJSX.CodeBlockNode)\n      return {\n        processed: true,\n        newPos: codeBlockNode.endPos,\n        wasBlank: false,\n      }\n    }\n  }\n\n  const indentRelativeToContentFenced = nextIndent - (contentStartColumn - 1)\n  if (\n    nextIndent + 1 >= contentStartColumn &&\n    indentRelativeToContentFenced <= 3\n  ) {\n    const continuationStart = currentPos + nextIndentInfo.charCount\n    if (continuationStart < nextLineEnd) {\n      const firstCharAfterIndent = source[continuationStart]\n      if (firstCharAfterIndent === '`' || firstCharAfterIndent === '~') {\n        const fencedResult = parseCodeFenced(\n          source,\n          continuationStart,\n          state,\n          options\n        )\n        if (fencedResult) {\n          const codeBlockNode = fencedResult as MarkdownToJSX.CodeBlockNode & {\n            endPos: number\n          }\n          const adjustedText = removeExtraIndentFromCodeBlock(\n            codeBlockNode.text || '',\n            contentStartColumn - 1\n          )\n          lastItem.push({\n            ...codeBlockNode,\n            text: adjustedText,\n            endPos: codeBlockNode.endPos,\n          } as MarkdownToJSX.CodeBlockNode & { endPos: number })\n          return {\n            processed: true,\n            newPos: codeBlockNode.endPos,\n            wasBlank: false,\n          }\n        }\n      }\n      // Try parsing as table when line starts with |\n      if (firstCharAfterIndent === '|') {\n        const tableResult = parseTable(\n          source,\n          continuationStart,\n          state,\n          options\n        )\n        if (tableResult) {\n          const tableNode = tableResult as MarkdownToJSX.TableNode & {\n            endPos: number\n          }\n          lastItem.push(tableNode)\n          return {\n            processed: true,\n            newPos: tableNode.endPos,\n            wasBlank: false,\n          }\n        }\n      }\n    }\n  }\n\n  if (\n    continuationContent.length > 0 &&\n    (continuationContent[0] === '-' ||\n      continuationContent[0] === '*' ||\n      continuationContent[0] === '+' ||\n      (continuationContent[0] >= '0' && continuationContent[0] <= '9'))\n  ) {\n    const listMarkerRegex = /^([-*+]|\\d{1,9}[.)])\\s+/\n    if (listMarkerRegex.test(continuationContent)) {\n      const inline = parseInlineWithState(\n        continuationContent,\n        0,\n        continuationContent.length,\n        state,\n        options\n      )\n      lastItem.push({ type: RuleType.text, text: '\\n' }, ...inline)\n      return {\n        processed: true,\n        newPos: skipToNextLine(source, nextLineEnd),\n        wasBlank: false,\n      }\n    }\n  }\n\n  const mergedPos = tryMergeBlockquoteContinuation(\n    source,\n    currentPos,\n    lastItem,\n    continuationContent,\n    state,\n    options\n  )\n  if (mergedPos !== null) {\n    return { processed: true, newPos: mergedPos, wasBlank: false }\n  }\n\n  const continuationBlocks = parseBlocksWithState(\n    continuationContent,\n    state,\n    options,\n    { inline: false, list: true }\n  )\n  if (continuationBlocks.length > 0) {\n    if (unwrapParagraphs && continuationBlocks[0].type === RuleType.paragraph) {\n      const continuationParagraph =\n        continuationBlocks[0] as MarkdownToJSX.ParagraphNode\n      lastItem.push(\n        { type: RuleType.text, text: '\\n' } as MarkdownToJSX.TextNode,\n        ...continuationParagraph.children\n      )\n      if (continuationBlocks.length > 1) {\n        lastItem.push(...continuationBlocks.slice(1))\n      }\n    } else if (\n      !prevLineWasBlank &&\n      continuationBlocks[0].type === RuleType.paragraph &&\n      lastItem.length > 0\n    ) {\n      const lastBlock = lastItem[lastItem.length - 1]\n      const continuationParagraph =\n        continuationBlocks[0] as MarkdownToJSX.ParagraphNode\n      if (lastBlock.type === RuleType.paragraph) {\n        ;(lastBlock as MarkdownToJSX.ParagraphNode).children.push(\n          { type: RuleType.text, text: '\\n' } as MarkdownToJSX.TextNode,\n          ...continuationParagraph.children\n        )\n      } else if (lastBlock.type === RuleType.heading) {\n        lastItem.push(...continuationParagraph.children)\n      } else if (!listItemHasBlockContent(lastItem)) {\n        lastItem.push(\n          { type: RuleType.text, text: ' ' } as MarkdownToJSX.TextNode,\n          ...continuationParagraph.children\n        )\n      } else {\n        lastItem.push(...continuationBlocks)\n      }\n      if (continuationBlocks.length > 1) {\n        lastItem.push(...continuationBlocks.slice(1))\n      }\n    } else {\n      lastItem.push(...continuationBlocks)\n    }\n    return {\n      processed: true,\n      newPos: skipToNextLine(source, nextLineEnd),\n      wasBlank: false,\n    }\n  }\n\n  if (prevLineWasBlank) {\n    const inline = parseWithInlineMode(state, true, () =>\n      parseInlineSpan(\n        continuationContent,\n        0,\n        continuationContent.length,\n        state,\n        options\n      )\n    )\n    lastItem.push({\n      type: RuleType.paragraph,\n      children: inline,\n    } as MarkdownToJSX.ParagraphNode)\n  } else {\n    appendListContinuation(continuationContent, lastItem, state, options)\n  }\n  return {\n    processed: true,\n    newPos: skipToNextLine(source, nextLineEnd),\n    wasBlank: false,\n  }\n}\n\nfunction parseList(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline) return null\n\n  // Set inList state for proper GFM task tracking during inline parsing\n  var originalInList = state.inList\n  state.inList = true\n\n  // Lists must start at the beginning of a line (block boundary)\n  if (pos > 0) {\n    var prevCharCode = charCode(source, pos - 1)\n    if (prevCharCode !== $.CHAR_NEWLINE && prevCharCode !== $.CHAR_CR) {\n      state.inList = originalInList\n      return null\n    }\n  }\n\n  var lineEnd = util.findLineEnd(source, pos)\n  var indentInfo = calculateIndent(source, pos, lineEnd)\n  // Early fail: headings/lists cannot be indented more than 3 spaces unless in list context\n  if (indentInfo.spaceEquivalent > 3 && !state.inList) {\n    state.inList = originalInList\n    return null\n  }\n  var line = source.slice(pos, lineEnd)\n  var indent = indentInfo.charCount\n  var lineWithoutIndent = line.slice(indent)\n\n  // Detect list type: ordered (digit marker) vs unordered (-/*/+ marker)\n  var matchResult = matchListItem(lineWithoutIndent)\n  if (!matchResult) {\n    state.inList = originalInList\n    return null\n  }\n  var match = matchResult.match\n  var ordered = matchResult.ordered\n  var listItemRegex = matchResult.listItemRegex\n\n  var baseIndent = indentInfo.spaceEquivalent\n  // Extract list-specific properties: start number and delimiter for ordered, marker for unordered\n  var start = ordered ? parseInt(match[1], 10) : undefined\n  var delimiter = ordered ? match[2] : undefined // '.' or ')' for ordered lists\n  var marker = ordered ? undefined : match[1] // '-', '*', or '+' for unordered lists\n\n  // Check if this is an empty list item (no content after marker)\n  var isEmptyItem = ordered ? match[3] === '' : match[2] === ''\n\n  // Helper: Check if we're at a block boundary (document start or after blank line)\n  function isAtBlockBoundary(\n    checkPos: number,\n    requireBlankLine: boolean\n  ): boolean {\n    if (checkPos === 0) return true\n    var prevCode = charCode(source, checkPos - 1)\n    if (prevCode !== $.CHAR_NEWLINE) return false\n    if (!requireBlankLine) return true\n    var backPos = checkPos - 2\n    while (backPos >= 0) {\n      var code = charCode(source, backPos)\n      if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB) break\n      backPos--\n    }\n    return backPos < 0 || charCode(source, backPos) === $.CHAR_NEWLINE\n  }\n\n  // Per CommonMark: empty list items cannot interrupt paragraphs (need blank line)\n  if (isEmptyItem && !isAtBlockBoundary(pos, true)) {\n    state.inList = originalInList\n    return null\n  }\n\n  // Per CommonMark: only ordered lists starting with 1 can interrupt paragraphs\n  if (ordered && start !== 1 && !isAtBlockBoundary(pos, false)) {\n    return null\n  }\n\n  // For unordered lists, check that the whitespace after marker is regular space/tab, not Unicode whitespace\n  if (!ordered && checkUnicodeWhitespaceAfterMarker(match, marker)) {\n    return null\n  }\n\n  // Calculate the content start column: where the first non-whitespace character\n  // after the marker delimiter actually appears in the source\n  // This is needed to determine continuation indentation\n  var markerStartInLine = match.index || 0\n  // isEmptyItem is already set above - check if it needs updating based on spacesAfterMarkerCount\n  // Empty item is different from item with whitespace but no content\n  // We'll calculate spacesAfterMarkerCount later and update isEmptyItem if needed\n  var markerEndInLine = ordered\n    ? markerStartInLine + match[1].length + match[2].length + 1 // number + delimiter + required space\n    : isEmptyItem\n      ? markerStartInLine + match[1].length // marker only (no space)\n      : markerStartInLine + match[1].length + 1 // marker + required space\n  // Find the actual position after marker delimiter in the source\n  var contentStartInSource = pos + indent + markerEndInLine\n  // Count spaces/tabs before first non-whitespace in the content\n  // Per CommonMark spec: marker must be followed by 1 â‰¤ N â‰¤ 4 spaces\n  var contentColumnResult = calculateListItemContentColumn(\n    source,\n    contentStartInSource,\n    lineEnd,\n    baseIndent,\n    markerEndInLine\n  )\n  var contentStartColumn = contentColumnResult.contentStartColumn\n  // minimumContentStartColumn is the minimum column where content can start (for continuation checks)\n  // This is the column after marker+space, regardless of how much whitespace follows\n  // For empty items, it's right after the marker\n  var markerBaseColumn = baseIndent + markerStartInLine + match[1].length\n  var minimumContentStartColumn = ordered\n    ? markerBaseColumn + match[2].length + 1 // number + delimiter + space\n    : isEmptyItem\n      ? markerBaseColumn // marker only (no space)\n      : markerBaseColumn + 1 // marker + space\n\n  var items: MarkdownToJSX.ASTNode[][] = []\n  // Track contentStartColumn for each item (for nested list detection)\n  var itemContentStartColumns: number[] = []\n\n  // Helper: Check if a marker column is nested enough to belong to the last item\n  function isMarkerNested(\n    markerColumn: number,\n    lastItemContentColumn: number,\n    hasBlockContent: boolean\n  ): boolean {\n    return hasBlockContent\n      ? markerColumn >= lastItemContentColumn\n      : markerColumn > lastItemContentColumn\n  }\n\n  // Helper: Get last item\n  function getLastItem(): MarkdownToJSX.ASTNode[] {\n    return items[items.length - 1]\n  }\n\n  // Helper: Get last item's content start column\n  function getLastItemContentColumn(): number {\n    return (\n      itemContentStartColumns[itemContentStartColumns.length - 1] ??\n      contentStartColumn\n    )\n  }\n\n  function tryParseNestedList(\n    pos: number,\n    lastItem: MarkdownToJSX.ASTNode[]\n  ): ParseResult | null {\n    const parentItem = findNestedListParent(lastItem)\n    const originalList = state.inList\n    state.inList = true\n    const result = parseList(source, pos, state, options)\n    state.inList = originalList\n    if (result) {\n      parentItem.push(result)\n      return result\n    }\n    return null\n  }\n\n  var currentPos = skipToNextLine(source, lineEnd)\n\n  // Check if this is a loose list (has blank lines)\n  var checkPos = currentPos\n  var hasBlankLines = false\n\n  while (checkPos < source.length) {\n    var nextLineEnd = util.findLineEnd(source, checkPos)\n    var nextLine = source.slice(checkPos, nextLineEnd)\n    if (nextLine.trim() === '') {\n      // look ahead to next non-empty line\n      var look = skipToNextLine(source, nextLineEnd)\n      while (look < source.length) {\n        var code = charCode(source, look)\n        if (code === $.CHAR_NEWLINE) {\n          // keep skipping\n        } else if (!WHITESPACE_CHARS.has(source[look])) {\n          break\n        }\n        look++\n      }\n      var lookEnd = util.findLineEnd(source, look)\n      var lookLine = source.slice(look, lookEnd)\n      var lookIndentInfo = calculateIndent(source, look, lookEnd)\n      var lookLineWithoutIndent = lookLine.slice(lookIndentInfo.charCount)\n      if (\n        isMatchingListItem(\n          lookLineWithoutIndent,\n          lookIndentInfo,\n          ordered,\n          marker,\n          delimiter,\n          baseIndent,\n          listItemRegex\n        )\n      ) {\n        hasBlankLines = true\n      } else {\n        // Per CommonMark: link reference definitions can interrupt lists\n        // If blank line is followed by a link reference definition, check if there's a list item after it\n        var refEndPos = skipLinkReferenceDefinition(\n          source,\n          look,\n          lookEnd,\n          lookIndentInfo,\n          lookLineWithoutIndent,\n          state,\n          options\n        )\n        if (refEndPos) {\n          var afterRefPos = refEndPos\n          while (\n            afterRefPos < source.length &&\n            charCode(source, afterRefPos) === $.CHAR_NEWLINE\n          ) {\n            afterRefPos++\n          }\n          if (afterRefPos < source.length) {\n            var afterRefLineEnd = util.findLineEnd(source, afterRefPos)\n            var afterRefLine = source.slice(afterRefPos, afterRefLineEnd)\n            var afterRefIndentInfo = calculateIndent(\n              source,\n              afterRefPos,\n              afterRefLineEnd\n            )\n            var afterRefLineWithoutIndent = afterRefLine.slice(\n              afterRefIndentInfo.charCount\n            )\n            if (\n              isMatchingListItem(\n                afterRefLineWithoutIndent,\n                afterRefIndentInfo,\n                ordered,\n                marker,\n                delimiter,\n                baseIndent,\n                listItemRegex\n              )\n            ) {\n              hasBlankLines = true\n            }\n          }\n        }\n      }\n      break\n    }\n    var nextIndentInfo = calculateIndent(source, checkPos, nextLineEnd)\n    var nextLineWithoutIndent = nextLine.slice(nextIndentInfo.charCount)\n    var nextMatchResult = matchListItem(nextLineWithoutIndent)\n    if (!nextMatchResult) break\n    var nextMatch = nextMatchResult.match\n    if (ordered) {\n      if (nextMatch[2] !== delimiter) break\n    } else {\n      if (nextMatch[1] !== marker) break\n    }\n    checkPos = skipToNextLine(source, nextLineEnd)\n  }\n\n  // Parse the first item\n  var firstItemContent = ordered ? match[3] : match[2]\n  // Trim leading whitespace from content (regex now captures optional whitespace)\n  firstItemContent = firstItemContent.trimStart()\n\n  // Per CommonMark spec: tabs after list marker need special handling\n  // For `-\\t\\tfoo`: `-` at column 0, first tab at column 1 = 3 spaces (one for marker delimiter),\n  // second tab at column 4 = 4 spaces, total 6 spaces, so code block with 2 spaces remaining\n  // The regex `\\s+` consumes the tabs, so match[2]/match[3] is just `foo`\n  // We need to check the original source to detect tabs after the marker\n  var markerStartPos = pos + indent + (match.index || 0)\n  var markerEndPos = ordered\n    ? markerStartPos + match[1].length + match[2].length // number + delimiter\n    : markerStartPos + match[1].length // marker\n\n  // Check for spaces after marker (for code blocks with 5+ spaces)\n  // Per CommonMark: if there are 4+ spaces after the marker (including required space),\n  // the first line is an indented code block\n  var contentStartPos = markerEndPos\n  // Skip the required space/tab after marker\n  while (contentStartPos < source.length) {\n    var code = charCode(source, contentStartPos)\n    if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB) break\n    contentStartPos++\n  }\n  // Count spaces after marker (including the required one)\n  var spacesAfterMarkerCount = 0\n  var spacesCheckPos = markerEndPos\n  while (spacesCheckPos < lineEnd) {\n    var code = charCode(source, spacesCheckPos)\n    if (code === $.CHAR_TAB) {\n      spacesAfterMarkerCount += 4 - (spacesAfterMarkerCount % 4)\n    } else if (code === $.CHAR_SPACE) {\n      spacesAfterMarkerCount++\n    } else {\n      break\n    }\n    spacesCheckPos++\n  }\n\n  var tabsProcessed = false\n  if (\n    markerEndPos < source.length &&\n    charCode(source, markerEndPos) === $.CHAR_TAB\n  ) {\n    // First tab after marker was consumed by `\\s+`\n    // Tab at column 1 = 3 spaces (1 for delimiter, 2 for content)\n    // Check if there's a second tab\n    var tabCount = 1\n    var tabCheckPos = markerEndPos + 1\n    while (\n      tabCheckPos < source.length &&\n      charCode(source, tabCheckPos) === $.CHAR_TAB\n    ) {\n      tabCount++\n      tabCheckPos++\n    }\n\n    if (tabCount >= 2) {\n      // We have 2+ tabs after marker: first gives 2 spaces, second at column 4 = 4 spaces\n      // Total: 6 spaces, then remove 4 for code block = 2 spaces\n      firstItemContent = '      ' + firstItemContent\n      tabsProcessed = true\n    }\n  }\n  // Update isEmptyItem now that we know spacesAfterMarkerCount\n  // Empty item is one with no whitespace after marker (spacesAfterMarkerCount === 0)\n  // For unordered lists, also check that match[2] is empty (no content captured)\n  if (!ordered) {\n    isEmptyItem = isEmptyItem && spacesAfterMarkerCount === 0\n  }\n  // RULE_2_CODE_START: if 4+ spaces after marker, first line is indented code block\n  // Skip if tabs were already processed (they already account for code block indentation)\n  if (spacesAfterMarkerCount >= 4 && !tabsProcessed) {\n    // Preserve the leading spaces for code blocks\n    const preservedSpaces = ' '.repeat(spacesAfterMarkerCount - 1)\n    firstItemContent = preservedSpaces + firstItemContent.trimStart()\n  }\n\n  // RULE_3_BLANK_START: check if item starts with blank line\n  // If firstItemContent is empty (just whitespace), this is RULE_3_BLANK_START\n  var startsWithBlankLine = firstItemContent.trim() === ''\n  if (startsWithBlankLine) {\n    // For RULE_3_BLANK_START, content starts after blank line(s)\n    // Continuation lines need to be indented by W + 1 spaces minimum\n    // W is the width of the marker (1 for '-', 2 for '10.', etc.)\n    // So minimum continuation indent is markerWidth + 1\n  }\n\n  // Check if there will be blank lines within the first item (after currentPos)\n  // by looking ahead to see if we'll encounter a blank line before the next item or end\n  let firstItemHasBlankLine = hasBlankLines\n  if (!hasBlankLines && currentPos < source.length) {\n    var firstCheckPos = currentPos\n    while (firstCheckPos < source.length) {\n      var firstNextLineEnd = util.findLineEnd(source, firstCheckPos)\n      var firstNextLine = source.slice(firstCheckPos, firstNextLineEnd)\n      if (isBlankLineCheck(source, firstCheckPos, firstNextLineEnd)) {\n        // Found blank line - check if continuation belongs to nested list or first item\n        var afterBlank = skipToNextLine(source, firstNextLineEnd)\n        // Skip consecutive blank lines\n        while (afterBlank < source.length) {\n          var blankLineEnd = util.findLineEnd(source, afterBlank)\n          if (isBlankLineCheck(source, afterBlank, blankLineEnd)) {\n            afterBlank = skipToNextLine(source, blankLineEnd)\n          } else {\n            break\n          }\n        }\n\n        if (afterBlank < source.length) {\n          var afterIndentInfo = calculateIndent(\n            source,\n            afterBlank,\n            source.length\n          )\n          var afterIndent = afterIndentInfo.spaceEquivalent\n          if (afterIndent >= baseIndent) {\n            var afterLine = source.slice(\n              afterBlank,\n              util.findLineEnd(source, afterBlank)\n            )\n            var afterMatch = afterLine\n              .slice(afterIndentInfo.charCount)\n              .match(listItemRegex)\n            var afterIsNewItem =\n              afterMatch &&\n              (ordered ? afterMatch[2] === delimiter : afterMatch[1] === marker)\n\n            // Find nested item before blank line and calculate its content column\n            var nestedItemContentColumn = null\n            for (\n              var nestedCheckPos = currentPos;\n              nestedCheckPos < firstCheckPos;\n              nestedCheckPos = util.findLineEnd(source, nestedCheckPos) + 1\n            ) {\n              var nestedCheckLineEnd = util.findLineEnd(source, nestedCheckPos)\n              var nestedCheckIndentInfo = calculateIndent(\n                source,\n                nestedCheckPos,\n                nestedCheckLineEnd\n              )\n              var nestedCheckMatch = source\n                .slice(nestedCheckPos, nestedCheckLineEnd)\n                .slice(nestedCheckIndentInfo.charCount)\n                .match(listItemRegex)\n              var isNestedItem =\n                nestedCheckMatch &&\n                nestedCheckIndentInfo.spaceEquivalent > baseIndent &&\n                nestedCheckIndentInfo.spaceEquivalent >= contentStartColumn &&\n                (ordered\n                  ? nestedCheckMatch[2] === delimiter\n                  : nestedCheckMatch[1] === marker)\n\n              if (isNestedItem) {\n                // Calculate nested item's content column (same pattern as contentStartColumn)\n                var nestedMarkerStart =\n                  nestedCheckIndentInfo.spaceEquivalent + 1\n                var nestedMarkerEnd = ordered\n                  ? nestedMarkerStart +\n                    nestedCheckMatch[1].length +\n                    nestedCheckMatch[2].length +\n                    1\n                  : nestedMarkerStart + nestedCheckMatch[1].length + 1\n                var nestedContentStartInSource =\n                  nestedCheckPos +\n                  nestedCheckIndentInfo.charCount +\n                  nestedCheckMatch[0].length\n                var nestedResult = calculateListItemContentColumn(\n                  source,\n                  nestedContentStartInSource,\n                  nestedCheckLineEnd,\n                  nestedMarkerStart,\n                  nestedMarkerEnd - nestedMarkerStart\n                )\n                nestedItemContentColumn = nestedResult.contentStartColumn\n                break\n              }\n            }\n\n            var continuationCheckColumn =\n              spacesAfterMarkerCount >= 5\n                ? minimumContentStartColumn\n                : contentStartColumn\n            if (\n              !afterIsNewItem &&\n              afterIndent >= continuationCheckColumn &&\n              (nestedItemContentColumn === null ||\n                afterIndent + 1 < nestedItemContentColumn)\n            ) {\n              firstItemHasBlankLine = true\n            }\n          }\n        }\n        break\n      }\n      // Check if this line is a new list item (at same or greater indentation)\n      var firstLineIndentInfo = calculateIndent(\n        source,\n        firstCheckPos,\n        firstNextLineEnd\n      )\n      var firstIndent = firstLineIndentInfo.spaceEquivalent\n      var firstLineWithoutIndent = firstNextLine.slice(\n        firstLineIndentInfo.charCount\n      )\n      var firstLineMatch = firstLineWithoutIndent.match(listItemRegex)\n      var firstIsNewItem =\n        firstLineMatch &&\n        (ordered\n          ? firstLineMatch[2] === delimiter\n          : firstLineMatch[1] === marker)\n      // If it's a new item at baseIndent, it's the next item at same level - stop looking\n      // For nested items, continue looking for blank lines after the nested list\n      if (firstIsNewItem) {\n        if (firstIndent <= baseIndent) {\n          // Same level or higher - stop looking\n          break\n        }\n        // Nested list - continue looking (don't break)\n      }\n      firstCheckPos = skipToNextLine(source, firstNextLineEnd)\n    }\n  }\n\n  // Handle fenced code blocks that span multiple lines\n  // Note: We use manual expansion here rather than parseCodeFenced because\n  // we need to return a content string (with fence lines) that will be parsed later,\n  // not an AST node. parseCodeFenced returns an AST node, which doesn't fit this use case.\n  var actualFirstItemContent = firstItemContent\n  if (\n    util.startsWith(firstItemContent, '```') ||\n    util.startsWith(firstItemContent, '~~~')\n  ) {\n    var markerWidth = ordered\n      ? match[1].length + match[2].length + 1\n      : match[1].length + 1\n    var expandedResult = expandMultilineFencedCodeBlock(\n      source,\n      firstItemContent,\n      currentPos,\n      markerWidth\n    )\n    actualFirstItemContent = expandedResult.content\n    currentPos = expandedResult.endPos\n  }\n\n  // For tight lists with whitespace-only first line, combine with continuation to avoid multiple blocks\n  var hasWhitespaceButNoContent =\n    !isEmptyItem &&\n    firstItemContent.trim() === '' &&\n    spacesAfterMarkerCount > 0 &&\n    spacesAfterMarkerCount < 5\n  // For ALL tight lists (no blank lines), concatenate simple text continuation lines BEFORE\n  // building the item content. This is necessary to preserve hard line breaks (two trailing\n  // spaces before newline) that would otherwise be lost when first line and continuation are\n  // parsed separately. The broader condition (not just whitespace-only first lines) is safe\n  // because we stop collecting text when we hit NEW block elements (not continuations of the\n  // same block element), which ensures block-level structures are still parsed correctly.\n  if (!firstItemHasBlankLine) {\n    // Detect if the first line starts a blockquote (to allow continuation lines)\n    var firstLineFirstChar =\n      actualFirstItemContent.length > 0 ? actualFirstItemContent[0] : ''\n    var firstLineStartsBlockQuote = firstLineFirstChar === '>'\n\n    var pos = currentPos\n    while (pos < source.length) {\n      var lineEnd = util.findLineEnd(source, pos)\n      var line = source.slice(pos, lineEnd)\n      if (line.trim() === '') break\n      var indentInfo = calculateIndent(source, pos, lineEnd)\n      if (indentInfo.spaceEquivalent < minimumContentStartColumn) break\n      var lineWithoutIndent = line.slice(indentInfo.charCount)\n      if (\n        indentInfo.spaceEquivalent <= baseIndent &&\n        isMatchingListItem(\n          lineWithoutIndent,\n          indentInfo,\n          ordered,\n          marker,\n          delimiter,\n          baseIndent,\n          listItemRegex\n        )\n      ) {\n        break\n      }\n      // Check for nested list items\n      if (\n        isLineListItem(lineWithoutIndent) &&\n        indentInfo.spaceEquivalent > baseIndent\n      ) {\n        break\n      }\n      // Check for block elements - stop collecting text if we hit a NEW block element\n      // (not a continuation of the same block element started on the first line)\n      var firstChar = lineWithoutIndent.length > 0 ? lineWithoutIndent[0] : ''\n      // Allow blockquote continuation if first line started a blockquote\n      var isBlockQuoteContinuation =\n        firstChar === '>' && firstLineStartsBlockQuote\n      if (\n        (firstChar === '>' && !isBlockQuoteContinuation) ||\n        firstChar === '#' ||\n        util.startsWith(lineWithoutIndent, '```') ||\n        util.startsWith(lineWithoutIndent, '~~~')\n      ) {\n        break\n      }\n      actualFirstItemContent += '\\n' + lineWithoutIndent\n      currentPos = pos = skipToNextLine(source, lineEnd)\n    }\n  }\n\n  // Build first item with GFM task support\n  items.push(\n    buildListItemContent(\n      actualFirstItemContent,\n      firstItemHasBlankLine,\n      state,\n      options\n    )\n  )\n  itemContentStartColumns.push(contentStartColumn)\n\n  // Process continuation lines for the first item\n  // For tight lists (no blank lines), also process continuation if it's indented enough\n  const shouldProcessContinuation =\n    firstItemHasBlankLine &&\n    (spacesAfterMarkerCount >= 5 || hasWhitespaceButNoContent)\n  if (shouldProcessContinuation) {\n    const lastItem = getLastItem()\n    currentPos = processContinuation(\n      source,\n      lastItem,\n      minimumContentStartColumn,\n      currentPos,\n      baseIndent,\n      ordered,\n      marker,\n      delimiter,\n      listItemRegex,\n      state,\n      options,\n      true\n    )\n  } else if (!firstItemHasBlankLine) {\n    // For tight lists (no blank lines), process continuation lines\n    const continuationColumn = minimumContentStartColumn - 1\n    while (currentPos < source.length) {\n      const nextLineEnd = util.findLineEnd(source, currentPos)\n      const nextLine = source.slice(currentPos, nextLineEnd)\n      const nextIndentInfo = calculateIndent(source, currentPos, nextLineEnd)\n      const nextIndent = nextIndentInfo.spaceEquivalent\n      const nextLineWithoutIndent = nextLine.slice(nextIndentInfo.charCount)\n\n      if (\n        nextLine.trim() === '' ||\n        (nextIndent <= baseIndent &&\n          isMatchingListItem(\n            nextLineWithoutIndent,\n            nextIndentInfo,\n            ordered,\n            marker,\n            delimiter,\n            baseIndent,\n            listItemRegex\n          )) ||\n        (isLineListItem(nextLineWithoutIndent) && nextIndent > baseIndent) ||\n        nextIndent < continuationColumn\n      ) {\n        break\n      }\n\n      const lastItem = getLastItem()\n      const result = processListContinuationLine(\n        source,\n        currentPos,\n        nextLineEnd,\n        nextIndentInfo,\n        continuationColumn,\n        contentStartColumn,\n        lastItem,\n        false,\n        state,\n        options,\n        true,\n        baseIndent\n      )\n      if (result.processed) {\n        currentPos = result.newPos\n      } else {\n        break\n      }\n    }\n  }\n\n  // Continue parsing subsequent list items\n  var prevLineWasBlank = false\n  while (currentPos < source.length) {\n    const nextLineEnd = util.findLineEnd(source, currentPos)\n\n    const nextLine = source.slice(currentPos, nextLineEnd)\n    const nextIndentInfo = calculateIndent(source, currentPos, nextLineEnd)\n    const nextIndentChars = nextIndentInfo.charCount\n    const nextIndent = nextIndentInfo.spaceEquivalent\n\n    if (nextLine.trim() === '') {\n      // Blank line - mark as loose list and continue\n      hasBlankLines = true\n      prevLineWasBlank = true\n      currentPos = skipToNextLine(source, nextLineEnd)\n    } else if (nextIndent < baseIndent) {\n      const nextLineWithoutIndent = nextLine.slice(nextIndentChars)\n      if (\n        nextLineWithoutIndent.startsWith('<') &&\n        checkHTMLTagInterruptsList(\n          source,\n          currentPos,\n          nextIndentChars,\n          baseIndent,\n          nextIndent,\n          options\n        )\n      ) {\n        break\n      }\n\n      // Less indented - check if this is a lazy continuation line\n      // Per CommonMark: lazy continuation lines can have all indentation deleted\n      // They are still part of the list item if they are paragraph continuation text\n      const trimmed = nextLineWithoutIndent.trim()\n      if (\n        trimmed.length > 0 &&\n        items.length > 0 &&\n        !isBlockStartChar(trimmed[0]) &&\n        !isMatchingListItem(\n          nextLineWithoutIndent,\n          nextIndentInfo,\n          ordered,\n          marker,\n          delimiter,\n          baseIndent,\n          listItemRegex\n        )\n      ) {\n        const lastItem = getLastItem()\n        if (lastItem.length > 0) {\n          const lastBlock = lastItem[lastItem.length - 1]\n          if (\n            !prevLineWasBlank &&\n            (lastBlock.type === RuleType.paragraph ||\n              lastBlock.type === RuleType.text)\n          ) {\n            // This is a lazy continuation line - continue the paragraph\n            // Per CommonMark: lazy continuation only applies when there's no blank line\n            appendListContinuation(\n              nextLineWithoutIndent,\n              lastItem,\n              state,\n              options\n            )\n            prevLineWasBlank = false\n            currentPos = skipToNextLine(source, nextLineEnd)\n            continue\n          }\n        }\n      }\n      // Not a lazy continuation - end of list\n      break\n    } else {\n      const nextLineWithoutIndent = nextLine.slice(nextIndentChars)\n\n      // Check for setext heading BEFORE thematic break\n      // If last item ends with text/paragraph and this line is setext underline, convert to heading\n      // Per CommonMark: setext underline must be indented enough to be continuation\n      // BUT: don't check if this line is a list item marker (would be continuation of wrong item)\n      if (items.length > 0) {\n        const lastItemContentStartColumn =\n          itemContentStartColumns[items.length - 1] || contentStartColumn\n        if (\n          nextIndent + 1 >= lastItemContentStartColumn &&\n          !isMatchingListItem(\n            nextLineWithoutIndent,\n            nextIndentInfo,\n            ordered,\n            marker,\n            delimiter,\n            baseIndent,\n            listItemRegex\n          )\n        ) {\n          const lastItem = getLastItem()\n          if (\n            lastItem.length > 0 &&\n            convertSetextHeadingInListItem(\n              lastItem,\n              nextLineWithoutIndent,\n              options\n            )\n          ) {\n            currentPos = skipToNextLine(source, nextLineEnd)\n            continue\n          }\n        }\n      }\n\n      // Check if this line is a thematic break (per CommonMark, thematic breaks end lists)\n      const thematicBreakResult = parseBreakThematic(\n        source,\n        currentPos,\n        state,\n        options\n      )\n      if (thematicBreakResult) {\n        // Thematic break ends the list\n        break\n      }\n\n      // Per CommonMark spec: link reference definitions interrupt list continuation\n      // Check if this is a link reference definition after a blank line\n      if (prevLineWasBlank) {\n        const refEndPos = skipLinkReferenceDefinition(\n          source,\n          currentPos,\n          nextLineEnd,\n          nextIndentInfo,\n          nextLineWithoutIndent,\n          state,\n          options\n        )\n        if (refEndPos) {\n          // Skip link reference definition and continue parsing list (don't break)\n          currentPos = refEndPos\n          prevLineWasBlank = false\n          continue\n        }\n      }\n\n      // If line is at base indentation and not a list item, check for lazy continuation first\n      if (nextIndent <= baseIndent) {\n        if (\n          nextLineWithoutIndent.startsWith('<') &&\n          checkHTMLTagInterruptsList(\n            source,\n            currentPos,\n            nextIndentChars,\n            baseIndent,\n            nextIndent,\n            options\n          )\n        ) {\n          break\n        }\n\n        if (\n          !isMatchingListItem(\n            nextLineWithoutIndent,\n            nextIndentInfo,\n            ordered,\n            marker,\n            delimiter,\n            baseIndent,\n            listItemRegex\n          )\n        ) {\n          // Check for lazy continuation when nextIndent === baseIndent\n          // Per CommonMark: lazy continuation lines can have all indentation deleted\n          // BUT: only if there was no blank line before (lazy continuation requires no blank line)\n          // AND: only if it's truly paragraph continuation text (not a block start)\n          if (nextIndent === baseIndent && !prevLineWasBlank) {\n            const trimmed = nextLineWithoutIndent.trim()\n            if (trimmed.length > 0 && !isBlockStartChar(trimmed[0])) {\n              // Check if this line would start a block (like HTML comment, thematic break, etc.)\n              // If so, it should break the list, not continue it\n              const blockResult = parseBlock(source, currentPos, state, options)\n              if (blockResult && blockResult.type !== RuleType.paragraph) {\n                break\n              }\n              const lastItem = getLastItem()\n              if (lastItem.length > 0 && !listItemHasBlockContent(lastItem)) {\n                // Continuation line at base indentation - add newline for proper spacing\n                appendListContinuation(\n                  nextLineWithoutIndent,\n                  lastItem,\n                  state,\n                  options,\n                  true\n                )\n                prevLineWasBlank = false\n                currentPos = skipToNextLine(source, nextLineEnd)\n                continue\n              }\n            }\n          }\n          break\n        }\n      }\n\n      // Check for empty items with blank lines\n      if (\n        shouldBreakForEmptyItem(\n          items,\n          isEmptyItem,\n          prevLineWasBlank,\n          firstItemContent\n        )\n      )\n        break\n\n      const nextMatchResult = matchListItem(nextLineWithoutIndent)\n      const nextMatch = nextMatchResult ? nextMatchResult.match : null\n      const isSameType =\n        nextMatch &&\n        (ordered ? nextMatch[2] === delimiter : nextMatch[1] === marker)\n      // Per CommonMark: list markers may be indented by up to 3 spaces\n      // If marker is too indented (> 3 spaces), it's not a valid list item\n      // If there's a blank line before such a marker, end the list (e.g., Example 313)\n      if (isSameType && nextIndent > 3 && prevLineWasBlank) {\n        break\n      }\n      // Skip list item processing and fall through to continuation check\n      if (isSameType && nextIndent <= baseIndent + 3) {\n        if (nextIndent >= 4 && prevLineWasBlank) break\n        if (nextIndent === baseIndent) {\n          // Item at same level - parse as new item\n          let itemContent = ordered ? nextMatch[3] : nextMatch[2]\n          itemContent = itemContent.trimStart()\n\n          const result = addListItem(\n            source,\n            items,\n            itemContentStartColumns,\n            itemContent,\n            currentPos,\n            nextLineEnd,\n            nextIndent,\n            nextIndentChars,\n            nextMatch,\n            ordered,\n            hasBlankLines,\n            state,\n            options\n          )\n          currentPos = result.newCurrentPos\n          prevLineWasBlank = false\n\n          // For empty items, process continuation immediately\n          if (itemContent.trim() === '') {\n            const newItem = items[items.length - 1]\n            const thisItemContentStartColumn = getLastItemContentColumn()\n            currentPos = processContinuation(\n              source,\n              newItem,\n              thisItemContentStartColumn,\n              currentPos,\n              baseIndent,\n              ordered,\n              marker,\n              delimiter,\n              listItemRegex,\n              state,\n              options\n            )\n          }\n\n          continue\n        }\n        if (nextIndent > baseIndent) {\n          // Per CommonMark spec: items are only nested if indented enough to belong to previous item\n          // If there was a blank line before this item, it's at the same level (not nested)\n          if (prevLineWasBlank) {\n            // Blank line before item means it's a new item at same level, not nested\n            let itemContent = ordered ? nextMatch[3] : nextMatch[2]\n            // Trim leading whitespace from content (regex now captures optional whitespace)\n            itemContent = itemContent.trimStart()\n            const result = addListItem(\n              source,\n              items,\n              itemContentStartColumns,\n              itemContent,\n              currentPos,\n              nextLineEnd,\n              nextIndent,\n              nextIndentChars,\n              nextMatch,\n              ordered,\n              hasBlankLines,\n              state,\n              options\n            )\n            currentPos = result.newCurrentPos\n            prevLineWasBlank = false\n            continue\n          }\n          // Check if this item's marker position is indented enough to be continuation of previous item\n          // We need to calculate the previous item's contentStartColumn, not use the first item's\n          const lastItem = getLastItem()\n          const markerColumn = nextIndent + 1\n          const isNested = isMarkerNested(\n            markerColumn,\n            getLastItemContentColumn(),\n            listItemHasBlockContent(lastItem)\n          )\n\n          if (isNested) {\n            const nestedResult = tryParseNestedList(currentPos, lastItem)\n            if (nestedResult) {\n              currentPos = nestedResult.endPos\n              prevLineWasBlank = false\n              continue\n            }\n          }\n          // Item is not indented enough to be nested - check if it's same type for same level\n          if (!isNested && isSameType) {\n            // This item has more indentation than baseIndent but not enough to be nested\n            // It's still at the same level - parse it as a new item\n            let itemContent = ordered ? nextMatch[3] : nextMatch[2]\n            // Trim leading whitespace from content\n            itemContent = itemContent.trimStart()\n            if (!hasBlankLines) {\n              // Check if this item has blank lines within it\n              let checkItemPos = skipToNextLine(source, nextLineEnd)\n              while (checkItemPos < source.length) {\n                const checkLineEnd = util.findLineEnd(source, checkItemPos)\n                const checkLine = source.slice(checkItemPos, checkLineEnd)\n                const checkIndentInfo = calculateIndent(\n                  source,\n                  checkItemPos,\n                  checkLineEnd\n                )\n                const checkIndent = checkIndentInfo.spaceEquivalent\n\n                if (checkLine.trim() === '') {\n                  const afterBlank = skipToNextLine(source, checkLineEnd)\n                  if (afterBlank < source.length) {\n                    const afterBlankIndentInfo = calculateIndent(\n                      source,\n                      afterBlank,\n                      source.length\n                    )\n                    const afterBlankIndent =\n                      afterBlankIndentInfo.spaceEquivalent\n                    // Calculate contentStartColumn for this item\n                    const thisItemMarkerStart = nextIndent\n                    const thisItemContentStart =\n                      thisItemMarkerStart +\n                      (ordered\n                        ? nextMatch[1].length + nextMatch[2].length + 1\n                        : nextMatch[1].length + 1)\n                    if (afterBlankIndent + 1 > thisItemContentStart) {\n                      break\n                    }\n                  }\n                  break\n                } else if (checkIndent <= baseIndent) {\n                  // Check if this is the next list item at baseIndent or less\n                  const checkLineWithoutIndent = checkLine.slice(\n                    checkIndentInfo.charCount\n                  )\n                  const checkMatch = checkLineWithoutIndent.match(listItemRegex)\n                  const isNextItem =\n                    checkMatch &&\n                    (ordered\n                      ? checkMatch[2] === delimiter\n                      : checkMatch[1] === marker)\n                  if (isNextItem && checkIndent <= baseIndent) {\n                    break\n                  }\n                }\n                checkItemPos = skipToNextLine(source, checkLineEnd)\n              }\n            }\n            const result = addListItem(\n              source,\n              items,\n              itemContentStartColumns,\n              itemContent,\n              currentPos,\n              nextLineEnd,\n              nextIndent,\n              nextIndentChars,\n              nextMatch,\n              ordered,\n              hasBlankLines,\n              state,\n              options\n            )\n            currentPos = result.newCurrentPos\n            prevLineWasBlank = false\n            continue\n          } else if (!isNested && !isSameType) {\n            // Different marker type at same level - end this list\n            break\n          }\n          // Fall through to continuation check if isNested but parseList failed\n          // Check if this is continuation content\n          // Per CommonMark: continuation needs to be indented to at least the content start column\n          // nextIndent is space count (0-indexed), contentStartColumn is column number (1-indexed)\n          // When list item has block content, exact indentation (==) continues; otherwise use >\n          // For continuation checks, use minimumContentStartColumn (column after marker+space)\n          // instead of contentStartColumn (which can be higher for code blocks)\n          {\n            const lastItem = getLastItem()\n            // Check if last item is empty (no content)\n            const lastItemIsEmpty = lastItem.length === 0\n            // Check for empty items with blank lines\n            if (\n              lastItemIsEmpty &&\n              shouldBreakForEmptyItem(\n                items,\n                isEmptyItem,\n                prevLineWasBlank,\n                firstItemContent\n              )\n            )\n              break\n\n            const hasBlockContent = lastItem.some(\n              node =>\n                node.type === RuleType.codeBlock ||\n                node.type === RuleType.paragraph ||\n                node.type === RuleType.blockQuote ||\n                node.type === RuleType.orderedList ||\n                node.type === RuleType.unorderedList ||\n                node.type === RuleType.heading\n            )\n            // For empty items, use minimumContentStartColumn (marker + space) instead of contentStartColumn\n            // which can be higher when there's extra whitespace but no content\n            const continuationColumn =\n              lastItemIsEmpty && items.length === 1\n                ? minimumContentStartColumn\n                : contentStartColumn\n            const continuationCheck = hasBlockContent\n              ? nextIndent >= continuationColumn\n              : nextIndent > continuationColumn\n            if (continuationCheck) {\n              const result = processListContinuationLine(\n                source,\n                currentPos,\n                nextLineEnd,\n                nextIndentInfo,\n                continuationColumn,\n                contentStartColumn,\n                getLastItem(),\n                prevLineWasBlank,\n                state,\n                options,\n                undefined,\n                baseIndent\n              )\n              if (result.processed) {\n                prevLineWasBlank = result.wasBlank\n                currentPos = result.newPos\n                continue\n              }\n            } else {\n              break\n            }\n          }\n        } else if (nextIndent === baseIndent) {\n          // Check for Unicode whitespace after marker in unordered lists\n          if (\n            !ordered &&\n            nextMatch &&\n            checkUnicodeWhitespaceAfterMarker(nextMatch, nextMatch[1])\n          ) {\n            break\n          }\n          let itemContent = ordered ? nextMatch[3] : nextMatch[2]\n          // Trim leading whitespace from content (regex now captures optional whitespace)\n          itemContent = itemContent.trimStart()\n          // Per CommonMark: A list is loose if items are separated by blank lines,\n          // OR if an item directly contains two block-level elements with a blank line between them.\n          // If list is loose (hasBlankLines = true), ALL items are wrapped.\n          // Otherwise, an item is wrapped only if it has blank lines within it.\n          // A blank line before this item means the PREVIOUS item was separated from this one,\n          // making the list loose. For this item, we check if it has continuation after blank lines.\n          // But if the list is already loose (hasBlankLines), wrap this item too.\n          const result = addListItem(\n            source,\n            items,\n            itemContentStartColumns,\n            itemContent,\n            currentPos,\n            nextLineEnd,\n            baseIndent,\n            nextIndentChars,\n            nextMatch,\n            ordered,\n            hasBlankLines,\n            state,\n            options\n          )\n          currentPos = result.newCurrentPos\n          prevLineWasBlank = false\n        }\n      } else if (nextIndent > baseIndent) {\n        // Check if this is a list item - if so, check if it should be nested or separate\n        // Per CommonMark: list item markers can only be indented 0-3 spaces relative to baseIndent\n        // However, nested lists can have more indentation if they're indented relative to content start\n        // So we need to try parsing as nested list first, then check for paragraph continuation\n        const lastItem = getLastItem()\n        const isListItemResult = isLineListItem(nextLineWithoutIndent)\n        if (isListItemResult) {\n          // Check if marker would be properly nested (relative to content start column)\n          // This handles nested lists that may have > 3 spaces indent from baseIndent\n          const markerColumn = nextIndent + 1\n          const isNested = isMarkerNested(\n            markerColumn,\n            getLastItemContentColumn(),\n            listItemHasBlockContent(lastItem)\n          )\n\n          if (isNested) {\n            // Properly nested - try parsing as nested list\n            const nestedResult = tryParseNestedList(currentPos, lastItem)\n            if (nestedResult) {\n              currentPos = nestedResult.endPos\n              prevLineWasBlank = false\n              continue\n            }\n          }\n\n          // Not properly nested - check if marker indent is valid (0-3 spaces relative to baseIndent)\n          // Per CommonMark: list item markers can only be indented 0-3 spaces relative to baseIndent\n          const markerIndentRelative = nextIndent - baseIndent\n          if (markerIndentRelative > 3) {\n            // Too much indentation (> 3 spaces from baseIndent) and not nested - not a valid list item marker\n            // Check if it should be treated as paragraph continuation (if last item ends with paragraph)\n            const lastBlock =\n              lastItem.length > 0 ? lastItem[lastItem.length - 1] : null\n            if (\n              lastBlock &&\n              (lastBlock.type === RuleType.paragraph ||\n                lastBlock.type === RuleType.text)\n            ) {\n              // This is paragraph continuation text, not a code block or nested list\n              appendListContinuation(\n                nextLineWithoutIndent,\n                lastItem,\n                state,\n                options\n              )\n              prevLineWasBlank = false\n              currentPos = skipToNextLine(source, nextLineEnd)\n              continue\n            }\n            // Not paragraph continuation - fall through to code block check\n          } else {\n            // Valid marker indent (0-3 spaces) but not nested - this should be a separate list\n            break\n          }\n        } else {\n          // Not a list item - try parsing as nested list (for other block types)\n          const nestedResult = tryParseNestedList(currentPos, lastItem)\n          if (nestedResult) {\n            currentPos = nestedResult.endPos\n            prevLineWasBlank = false\n            continue\n          }\n        }\n        // Check if this is continuation content\n        // Per CommonMark: continuation needs to be indented to at least the content start column\n        // nextIndent is space count (0-indexed), contentStartColumn is column number (1-indexed)\n        // When list item has block content, exact indentation (==) continues; otherwise use >\n        // For continuation checks, use minimumContentStartColumn (column after marker+space)\n        // instead of contentStartColumn (which can be higher for code blocks)\n        const continuationColumn = contentStartColumn\n        const continuationCheck = listItemHasBlockContent(lastItem)\n          ? nextIndent >= continuationColumn - 1\n          : nextIndent > continuationColumn - 1\n        if (continuationCheck) {\n          const result = processListContinuationLine(\n            source,\n            currentPos,\n            nextLineEnd,\n            nextIndentInfo,\n            continuationColumn - 1,\n            contentStartColumn,\n            getLastItem(),\n            prevLineWasBlank,\n            state,\n            options,\n            undefined,\n            baseIndent\n          )\n          if (result.processed) {\n            prevLineWasBlank = result.wasBlank\n            currentPos = result.newPos\n            continue\n          }\n        } else {\n          break\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  // For loose lists, ensure all items have paragraph wrappers\n  // The first item may have been created before we detected that the list is loose\n  if (\n    hasBlankLines &&\n    items.length > 1 &&\n    items[0].length > 0 &&\n    items[0][0].type !== RuleType.paragraph\n  ) {\n    // Check if list is truly loose (another item has paragraph wrapper)\n    for (var j = 1; j < items.length; j++) {\n      if (items[j].length > 0 && items[j][0].type === RuleType.paragraph) {\n        // First item is all inline content - wrap it for loose lists\n        var isBlock = false\n        for (var i = 0; i < items[0].length; i++) {\n          var t = items[0][i].type\n          if (\n            t === RuleType.codeBlock ||\n            t === RuleType.heading ||\n            t === RuleType.blockQuote ||\n            t === RuleType.orderedList ||\n            t === RuleType.unorderedList ||\n            t === RuleType.htmlBlock ||\n            t === RuleType.breakThematic\n          ) {\n            isBlock = true\n            break\n          }\n        }\n        if (!isBlock) {\n          items[0] = [\n            {\n              type: RuleType.paragraph,\n              children: items[0],\n            } as MarkdownToJSX.ParagraphNode,\n          ]\n        }\n        break\n      }\n    }\n  }\n\n  const listNode = ordered\n    ? ({\n        type: RuleType.orderedList,\n        items,\n        ordered: true,\n        start,\n      } as MarkdownToJSX.OrderedListNode)\n    : ({\n        type: RuleType.unorderedList,\n        items,\n        ordered: false,\n      } as MarkdownToJSX.UnorderedListNode)\n\n  // Restore original inList state\n  state.inList = originalInList\n\n  return {\n    ...listNode,\n    endPos: currentPos,\n  } as (MarkdownToJSX.OrderedListNode | MarkdownToJSX.UnorderedListNode) & {\n    endPos: number\n  }\n}\n\nfunction parseTable(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline) return null\n\n  const lines: string[] = []\n  let currentPos = pos\n\n  while (currentPos < source.length) {\n    const lineEnd = util.findLineEnd(source, currentPos)\n    if (isBlankLineCheck(source, currentPos, lineEnd)) break\n\n    const line = source.slice(currentPos, lineEnd).trim()\n    const isTableLine =\n      line.indexOf('|') !== -1 ||\n      (lines.length >= 3 && line && !isBlockStartChar(line[0]))\n\n    if (!isTableLine) break\n    lines.push(line)\n    currentPos = skipToNextLine(source, lineEnd)\n  }\n\n  if (lines.length < 2) return null\n\n  // Unwrap pipes and split cells\n  const unwrap = (line: string) =>\n    line[0] === '|' && line[line.length - 1] === '|' ? line.slice(1, -1) : line\n\n  const splitCells = (line: string) => {\n    const cells: string[] = []\n    let current = ''\n    let inCode = false\n\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i]\n      if (ch === '\\\\' && i + 1 < line.length && line[i + 1] === '|') {\n        current += '|'\n        i++\n      } else if (ch === '`') {\n        inCode = !inCode\n        current += ch\n      } else if (ch === '|' && !inCode) {\n        cells.push(current.trim())\n        current = ''\n      } else {\n        current += ch\n      }\n    }\n    cells.push(current.trim())\n    return cells\n  }\n\n  const headerCells = splitCells(unwrap(lines[0]))\n  if (!headerCells.length) return null\n\n  const separatorCells = splitCells(unwrap(lines[1]))\n  if (\n    separatorCells.length !== headerCells.length ||\n    separatorCells.some(cell => !/^:?-+:?$/.test(cell))\n  ) {\n    return null\n  }\n\n  const alignments = separatorCells.map(cell => {\n    const start = cell[0] === ':'\n    const end = cell[cell.length - 1] === ':'\n    return start && end ? 'center' : start ? 'left' : end ? 'right' : null\n  })\n\n  if (options.optimizeForStreaming && lines.length === 2) {\n    return null\n  }\n\n  const parseRow = (cells: string[]) =>\n    parseWithInlineMode(state, true, () =>\n      cells.map(cell => parseInlineSpan(cell, 0, cell.length, state, options))\n    )\n\n  const header = parseRow(headerCells)\n\n  const body = lines.slice(2).map(line => {\n    const cells =\n      line.indexOf('|') !== -1 ? splitCells(unwrap(line)) : [line.trim()]\n\n    // Normalize cell count\n    const count = headerCells.length\n    while (cells.length < count) cells.push('')\n    cells.length = count\n\n    return parseRow(cells)\n  })\n\n  return {\n    type: RuleType.table,\n    header,\n    cells: body,\n    align: alignments,\n    endPos: currentPos,\n  } as MarkdownToJSX.TableNode & { endPos: number }\n}\n\n// Type 6 block-level tags - only the most common ones that matter in practice\n// Unknown tags default to type 7 (inline/non-interrupting) for safety\n// This is a pragmatic subset of the CommonMark spec's full list\nvar TYPE6_TAGS = [\n  'div',\n  'p',\n  'section',\n  'article',\n  'aside',\n  'nav',\n  'header',\n  'footer',\n  'main',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'blockquote',\n  'ul',\n  'ol',\n  'li',\n  'dl',\n  'dt',\n  'dd',\n  'table',\n  'thead',\n  'tbody',\n  'tfoot',\n  'tr',\n  'td',\n  'th',\n  'form',\n  'fieldset',\n  'hr',\n  'pre',\n  'details',\n  'summary',\n  'figure',\n  'figcaption',\n]\n\n// Type 1 block tags for fast lookup\nconst TYPE1_TAGS_SET = new Set(['pre', 'script', 'style', 'textarea'])\n\nfunction isType6Tag(tagName: string): boolean {\n  return TYPE6_TAGS.indexOf(tagName.toLowerCase()) !== -1\n}\n\nexport function isType1Block(tagLower: string): boolean {\n  return TYPE1_TAGS_SET.has(tagLower)\n}\n\nfunction isBlankLineCheck(\n  source: string,\n  lineStart: number,\n  lineEnd: number\n): boolean {\n  for (var i = lineStart; i < lineEnd; i++) {\n    const code = charCode(source, i)\n    if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB && code !== $.CHAR_CR)\n      return false\n  }\n  return true\n}\n\nfunction parseWithInlineMode<T>(\n  state: MarkdownToJSX.State,\n  inlineMode: boolean,\n  parseFn: () => T\n): T {\n  const originalInline = state.inline\n  state.inline = inlineMode\n  try {\n    return parseFn()\n  } finally {\n    state.inline = originalInline\n  }\n}\n\nfunction findNextBlankLine(\n  source: string,\n  startPos: number,\n  sourceLen: number\n): number {\n  var pos = startPos\n  while (pos < sourceLen) {\n    var nextLineEnd = util.findLineEnd(source, pos)\n    if (isBlankLineCheck(source, pos, nextLineEnd)) return pos\n    pos = skipToNextLine(source, nextLineEnd)\n  }\n  return sourceLen\n}\n\nfunction createHTMLCommentResult(\n  text: string,\n  endPos: number,\n  options?: { raw?: boolean; endsWithGreaterThan?: boolean }\n): MarkdownToJSX.HTMLCommentNode & {\n  endPos: number\n  raw?: boolean\n  endsWithGreaterThan?: boolean\n} {\n  return {\n    type: RuleType.htmlComment,\n    text: util.normalizeInput(text),\n    endPos,\n    ...options,\n  } as MarkdownToJSX.HTMLCommentNode & {\n    endPos: number\n    raw?: boolean\n    endsWithGreaterThan?: boolean\n  }\n}\n\nfunction createVerbatimHTMLBlock(\n  tagName: string,\n  text: string,\n  endPos: number,\n  attrs?: { [key: string]: any },\n  rawAttrs?: string,\n  isClosingTag?: boolean,\n  canInterruptParagraph?: boolean,\n  options?: ParseOptions,\n  state?: MarkdownToJSX.State\n): MarkdownToJSX.HTMLNode & {\n  endPos: number\n  isClosingTag?: boolean\n  canInterruptParagraph?: boolean\n} {\n  var normalizedText = util.normalizeInput(text)\n  // Detect empty unclosed HTML tags when forceBlock or optimizeForStreaming is used to avoid infinite recursion\n  // For empty unclosed tags like <var>, the text field contains the opening tag itself\n  // When forceBlock/optimizeForStreaming is used, this would cause recursion if the tag is parsed again\n  var finalText = normalizedText\n  if (\n    options &&\n    (options.forceBlock || options.optimizeForStreaming) &&\n    text &&\n    !isClosingTag\n  ) {\n    var openingTagPattern = new RegExp(\n      '^<' + tagName.toLowerCase() + '(\\\\s[^>]*)?>$',\n      'i'\n    )\n    if (openingTagPattern.test(text.trim())) {\n      // Empty unclosed tag detected - render as empty element to avoid recursion\n      finalText = ''\n    }\n  }\n\n  // Always parse content into children, even for verbatim blocks\n  // Extract content from text (may include opening tag)\n  var contentToParse = finalText\n  var tagLower = tagName.toLowerCase()\n\n  // If text starts with opening tag, extract just the content\n  var openingTagPattern2 = new RegExp('^<' + tagLower + '[\\\\s>]', 'i')\n  if (openingTagPattern2.test(contentToParse)) {\n    // Find the end of opening tag\n    var tagEnd = contentToParse.indexOf('>')\n    if (tagEnd !== -1) {\n      contentToParse = contentToParse.slice(tagEnd + 1)\n      // Remove closing tag if present\n      var closingTag = '</' + tagLower + '>'\n      var closingIdx = contentToParse.indexOf(closingTag)\n      if (closingIdx !== -1) {\n        contentToParse = contentToParse.slice(0, closingIdx)\n      }\n    }\n  } else {\n    // Text might just be content, but check for closing tag\n    var closingTag2 = '</' + tagLower + '>'\n    var closingIdx2 = contentToParse.indexOf(closingTag2)\n    if (closingIdx2 !== -1) {\n      contentToParse = contentToParse.slice(0, closingIdx2)\n    }\n  }\n\n  // Parse content into children\n  var children: MarkdownToJSX.ASTNode[] = []\n\n  // In streaming mode, skip all child parsing to avoid infinite recursion with unclosed tags\n  // The content will be rendered as plain text inside the HTML block\n  if (contentToParse && options && !options.optimizeForStreaming) {\n    var parseState: MarkdownToJSX.State = state || {\n      inline: false,\n      inHTML: true,\n      inAnchor: false,\n    }\n\n    // Determine if content should be parsed as blocks or inline\n    var trimmed = contentToParse.trim()\n    var hasDoubleNewline = DOUBLE_NEWLINE_R.test(trimmed)\n    var hasBlockSyntax = BLOCK_SYNTAX_R.test(trimmed)\n    var hasHTMLTags = HTML_BLOCK_ELEMENT_START_R.test(trimmed)\n\n    if (hasDoubleNewline || hasBlockSyntax || hasHTMLTags) {\n      // Parse as blocks\n      var blockState = {\n        ...parseState,\n        inline: false,\n        inHTML: true,\n        inAnchor: parseState.inAnchor || tagLower === 'a',\n      }\n      children = parseBlocksInHTML(trimmed, blockState, options)\n    } else if (trimmed) {\n      // Parse as inline\n      var inlineState = {\n        ...parseState,\n        inline: true,\n        inHTML: true,\n        inAnchor: parseState.inAnchor || tagLower === 'a',\n      }\n      children = parseInlineSpan(\n        trimmed,\n        0,\n        trimmed.length,\n        inlineState,\n        options\n      )\n    }\n  }\n\n  return {\n    type: RuleType.htmlBlock,\n    tag: tagName as MarkdownToJSX.HTMLTags,\n    attrs: attrs || {},\n    rawAttrs: rawAttrs,\n    children: children,\n    rawText: finalText,\n    text: contentToParse, // @deprecated - cleaned up content without tags, use rawText for full raw HTML\n    verbatim: true,\n    isClosingTag: isClosingTag,\n    canInterruptParagraph: canInterruptParagraph,\n    endPos: endPos,\n  } as MarkdownToJSX.HTMLNode & {\n    endPos: number\n    isClosingTag?: boolean\n    canInterruptParagraph?: boolean\n  }\n}\n\n/**\n * Check if content contains block-worthy elements that should be parsed\n * (explicit block syntax or blank lines not inside type 1 HTML blocks)\n */\nfunction hasBlockContent(content: string): boolean {\n  const hasExplicitBlockSyntax = BLOCK_SYNTAX_R.test(content)\n  const hasBlankLines = DOUBLE_NEWLINE_R.test(content)\n  const hasType1Tags = TYPE1_TAG_R.test(content)\n  return hasExplicitBlockSyntax || (hasBlankLines && !hasType1Tags)\n}\n\nfunction processHTMLBlock(\n  tagNameOriginal: string,\n  tagName: string,\n  attrs: string,\n  content: string,\n  fullMatch: string,\n  endPos: number,\n  source: string,\n  state: MarkdownToJSX.State,\n  parentInAnchor: boolean,\n  options: ParseOptions\n): MarkdownToJSX.HTMLNode & { endPos: number } {\n  // Apply block-level paragraph wrapping heuristics\n  if (!state.inHTML && !state.inline && !util.endsWith(fullMatch, '\\n')) {\n    let checkPos = endPos\n    const sourceLen = source.length\n\n    while (checkPos < sourceLen) {\n      const lineEnd = util.findLineEnd(source, checkPos)\n      if (isBlankLineCheck(source, checkPos, lineEnd)) break\n\n      const line = source.slice(checkPos, lineEnd).trim()\n      if (line.length > 0 && isBlockStartChar(line[0])) {\n        const htmlResult = parseHTML(source, checkPos, state, options)\n        if (htmlResult) {\n          checkPos = htmlResult.endPos\n          continue\n        }\n        const selfClosingMatch = parseHTMLTag(source, checkPos)\n        if (selfClosingMatch) {\n          checkPos = selfClosingMatch.endPos\n          continue\n        }\n        return null\n      }\n      checkPos = skipToNextLine(source, lineEnd)\n    }\n  }\n\n  const lowerTag = tagName\n  const isType1BlockTag = isType1Block(lowerTag)\n\n  // Per CommonMark spec: Type 6 blocks that end at blank lines should have verbatim content\n  // Check if this is a type 6 block (block-level, not type 1, not void)\n  var isType6Block = !isType1BlockTag && !util.isVoidElement(tagName)\n\n  // Always extract raw attributes from fullMatch if available (for consistency)\n  // Per CommonMark spec Example 153: newlines and spaces between attributes should be removed\n  // (not converted to spaces) when rendering. Extract raw attributes so html() can handle this.\n  var rawOpeningTag: string | undefined = undefined\n  // Extract raw attributes from opening tag slice if fullMatch is available\n  if (fullMatch) {\n    // Find the closing > of the opening tag\n    var openingTagEnd = fullMatch.indexOf('>')\n    if (openingTagEnd !== -1) {\n      var openingTagSlice = fullMatch.slice(0, openingTagEnd + 1)\n      // Check if opening tag has newlines (for rawOpeningTag preservation)\n      if (openingTagSlice.indexOf('\\n') !== -1) {\n        rawOpeningTag = openingTagSlice\n      }\n      // Always extract raw attributes from the opening tag slice for consistency\n      // Find the tag name end (after <div or <div/) - first whitespace or >\n      var tagNameEnd = openingTagEnd\n      for (var i = 1; i < openingTagEnd; i++) {\n        var ch = openingTagSlice[i]\n        if (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '>') {\n          tagNameEnd = i\n          break\n        }\n      }\n      // Extract attributes from after tag name to before >\n      // Preserve leading whitespace for CommonMark compliance (Examples 615-616)\n      attrs = openingTagSlice.slice(tagNameEnd, openingTagEnd)\n    }\n  }\n\n  // Parse attributes, but always preserve raw attributes for consistency\n  // Per CommonMark spec Example 153: newlines and spaces between attributes should be removed\n  // (not converted to spaces) when rendering. Store raw attributes so html() can handle this.\n  // Trim leading whitespace for parsing, but preserve full attrs (with whitespace) for rawAttrs\n  var attrsTrimmed = attrs.replace(/^[\\s\\n\\r\\t]+/, '')\n  var parsedAttributes = parseHTMLAttributes(\n    attrsTrimmed,\n    tagName,\n    tagNameOriginal,\n    options\n  )\n  var attributes: Record<string, any> = {\n    ...parsedAttributes,\n  }\n\n  // For type 6 blocks, check if content ends with blank line or if there's no closing tag\n  // Both cases mean content should be verbatim\n  var endedAtBlankLine = false\n  var hasClosingTagWithBlockSyntax = false\n  if (isType6Block && content.length > 0) {\n    // Check if there's a closing tag in the content - if so, extract content before it\n    var closingTagPattern = '</' + lowerTag\n    var closingTagIdx = content.indexOf(closingTagPattern)\n    if (closingTagIdx >= 0) {\n      var afterTag = closingTagIdx + closingTagPattern.length\n      while (\n        afterTag < content.length &&\n        (content[afterTag] === ' ' || content[afterTag] === '\\t')\n      )\n        afterTag++\n      if (afterTag < content.length && content[afterTag] === '>') {\n        var contentBeforeClosingTag = content.slice(0, closingTagIdx)\n        if (hasBlockContent(contentBeforeClosingTag)) {\n          content = contentBeforeClosingTag\n          hasClosingTagWithBlockSyntax = true\n        } else {\n          endedAtBlankLine = true\n        }\n      }\n    }\n\n    // If we didn't find a proper closing tag with block syntax, check if content ends with blank lines\n    if (!hasClosingTagWithBlockSyntax) {\n      // Check if content ends with blank line pattern (newline, optional whitespace, newline)\n      var checkPos = content.length - 1\n      // Skip trailing newline\n      if (content[checkPos] === '\\n') {\n        checkPos--\n        // Skip whitespace\n        while (\n          checkPos >= 0 &&\n          (content[checkPos] === ' ' ||\n            content[checkPos] === '\\t' ||\n            content[checkPos] === '\\r')\n        ) {\n          checkPos--\n        }\n        // If there's another newline before this, we have a blank line ending\n        if (checkPos >= 0 && content[checkPos] === '\\n') {\n          endedAtBlankLine = true\n        }\n      }\n    }\n  }\n\n  // Determine if this block should have verbatim rendering hint\n  // Type 1 blocks and Type 6 blocks ending with blank lines should be verbatim\n  var shouldTreatAsVerbatim =\n    isType1BlockTag ||\n    (isType6Block && endedAtBlankLine && !hasBlockContent(content))\n\n  var normalizedContent = util.normalizeInput(content)\n  // Store original content for text field before we modify it for parsing\n  var contentForText = normalizedContent\n  if (shouldTreatAsVerbatim) {\n    if (normalizedContent.length > 0 && normalizedContent[0] === '\\n') {\n      normalizedContent = normalizedContent.slice(1)\n      contentForText = normalizedContent\n    }\n    if (\n      normalizedContent.length > 0 &&\n      normalizedContent[normalizedContent.length - 1] === '\\n'\n    ) {\n      normalizedContent = normalizedContent.slice(0, -1)\n      contentForText = normalizedContent\n    }\n    // Remove closing tag from content before parsing (it should only be in text field)\n    // But keep it in contentForText for the text field\n    var closingTagPattern = '</' + lowerTag + '>'\n    var closingTagIdx = normalizedContent.indexOf(closingTagPattern)\n    if (closingTagIdx !== -1) {\n      normalizedContent = normalizedContent.slice(0, closingTagIdx)\n      // contentForText keeps the closing tag\n    }\n  }\n\n  const leftTrimMatch = normalizedContent.match(/^([ \\t]*)/)\n  const leftTrimAmount = leftTrimMatch ? leftTrimMatch[1] : ''\n  const trimmer = new RegExp(\n    `^${leftTrimAmount.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}`,\n    'gm'\n  )\n  const trimmed = normalizedContent.replace(trimmer, '')\n\n  const hasDoubleNewline = DOUBLE_NEWLINE_R.test(trimmed)\n  const hasNonParagraphBlockSyntax = BLOCK_SYNTAX_R.test(trimmed)\n  const isParagraphTag = lowerTag === 'p'\n  // Check if content contains HTML tags - if so, parse as blocks for proper nesting\n  const hasHTMLTags = HTML_BLOCK_ELEMENT_START_R.test(trimmed)\n  const hasBlockSyntax = isParagraphTag\n    ? hasDoubleNewline\n    : hasDoubleNewline ||\n      hasNonParagraphBlockSyntax ||\n      (state.inHTML && hasHTMLTags)\n\n  // ALWAYS parse content into children, regardless of verbatim flag\n  // Recursion is prevented by state.inHTML guard at parseHTML entry\n  let children: MarkdownToJSX.ASTNode[] = []\n  if (trimmed) {\n    // Parse as blocks when content contains HTML tags to ensure nested HTML is parsed correctly\n    if (hasBlockSyntax || hasHTMLTags) {\n      const blockState = {\n        ...state,\n        inline: false,\n        inHTML: true,\n        inAnchor: state.inAnchor || lowerTag === 'a',\n      }\n      children = parseBlocksInHTML(trimmed, blockState, options)\n    } else {\n      const childState = {\n        ...state,\n        inline: true,\n        inHTML: options.optimizeForStreaming ? true : state.inHTML,\n        inAnchor: parentInAnchor || state.inAnchor || lowerTag === 'a',\n      }\n      children = parseInlineSpan(\n        trimmed,\n        0,\n        trimmed.length,\n        childState,\n        options\n      )\n    }\n  }\n\n  // Store raw text for verbatim blocks (for CommonMark compliance in default renderer)\n  var finalText: string | undefined = undefined\n  if (shouldTreatAsVerbatim) {\n    if (rawOpeningTag !== undefined) {\n      // Type 1 block with newlines in opening tag - preserve raw opening tag + content\n      // Store the full raw HTML (opening tag + content) in text field\n      // The closing tag will be added by html()\n      finalText = rawOpeningTag + contentForText\n    } else {\n      finalText = contentForText\n    }\n  }\n\n  return {\n    type: RuleType.htmlBlock,\n    tag: (shouldTreatAsVerbatim\n      ? tagName\n      : tagNameOriginal) as MarkdownToJSX.HTMLTags,\n    attrs: attributes,\n    rawAttrs: attrs,\n    children: children,\n    rawText: finalText,\n    text: trimmed, // @deprecated - cleaned up content without tags, use rawText for full raw HTML\n    verbatim: shouldTreatAsVerbatim,\n    canInterruptParagraph: true, // type 1-6 blocks can interrupt paragraphs\n    endPos: endPos,\n  } as MarkdownToJSX.HTMLNode & {\n    endPos: number\n    canInterruptParagraph?: boolean\n  }\n}\n\nfunction parseHTML(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  // Must start with '<'\n  if (source[pos] !== '<') return null\n\n  // In streaming mode, skip all HTML parsing when already inside HTML to avoid infinite recursion\n  if (options.optimizeForStreaming && state.inHTML) {\n    return null\n  }\n\n  // Track attempt after cheap disqualifications but before expensive parsing work\n  if (!state.inline) {}\n\n  // Check for processing instructions, declarations, and comments first (before unified parser)\n  if (pos + 1 < source.length) {\n    if (source[pos + 1] === '?') {\n      var piToken = scanRawHTML(source, pos)\n      if (piToken && piToken.kind === 'pi') {\n        return createHTMLCommentResult(piToken.text || '', piToken.endPos, {\n          raw: true,\n        })\n      }\n    } else if (source[pos + 1] === '!') {\n      // Check for HTML comments (<!-- ... -->)\n      if (pos + 3 < source.length && source.slice(pos, pos + 4) === '<!--') {\n        if (state.inline) {} else {}\n        var token = scanRawHTML(source, pos)\n        if (token && token.kind === 'comment') {\n          // Extract text content (strip <!-- and -->)\n          var text = token.text || ''\n          var endsWithGreaterThan = false\n          if (text === '<!-->') {\n            text = ''\n            endsWithGreaterThan = true\n          } else if (text === '<!--->') {\n            text = '-'\n            endsWithGreaterThan = true\n          } else if (text.startsWith('<!--') && text.endsWith('-->')) {\n            text = text.slice(4, -3)\n          }\n          // Track hit for inline mode (block mode hit tracking happens in parseMarkdown)\n          if (state.inline) {}\n          return createHTMLCommentResult(text, token.endPos, {\n            endsWithGreaterThan,\n          })\n        }\n      }\n      var declToken = scanRawHTML(source, pos)\n      if (\n        declToken &&\n        (declToken.kind === 'declaration' || declToken.kind === 'cdata')\n      ) {\n        return createHTMLCommentResult(declToken.text || '', declToken.endPos, {\n          raw: true,\n        })\n      }\n    }\n  }\n\n  // Check for space/newline after < (invalid HTML - should be escaped)\n  if (pos + 1 < source.length) {\n    const nextChar = source[pos + 1]\n    if (\n      nextChar === ' ' ||\n      nextChar === '\\n' ||\n      nextChar === '\\t' ||\n      nextChar === '\\r'\n    ) {\n      return null\n    }\n  }\n\n  // Check if this looks like an autolink before parsing as HTML\n  var closeIdx = source.indexOf('>', pos + 1)\n  if (closeIdx !== -1) {\n    var contentBetween = source.slice(pos + 1, closeIdx)\n    // Check for spaces - if found, might be failed autolink\n    var hasSpace =\n      contentBetween.indexOf(' ') !== -1 || contentBetween.indexOf('\\t') !== -1\n\n    // Check for HTTP(S) URLs - these should be autolinks, not HTML tags\n    if (\n      !hasSpace &&\n      (util.startsWith(contentBetween, 'http://') ||\n        util.startsWith(contentBetween, 'https://'))\n    ) {\n      return null // This is an autolink, not an HTML tag\n    }\n\n    // Check for URI schemes (scheme:pattern) - no spaces\n    if (!hasSpace && isValidUriScheme(contentBetween)) {\n      return null // This is an autolink (URI scheme), not an HTML tag\n    }\n  }\n\n  // Use unified parser\n  var tagResult = parseHTMLTag(source, pos)\n\n  // If parseHTMLTag returns null, it might be an incomplete tag\n  // Handle incomplete/partial tags inline (previously handled by matchHTMLBlock)\n  if (!tagResult && !state.inline) {\n    // Check if we have < followed by a valid tag name (even without closing >)\n    var sourceLen = source.length\n    var firstLineEnd = util.findLineEnd(source, pos)\n    var lineStart = pos\n    // Skip up to 3 spaces of indentation (per spec)\n    var indent = 0\n    while (\n      lineStart < firstLineEnd &&\n      indent < 3 &&\n      (source[lineStart] === ' ' || source[lineStart] === '\\t')\n    ) {\n      indent++\n      lineStart++\n    }\n    if (lineStart >= firstLineEnd || source[lineStart] !== '<') return null\n\n    // Try to parse tag name even if tag is incomplete\n    // Only handle incomplete tags for block-level tags (type 6)\n    // Non-block-level tags that parseHTMLTag can't parse are invalid, not incomplete\n    if (lineStart + 1 < firstLineEnd) {\n      var tagNameResult = parseHTMLTagName(source, lineStart + 1)\n      if (tagNameResult) {\n        var tagName = tagNameResult.tagName\n        var isType6 = isType6Tag(tagName)\n        // Only handle incomplete tags for block-level tags\n        if (!isType6) {\n          return null // Non-block-level tags that parseHTMLTag can't parse are invalid\n        }\n        // Find where the tag would end (end of line or before invalid char)\n        var partialTagEnd = tagNameResult.nextPos\n        var hasNewlineInTag = false\n        var inQuotesPartial = false\n        var quoteCharPartial = ''\n        var checkEnd = firstLineEnd\n        var foundClosingAngle = false\n        // Check across multiple lines to find the end of the tag\n        // Optimized: use indexOf to quickly find boundary characters\n        while (checkEnd < sourceLen && !foundClosingAngle) {\n          var advancedInInnerLoop = false\n          while (partialTagEnd < checkEnd) {\n            var c = source[partialTagEnd]\n            if (inQuotesPartial) {\n              if (c === quoteCharPartial) {\n                inQuotesPartial = false\n                quoteCharPartial = ''\n              }\n              if (c === '\\n' || c === '\\r') {\n                hasNewlineInTag = true\n              }\n              partialTagEnd++\n              advancedInInnerLoop = true\n            } else if (c === '\"' || c === \"'\") {\n              inQuotesPartial = true\n              quoteCharPartial = c\n              partialTagEnd++\n              advancedInInnerLoop = true\n            } else if (c === '\\n' || c === '\\r') {\n              hasNewlineInTag = true\n              partialTagEnd++\n              advancedInInnerLoop = true\n              var nextLineEnd = util.findLineEnd(source, partialTagEnd)\n              if (nextLineEnd === partialTagEnd) break\n              checkEnd = nextLineEnd\n            } else if (c === '>') {\n              partialTagEnd++\n              foundClosingAngle = true\n              break\n            } else {\n              partialTagEnd++\n              advancedInInnerLoop = true\n            }\n          }\n          if (foundClosingAngle) break\n          if (!advancedInInnerLoop && partialTagEnd >= checkEnd) {\n            var nextCheckEnd = util.findLineEnd(source, checkEnd + 1)\n            if (nextCheckEnd <= checkEnd) break\n            checkEnd = nextCheckEnd\n          } else if (partialTagEnd >= checkEnd && checkEnd < sourceLen) {\n            var nextCheckEnd = util.findLineEnd(source, checkEnd + 1)\n            if (nextCheckEnd <= checkEnd) break\n            checkEnd = nextCheckEnd\n          } else {\n            break\n          }\n        }\n        // Only handle as incomplete tag if it has a newline (extends beyond first line)\n        // OR if it extends to end of first line without closing >\n        // If tag completes on first line with closing >, parseHTMLTag should have handled it\n        if (!hasNewlineInTag && foundClosingAngle) {\n          return null // Tag completes on first line but parseHTMLTag returned null - invalid, not incomplete\n        }\n        // Tag has newline - treat as incomplete and extend to end of first line if needed\n        if (partialTagEnd >= firstLineEnd && firstLineEnd < sourceLen) {\n          partialTagEnd = firstLineEnd\n        }\n        // Determine block type and find blank line\n        var blockType: 'type6' | 'type7' = isType6 ? 'type6' : 'type7'\n        var tagEnd = partialTagEnd\n        var blockEnd = findNextBlankLine(\n          source,\n          skipToNextLine(source, firstLineEnd),\n          sourceLen\n        )\n        var blockContent = source.slice(tagEnd, blockEnd)\n        var isClosingTag = pos + 1 < source.length && source[pos + 1] === '/'\n\n        // For type 7 blocks with incomplete tags, preserve raw HTML\n        if (blockType === 'type7' && blockContent.trim() === '') {\n          var rawTagHTML = source.slice(pos, blockEnd)\n          var tagLineEnd = util.findLineEnd(rawTagHTML, 0)\n          if (tagLineEnd < rawTagHTML.length) tagLineEnd++\n          var rawTag = rawTagHTML.slice(0, tagLineEnd)\n          return createVerbatimHTMLBlock(\n            tagName,\n            rawTag,\n            blockEnd,\n            {},\n            undefined,\n            isClosingTag,\n            false, // type 7 blocks cannot interrupt paragraphs\n            options,\n            state\n          )\n        }\n\n        // For type 6/7 blocks with incomplete tags and content, preserve full raw HTML\n        var fullRawHTML = source.slice(pos, blockEnd)\n        return createVerbatimHTMLBlock(\n          tagName,\n          fullRawHTML,\n          blockEnd,\n          {},\n          undefined,\n          isClosingTag,\n          blockType === 'type6', // type 6 can interrupt, type 7 cannot\n          options,\n          state\n        )\n      }\n    }\n    return null\n  }\n\n  if (!tagResult) return null\n\n  // Per CommonMark spec: reject HTML tags that look like failed autolinks\n  // Check if the content between < and > looks like a failed autolink\n  // (HTTP(S) URLs with spaces are failed autolinks - checked above)\n  if (closeIdx !== -1) {\n    var contentBetweenCheck = source.slice(pos + 1, closeIdx)\n    // If it starts with http:// or https:// but has spaces, it's a failed autolink\n    if (\n      (util.startsWith(contentBetweenCheck, 'http://') ||\n        util.startsWith(contentBetweenCheck, 'https://')) &&\n      (contentBetweenCheck.indexOf(' ') !== -1 ||\n        contentBetweenCheck.indexOf('\\t') !== -1)\n    ) {\n      return null // Failed autolink - reject as HTML tag\n    }\n  }\n\n  // If a tag name has a colon at position 1 (e.g., \"m:abc\"), it's trying to be an autolink\n  // but the scheme is only 1 character (invalid). These should be escaped, not parsed as HTML.\n  // Examples: <m:abc>, <x:foo> should be escaped as &lt;m:abc&gt;, &lt;x:foo&gt;\n  var tagNameStart = pos + (tagResult.isClosing ? 2 : 1)\n  if (tagNameStart < source.length) {\n    var tagNameFirstChar = source[tagNameStart]\n    var tagNameFirstCharCode = charCode(tagNameFirstChar)\n    // Check if it starts with a letter\n    if (\n      (tagNameFirstCharCode >= 97 && tagNameFirstCharCode <= 122) ||\n      (tagNameFirstCharCode >= 65 && tagNameFirstCharCode <= 90)\n    ) {\n      // Check if second character is a colon (making it a 1-char scheme, which is invalid)\n      if (\n        tagNameStart + 1 < source.length &&\n        source[tagNameStart + 1] === ':'\n      ) {\n        // This looks like a failed autolink attempt - reject as HTML tag\n        return null\n      }\n    }\n  }\n\n  // Handle closing tags\n  if (tagResult.isClosing) {\n    // Per CommonMark: closing tags cannot have attributes\n    // If attrs is not empty (after trimming whitespace), it's invalid HTML - escape it\n    var attrsTrimmed = tagResult.attrs.trim()\n    if (attrsTrimmed.length > 0) {\n      // Invalid closing tag with attributes - return null to allow escaping\n      return null\n    }\n\n    // Per CommonMark spec: closing tags are type 7 HTML blocks\n    // Parse as block if: (1) on its own line, or (2) followed by a block-level HTML tag\n    // Per Example 148: </td></tr></table> should be block-level\n    // Per Example 623: </a></foo > should be inline (wrapped in paragraph)\n    if (!state.inline) {\n      var sourceLen = source.length\n      var firstLineEnd = util.findLineEnd(source, pos)\n      var tagEnd = tagResult.endPos\n\n      // Check if tag is on its own line or followed by a block-level HTML tag\n      var afterTag = tagEnd\n      while (\n        afterTag < firstLineEnd &&\n        (source[afterTag] === ' ' ||\n          source[afterTag] === '\\t' ||\n          source[afterTag] === '\\r')\n      ) {\n        afterTag++\n      }\n\n      var shouldParseAsBlock =\n        afterTag >= firstLineEnd ||\n        (source[afterTag] === '<' &&\n          (function () {\n            var nextTag = parseHTMLTag(source, afterTag)\n            return nextTag && isType6Tag(nextTag.tagLower)\n          })())\n\n      if (shouldParseAsBlock) {\n        var blockEnd = findNextBlankLine(\n          source,\n          skipToNextLine(source, firstLineEnd),\n          sourceLen\n        )\n        var blockContent = source.slice(tagEnd, blockEnd)\n        if (blockContent.length > 0) {\n          if (blockContent[0] === '\\r' && blockContent[1] === '\\n') {\n            blockContent = blockContent.slice(2)\n          } else if (blockContent[0] === '\\n' || blockContent[0] === '\\r') {\n            blockContent = blockContent.slice(1)\n          }\n        }\n\n        // Cache lowercase tag name to avoid repeated toLowerCase() calls\n        const tagLower = tagResult.tagLower || tagResult.tagName.toLowerCase()\n        return createVerbatimHTMLBlock(\n          tagResult.tagName,\n          blockContent,\n          blockEnd,\n          parseHTMLAttributes(\n            tagResult.whitespaceBeforeAttrs + tagResult.attrs,\n            tagLower,\n            tagResult.tagName,\n            options\n          ),\n          tagResult.whitespaceBeforeAttrs + tagResult.attrs,\n          true,\n          false,\n          options,\n          state\n        )\n      }\n    }\n\n    // Fallback: for inline context or if block parsing didn't match, parse as self-closing\n    // Per CommonMark spec Example 623: closing tags should preserve raw HTML to maintain spacing (e.g., </foo >)\n    // Always preserve rawText for closing tags (both inline and block level) so they can be rendered correctly\n    var rawText = source.slice(pos, tagResult.endPos)\n    const result: MarkdownToJSX.HTMLSelfClosingNode & {\n      endPos: number\n      isClosingTag?: boolean\n      rawText?: string\n    } = {\n      type: RuleType.htmlSelfClosing,\n      tag: tagResult.tagName,\n      attrs: {},\n      endPos: tagResult.endPos,\n      isClosingTag: true,\n      rawText: rawText,\n    }\n    return result\n  }\n\n  // Now use unified parser result\n  // tagResult already contains parsed tag info\n\n  // IMPORTANT: All validation must happen BEFORE block parsing check\n  // This ensures invalid tags are rejected even if they would match as blocks\n\n  // Validate tag name: cannot start with space or newline after <\n  // Per CommonMark spec Example 621: < a> and <\\nfoo> are invalid\n  var tagNameStart = pos + (tagResult.isClosing ? 2 : 1)\n  if (tagNameStart < source.length) {\n    var firstChar = source[tagNameStart]\n    if (\n      firstChar === ' ' ||\n      firstChar === '\\t' ||\n      firstChar === '\\n' ||\n      firstChar === '\\r'\n    ) {\n      // Tag name starts with whitespace - invalid HTML\n      return null\n    }\n  }\n\n  // Attributes are passed through opaquely - no validation\n\n  var tagNameLower = tagResult.tagLower\n  var isVoid = util.isVoidElement(tagResult.tagName)\n\n  // Check if this is a JSX component (starts with uppercase letter)\n  // JSX components should be parsed as block-level HTML even with newlines\n  const isJSXComponent =\n    tagResult.tagName.length > 0 &&\n    tagResult.tagName[0] >= 'A' &&\n    tagResult.tagName[0] <= 'Z'\n\n  // Self-closing tags: has /> or is void (except anchor tags which need special handling)\n  // Per CommonMark spec: self-closing tags with newlines are type 7 blocks\n  // Type 7 blocks don't interrupt paragraphs, so they should be parsed as inline HTML\n  // IMPORTANT: Validation already happened above, so if we get here the tag is valid\n  // EXCEPTION: JSX components (uppercase tags) should always be parsed as block-level HTML\n  if (tagResult.isSelfClosing || (isVoid && tagNameLower !== 'a')) {\n    // If tag has newline, it's a type 7 block - don't interrupt paragraphs\n    // Return null to allow paragraph wrapping - parseInlineSpan will parse as raw HTML\n    // But only if validation passed (which already happened above)\n    // EXCEPTION: JSX components should be parsed as block-level HTML even with newlines\n    if (tagResult.hasNewline && !isJSXComponent) {\n      return null\n    }\n\n    // If we're not in HTML block context and not inline, parse as inline HTML\n    // This allows them to be wrapped in paragraphs per type 7 block rules\n    // Return null to allow paragraph wrapping - parseInlineSpan will parse them as raw HTML\n    // EXCEPTION: JSX components should be parsed as block-level HTML even when not in HTML block context\n    if (!state.inHTML && !state.inline && !isJSXComponent) {\n      return null\n    }\n\n    var attrsTrimmedSelfClose = tagResult.attrs.replace(/\\/\\s*$/, '')\n    var selfCloseAttrs = parseHTMLAttributes(\n      attrsTrimmedSelfClose,\n      tagNameLower,\n      tagResult.tagName,\n      options\n    )\n    // For inline context, preserve raw HTML to maintain spacing\n    var rawText = state.inline ? source.slice(pos, tagResult.endPos) : undefined\n    const result: MarkdownToJSX.HTMLSelfClosingNode & {\n      endPos: number\n      rawText?: string\n    } = {\n      type: RuleType.htmlSelfClosing,\n      tag: tagResult.tagName,\n      attrs: selfCloseAttrs,\n      endPos: tagResult.endPos,\n    }\n    if (rawText !== undefined) {\n      result.rawText = rawText\n    }\n    return result\n  }\n\n  // For inline context, parse as simple opening tag (no closing tag search)\n  // IMPORTANT: Validation must happen before this check to reject invalid tags\n  // Note: parseHTMLTag only returns a result if tag has closing >, so tag is complete\n  // Multiline attributes are supported - newlines in tags are valid HTML\n  if (state.inline) {\n    // Validation already happened above, so if we get here the tag is valid\n    var attrsTrimmedInline = tagResult.attrs.replace(/\\/\\s*$/, '')\n    // Preserve whitespace before attributes for CommonMark compliance\n    var rawAttrsWithWhitespace =\n      tagResult.whitespaceBeforeAttrs + attrsTrimmedInline\n    var parsedInlineAttrs = parseHTMLAttributes(\n      attrsTrimmedInline,\n      tagNameLower,\n      tagResult.tagName,\n      options\n    )\n    var inlineAttrs: Record<string, any> = {\n      ...parsedInlineAttrs,\n    }\n\n    // For non-void inline tags, find matching closing tag and parse content\n    var inlineEndPos = tagResult.endPos\n    var children: MarkdownToJSX.ASTNode[] = []\n    if (!util.isVoidElement(tagResult.tagName)) {\n      var closingResult = findInlineClosingTag(\n        source,\n        tagResult.endPos,\n        tagNameLower\n      )\n      if (closingResult !== null) {\n        var content = source.slice(tagResult.endPos, closingResult[0])\n        // Recursion is prevented by state.inHTML guard at parseHTML entry\n        if (content) {\n          if (\n            (state.inHTML && HTML_BLOCK_ELEMENT_START_R.test(content)) ||\n            hasBlockContent(content)\n          ) {\n            children = parseBlocksInHTML(\n              content,\n              {\n                ...state,\n                inline: false,\n                inHTML: true,\n                inAnchor: state.inAnchor || tagNameLower === 'a',\n              },\n              options\n            )\n          } else {\n            children = parseInlineSpan(\n              content,\n              0,\n              content.length,\n              {\n                ...state,\n                inline: true,\n                inHTML: options.optimizeForStreaming ? true : state.inHTML,\n                inAnchor: state.inAnchor || tagNameLower === 'a',\n              },\n              options\n            )\n          }\n        }\n        inlineEndPos = closingResult[1]\n      }\n    }\n    return {\n      type: RuleType.htmlBlock,\n      tag: tagResult.tagName as MarkdownToJSX.HTMLTags,\n      attrs: inlineAttrs,\n      rawAttrs: rawAttrsWithWhitespace,\n      children: children,\n      verbatim: false,\n      endPos: inlineEndPos,\n    } as MarkdownToJSX.HTMLNode & { endPos: number }\n  }\n\n  // For inline context, don't try block parsing - simple opening tags should be parsed inline\n  // Block parsing is only for tags that need closing tags or are block-level\n  if (!state.inline) {\n    // Determine block type inline (previously handled by matchHTMLBlock)\n    var sourceLen = source.length\n    var firstLineEnd = util.findLineEnd(source, pos)\n    var tagLower = tagResult.tagLower\n    var isType1BlockVar = isType1Block(tagLower)\n    var isType6Block = !isType1BlockVar && isType6Tag(tagResult.tagName)\n    var tagHasClosingAngle = false\n    var checkPos = pos\n    while (checkPos < tagResult.endPos) {\n      if (source[checkPos] === '>') {\n        tagHasClosingAngle = true\n        break\n      }\n      checkPos++\n    }\n    // Check if tag is followed by end of line (with optional whitespace)\n    var afterTag = tagResult.endPos\n    while (\n      afterTag < firstLineEnd &&\n      (source[afterTag] === ' ' || source[afterTag] === '\\t')\n    ) {\n      afterTag++\n    }\n    // Check if tag is complete on line\n    // For type 6 blocks, they can have content on same line\n    // For other tags, they must be followed by newline or end of line\n    var isCompleteOnLine =\n      afterTag >= firstLineEnd ||\n      source[afterTag] === '\\n' ||\n      source[afterTag] === '\\r' ||\n      (isType6Block && afterTag < firstLineEnd) ||\n      !tagHasClosingAngle\n\n    // Type 1 blocks (pre, script, style, textarea) need matching closing tags\n    // Handle type 1 blocks even if they have newlines in the opening tag\n    if (isType1BlockVar && tagHasClosingAngle && !tagResult.isClosing) {\n      // Type 1: find matching closing tag\n      var type1TagName = tagResult.tagName\n      var type1TagEnd = tagResult.endPos\n      var type1Attrs = tagResult.attrs\n      var type1ContentPos = type1TagEnd\n      if (source[type1ContentPos] === '\\n') type1ContentPos++\n      var type1ContentStart = type1ContentPos\n      var type1ContentEnd = type1ContentPos\n      var type1Depth = 1\n      var type1OpenTagLen = tagLower.length + 1\n      while (type1Depth > 0) {\n        var type1Idx = source.indexOf('<', type1ContentPos)\n        if (type1Idx === -1) {\n          type1ContentEnd = sourceLen\n          type1ContentPos = sourceLen\n          break\n        }\n        var type1OpenIdx = -1\n        var type1CloseIdx = -1\n        if (source[type1Idx + 1] === '/') {\n          type1CloseIdx = type1Idx\n        } else if (\n          type1Idx + type1OpenTagLen + 1 <= sourceLen &&\n          (source[type1Idx + 1] === tagLower[0] ||\n            source[type1Idx + 1] === type1TagName[0])\n        ) {\n          var type1TagCandidate = source.substring(\n            type1Idx + 1,\n            type1Idx + type1OpenTagLen\n          )\n          if (\n            type1TagCandidate.toLowerCase() === tagLower &&\n            (source[type1Idx + type1OpenTagLen] === ' ' ||\n              source[type1Idx + type1OpenTagLen] === '>')\n          ) {\n            type1OpenIdx = type1Idx\n          }\n        }\n        if (type1OpenIdx === -1 && type1CloseIdx === -1) {\n          type1ContentPos = type1Idx + 1\n          continue\n        }\n        if (\n          type1OpenIdx !== -1 &&\n          (type1CloseIdx === -1 || type1OpenIdx < type1CloseIdx)\n        ) {\n          type1ContentPos = type1OpenIdx + type1OpenTagLen + 1\n          type1Depth++\n        } else {\n          var type1P = type1CloseIdx + 2\n          while (type1P < sourceLen) {\n            var type1C = source[type1P]\n            if (\n              type1C !== ' ' &&\n              type1C !== '\\t' &&\n              type1C !== '\\n' &&\n              type1C !== '\\r'\n            )\n              break\n            type1P++\n          }\n          if (type1P + tagLower.length > sourceLen) break\n          var type1CloseTagCandidate = source.substring(\n            type1P,\n            type1P + tagLower.length\n          )\n          if (type1CloseTagCandidate.toLowerCase() !== tagLower) {\n            type1ContentPos = type1P\n            continue\n          }\n          type1P += tagLower.length\n          while (type1P < sourceLen) {\n            var type1C2 = source[type1P]\n            if (\n              type1C2 !== ' ' &&\n              type1C2 !== '\\t' &&\n              type1C2 !== '\\n' &&\n              type1C2 !== '\\r'\n            )\n              break\n            type1P++\n          }\n          if (type1P >= sourceLen || source[type1P] !== '>') {\n            type1ContentPos = type1P\n            continue\n          }\n          var type1ClosingTagEnd = type1P + 1\n          var type1LineEndAfterClose = util.findLineEnd(\n            source,\n            type1ClosingTagEnd\n          )\n          type1ContentEnd = type1LineEndAfterClose\n          type1ContentPos = type1LineEndAfterClose + 1\n          type1Depth--\n        }\n      }\n      var type1TrailingNl = 0\n      while (\n        type1ContentPos + type1TrailingNl < sourceLen &&\n        source[type1ContentPos + type1TrailingNl] === '\\n'\n      )\n        type1TrailingNl++\n      var type1FullMatch = source.slice(pos, type1ContentPos + type1TrailingNl)\n      var type1Content = source.slice(type1ContentStart, type1ContentEnd)\n      var type1EndPos = type1ContentPos + type1TrailingNl\n      return processHTMLBlock(\n        tagResult.tagName,\n        tagResult.tagName,\n        type1Attrs,\n        type1Content,\n        type1FullMatch,\n        type1EndPos,\n        source,\n        state,\n        false,\n        options\n      )\n    }\n\n    // Type 6/7 blocks end at blank lines\n    if (isCompleteOnLine || !tagHasClosingAngle) {\n      // Determine if type 6 or type 7\n      var blockType: 'type6' | 'type7' = isType6Block ? 'type6' : 'type7'\n      var tagEnd = tagResult.endPos\n      var blockEnd = findNextBlankLine(\n        source,\n        skipToNextLine(source, firstLineEnd),\n        sourceLen\n      )\n\n      // For type 6 blocks, check if there's a closing tag before the blank line\n      // If found AND the next content is another HTML tag, stop at the closing tag\n      // This ensures proper nesting of sibling elements (e.g., <dt></dt><dd></dd>)\n      if (blockType === 'type6' && !tagResult.isClosing) {\n        // For JSX components, preserve case; for HTML, use lowercase\n        const tagNameForClosing = isJSXComponent\n          ? tagResult.tagName\n          : tagResult.tagLower || tagResult.tagName.toLowerCase()\n        var closingTagPattern = '</' + tagNameForClosing\n        var openingTagPattern = '<' + tagNameForClosing\n\n        // Find the matching closing tag by tracking nesting depth\n        var searchPos = tagEnd\n        var depth = 1 // We already have one opening tag (depth starts at 1)\n        var closingIdx = -1\n        while (searchPos < blockEnd && depth > 0) {\n          var nextOpenIdx = source.indexOf(openingTagPattern, searchPos)\n          var nextCloseIdx = source.indexOf(closingTagPattern, searchPos)\n\n          // Validate and find next valid opening tag (followed by whitespace or >)\n          // Note: We don't accept / because that indicates a self-closing tag\n          while (nextOpenIdx !== -1 && nextOpenIdx < blockEnd) {\n            var afterOpenPos = nextOpenIdx + openingTagPattern.length\n            if (afterOpenPos >= sourceLen) {\n              nextOpenIdx = -1\n              break\n            }\n            var charAfterOpen = source[afterOpenPos]\n            if (\n              charAfterOpen === ' ' ||\n              charAfterOpen === '\\t' ||\n              charAfterOpen === '\\n' ||\n              charAfterOpen === '\\r' ||\n              charAfterOpen === '>'\n            ) {\n              break // Valid opening tag found\n            }\n            // Not valid (could be self-closing like <div/> or partial match), search for next\n            nextOpenIdx = source.indexOf(openingTagPattern, afterOpenPos)\n          }\n\n          if (nextOpenIdx === -1 || nextOpenIdx >= blockEnd) {\n            nextOpenIdx = blockEnd\n          }\n          if (nextCloseIdx === -1 || nextCloseIdx >= blockEnd) {\n            nextCloseIdx = blockEnd\n          }\n\n          if (nextOpenIdx < nextCloseIdx) {\n            // Found an opening tag first - increase depth\n            depth++\n            searchPos = nextOpenIdx + openingTagPattern.length\n          } else if (nextCloseIdx < blockEnd) {\n            // Found a closing tag first - decrease depth\n            depth--\n            if (depth === 0) {\n              closingIdx = nextCloseIdx\n              break\n            }\n            searchPos = nextCloseIdx + closingTagPattern.length\n          } else {\n            break // No more tags found\n          }\n        }\n\n        if (closingIdx !== -1 && closingIdx < blockEnd) {\n          // Found the matching closing tag before the blank line\n          // Check if it's valid\n          var afterClosingTag = closingIdx + closingTagPattern.length\n          while (\n            afterClosingTag < sourceLen &&\n            (source[afterClosingTag] === ' ' ||\n              source[afterClosingTag] === '\\t')\n          ) {\n            afterClosingTag++\n          }\n          if (afterClosingTag < sourceLen && source[afterClosingTag] === '>') {\n            // Valid closing tag found before blank line\n            // Check if the content immediately after the closing tag (after newline) starts with another HTML tag\n            var closingTagEndPos = afterClosingTag + 1\n            var nextContentPos = closingTagEndPos\n            // Skip to next line\n            while (\n              nextContentPos < sourceLen &&\n              source[nextContentPos] !== '\\n'\n            ) {\n              nextContentPos++\n            }\n            if (nextContentPos < sourceLen) {\n              nextContentPos++ // Skip the newline\n            }\n            // Skip leading whitespace on next line\n            while (\n              nextContentPos < sourceLen &&\n              (source[nextContentPos] === ' ' ||\n                source[nextContentPos] === '\\t')\n            ) {\n              nextContentPos++\n            }\n            // Check if next content is another HTML tag (that is NOT a closing tag for our current tag)\n            if (\n              nextContentPos < sourceLen &&\n              source[nextContentPos] === '<' &&\n              !util.startsWith(source.slice(nextContentPos), closingTagPattern)\n            ) {\n              var nextTag = parseHTMLTag(source, nextContentPos)\n              if (nextTag) {\n                // Next content is a different HTML tag - stop at our closing tag\n                blockEnd = closingTagEndPos\n              }\n            }\n            // Otherwise, continue to blank line as per CommonMark\n          }\n        } else {\n          // No matching closing tag found before blank line\n          // Check if there's a closing tag after the blank line\n          closingIdx = source.indexOf(closingTagPattern, tagEnd)\n          if (closingIdx !== -1) {\n            // Closing tag found but after blank line\n            // Check if there's block content that would warrant extending to the closing tag\n            var extendedContent = source.slice(tagEnd, closingIdx)\n            var shouldExtend =\n              isJSXComponent || hasBlockContent(extendedContent)\n            if (shouldExtend) {\n              // Extend block to include closing tag\n              var afterClosingTag2 = closingIdx + closingTagPattern.length\n              while (\n                afterClosingTag2 < sourceLen &&\n                (source[afterClosingTag2] === ' ' ||\n                  source[afterClosingTag2] === '\\t')\n              ) {\n                afterClosingTag2++\n              }\n              if (\n                afterClosingTag2 < sourceLen &&\n                source[afterClosingTag2] === '>'\n              ) {\n                var closingLineEnd = util.findLineEnd(\n                  source,\n                  afterClosingTag2 + 1\n                )\n                blockEnd = closingLineEnd\n              }\n            }\n          }\n        }\n      }\n\n      var blockContent = source.slice(tagEnd, blockEnd)\n      var blockAttrs = tagResult.whitespaceBeforeAttrs + tagResult.attrs\n      var isClosingTag = tagResult.isClosing\n\n      // Handle type 6/7 blocks\n      // For type 7 blocks with empty content (standalone tags), determine if they should be block or inline\n      // Per CommonMark: Type 7 blocks cannot interrupt paragraphs, but if they're on their own line they're blocks\n      // However, if the tag contains newlines in attributes (without hasNewline flag because they're in quotes),\n      // it should be treated as inline and wrapped in a paragraph\n\n      // Helper to parse type 7 block attributes\n      const parseType7Attrs = () => {\n        const tagLower = tagResult.tagLower || tagResult.tagName.toLowerCase()\n        const rawAttrs = tagResult.whitespaceBeforeAttrs + tagResult.attrs\n        return {\n          parsed: parseHTMLAttributes(\n            rawAttrs,\n            tagLower,\n            tagResult.tagName,\n            options\n          ),\n          raw: rawAttrs,\n        }\n      }\n\n      if (blockType === 'type7' && blockContent.trim() === '') {\n        // Check if the tag itself contains a newline (inside the tag, not after it)\n        var rawTagText = source.slice(pos, tagResult.endPos)\n        var tagContainsNewline = rawTagText.indexOf('\\n') !== -1\n\n        if (tagContainsNewline) {\n          // Tag has newline inside it (in attribute) - should be wrapped in paragraph\n          return null\n        }\n\n        // Tag is on its own line, treat as block\n        var tagEndInSource = tagResult.endPos\n        var tagLineEnd = util.findLineEnd(source, tagEndInSource)\n        if (tagLineEnd < source.length) tagLineEnd++\n        var rawTag = source.slice(pos, tagLineEnd)\n        // Parse attributes for single-line type 7 blocks\n        const type7Attrs = parseType7Attrs()\n        return createVerbatimHTMLBlock(\n          tagResult.tagName,\n          rawTag,\n          blockEnd,\n          type7Attrs.parsed,\n          type7Attrs.raw,\n          isClosingTag,\n          false, // type 7 blocks cannot interrupt paragraphs\n          options,\n          state\n        )\n      }\n\n      // For type 7 blocks with multi-line or incomplete opening tags, preserve raw HTML\n      var openingTagHasNewline = tagResult.hasNewline\n      var openingTagIsIncomplete = !tagHasClosingAngle\n      if (\n        (openingTagHasNewline || openingTagIsIncomplete) &&\n        blockType === 'type7'\n      ) {\n        var openingTagEnd = tagResult.endPos\n        var rawOpeningTag = source.slice(pos, openingTagEnd)\n        var rawContent = blockContent\n        var fullRawHTML = rawOpeningTag + rawContent\n        // Parse attributes even for multi-line tags (#781)\n        const multilineAttrs = parseType7Attrs()\n        return createVerbatimHTMLBlock(\n          tagResult.tagName,\n          fullRawHTML,\n          blockEnd,\n          multilineAttrs.parsed,\n          multilineAttrs.raw,\n          isClosingTag,\n          false, // type 7 blocks cannot interrupt paragraphs\n          options,\n          state\n        )\n      }\n\n      // Parse attributes, but always preserve raw attributes for consistency\n      // Cache lowercase tag name to avoid repeated toLowerCase() calls\n      const tagLower = tagResult.tagLower || tagResult.tagName.toLowerCase()\n      var parsedBlockAttributes = parseHTMLAttributes(\n        blockAttrs,\n        tagLower,\n        tagResult.tagName,\n        options\n      )\n      var blockAttributes: Record<string, any> = {\n        ...parsedBlockAttributes,\n      }\n\n      // For type 6 blocks with block syntax, parse through processHTMLBlock\n      if (blockType === 'type6') {\n        var contentForBlockCheck = blockContent\n        var closingTagIdx = blockContent.indexOf('</' + tagLower)\n        if (closingTagIdx >= 0) {\n          var afterTag = closingTagIdx + 2 + tagResult.tagName.length\n          while (\n            afterTag < blockContent.length &&\n            (blockContent[afterTag] === ' ' || blockContent[afterTag] === '\\t')\n          )\n            afterTag++\n          if (\n            afterTag < blockContent.length &&\n            blockContent[afterTag] === '>'\n          ) {\n            contentForBlockCheck = blockContent.slice(0, closingTagIdx)\n          }\n        }\n\n        if (hasBlockContent(contentForBlockCheck)) {\n          return processHTMLBlock(\n            tagResult.tagName,\n            tagResult.tagName,\n            blockAttrs,\n            contentForBlockCheck,\n            source.slice(pos, tagResult.endPos),\n            blockEnd,\n            source,\n            state,\n            false,\n            options\n          )\n        }\n      }\n\n      var verbatimContent = blockContent\n      if (verbatimContent.length > 0) {\n        if (verbatimContent[0] === '\\r' && verbatimContent[1] === '\\n') {\n          verbatimContent = verbatimContent.slice(2)\n        } else if (verbatimContent[0] === '\\n' || verbatimContent[0] === '\\r') {\n          verbatimContent = verbatimContent.slice(1)\n        }\n      }\n      // Per CommonMark spec: remove common leading whitespace from all lines\n      var lines = verbatimContent.split('\\n')\n      var minIndent = Infinity\n      for (var lineIdx = 0; lineIdx < lines.length; lineIdx++) {\n        var line = lines[lineIdx]\n        if (line.trim().length === 0) continue\n        var indent = 0\n        while (\n          indent < line.length &&\n          (line[indent] === ' ' || line[indent] === '\\t')\n        ) {\n          indent++\n        }\n        if (indent < minIndent) minIndent = indent\n      }\n      if (minIndent > 0 && minIndent < Infinity) {\n        var dedentedLines: string[] = []\n        for (var lineIdx2 = 0; lineIdx2 < lines.length; lineIdx2++) {\n          var line2 = lines[lineIdx2]\n          if (line2.trim().length === 0) {\n            dedentedLines.push(line2)\n          } else {\n            dedentedLines.push(line2.slice(minIndent))\n          }\n        }\n        verbatimContent = dedentedLines.join('\\n')\n      }\n\n      return createVerbatimHTMLBlock(\n        tagResult.tagName,\n        verbatimContent,\n        blockEnd,\n        blockAttributes,\n        blockAttrs,\n        isClosingTag,\n        blockType === 'type6' ? true : false, // type 6 can interrupt, type 7 cannot\n        options,\n        state\n      )\n    }\n  }\n\n  // If we're in inline context and didn't match simple tag parsing, return null\n  // This allows the tag to be escaped or handled by other parsers\n  if (state.inline) {\n    return null\n  }\n\n  // Fallback: Try void element without /> (manual parsing)\n  // Only try this if self-closing didn't match\n  var tagNameResult = parseHTMLTagName(source, pos + 1)\n  if (!tagNameResult) return null\n\n  var tagName = tagNameResult.tagName\n  if (!util.isVoidElement(tagName)) {\n    return null\n  }\n\n  // Use tagLower from parseHTMLTagName result to avoid repeated toLowerCase() calls\n  const tagLowerVoid = tagNameResult.tagLower\n\n  var i = tagNameResult.nextPos\n  var len = source.length\n  while (i < len && isSpaceOrTab(source[i])) i++\n  var attrsStart = i\n\n  while (i < len && source[i] !== '>') i++\n  if (i >= len) return null\n\n  const attrs = source.slice(attrsStart, i).trim()\n  const afterAngle = i + 1\n\n  let checkIdx = afterAngle\n  while (checkIdx < len && isSpaceOrTab(source[checkIdx])) checkIdx++\n  const closeTagPattern = '</' + tagLowerVoid + '>'\n  const foundIdx = source.toLowerCase().indexOf(closeTagPattern, checkIdx)\n  if (foundIdx !== -1) {\n    const between = source.slice(checkIdx, foundIdx).trim()\n    if (between) {\n      return null\n    }\n  }\n\n  i++\n  const endPos = i\n  while (i < len && isSpaceOrTab(source[i])) i++\n  if (i < len && source[i] === '\\n') i++\n\n  const fallbackAttributes = parseHTMLAttributes(\n    attrs,\n    tagName,\n    tagName,\n    options\n  )\n\n  return {\n    type: RuleType.htmlSelfClosing,\n    tag: tagName,\n    attrs: fallbackAttributes,\n    endPos,\n  } as MarkdownToJSX.HTMLSelfClosingNode & { endPos: number }\n}\n\n// ============================================================================\n// HTML Token Interface and Unified Scanner\n// Ultra-compact unified scanner for all HTML constructs\n// ============================================================================\n\nexport interface HTMLToken {\n  kind: 'tag' | 'comment' | 'pi' | 'declaration' | 'cdata'\n  tagNameLower?: string\n  tagName?: string\n  isClosing?: boolean\n  isSelfClosing?: boolean\n  hasNewline: boolean\n  type6Candidate?: boolean\n  type7Candidate?: boolean\n  endPos: number\n  attrs?: string\n  whitespaceBeforeAttrs?: string\n  text?: string\n  raw?: boolean\n}\n\n/**\n * Scan tag-like constructs: </tag, <tag\n */\nfunction scanTagLike(source: string, pos: number): HTMLToken | null {\n  if (source[pos] !== '<') return null\n\n  var sourceLen = source.length\n\n  // Check for closing tag (</tag>)\n  var isClosing = false\n  var tagStart = pos + 1\n  if (pos + 1 < sourceLen && source[pos + 1] === '/') {\n    isClosing = true\n    tagStart = pos + 2\n  }\n\n  // Parse tag name\n  var tagNameResult = parseHTMLTagName(source, tagStart)\n  if (!tagNameResult) return null\n\n  var tagName = tagNameResult.tagName\n  var tagLower = tagNameResult.tagLower\n  var attrsStart = tagNameResult.nextPos\n\n  // Fast path: tags without attributes or whitespace\n  if (attrsStart < sourceLen) {\n    var immediateChar = source[attrsStart]\n    if (immediateChar === '>' || immediateChar === '/') {\n      var endPos = immediateChar === '>' ? attrsStart + 1 : attrsStart + 2\n      if (\n        immediateChar === '/' &&\n        (attrsStart + 1 >= sourceLen || source[attrsStart + 1] !== '>')\n      ) {\n        return null\n      }\n      var isSelfClosingFast = immediateChar === '/'\n      var type6CandidateFast = isType6Tag(tagName)\n      var type7CandidateFast = !isType1Block(tagLower) && !type6CandidateFast\n      return {\n        kind: 'tag',\n        tagNameLower: tagLower,\n        tagName: tagName,\n        isClosing: isClosing,\n        isSelfClosing: isSelfClosingFast,\n        hasNewline: false,\n        type6Candidate: type6CandidateFast,\n        type7Candidate: type7CandidateFast,\n        endPos: endPos,\n        attrs: '',\n        whitespaceBeforeAttrs: '',\n      }\n    }\n  }\n\n  // Capture whitespace after tag name (including newlines per CommonMark spec)\n  var whitespaceStart = attrsStart\n  var hasNewline = false\n  while (attrsStart < sourceLen) {\n    var ch = source[attrsStart]\n    var code = charCode(source, attrsStart)\n    if (ch === ' ' || ch === '\\t') {\n      // Space or tab - continue\n    } else if (code === 10 || code === 13) {\n      // \\n or \\r\n      hasNewline = true\n    } else {\n      break // Not whitespace\n    }\n    attrsStart++\n  }\n  var whitespaceBeforeAttrs = source.slice(whitespaceStart, attrsStart)\n\n  // Parse attributes until we find > - minimal validation only for boundary detection\n  var tagEnd = attrsStart\n  var inQuotes = false\n  var quoteChar = ''\n  var braceDepth = 0\n  var hasSlash = false\n  var hasSpaceBeforeSlash = false\n\n  // State machine for attribute parsing: 0=normal, 1=inDoubleQuotes, 2=inSingleQuotes\n  var parseState = 0\n  while (tagEnd < sourceLen) {\n    var char = source[tagEnd]\n    var code = charCode(source, tagEnd)\n\n    // Handle quotes state machine\n    if (parseState === 1) {\n      // in double quotes\n      if (char === '\"') {\n        // Check for consecutive quotes (invalid HTML)\n        if (tagEnd + 1 < sourceLen && source[tagEnd + 1] === '\"') {\n          return null\n        }\n        parseState = 0\n      }\n      tagEnd++\n    } else if (parseState === 2) {\n      // in single quotes\n      if (char === \"'\") {\n        parseState = 0\n      }\n      tagEnd++\n    } else if (char === '\"') {\n      parseState = 1\n      tagEnd++\n    } else if (char === \"'\") {\n      parseState = 2\n      tagEnd++\n    } else if (char === '{' || (char === '}' && braceDepth > 0)) {\n      // Track JSX expression brace depth\n      braceDepth += char === '{' ? 1 : -1\n      tagEnd++\n    } else if (char === '>' && braceDepth === 0) {\n      // Found closing > - check for self-closing / and space before >\n      if (tagEnd > attrsStart) {\n        var checkBack = tagEnd - 1\n        while (checkBack >= attrsStart) {\n          var backChar = source[checkBack]\n          if (backChar !== ' ' && backChar !== '\\t') break\n          checkBack--\n        }\n        if (checkBack >= attrsStart && source[checkBack] === '/') {\n          hasSlash = true\n          hasSpaceBeforeSlash = checkBack < tagEnd - 1\n        }\n      }\n      tagEnd++\n      break\n    } else {\n      // Check for invalid attribute name characters (*, #, !)\n      if (char === '*' || char === '#' || char === '!') {\n        var checkAhead = tagEnd + 1\n        while (checkAhead < sourceLen) {\n          var aheadChar = source[checkAhead]\n          if (\n            aheadChar === '=' ||\n            aheadChar === ' ' ||\n            aheadChar === '\\t' ||\n            aheadChar === '\\n' ||\n            aheadChar === '\\r' ||\n            aheadChar === '>'\n          ) {\n            break\n          }\n          checkAhead++\n        }\n        if (checkAhead < sourceLen && source[checkAhead] === '=') {\n          return null // Invalid char in attribute name\n        }\n      }\n      // Track newlines\n      if (code === 10 || code === 13) {\n        // \\n or \\r\n        hasNewline = true\n      }\n      tagEnd++\n    }\n  }\n\n  // Must have found >\n  if (tagEnd > sourceLen || source[tagEnd - 1] !== '>') {\n    return null\n  }\n\n  // Reject tags with unclosed quotes\n  if (parseState === 1 || parseState === 2) {\n    return null\n  }\n\n  // Reject tags with unclosed JSX expressions\n  if (braceDepth > 0) {\n    return null\n  }\n\n  // Reject tags with space between / and > (invalid HTML structure)\n  if (hasSpaceBeforeSlash) {\n    return null\n  }\n\n  var attrsEnd = tagEnd - 1\n  if (hasSlash) {\n    // For self-closing tags, exclude the / from attrs\n    attrsEnd--\n  }\n  var attrs = source.slice(attrsStart, attrsEnd)\n  var isSelfClosing = hasSlash\n\n  // Minimal validation: reject missing space after quoted attribute value\n  var lastQuotePos = -1\n  var inQuotesCheck = false\n  var quoteCharCheck = ''\n  var afterEquals = false\n  for (var i = 0; i < attrs.length; i++) {\n    var ch = attrs[i]\n    if (inQuotesCheck) {\n      if (ch === quoteCharCheck) {\n        inQuotesCheck = false\n        lastQuotePos = i\n        quoteCharCheck = ''\n        afterEquals = false\n      }\n    } else if (ch === '\"' || ch === \"'\") {\n      inQuotesCheck = true\n      quoteCharCheck = ch\n      afterEquals = false\n    } else if (ch === '=') {\n      afterEquals = true\n    } else if (lastQuotePos !== -1 && i === lastQuotePos + 1) {\n      // Immediately after closing quote\n      var code = ch.charCodeAt(0)\n      if (isAlphaCode(code)) {\n        // Letter immediately after quote - missing space, reject\n        return null\n      }\n    } else if (\n      afterEquals &&\n      !inQuotesCheck &&\n      (ch === '*' || ch === '#' || ch === '!')\n    ) {\n      // Invalid char in unquoted attribute value - reject\n      return null\n    } else if (isSpaceOrTab(ch)) {\n      afterEquals = false\n    }\n  }\n\n  // Determine type 6/7 candidates\n  var type6Candidate = isType6Tag(tagName)\n  var type7Candidate = !isType1Block(tagLower) && !type6Candidate\n\n  return {\n    kind: 'tag',\n    tagNameLower: tagLower,\n    tagName: tagName,\n    isClosing: isClosing,\n    isSelfClosing: isSelfClosing,\n    hasNewline: hasNewline,\n    type6Candidate: type6Candidate,\n    type7Candidate: type7Candidate,\n    endPos: tagEnd,\n    attrs: attrs,\n    whitespaceBeforeAttrs: whitespaceBeforeAttrs,\n  }\n}\n\n// ============================================================================\n// Unified HTML Scanner\n// Ultra-compact unified scanner for all HTML constructs\n// ============================================================================\n\n/**\n * Unified HTML scanner - handles tags, comments, PIs, declarations, CDATA\n * Ultra-compact implementation tuned for minification\n */\nfunction scanRawHTML(s: string, p: number): HTMLToken | null {\n  if (p >= s.length || s[p] !== '<') return null\n  var l = s.length\n  if (p + 1 >= l) return null\n  var c = s[p + 1]\n  if (c === '!') {\n    if (p + 4 <= l && s.slice(p, p + 4) === '<!--') {\n      // Comment: scan for -->\n      var endPos = p + 4\n      if (endPos < l && s[endPos] === '>') {\n        return {\n          kind: 'comment',\n          hasNewline: false,\n          endPos: endPos + 1,\n          text: s.slice(p, endPos + 1),\n          raw: true,\n        }\n      }\n      if (endPos + 1 < l && s[endPos] === '-' && s[endPos + 1] === '>') {\n        return {\n          kind: 'comment',\n          hasNewline: false,\n          endPos: endPos + 2,\n          text: s.slice(p, endPos + 2),\n          raw: true,\n        }\n      }\n      while (endPos + 2 < l) {\n        if (s.slice(endPos, endPos + 3) === '-->') {\n          return {\n            kind: 'comment',\n            hasNewline: false,\n            endPos: endPos + 3,\n            text: s.slice(p, endPos + 3),\n            raw: true,\n          }\n        }\n        endPos++\n      }\n      return null\n    }\n    if (p + 9 <= l && s.slice(p, p + 9) === '<![CDATA[') {\n      // CDATA: scan for ]]>\n      var endPos = p + 9\n      while (endPos + 2 < l) {\n        if (s.slice(endPos, endPos + 3) === ']]>') {\n          return {\n            kind: 'cdata',\n            hasNewline: false,\n            endPos: endPos + 3,\n            text: s.slice(p, endPos + 3),\n            raw: true,\n          }\n        }\n        endPos++\n      }\n      return null\n    }\n    if (p + 2 < l && isAlphaCode(s.charCodeAt(p + 2))) {\n      // Declaration: scan for >\n      var endPos = p + 2\n      while (endPos < l && s[endPos] !== '>') endPos++\n      if (endPos >= l) return null\n      return {\n        kind: 'declaration',\n        hasNewline: false,\n        endPos: endPos + 1,\n        text: s.slice(p, endPos + 1),\n        raw: true,\n      }\n    }\n    return null\n  }\n  if (c === '?') {\n    // Processing instruction: scan for ?>\n    var endPos = p + 2\n    while (endPos + 1 < l) {\n      if (s.slice(endPos, endPos + 2) === '?>') {\n        return {\n          kind: 'pi',\n          hasNewline: false,\n          endPos: endPos + 2,\n          text: s.slice(p, endPos + 2),\n          raw: true,\n        }\n      }\n      endPos++\n    }\n    return null\n  }\n  return scanTagLike(s, p)\n}\n\ninterface DefinitionParseResult {\n  endPos: number\n  target: string\n  title?: string\n}\n\nfunction isBlockStartAt(s: string, p: number): boolean {\n  if (p >= s.length) return false\n  var c = s[p]\n  return (\n    c === '=' ||\n    c === '-' ||\n    c === '_' ||\n    c === '*' ||\n    c === '#' ||\n    c === '>' ||\n    c === '`' ||\n    c === '~' ||\n    c === '[' ||\n    (c >= '0' && c <= '9')\n  )\n}\n\nfunction isTitleDelimiter(s: string, p: number): boolean {\n  if (p >= s.length) return false\n  var c = s[p]\n  return c === '\"' || c === \"'\" || c === '('\n}\n\nfunction parseQuotedTitle(\n  s: string,\n  p: number,\n  closeChar: string\n): { value: string; endPos: number } | null {\n  var len = s.length\n  if (p >= len || s[p] !== closeChar) return null\n  p++\n  var start = p\n  var lastWasNewline = false\n  while (p < len && s[p] !== closeChar) {\n    var c = s.charCodeAt(p)\n    if (c === $.CHAR_NEWLINE) {\n      if (lastWasNewline) return null\n      lastWasNewline = true\n      p++\n    } else if (c === $.CHAR_CR) {\n      if (p + 1 < len && s.charCodeAt(p + 1) === $.CHAR_NEWLINE) {\n        if (lastWasNewline) return null\n        lastWasNewline = true\n        p += 2\n      } else {\n        lastWasNewline = false\n        p++\n      }\n    } else {\n      lastWasNewline = false\n      if (c === $.CHAR_BACKSLASH && p + 1 < len) p++\n      p++\n    }\n  }\n  if (p >= len) return null\n  return { value: s.slice(start, p), endPos: p + 1 }\n}\n\nfunction parseParenTitle(\n  s: string,\n  p: number\n): { value: string; endPos: number } | null {\n  var len = s.length\n  if (p >= len || s[p] !== '(') return null\n  p++\n  var start = p\n  var depth = 1\n  var lastWasNewline = false\n  while (p < len && depth > 0) {\n    var c = s.charCodeAt(p)\n    if (c === $.CHAR_NEWLINE) {\n      if (lastWasNewline) return null\n      lastWasNewline = true\n      p++\n    } else if (c === $.CHAR_CR) {\n      if (p + 1 < len && s.charCodeAt(p + 1) === $.CHAR_NEWLINE) {\n        if (lastWasNewline) return null\n        lastWasNewline = true\n        p += 2\n      } else {\n        lastWasNewline = false\n        p++\n      }\n    } else {\n      lastWasNewline = false\n      if (c === $.CHAR_BACKSLASH && p + 1 < len) {\n        p++\n      } else if (c === $.CHAR_PAREN_OPEN) {\n        depth++\n      } else if (c === $.CHAR_PAREN_CLOSE) {\n        depth--\n      }\n      p++\n    }\n  }\n  if (depth !== 0) return null\n  return { value: s.slice(start, p - 1), endPos: p }\n}\n\nfunction scanFootnoteEnd(s: string, p: number): number {\n  var len = s.length\n  var pos = p\n  while (pos < len) {\n    var isLineStart = pos === 0 || s[pos - 1] === '\\n'\n    var c = s.charCodeAt(pos)\n    if (c === $.CHAR_NEWLINE && pos > p) {\n      var nextPos = pos + 1\n      if (nextPos < len && s.charCodeAt(nextPos) === $.CHAR_CR) nextPos++\n      if (nextPos < len && s.charCodeAt(nextPos) === $.CHAR_NEWLINE) {\n        var afterBlank = nextPos + 1\n        while (\n          afterBlank < len &&\n          (s[afterBlank] === ' ' || s[afterBlank] === '\\t')\n        ) {\n          afterBlank++\n        }\n        var blankLineLen = afterBlank - (pos + 1)\n        if (s.charCodeAt(pos + 1) === $.CHAR_CR) blankLineLen--\n        if (\n          afterBlank < len &&\n          s.charCodeAt(afterBlank) !== $.CHAR_NEWLINE &&\n          s.charCodeAt(afterBlank) !== $.CHAR_CR &&\n          blankLineLen < 4\n        ) {\n          return pos\n        }\n      }\n    }\n    if (isLineStart && util.startsWith(s, '[^', pos)) {\n      var checkPos = pos + 2\n      while (checkPos < len && s[checkPos] !== ']') {\n        checkPos++\n      }\n      if (\n        checkPos < len &&\n        s[checkPos] === ']' &&\n        checkPos + 1 < len &&\n        s[checkPos + 1] === ':'\n      ) {\n        return pos\n      }\n    }\n    pos++\n  }\n  return len\n}\n\nfunction parseRefContent(\n  source: string,\n  pos: number,\n  urlNewlineCount: number\n): DefinitionParseResult | null {\n  const len = source.length\n  let i = pos\n\n  // Parse URL (can be in angle brackets or plain, can span multiple lines)\n  // At this point, i should be at the start of the destination (after any whitespace/newline)\n  // Per CommonMark spec: destination can be on the same line or following lines\n  const hasAngleBrackets = i < len && source[i] === '<'\n  if (hasAngleBrackets) i++\n\n  const urlStart = i\n  let urlEnd = urlStart\n\n  // Per CommonMark spec Example 199: empty destination after colon (just whitespace/newline)\n  // is invalid - should be parsed as paragraph, not reference definition\n  // Also check if we hit a blank line (two consecutive newlines) - destination ends there\n  if (urlStart >= len) {\n    // No destination found - invalid (except for empty <>)\n    if (!hasAngleBrackets) return null\n    // For angle brackets, empty destination is valid\n    urlEnd = urlStart\n  } else if (\n    urlNewlineCount > 0 &&\n    urlStart < len &&\n    source[urlStart] === '\\n'\n  ) {\n    // We had a newline after colon, skipped whitespace, but found another newline\n    // This means blank line after colon - empty destination, invalid\n    return null\n  } else {\n    // Find end of URL - can span multiple lines\n    // Per CommonMark spec: destination ends when we encounter:\n    // 1. Closing > for angle-bracketed URLs\n    // 2. Whitespace followed by title delimiter (\", ', or () on same or next line\n    // 3. End of input or two consecutive newlines (blank line)\n    while (urlEnd < len) {\n      if (hasAngleBrackets && source[urlEnd] === '>') {\n        break\n      }\n\n      if (source[urlEnd] === '\\n') {\n        // Check if next line continues the URL or starts a title\n        const nextLineStart = urlEnd + 1\n        if (nextLineStart >= len) break\n\n        // Check for blank line (two consecutive newlines)\n        if (nextLineStart < len && source[nextLineStart] === '\\n') {\n          // Blank line - URL ends here\n          break\n        }\n\n        // Skip whitespace on next line\n        let checkPos = nextLineStart\n        while (\n          checkPos < len &&\n          (source[checkPos] === ' ' || source[checkPos] === '\\t')\n        ) {\n          checkPos++\n        }\n\n        // If next line starts with title delimiter, URL ends here\n        if (checkPos < len && isTitleDelimiter(source, checkPos)) {\n          break\n        }\n\n        // Per CommonMark spec: reference definitions are block-level constructs\n        // If next line starts with '[', it's a new reference definition, so current one ends here\n        // Stop at the newline (don't include it in the URL)\n        if (checkPos < len && source[checkPos] === '[') {\n          break\n        }\n\n        // Check if next line looks like a block-level construct or content that would terminate the ref definition\n        // Per CommonMark spec: \"No further character may occur\" after title/URL\n        // URLs can span multiple lines, but continuation lines should still look like URLs\n        if (checkPos < len) {\n          const nextChar = source[checkPos]\n          if (isBlockStartAt(source, checkPos)) {\n            break\n          }\n          // Stop if next line starts with a letter (could be content, not URL continuation)\n          // URLs typically start with /, http, https, <, or are indented\n          // But allow if it looks like a URL scheme (letter followed by :)\n          if (nextChar >= 'a' && nextChar <= 'z') {\n            // Check if it's a URL scheme (e.g., \"http:\", \"ftp:\")\n            let schemeEnd = checkPos + 1\n            while (\n              schemeEnd < len &&\n              schemeEnd < checkPos + 32 &&\n              ((source[schemeEnd] >= 'a' && source[schemeEnd] <= 'z') ||\n                (source[schemeEnd] >= 'A' && source[schemeEnd] <= 'Z') ||\n                (source[schemeEnd] >= '0' && source[schemeEnd] <= '9') ||\n                source[schemeEnd] === '+' ||\n                source[schemeEnd] === '.' ||\n                source[schemeEnd] === '-')\n            ) {\n              schemeEnd++\n            }\n            // If followed by ':', it's a URL scheme - allow continuation\n            if (schemeEnd < len && source[schemeEnd] === ':') {\n              // URL scheme - allow continuation\n            } else {\n              // Not a URL scheme - stop here (likely content)\n              break\n            }\n          }\n        }\n\n        // Otherwise, continue URL on next line (skip the newline and leading whitespace)\n        urlEnd = checkPos\n        continue\n      }\n\n      if (\n        !hasAngleBrackets &&\n        (source[urlEnd] === ' ' || source[urlEnd] === '\\t')\n      ) {\n        // Check if this whitespace is followed by a title delimiter\n        let checkPos = urlEnd + 1\n        while (\n          checkPos < len &&\n          (source[checkPos] === ' ' || source[checkPos] === '\\t')\n        ) {\n          checkPos++\n        }\n\n        // Check if next char starts a title\n        if (checkPos < len && isTitleDelimiter(source, checkPos)) {\n          break\n        }\n\n        // Check if next line starts a title\n        if (checkPos < len && source[checkPos] === '\\n') {\n          const nextLineStart = checkPos + 1\n          if (nextLineStart < len && source[nextLineStart] === '\\n') {\n            // Blank line - URL ends here\n            break\n          }\n          let nextLineCheck = nextLineStart\n          while (\n            nextLineCheck < len &&\n            (source[nextLineCheck] === ' ' || source[nextLineCheck] === '\\t')\n          ) {\n            nextLineCheck++\n          }\n          if (nextLineCheck < len && isTitleDelimiter(source, nextLineCheck)) {\n            break\n          }\n        }\n\n        // No title delimiter found - URL continues (or ends if no title)\n        // Continue parsing to find title or end\n      }\n\n      urlEnd++\n    }\n  }\n\n  if (hasAngleBrackets && (urlEnd >= len || source[urlEnd] !== '>')) {\n    return null // No closing >\n  }\n\n  // Extract target and normalize whitespace\n  // Per CommonMark spec: destination can span multiple lines\n  // Leading/trailing whitespace on each line should be trimmed, but internal whitespace preserved\n  // Also, we need to preserve newlines between continuation lines\n  let target = source.slice(urlStart, urlEnd)\n\n  // Normalize whitespace: trim leading/trailing whitespace from each line\n  // but preserve newlines and internal whitespace\n  // Per CommonMark spec: leading/trailing whitespace is trimmed from destination\n  let targetLines: string[] = []\n  let targetLineStart = 0\n  for (let i = 0; i <= target.length; i++) {\n    if (i === target.length || target[i] === '\\n') {\n      let line = target.slice(targetLineStart, i)\n      // Trim leading/trailing whitespace from this line\n      line = line.trim()\n      if (line.length > 0 || targetLines.length === 0) {\n        // Only add non-empty lines, or the first line even if empty (for angle brackets)\n        targetLines.push(line)\n        if (i < target.length) {\n          targetLines.push('\\n')\n        }\n      } else if (i < target.length) {\n        // Empty continuation line - preserve as newline\n        targetLines.push('\\n')\n      }\n      targetLineStart = i + 1\n    }\n  }\n\n  target = targetLines.join('')\n\n  // Trim leading/trailing whitespace from the entire target\n  target = target.trim()\n\n  i = hasAngleBrackets ? urlEnd + 1 : urlEnd\n\n  // Check if we stopped URL parsing because next line starts with a block construct\n  // (indicating the ref definition ends here)\n  // Per Example 215: ref definitions end before setext headings\n  // A setext heading has content on one line, then = or - on the next line\n  // We need to look ahead to detect this pattern\n  var stoppedAtBlock = false\n  if (i < len && source[i] === '\\n') {\n    var nextLineStart = i + 1\n    var checkPos = nextLineStart\n    while (\n      checkPos < len &&\n      (source[checkPos] === ' ' || source[checkPos] === '\\t')\n    ) {\n      checkPos++\n    }\n    if (checkPos < len) {\n      const nextChar = source[checkPos]\n      if (isBlockStartAt(source, checkPos)) {\n        stoppedAtBlock = true\n      }\n      // Per Example 215: check if this looks like a setext heading\n      // Pattern: content line, then line starting with = or -\n      // If next line has content (not starting with block char), check if line after that starts with = or -\n      if (!stoppedAtBlock && nextChar !== '=' && nextChar !== '-') {\n        // Next line might be content - check if line after that starts with = or -\n        var firstLineEnd = util.findLineEnd(source, checkPos)\n        if (firstLineEnd < len) {\n          var secondLineStart = skipToNextLine(source, firstLineEnd)\n          var secondCheckPos = secondLineStart\n          while (\n            secondCheckPos < len &&\n            (source[secondCheckPos] === ' ' || source[secondCheckPos] === '\\t')\n          ) {\n            secondCheckPos++\n          }\n          if (secondCheckPos < len) {\n            var secondChar = source[secondCheckPos]\n            if (secondChar === '=' || secondChar === '-') {\n              // This is a setext heading pattern - ref definition should end before content line\n              stoppedAtBlock = true\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Per CommonMark spec: title delimiter must be separated by whitespace from destination\n  // Check if we see a title delimiter immediately after destination (no whitespace)\n  // This makes it invalid as a reference definition\n  if (!stoppedAtBlock && i < len && isTitleDelimiter(source, i)) {\n    // Title delimiter immediately after destination without whitespace - invalid\n    return null\n  }\n\n  // Skip whitespace between destination and title (including optional newline)\n  // Per CommonMark spec: title must be separated from destination by spaces/tabs\n  // The title can be on the same line or a following line\n  // Per CommonMark spec: Unicode whitespace (like non-breaking space) does NOT work for separation\n  // However, if we stopped because next line starts with a block construct, don't skip past the newline\n  let titleNewlineCount = 0\n  while (i < len && !stoppedAtBlock) {\n    const c = source[i]\n    if (c === '\\n') {\n      titleNewlineCount++\n      if (titleNewlineCount > 1) break // Only one optional newline allowed before title\n      i++\n      // After newline, skip leading whitespace on next line (only ASCII space/tab)\n      var whitespaceStart = i\n      i = util.skipWhitespace(source, i)\n      // If we hit Unicode whitespace, stop\n      if (\n        i < len &&\n        util.isUnicodeWhitespace(source[i]) &&\n        source[i] !== '\\n'\n      ) {\n        i = whitespaceStart - 1\n        break\n      }\n      // Check if next line starts with a block construct (ref definition ends here)\n      // Per Example 215: setext headings (= or -) also terminate ref definitions\n      if (i < len) {\n        const nextChar = source[i]\n        if (isBlockStartAt(source, i)) {\n          stoppedAtBlock = true\n          i = whitespaceStart - 1 // Back up to the newline\n          break\n        }\n        // Also check if this looks like a setext heading (need to look ahead to see if there's\n        // a line that starts with = or - after some content)\n        // For now, just checking = or - is sufficient as they're already in the block check above\n      }\n    } else if (c === ' ' || c === '\\t') {\n      i++\n    } else if (util.isUnicodeWhitespace(c)) {\n      // Unicode whitespace does NOT work for separation - stop here\n      break\n    } else {\n      break\n    }\n  }\n\n  // Parse optional title (can span multiple lines, but cannot contain blank lines)\n  let title: string | undefined = undefined\n  if (i < len) {\n    const titleChar = source[i]\n    var titleResult =\n      titleChar === '('\n        ? parseParenTitle(source, i)\n        : titleChar === '\"' || titleChar === \"'\"\n          ? parseQuotedTitle(source, i, titleChar)\n          : null\n    if (\n      titleResult === null &&\n      (titleChar === '\"' || titleChar === \"'\" || titleChar === '(')\n    ) {\n      return null\n    }\n    if (titleResult) {\n      title = titleResult.value\n      i = titleResult.endPos\n      var afterTitlePos = i\n      while (\n        afterTitlePos < len &&\n        (source[afterTitlePos] === ' ' || source[afterTitlePos] === '\\t')\n      ) {\n        afterTitlePos++\n      }\n      if (\n        afterTitlePos < len &&\n        source[afterTitlePos] !== '\\n' &&\n        source[afterTitlePos] !== '\\r'\n      ) {\n        return null\n      }\n      i = afterTitlePos\n    }\n  }\n\n  // Skip trailing whitespace\n  i = util.skipWhitespace(source, i)\n\n  // Must end at newline or end of input\n  // Per CommonMark spec: no further character may occur after title\n  // Per Example 210: if there's text after the title on the same line, it's invalid\n  // The title parsing already handles this - if title is found, i points to after the closing delimiter\n  // We just need to ensure there's no non-whitespace before the newline\n  if (i < len && source[i] !== '\\n') {\n    // Check if there's non-whitespace before the newline\n    var checkEndPos = i\n    while (checkEndPos < len && source[checkEndPos] !== '\\n') {\n      if (source[checkEndPos] !== ' ' && source[checkEndPos] !== '\\t') {\n        // Found non-whitespace after title - invalid reference definition\n        return null\n      }\n      checkEndPos++\n    }\n  }\n\n  // Also check: if no title was found, make sure we're at end of line or there's trailing text\n  // Per Example 210: `[foo]: /url\\n\"title\" ok` - the \"title\" ok is trailing text, should invalidate\n  if (title === undefined && i < len && source[i] !== '\\n') {\n    // No title found, but there's content after destination - check if it's just whitespace\n    var checkTrailingPos = i\n    while (checkTrailingPos < len && source[checkTrailingPos] !== '\\n') {\n      if (\n        source[checkTrailingPos] !== ' ' &&\n        source[checkTrailingPos] !== '\\t'\n      ) {\n        // Found non-whitespace after destination - invalid reference definition\n        return null\n      }\n      checkTrailingPos++\n    }\n  }\n\n  return {\n    endPos: i < len && source[i] === '\\n' ? i + 1 : i,\n    target: target,\n    title: title,\n  }\n}\n\nfunction parseFootnoteContent(\n  source: string,\n  pos: number\n): DefinitionParseResult | null {\n  // pos is already after the colon and whitespace\n  let contentStart = pos\n  let contentEnd = scanFootnoteEnd(source, pos)\n  let stoppedAtBlankLine =\n    contentEnd < source.length &&\n    source[contentEnd] === '\\n' &&\n    source[contentEnd + 1] === '\\n'\n\n  // Extract the footnote content (from after ']:' to before next footnote or end)\n  let extractEnd = contentEnd\n\n  // pos is already after the colon and whitespace, so we can use it directly\n  let contentStartPos = pos\n\n  // Process lines directly without splitting to avoid intermediate array allocation\n  var processedParts: string[] = []\n  let lineStart = contentStartPos\n  let lineIndex = 0\n  let prevWasBlank = false\n\n  while (lineStart < extractEnd) {\n    // Find line end - use findLineEnd to properly handle CRLF\n    let lineEnd = util.findLineEnd(source, lineStart)\n    if (lineEnd > extractEnd) lineEnd = extractEnd\n\n    // Extract and process line\n    if (lineIndex === 0) {\n      // First line - trim trailing whitespace only\n      let trimmedEnd = lineEnd\n      while (\n        trimmedEnd > lineStart &&\n        (source[trimmedEnd - 1] === ' ' || source[trimmedEnd - 1] === '\\t')\n      ) {\n        trimmedEnd--\n      }\n      // Build first line\n      let firstLineStr = source.slice(lineStart, trimmedEnd)\n      processedParts.push(firstLineStr)\n      // Check if first line is blank\n      prevWasBlank = firstLineStr.length === 0\n    } else {\n      // Check indentation on current line\n      let leadingSpaceCount = 0\n      let checkPos = lineStart\n      while (\n        checkPos < lineEnd &&\n        checkPos < lineStart + 4 &&\n        source[checkPos] === ' '\n      ) {\n        leadingSpaceCount++\n        checkPos++\n      }\n\n      // Check if current line is blank\n      let lineHasContent = false\n      for (let k = lineStart; k < lineEnd; k++) {\n        if (source[k] !== ' ' && source[k] !== '\\t' && source[k] !== '\\r') {\n          lineHasContent = true\n          break\n        }\n      }\n      let currentIsBlank = !lineHasContent\n\n      // Process continuation line based on indentation rules\n      if (leadingSpaceCount >= 4 && prevWasBlank) {\n        // 4+ spaces after a blank line - this is a paragraph, preserve indentation\n        processedParts.push(source.slice(lineStart, lineEnd))\n      } else if (leadingSpaceCount === 4 && !prevWasBlank) {\n        // Exactly 4 spaces without blank line - remove (markdown continuation indentation)\n        processedParts.push(source.slice(lineStart + 4, lineEnd))\n      } else {\n        // Otherwise preserve (less than 4 spaces or more than 4 spaces without blank line)\n        processedParts.push(source.slice(lineStart, lineEnd))\n      }\n\n      // Update prevWasBlank for next iteration\n      prevWasBlank = currentIsBlank\n    }\n\n    // Move to next line\n    if (lineEnd < extractEnd) {\n      const charAtEnd = charCode(source, lineEnd)\n      if (charAtEnd === $.CHAR_CR || charAtEnd === $.CHAR_NEWLINE) {\n        processedParts.push('\\n')\n        lineStart = skipToNextLine(source, lineEnd)\n      } else {\n        lineStart = extractEnd\n      }\n    } else {\n      lineStart = extractEnd\n    }\n    lineIndex++\n  }\n\n  let footnoteContent = processedParts.join('')\n\n  // Trim trailing whitespace/newlines but preserve internal structure\n  // If we stopped at a blank line, remove the trailing newline from the last line\n  if (stoppedAtBlankLine) {\n    // Remove trailing newline if present (but preserve newlines between lines)\n    footnoteContent = footnoteContent.replace(/\\n$/, '')\n  }\n  var contentLen = footnoteContent.length\n  while (contentLen > 0) {\n    var lastChar = footnoteContent[contentLen - 1]\n    if (lastChar === '\\n' || lastChar === ' ') {\n      contentLen--\n    } else {\n      break\n    }\n  }\n  if (contentLen < footnoteContent.length) {\n    footnoteContent = footnoteContent.slice(0, contentLen)\n  }\n\n  return {\n    endPos: contentEnd,\n    target: footnoteContent,\n    title: undefined,\n  }\n}\n\nexport function parseDefinition(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  isFootnote: boolean\n): ParseResult | null {\n  if (source[pos] !== '[') return null\n  var hasCaret = pos + 1 < source.length && source[pos + 1] === '^'\n  if (isFootnote ? !hasCaret : hasCaret) return null\n\n  var lineStart = pos\n  while (lineStart > 0 && source[lineStart - 1] !== '\\n') lineStart--\n  if (\n    calculateIndent(source, lineStart, pos).spaceEquivalent >= 4 ||\n    state.inline\n  )\n    return null\n\n  var labelStart = pos + (isFootnote ? 2 : 1)\n  var len = source.length\n  var refEnd = findUnescapedChar(source, labelStart, len, ']')\n  if (refEnd === -1) return null\n  var ref = source.slice(labelStart, refEnd)\n  if (ref.length > 999) return null\n\n  var hasNonWhitespace = false,\n    hasUnescapedBracket = false,\n    labelHasNewlines = false\n  for (var j = 0; j < ref.length; j++) {\n    var c = ref[j]\n    if (c === '\\\\' && j + 1 < ref.length) {\n      j++\n      continue\n    }\n    var cCode = charCode(c)\n    if (cCode === $.CHAR_BRACKET_OPEN || cCode === $.CHAR_BRACKET_CLOSE) {\n      hasUnescapedBracket = true\n    } else if (cCode === $.CHAR_NEWLINE || cCode === $.CHAR_CR) {\n      labelHasNewlines = true\n    } else if (cCode !== $.CHAR_SPACE && cCode !== $.CHAR_TAB) {\n      hasNonWhitespace = true\n    }\n  }\n  if (!hasNonWhitespace || hasUnescapedBracket) return null\n\n  var i = refEnd + 1\n  if (labelHasNewlines) {\n    var labelStartCode = charCode(source, labelStart)\n    var refEndPrevCode = charCode(source, refEnd - 1)\n    if (\n      labelStartCode === $.CHAR_NEWLINE ||\n      labelStartCode === $.CHAR_CR ||\n      refEndPrevCode === $.CHAR_NEWLINE ||\n      refEndPrevCode === $.CHAR_CR ||\n      i >= len ||\n      source[i] !== ':'\n    )\n      return null\n  } else {\n    if (i >= len || source[i] !== ':') {\n      i = util.skipWhitespace(source, i)\n      if (i < len && charCode(source, i) === $.CHAR_NEWLINE)\n        i = util.skipWhitespace(source, i + 1)\n      if (i >= len || source[i] !== ':') return null\n    }\n  }\n  i++\n\n  var urlNewlineCount = 0\n  while (i < len) {\n    var iCode = charCode(source, i)\n    if (iCode === $.CHAR_NEWLINE) {\n      if (++urlNewlineCount > 1) break\n      i = util.skipWhitespace(source, i + 1)\n    } else if (iCode === $.CHAR_SPACE || iCode === $.CHAR_TAB) {\n      i++\n    } else {\n      break\n    }\n  }\n\n  const contentResult = isFootnote\n    ? parseFootnoteContent(source, i)\n    : parseRefContent(source, i, urlNewlineCount)\n  if (!contentResult) return null\n\n  const normalizedRef = normalizeReferenceLabel(ref)\n  const refs = state.refs || {}\n  const storageKey = isFootnote ? `^${normalizedRef}` : normalizedRef\n  if (!refs[storageKey]) {\n    refs[storageKey] = {\n      target: unescapeUrlOrTitle(contentResult.target.trim()),\n      title: contentResult.title\n        ? unescapeUrlOrTitle(contentResult.title)\n        : undefined,\n    }\n    state.refs = refs\n  }\n\n  return {\n    type: isFootnote ? RuleType.footnote : RuleType.ref,\n    endPos: contentResult.endPos,\n  } as (MarkdownToJSX.ReferenceNode | MarkdownToJSX.FootnoteNode) & {\n    endPos: number\n  }\n}\n\n// Delimiter stack entry for CommonMark spec delimiter stack algorithm\ninterface DelimiterEntry {\n  nodeIndex: number // Index in result array where this delimiter text node is\n  type: '*' | '_' | '~' | '='\n  length: number // Number of delimiters in the run\n  canOpen: boolean // Whether this delimiter can open emphasis\n  canClose: boolean // Whether this delimiter can close emphasis\n  active: boolean // Whether this delimiter is active\n  sourcePos: number // Source position where this delimiter starts (for overlap detection)\n  inAnchor: boolean // Whether this delimiter was collected inside a link (should not match with delimiters outside)\n}\n\n// Process emphasis using delimiter stack algorithm per CommonMark spec\nfunction processEmphasis(\n  nodes: MarkdownToJSX.ASTNode[],\n  delimiterStack: DelimiterEntry[],\n  stackBottom: number | null\n): void {\n  // openers_bottom for each delimiter type, indexed by numeric key: typeCode * 6 + (length % 3) * 2 + (canOpen ? 1 : 0)\n  // Type codes: '*' = 0, '_' = 1, '~' = 2, '=' = 3\n  var openersBottom: number[] = []\n\n  var currentPosition = stackBottom === null ? 0 : stackBottom + 1\n\n  while (currentPosition < delimiterStack.length) {\n    var closer = delimiterStack[currentPosition]\n    if (\n      !closer ||\n      (closer.type !== '*' &&\n        closer.type !== '_' &&\n        closer.type !== '~' &&\n        closer.type !== '=')\n    ) {\n      currentPosition++\n      continue\n    }\n\n    if (!closer.canClose || !closer.active) {\n      currentPosition++\n      continue\n    }\n\n    // Convert type to numeric code: '*' = 0, '_' = 1, '~' = 2, '=' = 3\n    var typeCode =\n      closer.type === '*'\n        ? 0\n        : closer.type === '_'\n          ? 1\n          : closer.type === '~'\n            ? 2\n            : 3\n    var openersBottomKey =\n      typeCode * 6 + (closer.length % 3) * 2 + (closer.canOpen ? 1 : 0)\n    var openersBottomIndex =\n      openersBottom[openersBottomKey] !== undefined\n        ? openersBottom[openersBottomKey]\n        : stackBottom === null\n          ? -1\n          : stackBottom\n\n    var openerIndex = -1\n    var closerType = closer.type\n    var closerInAnchor = closer.inAnchor\n    var closerCanOpen = closer.canOpen\n    var closerLength = closer.length\n    var closerLengthMod3 = closerLength % 3\n\n    for (var i = currentPosition - 1; i > openersBottomIndex; i--) {\n      var candidate = delimiterStack[i]\n      if (\n        !candidate ||\n        !candidate.active ||\n        candidate.type !== closerType ||\n        !candidate.canOpen ||\n        candidate.inAnchor !== closerInAnchor\n      )\n        continue\n      var openerLength = candidate.length\n      if (\n        (!closerCanOpen && !candidate.canClose) ||\n        closerLengthMod3 === 0 ||\n        (openerLength + closerLength) % 3 !== 0\n      ) {\n        openerIndex = i\n        break\n      }\n    }\n\n    if (openerIndex >= 0) {\n      var opener = delimiterStack[openerIndex]\n      var openerLength = opener.length\n\n      // Determine if emphasis or strong emphasis (both must have length >= 2 for strong)\n      var isStrong = openerLength >= 2 && closerLength >= 2\n      var delimitersToRemove = isStrong ? 2 : 1\n      if (\n        delimitersToRemove > openerLength ||\n        delimitersToRemove > closerLength\n      ) {\n        currentPosition++\n        continue\n      }\n\n      var openerNodeIndex = opener.nodeIndex\n      var closerNodeIndex = closer.nodeIndex\n      var contentStartIndex = openerNodeIndex + 1\n      var contentEndIndex = closerNodeIndex\n      var contentNodes = nodes.slice(contentStartIndex, contentEndIndex)\n\n      // Remove content nodes from nodes array (they'll be in the emphasis node)\n      if (contentNodes.length > 0) {\n        var nodesRemoved = contentEndIndex - contentStartIndex\n        nodes.splice(contentStartIndex, nodesRemoved)\n        for (var k = 0; k < delimiterStack.length; k++) {\n          if (delimiterStack[k].nodeIndex > contentStartIndex)\n            delimiterStack[k].nodeIndex -= nodesRemoved\n        }\n        if (closerNodeIndex > contentStartIndex) closerNodeIndex -= nodesRemoved\n      }\n\n      var emphasisTag =\n        opener.type === '~'\n          ? 'del'\n          : opener.type === '='\n            ? 'mark'\n            : isStrong\n              ? 'strong'\n              : 'em'\n      var emphasisNode: MarkdownToJSX.FormattedTextNode = {\n        type: RuleType.textFormatted,\n        tag: emphasisTag,\n        children: contentNodes,\n      }\n\n      var openerNode = nodes[openerNodeIndex] as MarkdownToJSX.TextNode\n      if (!openerNode || !openerNode.text) {\n        opener.active = closer.active = false\n        continue\n      }\n\n      // Remove delimiters from opener text node\n      var openerRemoved = openerNode.text.length <= delimitersToRemove\n      if (openerRemoved) {\n        nodes.splice(openerNodeIndex, 1)\n        for (var k = 0; k < delimiterStack.length; k++) {\n          if (delimiterStack[k].nodeIndex > openerNodeIndex)\n            delimiterStack[k].nodeIndex--\n        }\n        if (closerNodeIndex > openerNodeIndex) closerNodeIndex--\n      } else {\n        openerNode.text = openerNode.text.slice(delimitersToRemove)\n      }\n\n      var closerNode = nodes[closerNodeIndex] as MarkdownToJSX.TextNode\n      if (!closerNode || !closerNode.text) {\n        opener.active = closer.active = false\n        continue\n      }\n      var closerRemoved = closerNode.text.length <= delimitersToRemove\n      if (closerRemoved) {\n        nodes.splice(closerNodeIndex, 1)\n        for (var k = 0; k < delimiterStack.length; k++) {\n          if (delimiterStack[k].nodeIndex > closerNodeIndex)\n            delimiterStack[k].nodeIndex--\n        }\n      } else {\n        closerNode.text = closerNode.text.slice(delimitersToRemove)\n      }\n\n      // Insert emphasis node after opener (or at the position where opener was)\n      var insertIndex = openerRemoved\n        ? openerNodeIndex < closerNodeIndex\n          ? closerNodeIndex - 1\n          : openerNodeIndex\n        : openerNodeIndex + 1\n      if (insertIndex < 0 || insertIndex > nodes.length)\n        insertIndex = insertIndex < 0 ? 0 : nodes.length\n      nodes.splice(insertIndex, 0, emphasisNode)\n\n      // Update node indices in delimiter stack after insertion\n      for (var k = 0; k < delimiterStack.length; k++) {\n        if (delimiterStack[k].nodeIndex >= insertIndex) {\n          delimiterStack[k].nodeIndex++\n        }\n      }\n\n      // Remove delimiters between opener and closer from stack\n      for (var k = openerIndex + 1; k < currentPosition; k++) {\n        delimiterStack[k].active = false\n      }\n\n      // Update opener and closer in stack\n      if (openerRemoved) {\n        opener.active = false\n      } else {\n        opener.length -= delimitersToRemove\n        if (opener.length === 0) opener.active = false\n      }\n\n      if (closerRemoved) {\n        closer.active = false\n        currentPosition++\n      } else {\n        closer.length -= delimitersToRemove\n        if (closer.length === 0) {\n          closer.active = false\n          currentPosition++\n        }\n      }\n    } else {\n      // No opener found\n      openersBottom[openersBottomKey] = currentPosition - 1\n      if (!closer.canOpen) {\n        closer.active = false\n      }\n      currentPosition++\n    }\n  }\n\n  // Remove inactive delimiters from stack (O(n) shift algorithm instead of O(nÂ²) splice)\n  var writeIndex = 0\n  for (var i = 0; i < delimiterStack.length; i++) {\n    if (delimiterStack[i].active) {\n      delimiterStack[writeIndex++] = delimiterStack[i]\n    }\n  }\n  delimiterStack.length = writeIndex\n}\n\nexport function parseMarkdown(\n  input: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  var result: MarkdownToJSX.ASTNode[] = []\n  var pos = 0\n  var REF_CHECK_UNSET = -3\n  var cachedRefCheckPos = REF_CHECK_UNSET\n\n  // If inline mode, just parse the entire input as inline content\n  if (state.inline)\n    return parseInlineSpan(input, 0, input.length, state, options)\n\n  // Block parsing mode\n\n  // Check for frontmatter at the beginning (skip if doesn't start with ---)\n  if (pos === 0 && input.startsWith('---')) {\n    var frontmatterResult = parseFrontmatter(input, pos)\n    if (frontmatterResult) {\n      result.push(frontmatterResult)\n      pos = frontmatterResult.endPos\n    }\n  }\n\n  while (pos < input.length) {\n    // Skip leading newlines (but preserve whitespace for indented code blocks)\n    while (pos < input.length && input[pos] === '\\n') {\n      pos++\n    }\n\n    if (pos >= input.length) break\n    cachedRefCheckPos = REF_CHECK_UNSET\n\n    const char = input[pos]\n\n    // Try parseBlock first (handles indentation and tries all block parsers)\n    // Note: Individual parsers called by parseBlock track their own attempts\n    const parseResult = parseBlock(input, pos, state, options)\n    if (parseResult) {\n      const t = parseResult.type\n      if (t === RuleType.codeBlock) {\n        var isFenced = char === '`' || char === '~'\n        if (!isFenced && (char === ' ' || char === '\\t')) {\n          const lineEnd = util.findLineEnd(input, pos)\n          const indentInfo = calculateIndent(input, pos, lineEnd)\n          isFenced =\n            indentInfo.spaceEquivalent <= 3 &&\n            pos + indentInfo.charCount < input.length &&\n            (input[pos + indentInfo.charCount] === '`' ||\n              input[pos + indentInfo.charCount] === '~')\n        }\n      } else if (t === RuleType.breakThematic) {} else if (t === RuleType.blockQuote) {} else if (t === RuleType.heading) {} else if (t === RuleType.orderedList || t === RuleType.unorderedList) {} else if (t === RuleType.table) {} else if (t === RuleType.htmlComment) {} else if (t === RuleType.htmlBlock) {} else if (t === RuleType.ref) {}\n\n      // Special handling for HTML comments with trailing content\n      if (parseResult.type === RuleType.htmlComment) {\n        result.push(parseResult)\n        const htmlCheckPos = pos\n        pos = parseResult.endPos\n\n        // Per CommonMark spec Example 177: HTML comment blocks end at --> on the same line\n        // If there's content after --> on the same line, it should be treated as literal text\n        const commentLineEnd = util.findLineEnd(input, htmlCheckPos)\n        if (pos < commentLineEnd) {\n          const textContent = input.slice(pos, commentLineEnd)\n          if (textContent.trim().length > 0) {\n            result.push({\n              type: RuleType.text,\n              text: textContent,\n            } as MarkdownToJSX.TextNode)\n          }\n          pos = commentLineEnd\n          if (pos < input.length && input[pos] === '\\n') {\n            pos++\n          }\n        }\n        continue\n      }\n      // Special handling for HTML self-closing closing tags\n      if (\n        parseResult.type === RuleType.htmlBlock ||\n        parseResult.type === RuleType.htmlSelfClosing\n      ) {\n        const isSelfClosingClosingTag =\n          parseResult.type === RuleType.htmlSelfClosing &&\n          parseResult.isClosingTag === true\n        if (isSelfClosingClosingTag && !state.inline && !state.inHTML) {\n          // Don't match, fall through to other parsers\n        } else {\n          result.push(parseResult)\n          pos = parseResult.endPos\n          continue\n        }\n      } else {\n        result.push(parseResult)\n        pos = parseResult.endPos\n        continue\n      }\n    }\n\n    // Reference definition - check BEFORE setext heading to prevent conflicts\n    // Reference definitions take precedence over setext headings (e.g., [foo]: /url\\n===)\n    let refCheckPos =\n      cachedRefCheckPos !== REF_CHECK_UNSET ? cachedRefCheckPos : pos\n    if (cachedRefCheckPos === REF_CHECK_UNSET) {\n      if (isSpaceOrTab(char)) {\n        const lineEnd = util.findLineEnd(input, pos)\n        const indentInfo = calculateIndent(input, pos, lineEnd)\n        const checkPos = pos + indentInfo.charCount\n        if (\n          indentInfo.spaceEquivalent <= 3 &&\n          checkPos < input.length &&\n          input[checkPos] === '['\n        ) {\n          refCheckPos = checkPos\n        } else {\n          refCheckPos = -1\n        }\n      } else if (char === '[') {\n        refCheckPos = pos\n      } else {\n        refCheckPos = -1\n      }\n      cachedRefCheckPos = refCheckPos\n    }\n\n    if (\n      refCheckPos >= 0 &&\n      refCheckPos + 1 < input.length &&\n      input[refCheckPos + 1] === '^'\n    ) {\n      refCheckPos = -1\n    }\n\n    if (refCheckPos >= 0) {\n      const parseResult = parseDefinition(\n        input,\n        refCheckPos,\n        state,\n        options,\n        false\n      )\n      if (parseResult) {\n        result.push(parseResult)\n        pos = parseResult.endPos\n        continue\n      }\n      // parseDefinition returned null - check if this is an invalid reference definition that should be skipped\n      // Per CommonMark Examples 208 and 210: certain invalid reference definitions should be skipped entirely\n      const skipResult = shouldSkipInvalidReferenceDefinition(\n        input,\n        refCheckPos,\n        pos === 0\n      )\n      if (skipResult.shouldSkip) {\n        pos = skipResult.newPos\n        continue\n      }\n    }\n\n    // Heading (Setext style) - check after reference definitions\n    const setextResult = parseHeadingSetext(input, pos, state, options)\n    if (setextResult) {\n      result.push(setextResult)\n      pos = setextResult.endPos\n      continue\n    }\n\n    // Footnote definition (skip leading whitespace)\n    let footnoteCheckPos = pos\n    if (isSpaceOrTab(input[footnoteCheckPos])) {\n      const lineEnd = util.findLineEnd(input, pos)\n      const indentInfo = calculateIndent(input, pos, lineEnd)\n      footnoteCheckPos = pos + indentInfo.charCount\n    }\n    if (\n      footnoteCheckPos < input.length &&\n      input[footnoteCheckPos] === '[' &&\n      footnoteCheckPos + 1 < input.length &&\n      input[footnoteCheckPos + 1] === '^'\n    ) {\n      const footnoteResult = parseDefinition(\n        input,\n        footnoteCheckPos,\n        state,\n        options,\n        true\n      )\n      if (footnoteResult) {\n        pos = footnoteResult.endPos\n        continue\n      }\n    }\n\n    const paragraphResult = parseParagraph(input, pos, state, options)\n    if (paragraphResult) {\n      result.push(paragraphResult)\n      pos = paragraphResult.endPos\n      continue\n    }\n\n    pos++\n  }\n\n  // Note: Memory snapshot \"After block parsing\" is taken in compiler function\n  // after parseMarkdown returns, not here\n\n  // Footnotes footer is appended during rendering phase (not in AST)\n  // Footnotes are stored in refs with '^' prefix and extracted during rendering\n\n  // Collect all refs from state.refs (populated during parsing) and create a reference collection node\n  // Reference nodes stay in their original positions, but we prepend a collection node\n  // Include footnotes (keys starting with '^') so the renderer can handle them\n  const allRefs = state.refs || {}\n  const collectedRefs: {\n    [key: string]: { target: string; title: string | undefined }\n  } = {}\n  for (const key in allRefs) {\n    collectedRefs[key] = allRefs[key]\n  }\n\n  // Prepend reference collection node if we have any refs\n  if (util.hasKeys(collectedRefs)) {\n    const refCollectionNode: MarkdownToJSX.ReferenceCollectionNode = {\n      type: RuleType.refCollection,\n      refs: collectedRefs,\n    }\n    return [refCollectionNode, ...result]\n  }\n\n  return result\n}\n\n/**\n * Collect reference definitions from markdown input and populate the refs object.\n * This function scans the markdown for reference-style link and image definitions.\n *\n * @param input - The markdown string to scan\n * @param refs - Object to populate with reference definitions\n * @param options - Parser options\n */\nexport function collectReferenceDefinitions(\n  input: string,\n  refs: { [key: string]: { target: string; title: string | undefined } },\n  options: ParseOptions\n): void {\n  var pos = 0\n  var canStartRef = true\n  const len = input.length\n\n  while (pos < len) {\n    var newlines = 0\n    // Count consecutive newlines more efficiently\n    while (pos < len && charCode(input, pos) === $.CHAR_NEWLINE) {\n      newlines++\n      pos++\n    }\n    if (pos >= len) break\n    if (newlines > 0) canStartRef = true\n\n    // Skip fenced code\n    const currentCharCode = charCode(input, pos)\n    if (\n      currentCharCode === $.CHAR_BACKTICK ||\n      currentCharCode === $.CHAR_TILDE\n    ) {\n      var fence = parseCodeFenced(input, pos, { inline: false }, options)\n      if (fence) {\n        pos = fence.endPos\n        canStartRef = true\n        continue\n      }\n    }\n\n    // Try parse ref (up to 3 space indent)\n    var refPos = pos\n    var indent = 0\n    while (refPos < len && indent < 4) {\n      const code = charCode(input, refPos)\n      if (code === $.CHAR_SPACE) {\n        indent++\n        refPos++\n      } else if (code === $.CHAR_TAB) {\n        indent += 4 - (indent % 4)\n        refPos++\n      } else {\n        break\n      }\n    }\n\n    if (\n      indent < 4 &&\n      refPos < len &&\n      charCode(input, refPos) === $.CHAR_BRACKET_OPEN &&\n      canStartRef\n    ) {\n      if (refPos + 1 < len && charCode(input, refPos + 1) === $.CHAR_CARET) {\n        canStartRef = false\n        var lineEnd = util.findLineEnd(input, pos)\n        pos = lineEnd >= len ? len : skipToNextLine(input, lineEnd)\n        continue\n      } else {\n        var result = parseDefinition(\n          input,\n          refPos,\n          { inline: false, refs },\n          options,\n          false\n        )\n        if (result) {\n          pos = result.endPos\n          canStartRef = true\n          continue\n        }\n        // parseDefinition returned null - check if colon exists (invalid ref attempt) vs paragraph content\n        var lineEnd = util.findLineEnd(input, pos)\n        var colonPos = input.indexOf(':', refPos + 1)\n        if (colonPos === -1 || colonPos >= lineEnd) {\n          var indentInfo = calculateIndent(input, pos, lineEnd)\n          if (\n            !isBlankLineCheck(input, pos, lineEnd) &&\n            currentCharCode !== $.CHAR_HASH &&\n            currentCharCode !== $.CHAR_GT &&\n            currentCharCode !== $.CHAR_DASH &&\n            currentCharCode !== $.CHAR_EQ &&\n            indentInfo.spaceEquivalent < 4\n          ) {\n            canStartRef = false\n          }\n        }\n        pos = lineEnd >= len ? len : skipToNextLine(input, lineEnd)\n        continue\n      }\n    }\n\n    // Scan blockquotes for nested refs\n    if (currentCharCode === $.CHAR_GT && canStartRef) {\n      var bqEnd = pos\n      var bqLines = []\n      while (bqEnd < len) {\n        var lineEnd = util.findLineEnd(input, bqEnd)\n        var quotePos = bqEnd\n        while (quotePos < lineEnd) {\n          const code = charCode(input, quotePos)\n          if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n            quotePos++\n          } else {\n            break\n          }\n        }\n        if (quotePos >= lineEnd || charCode(input, quotePos) !== $.CHAR_GT)\n          break\n\n        var contentStart = quotePos + 1\n        if (\n          contentStart < lineEnd &&\n          (charCode(input, contentStart) === $.CHAR_SPACE ||\n            charCode(input, contentStart) === $.CHAR_TAB)\n        )\n          contentStart++\n        bqLines.push(input.slice(contentStart, lineEnd))\n        bqEnd = skipToNextLine(input, lineEnd)\n      }\n      if (bqLines.length) {\n        collectReferenceDefinitions(bqLines.join('\\n'), refs, options)\n        pos = bqEnd\n        canStartRef = true\n        continue\n      }\n    }\n\n    var lineEnd = util.findLineEnd(input, pos)\n    if (lineEnd >= len) {\n      pos = len\n    } else {\n      var isCurrentLineBlank = isBlankLineCheck(input, pos, lineEnd)\n      var indentInfo = calculateIndent(input, pos, lineEnd)\n      pos = skipToNextLine(input, lineEnd)\n      canStartRef =\n        currentCharCode === $.CHAR_HASH ||\n        currentCharCode === $.CHAR_GT ||\n        currentCharCode === $.CHAR_DASH ||\n        currentCharCode === $.CHAR_EQ ||\n        isCurrentLineBlank ||\n        indentInfo.spaceEquivalent >= 4\n    }\n  }\n}\n\n/**\n * Given a markdown string, return an abstract syntax tree (AST) of the markdown.\n *\n * The first node in the AST is a reference collection node. This node contains all the\n * reference definitions found in the markdown. These reference definitions are used to\n * resolve reference links and images in the markdown.\n *\n * @lang zh ç»™å®šä¸€ä¸ª Markdown å­—ç¬¦ä¸²ï¼Œè¿”å› Markdown çš„æŠ½è±¡è¯­æ³•æ ‘ (AST)ã€‚\n *\n * AST ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¼•ç”¨é›†åˆèŠ‚ç‚¹ã€‚æ­¤èŠ‚ç‚¹åŒ…å«åœ¨ Markdown ä¸­æ‰¾åˆ°çš„æ‰€æœ‰å¼•ç”¨å®šä¹‰ã€‚è¿™äº›å¼•ç”¨å®šä¹‰ç”¨äºè§£æ Markdown ä¸­çš„å¼•ç”¨é“¾æ¥å’Œå›¾åƒã€‚\n * @lang hi à¤à¤• Markdown à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤— à¤¦à¥€ à¤—à¤ˆ à¤¹à¥ˆ, Markdown à¤•à¤¾ à¤…à¤®à¥‚à¤°à¥à¤¤ à¤¸à¤¿à¤‚à¤Ÿà¥ˆà¤•à¥à¤¸ à¤Ÿà¥à¤°à¥€ (AST) à¤²à¥Œà¤Ÿà¤¾à¤¤à¤¾ à¤¹à¥ˆà¥¤\n *\n * AST à¤®à¥‡à¤‚ à¤ªà¤¹à¤²à¤¾ à¤¨à¥‹à¤¡ à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤¸à¤‚à¤—à¥à¤°à¤¹ à¤¨à¥‹à¤¡ à¤¹à¥ˆà¥¤ à¤¯à¤¹ à¤¨à¥‹à¤¡ Markdown à¤®à¥‡à¤‚ à¤ªà¤¾à¤ˆ à¤—à¤ˆ à¤¸à¤­à¥€ à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤ªà¤°à¤¿à¤­à¤¾à¤·à¤¾à¤à¤‚ à¤¶à¤¾à¤®à¤¿à¤² à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆà¥¤ à¤¯à¥‡ à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤ªà¤°à¤¿à¤­à¤¾à¤·à¤¾à¤à¤‚ Markdown à¤®à¥‡à¤‚ à¤¸à¤‚à¤¦à¤°à¥à¤­ à¤²à¤¿à¤‚à¤•à¥à¤¸ à¤”à¤° à¤›à¤µà¤¿à¤¯à¥‹à¤‚ à¤•à¥‹ à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤‰à¤ªà¤¯à¥‹à¤— à¤•à¥€ à¤œà¤¾à¤¤à¥€ à¤¹à¥ˆà¤‚à¥¤\n *\n * @param source - The markdown string to parse.\n * @lang zh @param source - è¦è§£æçš„ Markdown å­—ç¬¦ä¸²ã€‚\n * @lang hi @param source - à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ Markdown à¤¸à¥à¤Ÿà¥à¤°à¤¿à¤‚à¤—à¥¤\n * @param options - The options for the parser.\n * @lang zh @param options - è§£æå™¨çš„é€‰é¡¹ã€‚\n * @lang hi @param options - à¤ªà¤¾à¤°à¥à¤¸à¤° à¤•à¥‡ à¤²à¤¿à¤ à¤µà¤¿à¤•à¤²à¥à¤ªà¥¤\n * @returns The AST of the markdown.\n * @lang zh @returns Markdown çš„ ASTã€‚\n * @lang hi @returns Markdown à¤•à¤¾ ASTà¥¤\n */\nexport function parser(\n  source: string,\n  options?: MarkdownToJSX.Options\n): MarkdownToJSX.ASTNode[] {\n  // Strip BOM (U+FEFF) at document start per CommonMark spec\n  if (source.charCodeAt(0) === 0xfeff) {\n    source = source.slice(1)\n  }\n\n  // Normalize input: replace null bytes with U+FFFD per CommonMark spec\n  source = util.normalizeInput(source)\n\n  // Default state\n  const defaultState: MarkdownToJSX.State = { inline: false, refs: {} }\n  const finalState = { ...defaultState }\n\n  // Normalize options - convert MarkdownToJSX.Options to ParseOptions\n  const finalOptions: ParseOptions = {\n    ...options,\n    slugify: options?.slugify\n      ? (input: string) => options.slugify(input, util.slugify)\n      : util.slugify,\n    sanitizer: options?.sanitizer || util.sanitizer,\n    tagfilter: options?.tagfilter !== false,\n  }\n\n  // Collect reference definitions if not in inline mode\n  if (!finalState.inline) {\n    collectReferenceDefinitions(source, finalState.refs || {}, finalOptions)\n  }\n\n  // Parse markdown\n  const astNodes = parseMarkdown(source, finalState, finalOptions)\n\n  return astNodes\n}\n"],"names":[],"mappings":"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"}}]
}