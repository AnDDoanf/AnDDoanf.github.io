{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;KAElC;IACL,IAAIF,QAAQC,GAAG,CAACK,yBAAyB,EAAE;;SAcpC;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1C,IAAIP,QAAQC,GAAG,CAACO,SAAS,eAAE;gBACzBL,OAAOC,OAAO,GAAGC,QAAQ;YAC3B,OAAO;;QAGT,OAAO;;IAOT;AACF","ignoreList":[0]}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/instrumentation/utils.ts"],"sourcesContent":["export function getRevalidateReason(params: {\n  isOnDemandRevalidate?: boolean\n  isStaticGeneration?: boolean\n}): 'on-demand' | 'stale' | undefined {\n  if (params.isOnDemandRevalidate) {\n    return 'on-demand'\n  }\n  if (params.isStaticGeneration) {\n    return 'stale'\n  }\n  return undefined\n}\n"],"names":["getRevalidateReason","params","isOnDemandRevalidate","isStaticGeneration","undefined"],"mappings":";;;;AAAO,SAASA,oBAAoBC,MAGnC;IACC,IAAIA,OAAOC,oBAAoB,EAAE;QAC/B,OAAO;IACT;IACA,IAAID,OAAOE,kBAAkB,EAAE;QAC7B,OAAO;IACT;IACA,OAAOC;AACT","ignoreList":[0]}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/app-render/interop-default.ts"],"sourcesContent":["/**\n * Interop between \"export default\" and \"module.exports\".\n */\nexport function interopDefault(mod: any) {\n  return mod.default || mod\n}\n"],"names":["interopDefault","mod","default"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,SAASA,eAAeC,GAAQ;IACrC,OAAOA,IAAIC,OAAO,IAAID;AACxB","ignoreList":[0]}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/app-render/strip-flight-headers.ts"],"sourcesContent":["import type { IncomingHttpHeaders } from 'node:http'\n\nimport { FLIGHT_HEADERS } from '../../client/components/app-router-headers'\n\n/**\n * Removes the flight headers from the request.\n *\n * @param req the request to strip the headers from\n */\nexport function stripFlightHeaders(headers: IncomingHttpHeaders) {\n  for (const header of FLIGHT_HEADERS) {\n    delete headers[header]\n  }\n}\n"],"names":["FLIGHT_HEADERS","stripFlightHeaders","headers","header"],"mappings":";;;;AAEA,SAASA,cAAc,QAAQ,6CAA4C;;AAOpE,SAASC,mBAAmBC,OAA4B;IAC7D,KAAK,MAAMC,UAAUH,yMAAAA,CAAgB;QACnC,OAAOE,OAAO,CAACC,OAAO;IACxB;AACF","ignoreList":[0]}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/web/spec-extension/adapters/headers.ts"],"sourcesContent":["import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n"],"names":["ReflectAdapter","ReadonlyHeadersError","Error","constructor","callable","HeadersAdapter","Headers","headers","Proxy","get","target","prop","receiver","lowercased","toLowerCase","original","Object","keys","find","o","set","value","has","deleteProperty","seal","merge","Array","isArray","join","from","append","name","existing","push","delete","forEach","callbackfn","thisArg","entries","call","key","values","Symbol","iterator"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/api-utils/index.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { BaseNextRequest } from '../base-http'\nimport type { CookieSerializeOptions } from 'next/dist/compiled/cookie'\nimport type { NextApiResponse } from '../../shared/lib/utils'\n\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport {\n  PRERENDER_REVALIDATE_HEADER,\n  PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n} from '../../lib/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NodeSpan } from '../lib/trace/constants'\n\nexport type NextApiRequestCookies = Partial<{ [key: string]: string }>\nexport type NextApiRequestQuery = Partial<{ [key: string]: string | string[] }>\n\nexport type __ApiPreviewProps = {\n  previewModeId: string\n  previewModeEncryptionKey: string\n  previewModeSigningKey: string\n}\n\nexport function wrapApiHandler<T extends (...args: any[]) => any>(\n  page: string,\n  handler: T\n): T {\n  return ((...args) => {\n    getTracer().setRootSpanAttribute('next.route', page)\n    // Call API route method\n    return getTracer().trace(\n      NodeSpan.runHandler,\n      {\n        spanName: `executing api route (pages) ${page}`,\n      },\n      () => handler(...args)\n    )\n  }) as T\n}\n\n/**\n *\n * @param res response object\n * @param statusCode `HTTP` status code of response\n */\nexport function sendStatusCode(\n  res: NextApiResponse,\n  statusCode: number\n): NextApiResponse<any> {\n  res.statusCode = statusCode\n  return res\n}\n\n/**\n *\n * @param res response object\n * @param [statusOrUrl] `HTTP` status code of redirect\n * @param url URL of redirect\n */\nexport function redirect(\n  res: NextApiResponse,\n  statusOrUrl: string | number,\n  url?: string\n): NextApiResponse<any> {\n  if (typeof statusOrUrl === 'string') {\n    url = statusOrUrl\n    statusOrUrl = 307\n  }\n  if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {\n    throw new Error(\n      `Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`\n    )\n  }\n  res.writeHead(statusOrUrl, { Location: url })\n  res.write(url)\n  res.end()\n  return res\n}\n\nexport function checkIsOnDemandRevalidate(\n  req: Request | IncomingMessage | BaseNextRequest,\n  previewProps: __ApiPreviewProps\n): {\n  isOnDemandRevalidate: boolean\n  revalidateOnlyGenerated: boolean\n} {\n  const headers = HeadersAdapter.from(req.headers)\n\n  const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)\n  const isOnDemandRevalidate = previewModeId === previewProps.previewModeId\n\n  const revalidateOnlyGenerated = headers.has(\n    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER\n  )\n\n  return { isOnDemandRevalidate, revalidateOnlyGenerated }\n}\n\nexport const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`\nexport const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`\n\nexport const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024\n\nexport const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)\nexport const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)\n\nexport function clearPreviewData<T>(\n  res: NextApiResponse<T>,\n  options: {\n    path?: string\n  } = {}\n): NextApiResponse<T> {\n  if (SYMBOL_CLEARED_COOKIES in res) {\n    return res\n  }\n\n  const { serialize } =\n    require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')\n  const previous = res.getHeader('Set-Cookie')\n  res.setHeader(`Set-Cookie`, [\n    ...(typeof previous === 'string'\n      ? [previous]\n      : Array.isArray(previous)\n        ? previous\n        : []),\n    serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n    serialize(COOKIE_NAME_PRERENDER_DATA, '', {\n      // To delete a cookie, set `expires` to a date in the past:\n      // https://tools.ietf.org/html/rfc6265#section-4.1.1\n      // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n      expires: new Date(0),\n      httpOnly: true,\n      sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n      secure: process.env.NODE_ENV !== 'development',\n      path: '/',\n      ...(options.path !== undefined\n        ? ({ path: options.path } as CookieSerializeOptions)\n        : undefined),\n    }),\n  ])\n\n  Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {\n    value: true,\n    enumerable: false,\n  })\n  return res\n}\n\n/**\n * Custom error class\n */\nexport class ApiError extends Error {\n  readonly statusCode: number\n\n  constructor(statusCode: number, message: string) {\n    super(message)\n    this.statusCode = statusCode\n  }\n}\n\n/**\n * Sends error in `response`\n * @param res response object\n * @param statusCode of response\n * @param message of response\n */\nexport function sendError(\n  res: NextApiResponse,\n  statusCode: number,\n  message: string\n): void {\n  res.statusCode = statusCode\n  res.statusMessage = message\n  res.end(message)\n}\n\ninterface LazyProps {\n  req: IncomingMessage\n}\n\n/**\n * Execute getter function only if its needed\n * @param LazyProps `req` and `params` for lazyProp\n * @param prop name of property\n * @param getter function to get data\n */\nexport function setLazyProp<T>(\n  { req }: LazyProps,\n  prop: string,\n  getter: () => T\n): void {\n  const opts = { configurable: true, enumerable: true }\n  const optsReset = { ...opts, writable: true }\n\n  Object.defineProperty(req, prop, {\n    ...opts,\n    get: () => {\n      const value = getter()\n      // we set the property on the object to avoid recalculating it\n      Object.defineProperty(req, prop, { ...optsReset, value })\n      return value\n    },\n    set: (value) => {\n      Object.defineProperty(req, prop, { ...optsReset, value })\n    },\n  })\n}\n"],"names":["HeadersAdapter","PRERENDER_REVALIDATE_HEADER","PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER","getTracer","NodeSpan","wrapApiHandler","page","handler","args","setRootSpanAttribute","trace","runHandler","spanName","sendStatusCode","res","statusCode","redirect","statusOrUrl","url","Error","writeHead","Location","write","end","checkIsOnDemandRevalidate","req","previewProps","headers","from","previewModeId","get","isOnDemandRevalidate","revalidateOnlyGenerated","has","COOKIE_NAME_PRERENDER_BYPASS","COOKIE_NAME_PRERENDER_DATA","RESPONSE_LIMIT_DEFAULT","SYMBOL_PREVIEW_DATA","Symbol","SYMBOL_CLEARED_COOKIES","clearPreviewData","options","serialize","require","previous","getHeader","setHeader","Array","isArray","expires","Date","httpOnly","sameSite","process","env","NODE_ENV","secure","path","undefined","Object","defineProperty","value","enumerable","ApiError","constructor","message","sendError","statusMessage","setLazyProp","prop","getter","opts","configurable","optsReset","writable","set"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/api-utils/get-cookie-parser.ts"],"sourcesContent":["import type { NextApiRequestCookies } from '.'\n\n/**\n * Parse cookies from the `headers` of request\n * @param req request object\n */\n\nexport function getCookieParser(headers: {\n  [key: string]: string | string[] | null | undefined\n}): () => NextApiRequestCookies {\n  return function parseCookie(): NextApiRequestCookies {\n    const { cookie } = headers\n\n    if (!cookie) {\n      return {}\n    }\n\n    const { parse: parseCookieFn } =\n      require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')\n    return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)\n  }\n}\n"],"names":["getCookieParser","headers","parseCookie","cookie","parse","parseCookieFn","require","Array","isArray","join"],"mappings":"AAEA;;;CAGC,GAED;;;;AAAO,SAASA,gBAAgBC,OAE/B;IACC,OAAO,SAASC;QACd,MAAM,EAAEC,MAAM,EAAE,GAAGF;QAEnB,IAAI,CAACE,QAAQ;YACX,OAAO,CAAC;QACV;QAEA,MAAM,EAAEC,OAAOC,aAAa,EAAE,GAC5BC,QAAQ;QACV,OAAOD,cAAcE,MAAMC,OAAO,CAACL,UAAUA,OAAOM,IAAI,CAAC,QAAQN;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 442, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/base-http/index.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'\nimport type { I18NConfig } from '../config-shared'\n\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport type { NextApiRequestCookies } from '../api-utils'\nimport { getCookieParser } from '../api-utils/get-cookie-parser'\n\nexport interface BaseNextRequestConfig {\n  basePath: string | undefined\n  i18n?: I18NConfig\n  trailingSlash?: boolean | undefined\n}\n\nexport type FetchMetric = {\n  url: string\n  idx: number\n  end: number\n  start: number\n  method: string\n  status: number\n  cacheReason: string\n  cacheStatus: 'hit' | 'miss' | 'skip' | 'hmr'\n  cacheWarning?: string\n}\n\nexport type FetchMetrics = Array<FetchMetric>\n\nexport abstract class BaseNextRequest<Body = any> {\n  protected _cookies: NextApiRequestCookies | undefined\n  public abstract headers: IncomingHttpHeaders\n  public abstract fetchMetrics: FetchMetric[] | undefined\n\n  constructor(\n    public method: string,\n    public url: string,\n    public body: Body\n  ) {}\n\n  // Utils implemented using the abstract methods above\n\n  public get cookies() {\n    if (this._cookies) return this._cookies\n    return (this._cookies = getCookieParser(this.headers)())\n  }\n}\n\nexport abstract class BaseNextResponse<Destination = any> {\n  abstract statusCode: number | undefined\n  abstract statusMessage: string | undefined\n  abstract get sent(): boolean\n\n  constructor(public destination: Destination) {}\n\n  /**\n   * Sets a value for the header overwriting existing values\n   */\n  abstract setHeader(name: string, value: string | string[]): this\n\n  /**\n   * Removes a header\n   */\n  abstract removeHeader(name: string): this\n\n  /**\n   * Appends value for the given header name\n   */\n  abstract appendHeader(name: string, value: string): this\n\n  /**\n   * Get all values for a header as an array or undefined if no value is present\n   */\n  abstract getHeaderValues(name: string): string[] | undefined\n\n  abstract hasHeader(name: string): boolean\n\n  /**\n   * Get values for a header concatenated using `,` or undefined if no value is present\n   */\n  abstract getHeader(name: string): string | undefined\n\n  abstract getHeaders(): OutgoingHttpHeaders\n\n  abstract body(value: string): this\n\n  abstract send(): void\n\n  abstract onClose(callback: () => void): void\n\n  // Utils implemented using the abstract methods above\n\n  public redirect(destination: string, statusCode: number) {\n    this.setHeader('Location', destination)\n    this.statusCode = statusCode\n\n    // Since IE11 doesn't support the 308 header add backwards\n    // compatibility using refresh header\n    if (statusCode === RedirectStatusCode.PermanentRedirect) {\n      this.setHeader('Refresh', `0;url=${destination}`)\n    }\n\n    return this\n  }\n}\n"],"names":["RedirectStatusCode","getCookieParser","BaseNextRequest","constructor","method","url","body","cookies","_cookies","headers","BaseNextResponse","destination","redirect","statusCode","setHeader","PermanentRedirect"],"mappings":";;;;;;AAGA,SAASA,kBAAkB,QAAQ,+CAA8C;AAEjF,SAASC,eAAe,QAAQ,iCAAgC;;;AAsBzD,MAAeC;IAKpBC,YACSC,MAAc,EACdC,GAAW,EACXC,IAAU,CACjB;aAHOF,MAAAA,GAAAA;aACAC,GAAAA,GAAAA;aACAC,IAAAA,GAAAA;IACN;IAEH,qDAAqD;IAErD,IAAWC,UAAU;QACnB,IAAI,IAAI,CAACC,QAAQ,EAAE,OAAO,IAAI,CAACA,QAAQ;QACvC,OAAQ,IAAI,CAACA,QAAQ,OAAGP,2MAAAA,EAAgB,IAAI,CAACQ,OAAO;IACtD;AACF;AAEO,MAAeC;IAKpBP,YAAmBQ,WAAwB,CAAE;aAA1BA,WAAAA,GAAAA;IAA2B;IAqC9C,qDAAqD;IAE9CC,SAASD,WAAmB,EAAEE,UAAkB,EAAE;QACvD,IAAI,CAACC,SAAS,CAAC,YAAYH;QAC3B,IAAI,CAACE,UAAU,GAAGA;QAElB,0DAA0D;QAC1D,qCAAqC;QACrC,IAAIA,eAAeb,+MAAAA,CAAmBe,iBAAiB,EAAE;YACvD,IAAI,CAACD,SAAS,CAAC,WAAW,CAAC,MAAM,EAAEH,aAAa;QAClD;QAEA,OAAO,IAAI;IACb;AACF","ignoreList":[0]}},
    {"offset": {"line": 484, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/base-http/node.ts"],"sourcesContent":["import type { ServerResponse, IncomingMessage } from 'http'\nimport type { Writable, Readable } from 'stream'\n\nimport { SYMBOL_CLEARED_COOKIES } from '../api-utils'\nimport type { NextApiRequestCookies } from '../api-utils'\n\nimport { NEXT_REQUEST_META } from '../request-meta'\nimport type { RequestMeta } from '../request-meta'\n\nimport { BaseNextRequest, BaseNextResponse, type FetchMetric } from './index'\nimport type { OutgoingHttpHeaders } from 'node:http'\n\ntype Req = IncomingMessage & {\n  [NEXT_REQUEST_META]?: RequestMeta\n  cookies?: NextApiRequestCookies\n  fetchMetrics?: FetchMetric[]\n}\n\nexport class NodeNextRequest extends BaseNextRequest<Readable> {\n  public headers = this._req.headers\n  public fetchMetrics: FetchMetric[] | undefined = this._req?.fetchMetrics;\n\n  [NEXT_REQUEST_META]: RequestMeta = this._req[NEXT_REQUEST_META] || {}\n\n  constructor(private _req: Req) {\n    super(_req.method!.toUpperCase(), _req.url!, _req)\n  }\n\n  get originalRequest() {\n    // Need to mimic these changes to the original req object for places where we use it:\n    // render.tsx, api/ssg requests\n    this._req[NEXT_REQUEST_META] = this[NEXT_REQUEST_META]\n    this._req.url = this.url\n    this._req.cookies = this.cookies\n    return this._req\n  }\n\n  set originalRequest(value: Req) {\n    this._req = value\n  }\n\n  private streaming = false\n\n  /**\n   * Returns the request body as a Web Readable Stream. The body here can only\n   * be read once as the body will start flowing as soon as the data handler\n   * is attached.\n   *\n   * @internal\n   */\n  public stream() {\n    if (this.streaming) {\n      throw new Error(\n        'Invariant: NodeNextRequest.stream() can only be called once'\n      )\n    }\n    this.streaming = true\n\n    return new ReadableStream({\n      start: (controller) => {\n        this._req.on('data', (chunk) => {\n          controller.enqueue(new Uint8Array(chunk))\n        })\n        this._req.on('end', () => {\n          controller.close()\n        })\n        this._req.on('error', (err) => {\n          controller.error(err)\n        })\n      },\n    })\n  }\n}\n\nexport class NodeNextResponse extends BaseNextResponse<Writable> {\n  private textBody: string | undefined = undefined\n\n  public [SYMBOL_CLEARED_COOKIES]?: boolean\n\n  get originalResponse() {\n    if (SYMBOL_CLEARED_COOKIES in this) {\n      this._res[SYMBOL_CLEARED_COOKIES] = this[SYMBOL_CLEARED_COOKIES]\n    }\n\n    return this._res\n  }\n\n  constructor(\n    private _res: ServerResponse & { [SYMBOL_CLEARED_COOKIES]?: boolean }\n  ) {\n    super(_res)\n  }\n\n  get sent() {\n    return this._res.finished || this._res.headersSent\n  }\n\n  get statusCode() {\n    return this._res.statusCode\n  }\n\n  set statusCode(value: number) {\n    this._res.statusCode = value\n  }\n\n  get statusMessage() {\n    return this._res.statusMessage\n  }\n\n  set statusMessage(value: string) {\n    this._res.statusMessage = value\n  }\n\n  setHeader(name: string, value: string | string[]): this {\n    this._res.setHeader(name, value)\n    return this\n  }\n\n  removeHeader(name: string): this {\n    this._res.removeHeader(name)\n    return this\n  }\n\n  getHeaderValues(name: string): string[] | undefined {\n    const values = this._res.getHeader(name)\n\n    if (values === undefined) return undefined\n\n    return (Array.isArray(values) ? values : [values]).map((value) =>\n      value.toString()\n    )\n  }\n\n  hasHeader(name: string): boolean {\n    return this._res.hasHeader(name)\n  }\n\n  getHeader(name: string): string | undefined {\n    const values = this.getHeaderValues(name)\n    return Array.isArray(values) ? values.join(',') : undefined\n  }\n\n  getHeaders(): OutgoingHttpHeaders {\n    return this._res.getHeaders()\n  }\n\n  appendHeader(name: string, value: string): this {\n    const currentValues = this.getHeaderValues(name) ?? []\n\n    if (!currentValues.includes(value)) {\n      this._res.setHeader(name, [...currentValues, value])\n    }\n\n    return this\n  }\n\n  body(value: string) {\n    this.textBody = value\n    return this\n  }\n\n  send() {\n    this._res.end(this.textBody)\n  }\n\n  public onClose(callback: () => void) {\n    this.originalResponse.on('close', callback)\n  }\n}\n"],"names":["SYMBOL_CLEARED_COOKIES","NEXT_REQUEST_META","BaseNextRequest","BaseNextResponse","NodeNextRequest","constructor","_req","method","toUpperCase","url","headers","fetchMetrics","streaming","originalRequest","cookies","value","stream","Error","ReadableStream","start","controller","on","chunk","enqueue","Uint8Array","close","err","error","NodeNextResponse","originalResponse","_res","textBody","undefined","sent","finished","headersSent","statusCode","statusMessage","setHeader","name","removeHeader","getHeaderValues","values","getHeader","Array","isArray","map","toString","hasHeader","join","getHeaders","appendHeader","currentValues","includes","body","send","end","onClose","callback"],"mappings":";;;;;;AAGA,SAASA,sBAAsB,QAAQ,eAAc;AAGrD,SAASC,iBAAiB,QAAQ,kBAAiB;AAGnD,SAASC,eAAe,EAAEC,gBAAgB,QAA0B,UAAS;;;;;AAStE,MAAMC,wBAAwBF,yLAAAA;uBAIlCD,qBAAAA,qLAAAA,CAAAA;IAEDI,YAAoBC,IAAS,CAAE;YAJkB;QAK/C,KAAK,CAACA,KAAKC,MAAM,CAAEC,WAAW,IAAIF,KAAKG,GAAG,EAAGH,OAAAA,IAAAA,CAD3BA,IAAAA,GAAAA,MAAAA,IAAAA,CALbI,OAAAA,GAAU,IAAI,CAACJ,IAAI,CAACI,OAAO,EAAA,IAAA,CAC3BC,YAAAA,GAAAA,CAA0C,aAAA,IAAI,CAACL,IAAI,KAAA,OAAA,KAAA,IAAT,WAAWK,YAAY,EAAA,IAExE,CAACV,mBAAkB,GAAgB,IAAI,CAACK,IAAI,CAACL,qLAAAA,CAAkB,IAAI,CAAC,GAAA,IAAA,CAmB5DW,SAAAA,GAAY;IAfpB;IAEA,IAAIC,kBAAkB;QACpB,qFAAqF;QACrF,+BAA+B;QAC/B,IAAI,CAACP,IAAI,CAACL,qLAAAA,CAAkB,GAAG,IAAI,CAACA,qLAAAA,CAAkB;QACtD,IAAI,CAACK,IAAI,CAACG,GAAG,GAAG,IAAI,CAACA,GAAG;QACxB,IAAI,CAACH,IAAI,CAACQ,OAAO,GAAG,IAAI,CAACA,OAAO;QAChC,OAAO,IAAI,CAACR,IAAI;IAClB;IAEA,IAAIO,gBAAgBE,KAAU,EAAE;QAC9B,IAAI,CAACT,IAAI,GAAGS;IACd;IAIA;;;;;;GAMC,GACMC,SAAS;QACd,IAAI,IAAI,CAACJ,SAAS,EAAE;YAClB,MAAM,OAAA,cAEL,CAFK,IAAIK,MACR,gEADI,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QACA,IAAI,CAACL,SAAS,GAAG;QAEjB,OAAO,IAAIM,eAAe;YACxBC,OAAO,CAACC;gBACN,IAAI,CAACd,IAAI,CAACe,EAAE,CAAC,QAAQ,CAACC;oBACpBF,WAAWG,OAAO,CAAC,IAAIC,WAAWF;gBACpC;gBACA,IAAI,CAAChB,IAAI,CAACe,EAAE,CAAC,OAAO;oBAClBD,WAAWK,KAAK;gBAClB;gBACA,IAAI,CAACnB,IAAI,CAACe,EAAE,CAAC,SAAS,CAACK;oBACrBN,WAAWO,KAAK,CAACD;gBACnB;YACF;QACF;IACF;AACF;AAEO,MAAME,yBAAyBzB,0LAAAA;IAKpC,IAAI0B,mBAAmB;QACrB,IAAI7B,gMAAAA,IAA0B,IAAI,EAAE;YAClC,IAAI,CAAC8B,IAAI,CAAC9B,gMAAAA,CAAuB,GAAG,IAAI,CAACA,gMAAAA,CAAuB;QAClE;QAEA,OAAO,IAAI,CAAC8B,IAAI;IAClB;IAEAzB,YACUyB,IAA6D,CACrE;QACA,KAAK,CAACA,OAAAA,IAAAA,CAFEA,IAAAA,GAAAA,MAAAA,IAAAA,CAbFC,QAAAA,GAA+BC;IAgBvC;IAEA,IAAIC,OAAO;QACT,OAAO,IAAI,CAACH,IAAI,CAACI,QAAQ,IAAI,IAAI,CAACJ,IAAI,CAACK,WAAW;IACpD;IAEA,IAAIC,aAAa;QACf,OAAO,IAAI,CAACN,IAAI,CAACM,UAAU;IAC7B;IAEA,IAAIA,WAAWrB,KAAa,EAAE;QAC5B,IAAI,CAACe,IAAI,CAACM,UAAU,GAAGrB;IACzB;IAEA,IAAIsB,gBAAgB;QAClB,OAAO,IAAI,CAACP,IAAI,CAACO,aAAa;IAChC;IAEA,IAAIA,cAActB,KAAa,EAAE;QAC/B,IAAI,CAACe,IAAI,CAACO,aAAa,GAAGtB;IAC5B;IAEAuB,UAAUC,IAAY,EAAExB,KAAwB,EAAQ;QACtD,IAAI,CAACe,IAAI,CAACQ,SAAS,CAACC,MAAMxB;QAC1B,OAAO,IAAI;IACb;IAEAyB,aAAaD,IAAY,EAAQ;QAC/B,IAAI,CAACT,IAAI,CAACU,YAAY,CAACD;QACvB,OAAO,IAAI;IACb;IAEAE,gBAAgBF,IAAY,EAAwB;QAClD,MAAMG,SAAS,IAAI,CAACZ,IAAI,CAACa,SAAS,CAACJ;QAEnC,IAAIG,WAAWV,WAAW,OAAOA;QAEjC,OAAQY,CAAAA,MAAMC,OAAO,CAACH,UAAUA,SAAS;YAACA;SAAM,EAAGI,GAAG,CAAC,CAAC/B,QACtDA,MAAMgC,QAAQ;IAElB;IAEAC,UAAUT,IAAY,EAAW;QAC/B,OAAO,IAAI,CAACT,IAAI,CAACkB,SAAS,CAACT;IAC7B;IAEAI,UAAUJ,IAAY,EAAsB;QAC1C,MAAMG,SAAS,IAAI,CAACD,eAAe,CAACF;QACpC,OAAOK,MAAMC,OAAO,CAACH,UAAUA,OAAOO,IAAI,CAAC,OAAOjB;IACpD;IAEAkB,aAAkC;QAChC,OAAO,IAAI,CAACpB,IAAI,CAACoB,UAAU;IAC7B;IAEAC,aAAaZ,IAAY,EAAExB,KAAa,EAAQ;QAC9C,MAAMqC,gBAAgB,IAAI,CAACX,eAAe,CAACF,SAAS,EAAE;QAEtD,IAAI,CAACa,cAAcC,QAAQ,CAACtC,QAAQ;YAClC,IAAI,CAACe,IAAI,CAACQ,SAAS,CAACC,MAAM;mBAAIa;gBAAerC;aAAM;QACrD;QAEA,OAAO,IAAI;IACb;IAEAuC,KAAKvC,KAAa,EAAE;QAClB,IAAI,CAACgB,QAAQ,GAAGhB;QAChB,OAAO,IAAI;IACb;IAEAwC,OAAO;QACL,IAAI,CAACzB,IAAI,CAAC0B,GAAG,CAAC,IAAI,CAACzB,QAAQ;IAC7B;IAEO0B,QAAQC,QAAoB,EAAE;QACnC,IAAI,CAAC7B,gBAAgB,CAACR,EAAE,CAAC,SAASqC;IACpC;AACF","ignoreList":[0]}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/lib/experimental/ppr.ts"],"sourcesContent":["/**\n * If set to `incremental`, only those leaf pages that export\n * `experimental_ppr = true` will have partial prerendering enabled. If any\n * page exports this value as `false` or does not export it at all will not\n * have partial prerendering enabled. If set to a boolean, the options for\n * `experimental_ppr` will be ignored.\n */\n\nexport type ExperimentalPPRConfig = boolean | 'incremental'\n\n/**\n * Returns true if partial prerendering is enabled for the application. It does\n * not tell you if a given route has PPR enabled, as that requires analysis of\n * the route's configuration.\n *\n * @see {@link checkIsRoutePPREnabled} - for checking if a specific route has PPR enabled.\n */\nexport function checkIsAppPPREnabled(\n  config: ExperimentalPPRConfig | undefined\n): boolean {\n  // If the config is undefined, partial prerendering is disabled.\n  if (typeof config === 'undefined') return false\n\n  // If the config is a boolean, use it directly.\n  if (typeof config === 'boolean') return config\n\n  // If the config is a string, it must be 'incremental' to enable partial\n  // prerendering.\n  if (config === 'incremental') return true\n\n  return false\n}\n\n/**\n * Returns true if partial prerendering is supported for the current page with\n * the provided app configuration. If the application doesn't have partial\n * prerendering enabled, this function will always return false. If you want to\n * check if the application has partial prerendering enabled\n *\n * @see {@link checkIsAppPPREnabled} for checking if the application has PPR enabled.\n */\nexport function checkIsRoutePPREnabled(\n  config: ExperimentalPPRConfig | undefined\n): boolean {\n  // If the config is undefined, partial prerendering is disabled.\n  if (typeof config === 'undefined') return false\n\n  // If the config is a boolean, use it directly.\n  if (typeof config === 'boolean') return config\n\n  return false\n}\n"],"names":["checkIsAppPPREnabled","config","checkIsRoutePPREnabled"],"mappings":"AAAA;;;;;;CAMC,GAID;;;;;;CAMC,GACD;;;;;;AAAO,SAASA,qBACdC,MAAyC;IAEzC,gEAAgE;IAChE,IAAI,OAAOA,WAAW,aAAa,OAAO;IAE1C,+CAA+C;IAC/C,IAAI,OAAOA,WAAW,WAAW,OAAOA;IAExC,wEAAwE;IACxE,gBAAgB;IAChB,IAAIA,WAAW,eAAe,OAAO;IAErC,OAAO;AACT;AAUO,SAASC,uBACdD,MAAyC;IAEzC,gEAAgE;IAChE,IAAI,OAAOA,WAAW,aAAa,OAAO;IAE1C,+CAA+C;IAC/C,IAAI,OAAOA,WAAW,WAAW,OAAOA;IAExC,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 659, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/route-modules/checks.ts"],"sourcesContent":["import type { AppRouteRouteModule } from './app-route/module'\nimport type { AppPageRouteModule } from './app-page/module'\nimport type { PagesRouteModule } from './pages/module'\nimport type { PagesAPIRouteModule } from './pages-api/module'\n\nimport type { RouteModule } from './route-module'\n\nimport { RouteKind } from '../route-kind'\n\nexport function isAppRouteRouteModule(\n  routeModule: RouteModule\n): routeModule is AppRouteRouteModule {\n  return routeModule.definition.kind === RouteKind.APP_ROUTE\n}\n\nexport function isAppPageRouteModule(\n  routeModule: RouteModule\n): routeModule is AppPageRouteModule {\n  return routeModule.definition.kind === RouteKind.APP_PAGE\n}\n\nexport function isPagesRouteModule(\n  routeModule: RouteModule\n): routeModule is PagesRouteModule {\n  return routeModule.definition.kind === RouteKind.PAGES\n}\n\nexport function isPagesAPIRouteModule(\n  routeModule: RouteModule\n): routeModule is PagesAPIRouteModule {\n  return routeModule.definition.kind === RouteKind.PAGES_API\n}\n"],"names":["RouteKind","isAppRouteRouteModule","routeModule","definition","kind","APP_ROUTE","isAppPageRouteModule","APP_PAGE","isPagesRouteModule","PAGES","isPagesAPIRouteModule","PAGES_API"],"mappings":";;;;;;;;;;AAOA,SAASA,SAAS,QAAQ,gBAAe;;AAElC,SAASC,sBACdC,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,KAAKJ,2KAAAA,CAAUK,SAAS;AAC5D;AAEO,SAASC,qBACdJ,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,KAAKJ,2KAAAA,CAAUO,QAAQ;AAC3D;AAEO,SAASC,mBACdN,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,KAAKJ,2KAAAA,CAAUS,KAAK;AACxD;AAEO,SAASC,sBACdR,WAAwB;IAExB,OAAOA,YAAYC,UAAU,CAACC,IAAI,KAAKJ,2KAAAA,CAAUW,SAAS;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 687, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts"],"sourcesContent":["/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n"],"names":["ensureLeadingSlash","path","startsWith"],"mappings":"AAAA;;;CAGC,GACD;;;;AAAO,SAASA,mBAAmBC,IAAY;IAC7C,OAAOA,KAAKC,UAAU,CAAC,OAAOD,OAAO,CAAC,CAAC,EAAEA,MAAM;AACjD","ignoreList":[0]}},
    {"offset": {"line": 701, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/utils/app-paths.ts"],"sourcesContent":["import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n"],"names":["ensureLeadingSlash","isGroupSegment","normalizeAppPath","route","split","reduce","pathname","segment","index","segments","length","normalizeRscURL","url","replace"],"mappings":";;;;;;AAAA,SAASA,kBAAkB,QAAQ,uCAAsC;AACzE,SAASC,cAAc,QAAQ,gBAAe;;;AAqBvC,SAASC,iBAAiBC,KAAa;IAC5C,WAAOH,wNAAAA,EACLG,MAAMC,KAAK,CAAC,KAAKC,MAAM,CAAC,CAACC,UAAUC,SAASC,OAAOC;QACjD,8BAA8B;QAC9B,IAAI,CAACF,SAAS;YACZ,OAAOD;QACT;QAEA,sBAAsB;QACtB,QAAIL,iLAAAA,EAAeM,UAAU;YAC3B,OAAOD;QACT;QAEA,iCAAiC;QACjC,IAAIC,OAAO,CAAC,EAAE,KAAK,KAAK;YACtB,OAAOD;QACT;QAEA,uDAAuD;QACvD,IACGC,CAAAA,YAAY,UAAUA,YAAY,OAAM,KACzCC,UAAUC,SAASC,MAAM,GAAG,GAC5B;YACA,OAAOJ;QACT;QAEA,OAAO,GAAGA,SAAS,CAAC,EAAEC,SAAS;IACjC,GAAG;AAEP;AAMO,SAASI,gBAAgBC,GAAW;IACzC,OAAOA,IAAIC,OAAO,CAChB,eACA,AACA,8BAD8B;AAGlC","ignoreList":[0]}},
    {"offset": {"line": 739, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/utils/interception-routes.ts"],"sourcesContent":["import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport type InterceptionMarker = (typeof INTERCEPTION_ROUTE_MARKERS)[number]\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\ntype InterceptionRouteInformation = {\n  /**\n   * The intercepting route. This is the route that is being intercepted or the\n   * route that the user was coming from. This is matched by the Next-Url\n   * header.\n   */\n  interceptingRoute: string\n\n  /**\n   * The intercepted route. This is the route that is being intercepted or the\n   * route that the user is going to. This is matched by the request pathname.\n   */\n  interceptedRoute: string\n}\n\nexport function extractInterceptionRouteInformation(\n  path: string\n): InterceptionRouteInformation {\n  let interceptingRoute: string | undefined\n  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n  let interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n"],"names":["normalizeAppPath","INTERCEPTION_ROUTE_MARKERS","isInterceptionRouteAppPath","path","split","find","segment","m","startsWith","undefined","extractInterceptionRouteInformation","interceptingRoute","marker","interceptedRoute","Error","slice","concat","join","splitInterceptingRoute","length"],"mappings":";;;;;;;;AAAA,SAASA,gBAAgB,QAAQ,cAAa;;AAGvC,MAAMC,6BAA6B;IACxC;IACA;IACA;IACA;CACD,CAAS;AAIH,SAASC,2BAA2BC,IAAY;IACrD,wCAAwC;IACxC,OACEA,KACGC,KAAK,CAAC,KACNC,IAAI,CAAC,CAACC,UACLL,2BAA2BI,IAAI,CAAC,CAACE,IAAMD,QAAQE,UAAU,CAACD,SACtDE;AAEZ;AAiBO,SAASC,oCACdP,IAAY;IAEZ,IAAIQ;IACJ,IAAIC;IACJ,IAAIC;IAEJ,KAAK,MAAMP,WAAWH,KAAKC,KAAK,CAAC,KAAM;QACrCQ,SAASX,2BAA2BI,IAAI,CAAC,CAACE,IAAMD,QAAQE,UAAU,CAACD;QACnE,IAAIK,QAAQ;;YACT,CAACD,mBAAmBE,iBAAiB,GAAGV,KAAKC,KAAK,CAACQ,QAAQ;YAC5D;QACF;IACF;IAEA,IAAI,CAACD,qBAAqB,CAACC,UAAU,CAACC,kBAAkB;QACtD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,4BAA4B,EAAEX,KAAK,iFAAiF,CAAC,GADlH,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEAQ,wBAAoBX,2MAAAA,EAAiBW,mBAAmB,iDAAiD;;IAEzG,OAAQC;QACN,KAAK;YACH,oIAAoI;YACpI,IAAID,sBAAsB,KAAK;gBAC7BE,mBAAmB,CAAC,CAAC,EAAEA,kBAAkB;YAC3C,OAAO;gBACLA,mBAAmBF,oBAAoB,MAAME;YAC/C;YACA;QACF,KAAK;YACH,uHAAuH;YACvH,IAAIF,sBAAsB,KAAK;gBAC7B,MAAM,OAAA,cAEL,CAFK,IAAIG,MACR,CAAC,4BAA4B,EAAEX,KAAK,4DAA4D,CAAC,GAD7F,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF;YACAU,mBAAmBF,kBAChBP,KAAK,CAAC,KACNW,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACH,kBACPI,IAAI,CAAC;YACR;QACF,KAAK;YACH,kIAAkI;YAClIJ,mBAAmB,MAAMA;YACzB;QACF,KAAK;YACH,iIAAiI;YAEjI,MAAMK,yBAAyBP,kBAAkBP,KAAK,CAAC;YACvD,IAAIc,uBAAuBC,MAAM,IAAI,GAAG;gBACtC,MAAM,OAAA,cAEL,CAFK,IAAIL,MACR,CAAC,4BAA4B,EAAEX,KAAK,+DAA+D,CAAC,GADhG,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF;YAEAU,mBAAmBK,uBAChBH,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACH,kBACPI,IAAI,CAAC;YACR;QACF;YACE,MAAM,OAAA,cAAyC,CAAzC,IAAIH,MAAM,iCAAV,qBAAA;uBAAA;4BAAA;8BAAA;YAAwC;IAClD;IAEA,OAAO;QAAEH;QAAmBE;IAAiB;AAC/C","ignoreList":[0]}},
    {"offset": {"line": 832, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/utils/get-segment-param.tsx"],"sourcesContent":["import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'\nimport type { DynamicParamTypes } from '../../app-router-types'\n\nexport type SegmentParam = {\n  paramName: string\n  paramType: DynamicParamTypes\n}\n\n/**\n * Parse dynamic route segment to type of parameter\n */\nexport function getSegmentParam(segment: string): SegmentParam | null {\n  const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker) =>\n    segment.startsWith(marker)\n  )\n\n  // if an interception marker is part of the path segment, we need to jump ahead\n  // to the relevant portion for param parsing\n  if (interceptionMarker) {\n    segment = segment.slice(interceptionMarker.length)\n  }\n\n  if (segment.startsWith('[[...') && segment.endsWith(']]')) {\n    return {\n      // TODO-APP: Optional catchall does not currently work with parallel routes,\n      // so for now aren't handling a potential interception marker.\n      paramType: 'optional-catchall',\n      paramName: segment.slice(5, -2),\n    }\n  }\n\n  if (segment.startsWith('[...') && segment.endsWith(']')) {\n    return {\n      paramType: interceptionMarker\n        ? `catchall-intercepted-${interceptionMarker}`\n        : 'catchall',\n      paramName: segment.slice(4, -1),\n    }\n  }\n\n  if (segment.startsWith('[') && segment.endsWith(']')) {\n    return {\n      paramType: interceptionMarker\n        ? `dynamic-intercepted-${interceptionMarker}`\n        : 'dynamic',\n      paramName: segment.slice(1, -1),\n    }\n  }\n\n  return null\n}\n\nexport function isCatchAll(\n  type: DynamicParamTypes\n): type is\n  | 'catchall'\n  | 'catchall-intercepted-(..)(..)'\n  | 'catchall-intercepted-(.)'\n  | 'catchall-intercepted-(..)'\n  | 'catchall-intercepted-(...)'\n  | 'optional-catchall' {\n  return (\n    type === 'catchall' ||\n    type === 'catchall-intercepted-(..)(..)' ||\n    type === 'catchall-intercepted-(.)' ||\n    type === 'catchall-intercepted-(..)' ||\n    type === 'catchall-intercepted-(...)' ||\n    type === 'optional-catchall'\n  )\n}\n\nexport function getParamProperties(paramType: DynamicParamTypes): {\n  repeat: boolean\n  optional: boolean\n} {\n  let repeat = false\n  let optional = false\n\n  switch (paramType) {\n    case 'catchall':\n    case 'catchall-intercepted-(..)(..)':\n    case 'catchall-intercepted-(.)':\n    case 'catchall-intercepted-(..)':\n    case 'catchall-intercepted-(...)':\n      repeat = true\n      break\n    case 'optional-catchall':\n      repeat = true\n      optional = true\n      break\n    case 'dynamic':\n    case 'dynamic-intercepted-(..)(..)':\n    case 'dynamic-intercepted-(.)':\n    case 'dynamic-intercepted-(..)':\n    case 'dynamic-intercepted-(...)':\n      break\n    default:\n      paramType satisfies never\n  }\n\n  return { repeat, optional }\n}\n"],"names":["INTERCEPTION_ROUTE_MARKERS","getSegmentParam","segment","interceptionMarker","find","marker","startsWith","slice","length","endsWith","paramType","paramName","isCatchAll","type","getParamProperties","repeat","optional"],"mappings":";;;;;;;;AAAA,SAASA,0BAA0B,QAAQ,wBAAuB;;AAW3D,SAASC,gBAAgBC,OAAe;IAC7C,MAAMC,qBAAqBH,+NAAAA,CAA2BI,IAAI,CAAC,CAACC,SAC1DH,QAAQI,UAAU,CAACD;IAGrB,+EAA+E;IAC/E,4CAA4C;IAC5C,IAAIF,oBAAoB;QACtBD,UAAUA,QAAQK,KAAK,CAACJ,mBAAmBK,MAAM;IACnD;IAEA,IAAIN,QAAQI,UAAU,CAAC,YAAYJ,QAAQO,QAAQ,CAAC,OAAO;QACzD,OAAO;YACL,4EAA4E;YAC5E,8DAA8D;YAC9DC,WAAW;YACXC,WAAWT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC/B;IACF;IAEA,IAAIL,QAAQI,UAAU,CAAC,WAAWJ,QAAQO,QAAQ,CAAC,MAAM;QACvD,OAAO;YACLC,WAAWP,qBACP,CAAC,qBAAqB,EAAEA,oBAAoB,GAC5C;YACJQ,WAAWT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC/B;IACF;IAEA,IAAIL,QAAQI,UAAU,CAAC,QAAQJ,QAAQO,QAAQ,CAAC,MAAM;QACpD,OAAO;YACLC,WAAWP,qBACP,CAAC,oBAAoB,EAAEA,oBAAoB,GAC3C;YACJQ,WAAWT,QAAQK,KAAK,CAAC,GAAG,CAAC;QAC/B;IACF;IAEA,OAAO;AACT;AAEO,SAASK,WACdC,IAAuB;IAQvB,OACEA,SAAS,cACTA,SAAS,mCACTA,SAAS,8BACTA,SAAS,+BACTA,SAAS,gCACTA,SAAS;AAEb;AAEO,SAASC,mBAAmBJ,SAA4B;IAI7D,IAAIK,SAAS;IACb,IAAIC,WAAW;IAEf,OAAQN;QACN,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACHK,SAAS;YACT;QACF,KAAK;YACHA,SAAS;YACTC,WAAW;YACX;QACF,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACH;QACF;YACEN;IACJ;IAEA,OAAO;QAAEK;QAAQC;IAAS;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/routes/app.ts"],"sourcesContent":["import { InvariantError } from '../../invariant-error'\nimport { getSegmentParam, type SegmentParam } from '../utils/get-segment-param'\nimport {\n  INTERCEPTION_ROUTE_MARKERS,\n  type InterceptionMarker,\n} from '../utils/interception-routes'\n\nexport type RouteGroupAppRouteSegment = {\n  type: 'route-group'\n  name: string\n\n  /**\n   * If present, this segment has an interception marker prefixing it.\n   */\n  interceptionMarker?: InterceptionMarker\n}\n\nexport type ParallelRouteAppRouteSegment = {\n  type: 'parallel-route'\n  name: string\n\n  /**\n   * If present, this segment has an interception marker prefixing it.\n   */\n  interceptionMarker?: InterceptionMarker\n}\n\nexport type StaticAppRouteSegment = {\n  type: 'static'\n  name: string\n\n  /**\n   * If present, this segment has an interception marker prefixing it.\n   */\n  interceptionMarker?: InterceptionMarker\n}\n\nexport type DynamicAppRouteSegment = {\n  type: 'dynamic'\n  name: string\n  param: SegmentParam\n\n  /**\n   * If present, this segment has an interception marker prefixing it.\n   */\n  interceptionMarker?: InterceptionMarker\n}\n\n/**\n * Represents a single segment in a route path.\n * Can be either static (e.g., \"blog\") or dynamic (e.g., \"[slug]\").\n */\nexport type AppRouteSegment =\n  | StaticAppRouteSegment\n  | DynamicAppRouteSegment\n  | RouteGroupAppRouteSegment\n  | ParallelRouteAppRouteSegment\n\nexport type NormalizedAppRouteSegment =\n  | StaticAppRouteSegment\n  | DynamicAppRouteSegment\n\nexport function parseAppRouteSegment(segment: string): AppRouteSegment | null {\n  if (segment === '') {\n    return null\n  }\n\n  // Check if the segment starts with an interception marker\n  const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((m) =>\n    segment.startsWith(m)\n  )\n\n  const param = getSegmentParam(segment)\n  if (param) {\n    return {\n      type: 'dynamic',\n      name: segment,\n      param,\n      interceptionMarker,\n    }\n  } else if (segment.startsWith('(') && segment.endsWith(')')) {\n    return {\n      type: 'route-group',\n      name: segment,\n      interceptionMarker,\n    }\n  } else if (segment.startsWith('@')) {\n    return {\n      type: 'parallel-route',\n      name: segment,\n      interceptionMarker,\n    }\n  } else {\n    return {\n      type: 'static',\n      name: segment,\n      interceptionMarker,\n    }\n  }\n}\n\nexport type AppRoute = {\n  normalized: boolean\n  pathname: string\n  segments: AppRouteSegment[]\n  dynamicSegments: DynamicAppRouteSegment[]\n  interceptionMarker: InterceptionMarker | undefined\n  interceptingRoute: AppRoute | undefined\n  interceptedRoute: AppRoute | undefined\n}\n\nexport type NormalizedAppRoute = Omit<AppRoute, 'normalized' | 'segments'> & {\n  normalized: true\n  segments: NormalizedAppRouteSegment[]\n}\n\nexport function isNormalizedAppRoute(\n  route: InterceptionAppRoute\n): route is NormalizedInterceptionAppRoute\nexport function isNormalizedAppRoute(\n  route: AppRoute | InterceptionAppRoute\n): route is NormalizedAppRoute {\n  return route.normalized\n}\n\nexport type InterceptionAppRoute = Omit<\n  AppRoute,\n  'interceptionMarker' | 'interceptingRoute' | 'interceptedRoute'\n> & {\n  interceptionMarker: InterceptionMarker\n  interceptingRoute: AppRoute\n  interceptedRoute: AppRoute\n}\n\nexport type NormalizedInterceptionAppRoute = Omit<\n  InterceptionAppRoute,\n  | 'normalized'\n  | 'segments'\n  | 'interceptionMarker'\n  | 'interceptingRoute'\n  | 'interceptedRoute'\n> & {\n  normalized: true\n  segments: NormalizedAppRouteSegment[]\n  interceptionMarker: InterceptionMarker\n  interceptingRoute: NormalizedAppRoute\n  interceptedRoute: NormalizedAppRoute\n}\n\nexport function isInterceptionAppRoute(\n  route: NormalizedAppRoute\n): route is NormalizedInterceptionAppRoute\nexport function isInterceptionAppRoute(\n  route: AppRoute\n): route is InterceptionAppRoute {\n  return (\n    route.interceptionMarker !== undefined &&\n    route.interceptingRoute !== undefined &&\n    route.interceptedRoute !== undefined\n  )\n}\n\nexport function parseAppRoute(\n  pathname: string,\n  normalized: true\n): NormalizedAppRoute\nexport function parseAppRoute(pathname: string, normalized: false): AppRoute\nexport function parseAppRoute(\n  pathname: string,\n  normalized: boolean\n): AppRoute | NormalizedAppRoute {\n  const pathnameSegments = pathname.split('/').filter(Boolean)\n\n  // Build segments array with static and dynamic segments\n  const segments: AppRouteSegment[] = []\n\n  // Parse if this is an interception route.\n  let interceptionMarker: InterceptionMarker | undefined\n  let interceptingRoute: AppRoute | NormalizedAppRoute | undefined\n  let interceptedRoute: AppRoute | NormalizedAppRoute | undefined\n\n  for (const segment of pathnameSegments) {\n    // Parse the segment into an AppSegment.\n    const appSegment = parseAppRouteSegment(segment)\n    if (!appSegment) {\n      continue\n    }\n\n    if (\n      normalized &&\n      (appSegment.type === 'route-group' ||\n        appSegment.type === 'parallel-route')\n    ) {\n      throw new InvariantError(\n        `${pathname} is being parsed as a normalized route, but it has a route group or parallel route segment.`\n      )\n    }\n\n    segments.push(appSegment)\n\n    if (appSegment.interceptionMarker) {\n      const parts = pathname.split(appSegment.interceptionMarker)\n      if (parts.length !== 2) {\n        throw new Error(`Invalid interception route: ${pathname}`)\n      }\n\n      interceptingRoute = normalized\n        ? parseAppRoute(parts[0], true)\n        : parseAppRoute(parts[0], false)\n      interceptedRoute = normalized\n        ? parseAppRoute(parts[1], true)\n        : parseAppRoute(parts[1], false)\n      interceptionMarker = appSegment.interceptionMarker\n    }\n  }\n\n  const dynamicSegments = segments.filter(\n    (segment) => segment.type === 'dynamic'\n  )\n\n  return {\n    normalized,\n    pathname,\n    segments,\n    dynamicSegments,\n    interceptionMarker,\n    interceptingRoute,\n    interceptedRoute,\n  }\n}\n"],"names":["InvariantError","getSegmentParam","INTERCEPTION_ROUTE_MARKERS","parseAppRouteSegment","segment","interceptionMarker","find","m","startsWith","param","type","name","endsWith","isNormalizedAppRoute","route","normalized","isInterceptionAppRoute","undefined","interceptingRoute","interceptedRoute","parseAppRoute","pathname","pathnameSegments","split","filter","Boolean","segments","appSegment","push","parts","length","Error","dynamicSegments"],"mappings":";;;;;;;;;;AAAA,SAASA,cAAc,QAAQ,wBAAuB;AACtD,SAASC,eAAe,QAA2B,6BAA4B;AAC/E,SACEC,0BAA0B,QAErB,+BAA8B;;;;AAyD9B,SAASC,qBAAqBC,OAAe;IAClD,IAAIA,YAAY,IAAI;QAClB,OAAO;IACT;IAEA,0DAA0D;IAC1D,MAAMC,qBAAqBH,+NAAAA,CAA2BI,IAAI,CAAC,CAACC,IAC1DH,QAAQI,UAAU,CAACD;IAGrB,MAAME,YAAQR,qNAAAA,EAAgBG;IAC9B,IAAIK,OAAO;QACT,OAAO;YACLC,MAAM;YACNC,MAAMP;YACNK;YACAJ;QACF;IACF,OAAO,IAAID,QAAQI,UAAU,CAAC,QAAQJ,QAAQQ,QAAQ,CAAC,MAAM;QAC3D,OAAO;YACLF,MAAM;YACNC,MAAMP;YACNC;QACF;IACF,OAAO,IAAID,QAAQI,UAAU,CAAC,MAAM;QAClC,OAAO;YACLE,MAAM;YACNC,MAAMP;YACNC;QACF;IACF,OAAO;QACL,OAAO;YACLK,MAAM;YACNC,MAAMP;YACNC;QACF;IACF;AACF;AAoBO,SAASQ,qBACdC,KAAsC;IAEtC,OAAOA,MAAMC,UAAU;AACzB;AA6BO,SAASC,uBACdF,KAAe;IAEf,OACEA,MAAMT,kBAAkB,KAAKY,aAC7BH,MAAMI,iBAAiB,KAAKD,aAC5BH,MAAMK,gBAAgB,KAAKF;AAE/B;AAOO,SAASG,cACdC,QAAgB,EAChBN,UAAmB;IAEnB,MAAMO,mBAAmBD,SAASE,KAAK,CAAC,KAAKC,MAAM,CAACC;IAEpD,wDAAwD;IACxD,MAAMC,WAA8B,EAAE;IAEtC,0CAA0C;IAC1C,IAAIrB;IACJ,IAAIa;IACJ,IAAIC;IAEJ,KAAK,MAAMf,WAAWkB,iBAAkB;QACtC,wCAAwC;QACxC,MAAMK,aAAaxB,qBAAqBC;QACxC,IAAI,CAACuB,YAAY;YACf;QACF;QAEA,IACEZ,cACCY,CAAAA,WAAWjB,IAAI,KAAK,iBACnBiB,WAAWjB,IAAI,KAAK,gBAAe,GACrC;YACA,MAAM,OAAA,cAEL,CAFK,IAAIV,4LAAAA,CACR,GAAGqB,SAAS,2FAA2F,CAAC,GADpG,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;QAEAK,SAASE,IAAI,CAACD;QAEd,IAAIA,WAAWtB,kBAAkB,EAAE;YACjC,MAAMwB,QAAQR,SAASE,KAAK,CAACI,WAAWtB,kBAAkB;YAC1D,IAAIwB,MAAMC,MAAM,KAAK,GAAG;gBACtB,MAAM,OAAA,cAAoD,CAApD,IAAIC,MAAM,CAAC,4BAA4B,EAAEV,UAAU,GAAnD,qBAAA;2BAAA;gCAAA;kCAAA;gBAAmD;YAC3D;YAEAH,oBAAoBH,aAChBK,cAAcS,KAAK,CAAC,EAAE,EAAE,QACxBT,cAAcS,KAAK,CAAC,EAAE,EAAE;YAC5BV,mBAAmBJ,aACfK,cAAcS,KAAK,CAAC,EAAE,EAAE,QACxBT,cAAcS,KAAK,CAAC,EAAE,EAAE;YAC5BxB,qBAAqBsB,WAAWtB,kBAAkB;QACpD;IACF;IAEA,MAAM2B,kBAAkBN,SAASF,MAAM,CACrC,CAACpB,UAAYA,QAAQM,IAAI,KAAK;IAGhC,OAAO;QACLK;QACAM;QACAK;QACAM;QACA3B;QACAa;QACAC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1014, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/utils/parse-loader-tree.ts"],"sourcesContent":["import { DEFAULT_SEGMENT_KEY } from '../../segment'\nimport type { LoaderTree } from '../../../../server/lib/app-dir-module'\n\nexport function parseLoaderTree(tree: LoaderTree) {\n  const [segment, parallelRoutes, modules] = tree\n  const { layout, template } = modules\n  let { page } = modules\n  // a __DEFAULT__ segment means that this route didn't match any of the\n  // segments in the route, so we should use the default page\n  page = segment === DEFAULT_SEGMENT_KEY ? modules.defaultPage : page\n\n  const conventionPath = layout?.[1] || template?.[1] || page?.[1]\n\n  return {\n    page,\n    segment,\n    modules,\n    /* it can be either layout / template / page */\n    conventionPath,\n    parallelRoutes,\n  }\n}\n"],"names":["DEFAULT_SEGMENT_KEY","parseLoaderTree","tree","segment","parallelRoutes","modules","layout","template","page","defaultPage","conventionPath"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ,gBAAe;;AAG5C,SAASC,gBAAgBC,IAAgB;IAC9C,MAAM,CAACC,SAASC,gBAAgBC,QAAQ,GAAGH;IAC3C,MAAM,EAAEI,MAAM,EAAEC,QAAQ,EAAE,GAAGF;IAC7B,IAAI,EAAEG,IAAI,EAAE,GAAGH;IACf,sEAAsE;IACtE,2DAA2D;IAC3DG,OAAOL,YAAYH,sLAAAA,GAAsBK,QAAQI,WAAW,GAAGD;IAE/D,MAAME,iBAAiBJ,QAAQ,CAAC,EAAE,IAAIC,UAAU,CAAC,EAAE,IAAIC,MAAM,CAAC,EAAE;IAEhE,OAAO;QACLA;QACAL;QACAE;QACA,6CAA6C,GAC7CK;QACAN;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1040, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/utils/interception-prefix-from-param-type.ts"],"sourcesContent":["import type { DynamicParamTypes } from '../../app-router-types'\n\nexport function interceptionPrefixFromParamType(\n  paramType: DynamicParamTypes\n): string | null {\n  switch (paramType) {\n    case 'catchall-intercepted-(..)(..)':\n    case 'dynamic-intercepted-(..)(..)':\n      return '(..)(..)'\n    case 'catchall-intercepted-(.)':\n    case 'dynamic-intercepted-(.)':\n      return '(.)'\n    case 'catchall-intercepted-(..)':\n    case 'dynamic-intercepted-(..)':\n      return '(..)'\n    case 'catchall-intercepted-(...)':\n    case 'dynamic-intercepted-(...)':\n      return '(...)'\n    case 'catchall':\n    case 'dynamic':\n    case 'optional-catchall':\n    default:\n      return null\n  }\n}\n"],"names":["interceptionPrefixFromParamType","paramType"],"mappings":";;;;AAEO,SAASA,gCACdC,SAA4B;IAE5B,OAAQA;QACN,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;QACL,KAAK;QACL;YACE,OAAO;IACX;AACF","ignoreList":[0]}},
    {"offset": {"line": 1069, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/utils/resolve-param-value.ts"],"sourcesContent":["import type { Params } from '../../../../server/request/params'\nimport type { DynamicParamTypes } from '../../app-router-types'\nimport { InvariantError } from '../../invariant-error'\nimport type {\n  NormalizedAppRoute,\n  NormalizedAppRouteSegment,\n} from '../routes/app'\nimport { interceptionPrefixFromParamType } from './interception-prefix-from-param-type'\n\n/**\n * Extracts the param value from a path segment, handling interception markers\n * based on the expected param type.\n *\n * @param pathSegment - The path segment to extract the value from\n * @param params - The current params object for resolving dynamic param references\n * @param paramType - The expected param type which may include interception marker info\n * @returns The extracted param value\n */\nfunction getParamValueFromSegment(\n  pathSegment: NormalizedAppRouteSegment,\n  params: Params,\n  paramType: DynamicParamTypes\n): string {\n  // If the segment is dynamic, resolve it from the params object\n  if (pathSegment.type === 'dynamic') {\n    return params[pathSegment.param.paramName] as string\n  }\n\n  // If the paramType indicates this is an intercepted param, strip the marker\n  // that matches the interception marker in the param type\n  const interceptionPrefix = interceptionPrefixFromParamType(paramType)\n  if (interceptionPrefix === pathSegment.interceptionMarker) {\n    return pathSegment.name.replace(pathSegment.interceptionMarker, '')\n  }\n\n  // For static segments, use the name\n  return pathSegment.name\n}\n\n/**\n * Resolves a route parameter value from the route segments at the given depth.\n * This shared logic is used by both extractPathnameRouteParamSegmentsFromLoaderTree\n * and resolveRouteParamsFromTree.\n *\n * @param paramName - The parameter name to resolve\n * @param paramType - The parameter type (dynamic, catchall, etc.)\n * @param depth - The current depth in the route tree\n * @param route - The normalized route containing segments\n * @param params - The current params object (used to resolve embedded param references)\n * @param options - Configuration options\n * @returns The resolved parameter value, or undefined if it cannot be resolved\n */\nexport function resolveParamValue(\n  paramName: string,\n  paramType: DynamicParamTypes,\n  depth: number,\n  route: NormalizedAppRoute,\n  params: Params\n): string | string[] | undefined {\n  switch (paramType) {\n    case 'catchall':\n    case 'optional-catchall':\n    case 'catchall-intercepted-(..)(..)':\n    case 'catchall-intercepted-(.)':\n    case 'catchall-intercepted-(..)':\n    case 'catchall-intercepted-(...)':\n      // For catchall routes, derive from pathname using depth to determine\n      // which segments to use\n      const processedSegments: string[] = []\n\n      // Process segments to handle any embedded dynamic params\n      for (let index = depth; index < route.segments.length; index++) {\n        const pathSegment = route.segments[index]\n\n        if (pathSegment.type === 'static') {\n          let value = pathSegment.name\n\n          // For intercepted catch-all params, strip the marker from the first segment\n          const interceptionPrefix = interceptionPrefixFromParamType(paramType)\n          if (\n            interceptionPrefix &&\n            index === depth &&\n            interceptionPrefix === pathSegment.interceptionMarker\n          ) {\n            // Strip the interception marker from the value\n            value = value.replace(pathSegment.interceptionMarker, '')\n          }\n\n          processedSegments.push(value)\n        } else {\n          // If the segment is a param placeholder, check if we have its value\n          if (!params.hasOwnProperty(pathSegment.param.paramName)) {\n            // If the segment is an optional catchall, we can break out of the\n            // loop because it's optional!\n            if (pathSegment.param.paramType === 'optional-catchall') {\n              break\n            }\n\n            // Unknown param placeholder in pathname - can't derive full value\n            return undefined\n          }\n\n          // If the segment matches a param, use the param value\n          // We don't encode values here as that's handled during retrieval.\n          const paramValue = params[pathSegment.param.paramName]\n          if (Array.isArray(paramValue)) {\n            processedSegments.push(...paramValue)\n          } else {\n            processedSegments.push(paramValue as string)\n          }\n        }\n      }\n\n      if (processedSegments.length > 0) {\n        return processedSegments\n      } else if (paramType === 'optional-catchall') {\n        return undefined\n      } else {\n        // We shouldn't be able to match a catchall segment without any path\n        // segments if it's not an optional catchall\n        throw new InvariantError(\n          `Unexpected empty path segments match for a route \"${route.pathname}\" with param \"${paramName}\" of type \"${paramType}\"`\n        )\n      }\n    case 'dynamic':\n    case 'dynamic-intercepted-(..)(..)':\n    case 'dynamic-intercepted-(.)':\n    case 'dynamic-intercepted-(..)':\n    case 'dynamic-intercepted-(...)':\n      // For regular dynamic parameters, take the segment at this depth\n      if (depth < route.segments.length) {\n        const pathSegment = route.segments[depth]\n\n        // Check if the segment at this depth is a placeholder for an unknown param\n        if (\n          pathSegment.type === 'dynamic' &&\n          !params.hasOwnProperty(pathSegment.param.paramName)\n        ) {\n          // The segment is a placeholder like [category] and we don't have the value\n          return undefined\n        }\n\n        // If the segment matches a param, use the param value from params object\n        // Otherwise it's a static segment, just use it directly\n        // We don't encode values here as that's handled during retrieval\n        return getParamValueFromSegment(pathSegment, params, paramType)\n      }\n\n      return undefined\n\n    default:\n      paramType satisfies never\n  }\n}\n"],"names":["InvariantError","interceptionPrefixFromParamType","getParamValueFromSegment","pathSegment","params","paramType","type","param","paramName","interceptionPrefix","interceptionMarker","name","replace","resolveParamValue","depth","route","processedSegments","index","segments","length","value","push","hasOwnProperty","undefined","paramValue","Array","isArray","pathname"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree.ts"],"sourcesContent":["import type { LoaderTree } from '../../../server/lib/app-dir-module'\nimport type { Params } from '../../../server/request/params'\nimport type { DynamicParamTypes } from '../../../shared/lib/app-router-types'\nimport {\n  parseAppRouteSegment,\n  type NormalizedAppRoute,\n  type NormalizedAppRouteSegment,\n} from '../../../shared/lib/router/routes/app'\nimport { parseLoaderTree } from '../../../shared/lib/router/utils/parse-loader-tree'\nimport { resolveParamValue } from '../../../shared/lib/router/utils/resolve-param-value'\n\n/**\n * Validates that the static segments in currentPath match the corresponding\n * segments in targetSegments. This ensures we only extract dynamic parameters\n * that are part of the target pathname structure.\n *\n * Segments are compared literally - interception markers like \"(.)photo\" are\n * part of the pathname and must match exactly.\n *\n * @example\n * // Matching paths\n * currentPath: ['blog', '(.)photo']\n * targetSegments: ['blog', '(.)photo', '[id]']\n *  Returns true (both static segments match exactly)\n *\n * @example\n * // Non-matching paths\n * currentPath: ['blog', '(.)photo']\n * targetSegments: ['blog', 'photo', '[id]']\n *  Returns false (segments don't match - marker is part of pathname)\n *\n * @param currentPath - The accumulated path segments from the loader tree\n * @param targetSegments - The target pathname split into segments\n * @returns true if all static segments match, false otherwise\n */\nfunction validatePrefixMatch(\n  currentPath: NormalizedAppRouteSegment[],\n  route: NormalizedAppRoute\n): boolean {\n  for (let i = 0; i < currentPath.length; i++) {\n    const pathSegment = currentPath[i]\n    const targetPathSegment = route.segments[i]\n\n    // Type mismatch - one is static, one is dynamic\n    if (pathSegment.type !== targetPathSegment.type) {\n      return false\n    }\n\n    // One has an interception marker, the other doesn't.\n    if (\n      pathSegment.interceptionMarker !== targetPathSegment.interceptionMarker\n    ) {\n      return false\n    }\n\n    // Both are static but names don't match\n    if (\n      pathSegment.type === 'static' &&\n      targetPathSegment.type === 'static' &&\n      pathSegment.name !== targetPathSegment.name\n    ) {\n      return false\n    }\n    // Both are dynamic but param names don't match\n    else if (\n      pathSegment.type === 'dynamic' &&\n      targetPathSegment.type === 'dynamic' &&\n      pathSegment.param.paramType !== targetPathSegment.param.paramType &&\n      pathSegment.param.paramName !== targetPathSegment.param.paramName\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Extracts pathname route param segments from a loader tree and resolves\n * parameter values from static segments in the route.\n *\n * @param loaderTree - The loader tree structure containing route hierarchy\n * @param route - The target route to match against\n * @returns Object containing pathname route param segments and resolved params\n */\nexport function extractPathnameRouteParamSegmentsFromLoaderTree(\n  loaderTree: LoaderTree,\n  route: NormalizedAppRoute\n): {\n  pathnameRouteParamSegments: Array<{\n    readonly name: string\n    readonly paramName: string\n    readonly paramType: DynamicParamTypes\n  }>\n  params: Params\n} {\n  const pathnameRouteParamSegments: Array<{\n    readonly name: string\n    readonly paramName: string\n    readonly paramType: DynamicParamTypes\n  }> = []\n  const params: Params = {}\n\n  // BFS traversal with depth and path tracking\n  const queue: Array<{\n    tree: LoaderTree\n    depth: number\n    currentPath: NormalizedAppRouteSegment[]\n  }> = [{ tree: loaderTree, depth: 0, currentPath: [] }]\n\n  while (queue.length > 0) {\n    const { tree, depth, currentPath } = queue.shift()!\n    const { segment, parallelRoutes } = parseLoaderTree(tree)\n\n    // Build the path for the current node\n    let updatedPath = currentPath\n    let nextDepth = depth\n\n    const appSegment = parseAppRouteSegment(segment)\n\n    // Only add to path if it's a real segment that appears in the URL\n    // Route groups and parallel markers don't contribute to URL pathname\n    if (\n      appSegment &&\n      appSegment.type !== 'route-group' &&\n      appSegment.type !== 'parallel-route'\n    ) {\n      updatedPath = [...currentPath, appSegment]\n      nextDepth = depth + 1\n    }\n\n    // Check if this segment has a param and matches the target pathname at this depth\n    if (appSegment?.type === 'dynamic') {\n      const { paramName, paramType } = appSegment.param\n\n      // Check if this segment is at the correct depth in the target pathname\n      // A segment matches if:\n      // 1. There's a dynamic segment at this depth in the pathname\n      // 2. The parameter names match (e.g., [id] matches [id], not [category])\n      // 3. The static segments leading up to this point match (prefix check)\n      if (depth < route.segments.length) {\n        const targetSegment = route.segments[depth]\n\n        // Match if the target pathname has a dynamic segment at this depth\n        if (targetSegment.type === 'dynamic') {\n          // Check that parameter names match exactly\n          // This prevents [category] from matching against /[id]\n          if (paramName !== targetSegment.param.paramName) {\n            continue // Different param names, skip this segment\n          }\n\n          // Validate that the path leading up to this dynamic segment matches\n          // the target pathname. This prevents false matches like extracting\n          // [slug] from \"/news/[slug]\" when the tree has \"/blog/[slug]\"\n          if (validatePrefixMatch(currentPath, route)) {\n            pathnameRouteParamSegments.push({\n              name: segment,\n              paramName,\n              paramType,\n            })\n          }\n        }\n      }\n\n      // Resolve parameter value if it's not already known.\n      if (!params.hasOwnProperty(paramName)) {\n        const paramValue = resolveParamValue(\n          paramName,\n          paramType,\n          depth,\n          route,\n          params\n        )\n\n        if (paramValue !== undefined) {\n          params[paramName] = paramValue\n        }\n      }\n    }\n\n    // Continue traversing all parallel routes to find matching segments\n    for (const parallelRoute of Object.values(parallelRoutes)) {\n      queue.push({\n        tree: parallelRoute,\n        depth: nextDepth,\n        currentPath: updatedPath,\n      })\n    }\n  }\n\n  return { pathnameRouteParamSegments, params }\n}\n"],"names":["parseAppRouteSegment","parseLoaderTree","resolveParamValue","validatePrefixMatch","currentPath","route","i","length","pathSegment","targetPathSegment","segments","type","interceptionMarker","name","param","paramType","paramName","extractPathnameRouteParamSegmentsFromLoaderTree","loaderTree","pathnameRouteParamSegments","params","queue","tree","depth","shift","segment","parallelRoutes","updatedPath","nextDepth","appSegment","targetSegment","push","hasOwnProperty","paramValue","undefined","parallelRoute","Object","values"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1319, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/build/static-paths/utils.ts"],"sourcesContent":["import type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { Params } from '../../server/request/params'\nimport type { AppPageRouteModule } from '../../server/route-modules/app-page/module.compiled'\nimport type { AppRouteRouteModule } from '../../server/route-modules/app-route/module.compiled'\nimport { isAppPageRouteModule } from '../../server/route-modules/checks'\nimport type { DynamicParamTypes } from '../../shared/lib/app-router-types'\nimport {\n  parseAppRouteSegment,\n  type NormalizedAppRoute,\n} from '../../shared/lib/router/routes/app'\nimport { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\nimport type { AppSegment } from '../segment-config/app/app-segments'\nimport { extractPathnameRouteParamSegmentsFromLoaderTree } from './app/extract-pathname-route-param-segments-from-loader-tree'\nimport { resolveParamValue } from '../../shared/lib/router/utils/resolve-param-value'\nimport type { FallbackRouteParam } from './types'\n\n/**\n * Encodes a parameter value using the provided encoder.\n *\n * @param value - The value to encode.\n * @param encoder - The encoder to use.\n * @returns The encoded value.\n */\nexport function encodeParam(\n  value: string | string[],\n  encoder: (value: string) => string\n) {\n  let replaceValue: string\n  if (Array.isArray(value)) {\n    replaceValue = value.map(encoder).join('/')\n  } else {\n    replaceValue = encoder(value)\n  }\n\n  return replaceValue\n}\n\n/**\n * Normalizes a pathname to a consistent format.\n *\n * @param pathname - The pathname to normalize.\n * @returns The normalized pathname.\n */\nexport function normalizePathname(pathname: string) {\n  return pathname.replace(/\\\\/g, '/').replace(/(?!^)\\/$/, '')\n}\n\n/**\n * Extracts segments that contribute to the pathname by traversing the loader tree\n * based on the route module type.\n *\n * @param routeModule - The app route module (page or route handler)\n * @param segments - Array of AppSegment objects collected from the route\n * @param page - The target pathname to match against, INCLUDING interception\n *               markers (e.g., \"/blog/[slug]\", \"/(.)photo/[id]\")\n * @returns Array of segments with param info that contribute to the pathname\n */\nexport function extractPathnameRouteParamSegments(\n  routeModule: AppRouteRouteModule | AppPageRouteModule,\n  segments: readonly Readonly<AppSegment>[],\n  route: NormalizedAppRoute\n): Array<{\n  readonly name: string\n  readonly paramName: string\n  readonly paramType: DynamicParamTypes\n}> {\n  // For AppPageRouteModule, use the loaderTree traversal approach\n  if (isAppPageRouteModule(routeModule)) {\n    const { pathnameRouteParamSegments } =\n      extractPathnameRouteParamSegmentsFromLoaderTree(\n        routeModule.userland.loaderTree,\n        route\n      )\n    return pathnameRouteParamSegments\n  }\n\n  return extractPathnameRouteParamSegmentsFromSegments(segments)\n}\n\nexport function extractPathnameRouteParamSegmentsFromSegments(\n  segments: readonly Readonly<AppSegment>[]\n): Array<{\n  readonly name: string\n  readonly paramName: string\n  readonly paramType: DynamicParamTypes\n}> {\n  // TODO: should we consider what values are already present in the page?\n\n  // For AppRouteRouteModule, filter the segments array to get the route params\n  // that contribute to the pathname.\n  const result: Array<{\n    readonly name: string\n    readonly paramName: string\n    readonly paramType: DynamicParamTypes\n  }> = []\n\n  for (const segment of segments) {\n    // Skip segments without param info.\n    if (!segment.paramName || !segment.paramType) continue\n\n    // Collect all the route param keys that contribute to the pathname.\n    result.push({\n      name: segment.name,\n      paramName: segment.paramName,\n      paramType: segment.paramType,\n    })\n  }\n\n  return result\n}\n\n/**\n * Resolves all route parameters from the loader tree. This function uses\n * tree-based traversal to correctly handle the hierarchical structure of routes\n * and accurately determine parameter values based on their depth in the tree.\n *\n * This processes both regular route parameters (from the main children route) and\n * parallel route parameters (from slots like @modal, @sidebar).\n *\n * Unlike interpolateParallelRouteParams (which has a complete URL at runtime),\n * this build-time function determines which route params are unknown.\n * The pathname may contain placeholders like [slug], making it incomplete.\n *\n * @param loaderTree - The loader tree structure containing route hierarchy\n * @param params - The current route parameters object (will be mutated)\n * @param route - The current route being processed\n * @param fallbackRouteParams - Array of fallback route parameters (will be mutated)\n */\nexport function resolveRouteParamsFromTree(\n  loaderTree: LoaderTree,\n  params: Params,\n  route: NormalizedAppRoute,\n  fallbackRouteParams: FallbackRouteParam[]\n): void {\n  // Stack-based traversal with depth tracking\n  const stack: Array<{\n    tree: LoaderTree\n    depth: number\n  }> = [{ tree: loaderTree, depth: 0 }]\n\n  while (stack.length > 0) {\n    const { tree, depth } = stack.pop()!\n    const { segment, parallelRoutes } = parseLoaderTree(tree)\n\n    const appSegment = parseAppRouteSegment(segment)\n\n    // If this segment is a route parameter, then we should process it if it's\n    // not already known and is not already marked as a fallback route param.\n    if (\n      appSegment?.type === 'dynamic' &&\n      !params.hasOwnProperty(appSegment.param.paramName) &&\n      !fallbackRouteParams.some(\n        (param) => param.paramName === appSegment.param.paramName\n      )\n    ) {\n      const { paramName, paramType } = appSegment.param\n\n      const paramValue = resolveParamValue(\n        paramName,\n        paramType,\n        depth,\n        route,\n        params\n      )\n\n      if (paramValue !== undefined) {\n        params[paramName] = paramValue\n      } else if (paramType !== 'optional-catchall') {\n        // If we couldn't resolve the param, mark it as a fallback\n        fallbackRouteParams.push({ paramName, paramType })\n      }\n    }\n\n    // Calculate next depth - increment if this is not a route group and not empty\n    let nextDepth = depth\n    if (\n      appSegment &&\n      appSegment.type !== 'route-group' &&\n      appSegment.type !== 'parallel-route'\n    ) {\n      nextDepth++\n    }\n\n    // Add all parallel routes to the stack for processing.\n    for (const parallelRoute of Object.values(parallelRoutes)) {\n      stack.push({ tree: parallelRoute, depth: nextDepth })\n    }\n  }\n}\n"],"names":["isAppPageRouteModule","parseAppRouteSegment","parseLoaderTree","extractPathnameRouteParamSegmentsFromLoaderTree","resolveParamValue","encodeParam","value","encoder","replaceValue","Array","isArray","map","join","normalizePathname","pathname","replace","extractPathnameRouteParamSegments","routeModule","segments","route","pathnameRouteParamSegments","userland","loaderTree","extractPathnameRouteParamSegmentsFromSegments","result","segment","paramName","paramType","push","name","resolveRouteParamsFromTree","params","fallbackRouteParams","stack","tree","depth","length","pop","parallelRoutes","appSegment","type","hasOwnProperty","param","some","paramValue","undefined","nextDepth","parallelRoute","Object","values"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1423, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/app-render/get-short-dynamic-param-type.tsx"],"sourcesContent":["import type {\n  DynamicParamTypes,\n  DynamicParamTypesShort,\n} from '../../shared/lib/app-router-types'\n\nexport const dynamicParamTypes: Record<\n  DynamicParamTypes,\n  DynamicParamTypesShort\n> = {\n  catchall: 'c',\n  'catchall-intercepted-(..)(..)': 'ci(..)(..)',\n  'catchall-intercepted-(.)': 'ci(.)',\n  'catchall-intercepted-(..)': 'ci(..)',\n  'catchall-intercepted-(...)': 'ci(...)',\n  'optional-catchall': 'oc',\n  dynamic: 'd',\n  'dynamic-intercepted-(..)(..)': 'di(..)(..)',\n  'dynamic-intercepted-(.)': 'di(.)',\n  'dynamic-intercepted-(..)': 'di(..)',\n  'dynamic-intercepted-(...)': 'di(...)',\n}\n"],"names":["dynamicParamTypes","catchall","dynamic"],"mappings":";;;;AAKO,MAAMA,oBAGT;IACFC,UAAU;IACV,iCAAiC;IACjC,4BAA4B;IAC5B,6BAA6B;IAC7B,8BAA8B;IAC9B,qBAAqB;IACrBC,SAAS;IACT,gCAAgC;IAChC,2BAA2B;IAC3B,4BAA4B;IAC5B,6BAA6B;AAC/B,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1444, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/request/fallback-params.ts"],"sourcesContent":["import { resolveRouteParamsFromTree } from '../../build/static-paths/utils'\nimport type { FallbackRouteParam } from '../../build/static-paths/types'\nimport type { DynamicParamTypesShort } from '../../shared/lib/app-router-types'\nimport { dynamicParamTypes } from '../app-render/get-short-dynamic-param-type'\nimport type AppPageRouteModule from '../route-modules/app-page/module'\nimport { parseAppRoute } from '../../shared/lib/router/routes/app'\nimport { extractPathnameRouteParamSegmentsFromLoaderTree } from '../../build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree'\n\nexport type OpaqueFallbackRouteParamValue = [\n  /**\n   * The search value of the fallback route param. This is the opaque key\n   * that will be used to replace the dynamic param in the postponed state.\n   */\n  searchValue: string,\n\n  /**\n   * The dynamic param type of the fallback route param. This is the type of\n   * the dynamic param that will be used to replace the dynamic param in the\n   * postponed state.\n   */\n  dynamicParamType: DynamicParamTypesShort,\n]\n\n/**\n * An opaque fallback route params object. This is used to store the fallback\n * route params in a way that is not easily accessible to the client.\n */\nexport type OpaqueFallbackRouteParams = ReadonlyMap<\n  string,\n  OpaqueFallbackRouteParamValue\n>\n\n/**\n * The entries of the opaque fallback route params object.\n *\n * @param key the key of the fallback route param\n * @param value the value of the fallback route param\n */\nexport type OpaqueFallbackRouteParamEntries =\n  ReturnType<OpaqueFallbackRouteParams['entries']> extends MapIterator<\n    [infer K, infer V]\n  >\n    ? ReadonlyArray<[K, V]>\n    : never\n\n/**\n * Creates an opaque fallback route params object from the fallback route params.\n *\n * @param fallbackRouteParams the fallback route params\n * @returns the opaque fallback route params\n */\nexport function createOpaqueFallbackRouteParams(\n  fallbackRouteParams: readonly FallbackRouteParam[]\n): OpaqueFallbackRouteParams | null {\n  // If there are no fallback route params, we can return early.\n  if (fallbackRouteParams.length === 0) return null\n\n  // As we're creating unique keys for each of the dynamic route params, we only\n  // need to generate a unique ID once per request because each of the keys will\n  // be also be unique.\n  const uniqueID = Math.random().toString(16).slice(2)\n\n  const keys = new Map<string, OpaqueFallbackRouteParamValue>()\n\n  // Generate a unique key for the fallback route param, if this key is found\n  // in the static output, it represents a bug in cache components.\n  for (const { paramName, paramType } of fallbackRouteParams) {\n    keys.set(paramName, [\n      `%%drp:${paramName}:${uniqueID}%%`,\n      dynamicParamTypes[paramType],\n    ])\n  }\n\n  return keys\n}\n\n/**\n * Gets the fallback route params for a given page. This is an expensive\n * operation because it requires parsing the loader tree to extract the fallback\n * route params.\n *\n * @param page the page\n * @param routeModule the route module\n * @returns the opaque fallback route params\n */\nexport function getFallbackRouteParams(\n  page: string,\n  routeModule: AppPageRouteModule\n) {\n  const route = parseAppRoute(page, true)\n\n  // Extract the pathname-contributing segments from the loader tree. This\n  // mirrors the logic in buildAppStaticPaths where we determine which segments\n  // actually contribute to the pathname.\n  const { pathnameRouteParamSegments, params } =\n    extractPathnameRouteParamSegmentsFromLoaderTree(\n      routeModule.userland.loaderTree,\n      route\n    )\n\n  // Create fallback route params for the pathname segments.\n  const fallbackRouteParams: FallbackRouteParam[] =\n    pathnameRouteParamSegments.map(({ paramName, paramType }) => ({\n      paramName,\n      paramType,\n    }))\n\n  // Resolve route params from the loader tree. This mutates the\n  // fallbackRouteParams array to add any route params that are\n  // unknown at request time.\n  //\n  // The page parameter contains placeholders like [slug], which helps\n  // resolveRouteParamsFromTree determine which params are unknown.\n  resolveRouteParamsFromTree(\n    routeModule.userland.loaderTree,\n    params, // Static params extracted from the page\n    route, // The page pattern with placeholders\n    fallbackRouteParams // Will be mutated to add route params\n  )\n\n  // Convert the fallback route params to an opaque format that can be safely\n  // used in the postponed state without exposing implementation details.\n  return createOpaqueFallbackRouteParams(fallbackRouteParams)\n}\n"],"names":["resolveRouteParamsFromTree","dynamicParamTypes","parseAppRoute","extractPathnameRouteParamSegmentsFromLoaderTree","createOpaqueFallbackRouteParams","fallbackRouteParams","length","uniqueID","Math","random","toString","slice","keys","Map","paramName","paramType","set","getFallbackRouteParams","page","routeModule","route","pathnameRouteParamSegments","params","userland","loaderTree","map"],"mappings":";;;;;;AAAA,SAASA,0BAA0B,QAAQ,iCAAgC;AAG3E,SAASC,iBAAiB,QAAQ,6CAA4C;AAE9E,SAASC,aAAa,QAAQ,qCAAoC;AAClE,SAASC,+CAA+C,QAAQ,sFAAqF;;;;;AA6C9I,SAASC,gCACdC,mBAAkD;IAElD,8DAA8D;IAC9D,IAAIA,oBAAoBC,MAAM,KAAK,GAAG,OAAO;IAE7C,8EAA8E;IAC9E,8EAA8E;IAC9E,qBAAqB;IACrB,MAAMC,WAAWC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,KAAK,CAAC;IAElD,MAAMC,OAAO,IAAIC;IAEjB,2EAA2E;IAC3E,iEAAiE;IACjE,KAAK,MAAM,EAAEC,SAAS,EAAEC,SAAS,EAAE,IAAIV,oBAAqB;QAC1DO,KAAKI,GAAG,CAACF,WAAW;YAClB,CAAC,MAAM,EAAEA,UAAU,CAAC,EAAEP,SAAS,EAAE,CAAC;YAClCN,+NAAiB,CAACc,UAAU;SAC7B;IACH;IAEA,OAAOH;AACT;AAWO,SAASK,uBACdC,IAAY,EACZC,WAA+B;IAE/B,MAAMC,YAAQlB,gMAAAA,EAAcgB,MAAM;IAElC,wEAAwE;IACxE,6EAA6E;IAC7E,uCAAuC;IACvC,MAAM,EAAEG,0BAA0B,EAAEC,MAAM,EAAE,OAC1CnB,wSAAAA,EACEgB,YAAYI,QAAQ,CAACC,UAAU,EAC/BJ;IAGJ,0DAA0D;IAC1D,MAAMf,sBACJgB,2BAA2BI,GAAG,CAAC,CAAC,EAAEX,SAAS,EAAEC,SAAS,EAAE,GAAM,CAAA;YAC5DD;YACAC;QACF,CAAA;IAEF,8DAA8D;IAC9D,6DAA6D;IAC7D,2BAA2B;IAC3B,EAAE;IACF,oEAAoE;IACpE,iEAAiE;QACjEf,sMAAAA,EACEmB,YAAYI,QAAQ,CAACC,UAAU,EAC/BF,QACAF,OACAf,oBAAoB,sCAAsC;;IAG5D,2EAA2E;IAC3E,uEAAuE;IACvE,OAAOD,gCAAgCC;AACzC","ignoreList":[0]}},
    {"offset": {"line": 1503, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/app-render/manifests-singleton.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nexport interface ServerModuleMap {\n  readonly [name: string]: {\n    readonly id: string | number\n    readonly name: string\n    readonly chunks: Readonly<Array<string>> // currently not used\n    readonly async?: boolean\n  }\n}\n\n// This is a global singleton that is, among other things, also used to\n// encode/decode bound args of server function closures. This can't be using a\n// AsyncLocalStorage as it might happen at the module level.\nconst MANIFESTS_SINGLETON = Symbol.for('next.server.manifests')\n\ninterface ManifestsSingleton {\n  readonly clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n  readonly proxiedClientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: ServerModuleMap\n}\n\ntype GlobalThisWithManifests = typeof globalThis & {\n  [MANIFESTS_SINGLETON]?: ManifestsSingleton\n}\n\ntype ClientReferenceManifestMappingProp =\n  | 'clientModules'\n  | 'rscModuleMapping'\n  | 'edgeRscModuleMapping'\n  | 'ssrModuleMapping'\n  | 'edgeSSRModuleMapping'\n\nconst globalThisWithManifests = globalThis as GlobalThisWithManifests\n\nfunction createProxiedClientReferenceManifest(\n  clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n): DeepReadonly<ClientReferenceManifest> {\n  const createMappingProxy = (prop: ClientReferenceManifestMappingProp) => {\n    return new Proxy(\n      {},\n      {\n        get(_, id: string) {\n          const workStore = workAsyncStorage.getStore()\n\n          if (workStore) {\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (currentManifest?.[prop][id]) {\n              return currentManifest[prop][id]\n            }\n\n            // In development, we also check all other manifests to see if the\n            // module exists there. This is to support a scenario where React's\n            // I/O tracking (dev-only) creates a connection from one page to\n            // another through an emitted async I/O node that references client\n            // components from the other page, e.g. in owner props.\n            // TODO: Maybe we need to add a `debugBundlerConfig` option to React\n            // to avoid this workaround. The current workaround has the\n            // disadvantage that one might accidentally or intentionally share\n            // client references across pages (e.g. by storing them in a global\n            // variable), which would then only be caught in production.\n            if (process.env.NODE_ENV !== 'production') {\n              for (const [\n                route,\n                manifest,\n              ] of clientReferenceManifestsPerRoute) {\n                if (route === workStore.route) {\n                  continue\n                }\n\n                const entry = manifest[prop][id]\n\n                if (entry !== undefined) {\n                  return entry\n                }\n              }\n            }\n          } else {\n            // If there's no work store defined, we can assume that a client\n            // reference manifest is needed during module evaluation, e.g. to\n            // create a server function using a higher-order function. This\n            // might also use client components which need to be serialized by\n            // Flight, and therefore client references need to be resolvable. In\n            // that case we search all page manifests to find the module.\n            for (const manifest of clientReferenceManifestsPerRoute.values()) {\n              const entry = manifest[prop][id]\n\n              if (entry !== undefined) {\n                return entry\n              }\n            }\n          }\n\n          return undefined\n        },\n      }\n    )\n  }\n\n  const mappingProxies = new Map<\n    ClientReferenceManifestMappingProp,\n    ReturnType<typeof createMappingProxy>\n  >()\n\n  return new Proxy(\n    {},\n    {\n      get(_, prop) {\n        const workStore = workAsyncStorage.getStore()\n\n        switch (prop) {\n          case 'moduleLoading':\n          case 'entryCSSFiles':\n          case 'entryJSFiles': {\n            if (!workStore) {\n              throw new InvariantError(\n                `Cannot access \"${prop}\" without a work store.`\n              )\n            }\n\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (!currentManifest) {\n              throw new InvariantError(\n                `The client reference manifest for route \"${workStore.route}\" does not exist.`\n              )\n            }\n\n            return currentManifest[prop]\n          }\n          case 'clientModules':\n          case 'rscModuleMapping':\n          case 'edgeRscModuleMapping':\n          case 'ssrModuleMapping':\n          case 'edgeSSRModuleMapping': {\n            let proxy = mappingProxies.get(prop)\n\n            if (!proxy) {\n              proxy = createMappingProxy(prop)\n              mappingProxies.set(prop, proxy)\n            }\n\n            return proxy\n          }\n          default: {\n            throw new InvariantError(\n              `This is a proxied client reference manifest. The property \"${String(prop)}\" is not handled.`\n            )\n          }\n        }\n      },\n    }\n  ) as DeepReadonly<ClientReferenceManifest>\n}\n\n/**\n * This function creates a Flight-acceptable server module map proxy from our\n * Server Reference Manifest similar to our client module map. This is because\n * our manifest contains a lot of internal Next.js data that are relevant to the\n * runtime, workers, etc. that React doesn't need to know.\n */\nfunction createServerModuleMap(): ServerModuleMap {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          getServerActionsManifest()[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ]?.[id]?.workers\n\n        if (!workers) {\n          return undefined\n        }\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * The flight entry loader keys actions by bundlePath. bundlePath corresponds\n * with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page\n * name.\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string\n): string | undefined {\n  const serverActionsManifest = getServerActionsManifest()\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n\n  // There are no workers to handle this action, nothing to forward to.\n  if (!workers) {\n    return\n  }\n\n  // If there is an entry for the current page, we don't need to forward.\n  if (workers[normalizeWorkerPageName(pageName)]) {\n    return\n  }\n\n  // Otherwise, grab the first worker that has a handler for this action id.\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\nexport function setManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n}) {\n  const existingSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (existingSingleton) {\n    existingSingleton.clientReferenceManifestsPerRoute.set(\n      normalizeAppPath(page),\n      clientReferenceManifest\n    )\n\n    existingSingleton.serverActionsManifest = serverActionsManifest\n  } else {\n    const clientReferenceManifestsPerRoute = new Map<\n      string,\n      DeepReadonly<ClientReferenceManifest>\n    >([[normalizeAppPath(page), clientReferenceManifest]])\n\n    const proxiedClientReferenceManifest = createProxiedClientReferenceManifest(\n      clientReferenceManifestsPerRoute\n    )\n\n    globalThisWithManifests[MANIFESTS_SINGLETON] = {\n      clientReferenceManifestsPerRoute,\n      proxiedClientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap(),\n    }\n  }\n}\n\nfunction getManifestsSingleton(): ManifestsSingleton {\n  const manifestSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (!manifestSingleton) {\n    throw new InvariantError('The manifests singleton was not initialized.')\n  }\n\n  return manifestSingleton\n}\n\nexport function getClientReferenceManifest(): DeepReadonly<ClientReferenceManifest> {\n  return getManifestsSingleton().proxiedClientReferenceManifest\n}\n\nexport function getServerActionsManifest(): DeepReadonly<ActionManifest> {\n  return getManifestsSingleton().serverActionsManifest\n}\n\nexport function getServerModuleMap() {\n  return getManifestsSingleton().serverModuleMap\n}\n"],"names":["InvariantError","normalizeAppPath","pathHasPrefix","removePathPrefix","workAsyncStorage","MANIFESTS_SINGLETON","Symbol","for","globalThisWithManifests","globalThis","createProxiedClientReferenceManifest","clientReferenceManifestsPerRoute","createMappingProxy","prop","Proxy","get","_","id","workStore","getStore","currentManifest","route","process","env","NODE_ENV","manifest","entry","undefined","values","mappingProxies","Map","proxy","set","String","createServerModuleMap","getServerActionsManifest","workers","NEXT_RUNTIME","workerEntry","normalizeWorkerPageName","page","Object","at","moduleId","async","name","chunks","pageName","denormalizeWorkerPageName","bundlePath","selectWorkerForForwarding","actionId","serverActionsManifest","keys","setManifestsSingleton","clientReferenceManifest","existingSingleton","proxiedClientReferenceManifest","serverModuleMap","getManifestsSingleton","manifestSingleton","getClientReferenceManifest","getServerModuleMap"],"mappings":";;;;;;;;;;;;AAGA,SAASA,cAAc,QAAQ,mCAAkC;AACjE,SAASC,gBAAgB,QAAQ,0CAAyC;AAC1E,SAASC,aAAa,QAAQ,gDAA+C;AAC7E,SAASC,gBAAgB,QAAQ,mDAAkD;AACnF,SAASC,gBAAgB,QAAQ,gCAA+B;;;;;;AAWhE,uEAAuE;AACvE,8EAA8E;AAC9E,4DAA4D;AAC5D,MAAMC,sBAAsBC,OAAOC,GAAG,CAAC;AAuBvC,MAAMC,0BAA0BC;AAEhC,SAASC,qCACPC,gCAGC;IAED,MAAMC,qBAAqB,CAACC;QAC1B,OAAO,IAAIC,MACT,CAAC,GACD;YACEC,KAAIC,CAAC,EAAEC,EAAU;gBACf,MAAMC,YAAYd,uRAAAA,CAAiBe,QAAQ;gBAE3C,IAAID,WAAW;oBACb,MAAME,kBAAkBT,iCAAiCI,GAAG,CAC1DG,UAAUG,KAAK;oBAGjB,IAAID,mBAAAA,OAAAA,KAAAA,IAAAA,eAAiB,CAACP,KAAK,CAACI,GAAG,EAAE;wBAC/B,OAAOG,eAAe,CAACP,KAAK,CAACI,GAAG;oBAClC;oBAEA,kEAAkE;oBAClE,mEAAmE;oBACnE,gEAAgE;oBAChE,mEAAmE;oBACnE,uDAAuD;oBACvD,oEAAoE;oBACpE,2DAA2D;oBAC3D,kEAAkE;oBAClE,mEAAmE;oBACnE,4DAA4D;oBAC5D,IAAIK,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAc;wBACzC,KAAK,MAAM,CACTH,OACAI,SACD,IAAId,iCAAkC;4BACrC,IAAIU,UAAUH,UAAUG,KAAK,EAAE;gCAC7B;4BACF;4BAEA,MAAMK,QAAQD,QAAQ,CAACZ,KAAK,CAACI,GAAG;4BAEhC,IAAIS,UAAUC,WAAW;gCACvB,OAAOD;4BACT;wBACF;oBACF;gBACF,OAAO;oBACL,gEAAgE;oBAChE,iEAAiE;oBACjE,+DAA+D;oBAC/D,kEAAkE;oBAClE,oEAAoE;oBACpE,6DAA6D;oBAC7D,KAAK,MAAMD,YAAYd,iCAAiCiB,MAAM,GAAI;wBAChE,MAAMF,QAAQD,QAAQ,CAACZ,KAAK,CAACI,GAAG;wBAEhC,IAAIS,UAAUC,WAAW;4BACvB,OAAOD;wBACT;oBACF;gBACF;gBAEA,OAAOC;YACT;QACF;IAEJ;IAEA,MAAME,iBAAiB,IAAIC;IAK3B,OAAO,IAAIhB,MACT,CAAC,GACD;QACEC,KAAIC,CAAC,EAAEH,IAAI;YACT,MAAMK,YAAYd,uRAAAA,CAAiBe,QAAQ;YAE3C,OAAQN;gBACN,KAAK;gBACL,KAAK;gBACL,KAAK;oBAAgB;wBACnB,IAAI,CAACK,WAAW;4BACd,MAAM,OAAA,cAEL,CAFK,IAAIlB,4LAAAA,CACR,CAAC,eAAe,EAAEa,KAAK,uBAAuB,CAAC,GAD3C,qBAAA;uCAAA;4CAAA;8CAAA;4BAEN;wBACF;wBAEA,MAAMO,kBAAkBT,iCAAiCI,GAAG,CAC1DG,UAAUG,KAAK;wBAGjB,IAAI,CAACD,iBAAiB;4BACpB,MAAM,OAAA,cAEL,CAFK,IAAIpB,4LAAAA,CACR,CAAC,yCAAyC,EAAEkB,UAAUG,KAAK,CAAC,iBAAiB,CAAC,GAD1E,qBAAA;uCAAA;4CAAA;8CAAA;4BAEN;wBACF;wBAEA,OAAOD,eAAe,CAACP,KAAK;oBAC9B;gBACA,KAAK;gBACL,KAAK;gBACL,KAAK;gBACL,KAAK;gBACL,KAAK;oBAAwB;wBAC3B,IAAIkB,QAAQF,eAAed,GAAG,CAACF;wBAE/B,IAAI,CAACkB,OAAO;4BACVA,QAAQnB,mBAAmBC;4BAC3BgB,eAAeG,GAAG,CAACnB,MAAMkB;wBAC3B;wBAEA,OAAOA;oBACT;gBACA;oBAAS;wBACP,MAAM,OAAA,cAEL,CAFK,IAAI/B,4LAAAA,CACR,CAAC,2DAA2D,EAAEiC,OAAOpB,MAAM,iBAAiB,CAAC,GADzF,qBAAA;mCAAA;wCAAA;0CAAA;wBAEN;oBACF;YACF;QACF;IACF;AAEJ;AAEA;;;;;CAKC,GACD,SAASqB;IACP,OAAO,IAAIpB,MACT,CAAC,GACD;QACEC,KAAK,CAACC,GAAGC;gBAELkB,+BAAAA;YADF,MAAMC,UAAAA,CACJD,6BAAAA,0BAA0B,CACxBb,QAAQC,GAAG,CAACc,YAAY,KAAK,SAAS,0BAAS,OAChD,KAAA,OAAA,KAAA,IAAA,CAFDF,gCAAAA,0BAEG,CAAClB,GAAG,KAAA,OAAA,KAAA,IAFPkB,8BAESC,OAAO;YAElB,IAAI,CAACA,SAAS;gBACZ,OAAOT;YACT;YAEA,MAAMT,YAAYd,uRAAAA,CAAiBe,QAAQ;YAE3C,IAAImB;YAIJ,IAAIpB,WAAW;gBACboB,cAAcF,OAAO,CAACG,wBAAwBrB,UAAUsB,IAAI,EAAE;YAChE,OAAO;gBACL,gEAAgE;gBAChE,kEAAkE;gBAClE,sEAAsE;gBACtE,qEAAqE;gBACrE,qEAAqE;gBACrE,qEAAqE;gBACrE,oCAAoC;gBACpCF,cAAcG,OAAOb,MAAM,CAACQ,SAASM,EAAE,CAAC;YAC1C;YAEA,IAAI,CAACJ,aAAa;gBAChB,OAAOX;YACT;YAEA,MAAM,EAAEgB,QAAQ,EAAEC,KAAK,EAAE,GAAGN;YAE5B,OAAO;gBAAErB,IAAI0B;gBAAUE,MAAM5B;gBAAI6B,QAAQ,EAAE;gBAAEF;YAAM;QACrD;IACF;AAEJ;AAEA;;;CAGC,GACD,SAASL,wBAAwBQ,QAAgB;IAC/C,QAAI7C,iNAAAA,EAAc6C,UAAU,QAAQ;QAClC,OAAOA;IACT;IAEA,OAAO,QAAQA;AACjB;AAEA;;;CAGC,GACD,SAASC,0BAA0BC,UAAkB;IACnD,WAAOhD,2MAAAA,MAAiBE,uNAAAA,EAAiB8C,YAAY;AACvD;AAMO,SAASC,0BACdC,QAAgB,EAChBJ,QAAgB;QAIdK;IAFF,MAAMA,wBAAwBjB;IAC9B,MAAMC,UAAAA,CACJgB,mCAAAA,qBAAqB,CACnB9B,QAAQC,GAAG,CAACc,YAAY,KAAK,SAAS,0BAAS,OAChD,CAACc,SAAS,KAAA,OAAA,KAAA,IAFXC,iCAEahB,OAAO;IAEtB,qEAAqE;IACrE,IAAI,CAACA,SAAS;QACZ;IACF;IAEA,uEAAuE;IACvE,IAAIA,OAAO,CAACG,wBAAwBQ,UAAU,EAAE;QAC9C;IACF;IAEA,0EAA0E;IAC1E,OAAOC,0BAA0BP,OAAOY,IAAI,CAACjB,QAAQ,CAAC,EAAE;AAC1D;AAEO,SAASkB,sBAAsB,EACpCd,IAAI,EACJe,uBAAuB,EACvBH,qBAAqB,EAKtB;IACC,MAAMI,oBAAoBhD,uBAAuB,CAACH,oBAAoB;IAEtE,IAAImD,mBAAmB;QACrBA,kBAAkB7C,gCAAgC,CAACqB,GAAG,KACpD/B,2MAAAA,EAAiBuC,OACjBe;QAGFC,kBAAkBJ,qBAAqB,GAAGA;IAC5C,OAAO;QACL,MAAMzC,mCAAmC,IAAImB,IAG3C;YAAC;oBAAC7B,2MAAAA,EAAiBuC;gBAAOe;aAAwB;SAAC;QAErD,MAAME,iCAAiC/C,qCACrCC;QAGFH,uBAAuB,CAACH,oBAAoB,GAAG;YAC7CM;YACA8C;YACAL;YACAM,iBAAiBxB;QACnB;IACF;AACF;AAEA,SAASyB;IACP,MAAMC,oBAAoBpD,uBAAuB,CAACH,oBAAoB;IAEtE,IAAI,CAACuD,mBAAmB;QACtB,MAAM,OAAA,cAAkE,CAAlE,IAAI5D,4LAAAA,CAAe,iDAAnB,qBAAA;mBAAA;wBAAA;0BAAA;QAAiE;IACzE;IAEA,OAAO4D;AACT;AAEO,SAASC;IACd,OAAOF,wBAAwBF,8BAA8B;AAC/D;AAEO,SAAStB;IACd,OAAOwB,wBAAwBP,qBAAqB;AACtD;AAEO,SAASU;IACd,OAAOH,wBAAwBD,eAAe;AAChD","ignoreList":[0]}},
    {"offset": {"line": 1745, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/utils/html-bots.ts"],"sourcesContent":["// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\nexport const HTML_LIMITED_BOT_UA_RE =\n  /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i\n"],"names":["HTML_LIMITED_BOT_UA_RE"],"mappings":"AAAA,6GAA6G;AAC7G,sKAAsK;AACtK,kJAAkJ;AAClJ,iGAAiG;;;;;AAC1F,MAAMA,yBACX,sTAAqT","ignoreList":[0]}},
    {"offset": {"line": 1758, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/router/utils/is-bot.ts"],"sourcesContent":["import { HTML_LIMITED_BOT_UA_RE } from './html-bots'\n\n// Bot crawler that will spin up a headless browser and execute JS.\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i\n\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source\n\nexport { HTML_LIMITED_BOT_UA_RE }\n\nfunction isDomBotUA(userAgent: string) {\n  return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent)\n}\n\nfunction isHtmlLimitedBotUA(userAgent: string) {\n  return HTML_LIMITED_BOT_UA_RE.test(userAgent)\n}\n\nexport function isBot(userAgent: string): boolean {\n  return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent)\n}\n\nexport function getBotType(userAgent: string): 'dom' | 'html' | undefined {\n  if (isDomBotUA(userAgent)) {\n    return 'dom'\n  }\n  if (isHtmlLimitedBotUA(userAgent)) {\n    return 'html'\n  }\n  return undefined\n}\n"],"names":["HTML_LIMITED_BOT_UA_RE","HEADLESS_BROWSER_BOT_UA_RE","HTML_LIMITED_BOT_UA_RE_STRING","source","isDomBotUA","userAgent","test","isHtmlLimitedBotUA","isBot","getBotType","undefined"],"mappings":";;;;;;;;AAAA,SAASA,sBAAsB,QAAQ,cAAa;;AAEpD,mEAAmE;AACnE,yFAAyF;AACzF,4FAA4F;AAC5F,oGAAoG;AACpG,MAAMC,6BAA6B;AAE5B,MAAMC,gCAAgCF,iNAAAA,CAAuBG,MAAM,CAAA;;AAI1E,SAASC,WAAWC,SAAiB;IACnC,OAAOJ,2BAA2BK,IAAI,CAACD;AACzC;AAEA,SAASE,mBAAmBF,SAAiB;IAC3C,OAAOL,iNAAAA,CAAuBM,IAAI,CAACD;AACrC;AAEO,SAASG,MAAMH,SAAiB;IACrC,OAAOD,WAAWC,cAAcE,mBAAmBF;AACrD;AAEO,SAASI,WAAWJ,SAAiB;IAC1C,IAAID,WAAWC,YAAY;QACzB,OAAO;IACT;IACA,IAAIE,mBAAmBF,YAAY;QACjC,OAAO;IACT;IACA,OAAOK;AACT","ignoreList":[0]}},
    {"offset": {"line": 1797, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/lib/streaming-metadata.ts"],"sourcesContent":["import {\n  getBotType,\n  HTML_LIMITED_BOT_UA_RE_STRING,\n} from '../../shared/lib/router/utils/is-bot'\nimport type { BaseNextRequest } from '../base-http'\n\nexport function shouldServeStreamingMetadata(\n  userAgent: string,\n  htmlLimitedBots: string | undefined\n): boolean {\n  const blockingMetadataUARegex = new RegExp(\n    htmlLimitedBots || HTML_LIMITED_BOT_UA_RE_STRING,\n    'i'\n  )\n  // Only block metadata for HTML-limited bots\n  if (userAgent && blockingMetadataUARegex.test(userAgent)) {\n    return false\n  }\n  return true\n}\n\n// When the request UA is a html-limited bot, we should do a dynamic render.\n// In this case, postpone state is not sent.\nexport function isHtmlBotRequest(req: {\n  headers: BaseNextRequest['headers']\n}): boolean {\n  const ua = req.headers['user-agent'] || ''\n  const botType = getBotType(ua)\n\n  return botType === 'html'\n}\n"],"names":["getBotType","HTML_LIMITED_BOT_UA_RE_STRING","shouldServeStreamingMetadata","userAgent","htmlLimitedBots","blockingMetadataUARegex","RegExp","test","isHtmlBotRequest","req","ua","headers","botType"],"mappings":";;;;;;AAAA,SACEA,UAAU,EACVC,6BAA6B,QACxB,uCAAsC;;AAGtC,SAASC,6BACdC,SAAiB,EACjBC,eAAmC;IAEnC,MAAMC,0BAA0B,IAAIC,OAClCF,mBAAmBH,qOAAAA,EACnB;IAEF,4CAA4C;IAC5C,IAAIE,aAAaE,wBAAwBE,IAAI,CAACJ,YAAY;QACxD,OAAO;IACT;IACA,OAAO;AACT;AAIO,SAASK,iBAAiBC,GAEhC;IACC,MAAMC,KAAKD,IAAIE,OAAO,CAAC,aAAa,IAAI;IACxC,MAAMC,cAAUZ,kNAAAA,EAAWU;IAE3B,OAAOE,YAAY;AACrB","ignoreList":[0]}},
    {"offset": {"line": 1822, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/lib/server-action-request-meta.ts"],"sourcesContent":["import type { IncomingMessage } from 'http'\nimport type { BaseNextRequest } from '../base-http'\nimport type { NextRequest } from '../web/exports'\nimport { ACTION_HEADER } from '../../client/components/app-router-headers'\n\nexport function getServerActionRequestMetadata(\n  req: IncomingMessage | BaseNextRequest | NextRequest\n): {\n  actionId: string | null\n  isURLEncodedAction: boolean\n  isMultipartAction: boolean\n  isFetchAction: boolean\n  isPossibleServerAction: boolean\n} {\n  let actionId: string | null\n  let contentType: string | null\n\n  if (req.headers instanceof Headers) {\n    actionId = req.headers.get(ACTION_HEADER) ?? null\n    contentType = req.headers.get('content-type')\n  } else {\n    actionId = (req.headers[ACTION_HEADER] as string) ?? null\n    contentType = req.headers['content-type'] ?? null\n  }\n\n  // We don't actually support URL encoded actions, and the action handler will bail out if it sees one.\n  // But we still want it to flow through to the action handler, to prevent changes in behavior when a regular\n  // page component tries to handle a POST.\n  const isURLEncodedAction = Boolean(\n    req.method === 'POST' && contentType === 'application/x-www-form-urlencoded'\n  )\n  const isMultipartAction = Boolean(\n    req.method === 'POST' && contentType?.startsWith('multipart/form-data')\n  )\n  const isFetchAction = Boolean(\n    actionId !== undefined &&\n      typeof actionId === 'string' &&\n      req.method === 'POST'\n  )\n\n  const isPossibleServerAction = Boolean(\n    isFetchAction || isURLEncodedAction || isMultipartAction\n  )\n\n  return {\n    actionId,\n    isURLEncodedAction,\n    isMultipartAction,\n    isFetchAction,\n    isPossibleServerAction,\n  }\n}\n\nexport function getIsPossibleServerAction(\n  req: IncomingMessage | BaseNextRequest | NextRequest\n): boolean {\n  return getServerActionRequestMetadata(req).isPossibleServerAction\n}\n"],"names":["ACTION_HEADER","getServerActionRequestMetadata","req","actionId","contentType","headers","Headers","get","isURLEncodedAction","Boolean","method","isMultipartAction","startsWith","isFetchAction","undefined","isPossibleServerAction","getIsPossibleServerAction"],"mappings":";;;;;;AAGA,SAASA,aAAa,QAAQ,6CAA4C;;AAEnE,SAASC,+BACdC,GAAoD;IAQpD,IAAIC;IACJ,IAAIC;IAEJ,IAAIF,IAAIG,OAAO,YAAYC,SAAS;QAClCH,WAAWD,IAAIG,OAAO,CAACE,GAAG,CAACP,wMAAAA,KAAkB;QAC7CI,cAAcF,IAAIG,OAAO,CAACE,GAAG,CAAC;IAChC,OAAO;QACLJ,WAAYD,IAAIG,OAAO,CAACL,wMAAAA,CAAc,IAAe;QACrDI,cAAcF,IAAIG,OAAO,CAAC,eAAe,IAAI;IAC/C;IAEA,sGAAsG;IACtG,4GAA4G;IAC5G,yCAAyC;IACzC,MAAMG,qBAAqBC,QACzBP,IAAIQ,MAAM,KAAK,UAAUN,gBAAgB;IAE3C,MAAMO,oBAAoBF,QACxBP,IAAIQ,MAAM,KAAK,UAAA,CAAUN,eAAAA,OAAAA,KAAAA,IAAAA,YAAaQ,UAAU,CAAC,sBAAA;IAEnD,MAAMC,gBAAgBJ,QACpBN,aAAaW,aACX,OAAOX,aAAa,YACpBD,IAAIQ,MAAM,KAAK;IAGnB,MAAMK,yBAAyBN,QAC7BI,iBAAiBL,sBAAsBG;IAGzC,OAAO;QACLR;QACAK;QACAG;QACAE;QACAE;IACF;AACF;AAEO,SAASC,0BACdd,GAAoD;IAEpD,OAAOD,+BAA+BC,KAAKa,sBAAsB;AACnE","ignoreList":[0]}},
    {"offset": {"line": 1862, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/lib/fallback.ts"],"sourcesContent":["/**\n * Describes the different fallback modes that a given page can have.\n */\nexport const enum FallbackMode {\n  /**\n   * A BLOCKING_STATIC_RENDER fallback will block the request until the page is\n   * generated. No fallback page will be rendered, and users will have to wait\n   * to render the page.\n   */\n  BLOCKING_STATIC_RENDER = 'BLOCKING_STATIC_RENDER',\n\n  /**\n   * When set to PRERENDER, a fallback page will be sent to users in place of\n   * forcing them to wait for the page to be generated. This allows the user to\n   * see a rendered page earlier.\n   */\n  PRERENDER = 'PRERENDER',\n\n  /**\n   * When set to NOT_FOUND, pages that are not already prerendered will result\n   * in a not found response.\n   */\n  NOT_FOUND = 'NOT_FOUND',\n}\n\n/**\n * The fallback value returned from the `getStaticPaths` function.\n */\nexport type GetStaticPathsFallback = boolean | 'blocking'\n\n/**\n * Parses the fallback field from the prerender manifest.\n *\n * @param fallbackField The fallback field from the prerender manifest.\n * @returns The fallback mode.\n */\nexport function parseFallbackField(\n  fallbackField: string | boolean | null | undefined\n): FallbackMode | undefined {\n  if (typeof fallbackField === 'string') {\n    return FallbackMode.PRERENDER\n  } else if (fallbackField === null) {\n    return FallbackMode.BLOCKING_STATIC_RENDER\n  } else if (fallbackField === false) {\n    return FallbackMode.NOT_FOUND\n  } else if (fallbackField === undefined) {\n    return undefined\n  } else {\n    throw new Error(\n      `Invalid fallback option: ${fallbackField}. Fallback option must be a string, null, undefined, or false.`\n    )\n  }\n}\n\nexport function fallbackModeToFallbackField(\n  fallback: FallbackMode,\n  page: string | undefined\n): string | false | null {\n  switch (fallback) {\n    case FallbackMode.BLOCKING_STATIC_RENDER:\n      return null\n    case FallbackMode.NOT_FOUND:\n      return false\n    case FallbackMode.PRERENDER:\n      if (!page) {\n        throw new Error(\n          `Invariant: expected a page to be provided when fallback mode is \"${fallback}\"`\n        )\n      }\n\n      return page\n    default:\n      throw new Error(`Invalid fallback mode: ${fallback}`)\n  }\n}\n\n/**\n * Parses the fallback from the static paths result.\n *\n * @param result The result from the static paths function.\n * @returns The fallback mode.\n */\nexport function parseStaticPathsResult(\n  result: GetStaticPathsFallback\n): FallbackMode {\n  if (result === true) {\n    return FallbackMode.PRERENDER\n  } else if (result === 'blocking') {\n    return FallbackMode.BLOCKING_STATIC_RENDER\n  } else {\n    return FallbackMode.NOT_FOUND\n  }\n}\n"],"names":["FallbackMode","parseFallbackField","fallbackField","undefined","Error","fallbackModeToFallbackField","fallback","page","parseStaticPathsResult","result"],"mappings":"AAAA;;CAEC,GACD;;;;;;;;;;AAAO,IAAWA,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;IAChB;;;;GAIC,GAAA,YAAA,CAAA,yBAAA,GAAA;IAGD;;;;GAIC,GAAA,YAAA,CAAA,YAAA,GAAA;IAGD;;;GAGC,GAAA,YAAA,CAAA,YAAA,GAAA;WAlBeA;MAoBjB;AAaM,SAASC,mBACdC,aAAkD;IAElD,IAAI,OAAOA,kBAAkB,UAAU;QACrC,OAAA;IACF,OAAO,IAAIA,kBAAkB,MAAM;QACjC,OAAA;IACF,OAAO,IAAIA,kBAAkB,OAAO;QAClC,OAAA;IACF,OAAO,IAAIA,kBAAkBC,WAAW;QACtC,OAAOA;IACT,OAAO;QACL,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,yBAAyB,EAAEF,cAAc,8DAA8D,CAAC,GADrG,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;AACF;AAEO,SAASG,4BACdC,QAAsB,EACtBC,IAAwB;IAExB,OAAQD;QACN,KAAA;YACE,OAAO;QACT,KAAA;YACE,OAAO;QACT,KAAA;YACE,IAAI,CAACC,MAAM;gBACT,MAAM,OAAA,cAEL,CAFK,IAAIH,MACR,CAAC,iEAAiE,EAAEE,SAAS,CAAC,CAAC,GAD3E,qBAAA;2BAAA;gCAAA;kCAAA;gBAEN;YACF;YAEA,OAAOC;QACT;YACE,MAAM,OAAA,cAA+C,CAA/C,IAAIH,MAAM,CAAC,uBAAuB,EAAEE,UAAU,GAA9C,qBAAA;uBAAA;4BAAA;8BAAA;YAA8C;IACxD;AACF;AAQO,SAASE,uBACdC,MAA8B;IAE9B,IAAIA,WAAW,MAAM;QACnB,OAAA;IACF,OAAO,IAAIA,WAAW,YAAY;QAChC,OAAA;IACF,OAAO;QACL,OAAA;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1944, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/utils.ts"],"sourcesContent":["import type { HtmlProps } from './html-context.shared-runtime'\nimport type { ComponentType, JSX } from 'react'\nimport type { DomainLocale } from '../../server/config'\nimport type { Env } from '@next/env'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { NextRouter } from './router/router'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { PreviewData } from '../../types'\nimport type { COMPILER_NAMES } from './constants'\nimport type fs from 'fs'\n\nexport type NextComponentType<\n  Context extends BaseContext = NextPageContext,\n  InitialProps = {},\n  Props = {},\n> = ComponentType<Props> & {\n  /**\n   * Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.\n   * Make sure to return plain `Object` without using `Date`, `Map`, `Set`.\n   * @param context Context of `page`\n   */\n  getInitialProps?(context: Context): InitialProps | Promise<InitialProps>\n}\n\nexport type DocumentType = NextComponentType<\n  DocumentContext,\n  DocumentInitialProps,\n  DocumentProps\n>\n\nexport type AppType<P = {}> = NextComponentType<\n  AppContextType,\n  P,\n  AppPropsType<any, P>\n>\n\nexport type AppTreeType = ComponentType<\n  AppInitialProps & { [name: string]: any }\n>\n\n/**\n * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.\n * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting\n */\nexport const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const\nexport type NextWebVitalsMetric = {\n  id: string\n  startTime: number\n  value: number\n  attribution?: { [key: string]: unknown }\n} & (\n  | {\n      label: 'web-vital'\n      name: (typeof WEB_VITALS)[number]\n    }\n  | {\n      label: 'custom'\n      name:\n        | 'Next.js-hydration'\n        | 'Next.js-route-change-to-render'\n        | 'Next.js-render'\n    }\n)\n\nexport type Enhancer<C> = (Component: C) => C\n\nexport type ComponentsEnhancer =\n  | {\n      enhanceApp?: Enhancer<AppType>\n      enhanceComponent?: Enhancer<NextComponentType>\n    }\n  | Enhancer<NextComponentType>\n\nexport type RenderPageResult = {\n  html: string\n  head?: Array<JSX.Element | null>\n}\n\nexport type RenderPage = (\n  options?: ComponentsEnhancer\n) => DocumentInitialProps | Promise<DocumentInitialProps>\n\nexport type BaseContext = {\n  res?: ServerResponse\n  [k: string]: any\n}\n\nexport type NEXT_DATA = {\n  props: Record<string, any>\n  page: string\n  query: ParsedUrlQuery\n  buildId: string\n  assetPrefix?: string\n  nextExport?: boolean\n  autoExport?: boolean\n  isFallback?: boolean\n  isExperimentalCompile?: boolean\n  dynamicIds?: (string | number)[]\n  err?: Error & {\n    statusCode?: number\n    source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer\n  }\n  gsp?: boolean\n  gssp?: boolean\n  customServer?: boolean\n  gip?: boolean\n  appGip?: boolean\n  locale?: string\n  locales?: readonly string[]\n  defaultLocale?: string\n  domainLocales?: readonly DomainLocale[]\n  scriptLoader?: any[]\n  isPreview?: boolean\n  notFoundSrcPage?: string\n}\n\n/**\n * `Next` context\n */\nexport interface NextPageContext {\n  /**\n   * Error object if encountered during rendering\n   */\n  err?: (Error & { statusCode?: number }) | null\n  /**\n   * `HTTP` request object.\n   */\n  req?: IncomingMessage\n  /**\n   * `HTTP` response object.\n   */\n  res?: ServerResponse\n  /**\n   * Path section of `URL`.\n   */\n  pathname: string\n  /**\n   * Query string section of `URL` parsed as an object.\n   */\n  query: ParsedUrlQuery\n  /**\n   * `String` of the actual path including query.\n   */\n  asPath?: string\n  /**\n   * The currently active locale\n   */\n  locale?: string\n  /**\n   * All configured locales\n   */\n  locales?: readonly string[]\n  /**\n   * The configured default locale\n   */\n  defaultLocale?: string\n  /**\n   * `Component` the tree of the App to use if needing to render separately\n   */\n  AppTree: AppTreeType\n}\n\nexport type AppContextType<Router extends NextRouter = NextRouter> = {\n  Component: NextComponentType<NextPageContext>\n  AppTree: AppTreeType\n  ctx: NextPageContext\n  router: Router\n}\n\nexport type AppInitialProps<PageProps = any> = {\n  pageProps: PageProps\n}\n\nexport type AppPropsType<\n  Router extends NextRouter = NextRouter,\n  PageProps = {},\n> = AppInitialProps<PageProps> & {\n  Component: NextComponentType<NextPageContext, any, any>\n  router: Router\n  __N_SSG?: boolean\n  __N_SSP?: boolean\n}\n\nexport type DocumentContext = NextPageContext & {\n  renderPage: RenderPage\n  defaultGetInitialProps(\n    ctx: DocumentContext,\n    options?: { nonce?: string }\n  ): Promise<DocumentInitialProps>\n}\n\nexport type DocumentInitialProps = RenderPageResult & {\n  styles?: React.ReactElement[] | Iterable<React.ReactNode> | JSX.Element\n}\n\nexport type DocumentProps = DocumentInitialProps & HtmlProps\n\n/**\n * Next `API` route request\n */\nexport interface NextApiRequest extends IncomingMessage {\n  /**\n   * Object of `query` values from url\n   */\n  query: Partial<{\n    [key: string]: string | string[]\n  }>\n  /**\n   * Object of `cookies` from header\n   */\n  cookies: Partial<{\n    [key: string]: string\n  }>\n\n  body: any\n\n  env: Env\n\n  draftMode?: boolean\n\n  preview?: boolean\n  /**\n   * Preview data set on the request, if any\n   * */\n  previewData?: PreviewData\n}\n\n/**\n * Send body of response\n */\ntype Send<T> = (body: T) => void\n\n/**\n * Next `API` route response\n */\nexport type NextApiResponse<Data = any> = ServerResponse & {\n  /**\n   * Send data `any` data in response\n   */\n  send: Send<Data>\n  /**\n   * Send data `json` data in response\n   */\n  json: Send<Data>\n  status: (statusCode: number) => NextApiResponse<Data>\n  redirect(url: string): NextApiResponse<Data>\n  redirect(status: number, url: string): NextApiResponse<Data>\n\n  /**\n   * Set draft mode\n   */\n  setDraftMode: (options: { enable: boolean }) => NextApiResponse<Data>\n\n  /**\n   * Set preview data for Next.js' prerender mode\n   */\n  setPreviewData: (\n    data: object | string,\n    options?: {\n      /**\n       * Specifies the number (in seconds) for the preview session to last for.\n       * The given number will be converted to an integer by rounding down.\n       * By default, no maximum age is set and the preview session finishes\n       * when the client shuts down (browser is closed).\n       */\n      maxAge?: number\n      /**\n       * Specifies the path for the preview session to work under. By default,\n       * the path is considered the \"default path\", i.e., any pages under \"/\".\n       */\n      path?: string\n    }\n  ) => NextApiResponse<Data>\n\n  /**\n   * Clear preview data for Next.js' prerender mode\n   */\n  clearPreviewData: (options?: { path?: string }) => NextApiResponse<Data>\n\n  /**\n   * Revalidate a specific page and regenerate it using On-Demand Incremental\n   * Static Regeneration.\n   * The path should be an actual path, not a rewritten path. E.g. for\n   * \"/blog/[slug]\" this should be \"/blog/post-1\".\n   * @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath\n   */\n  revalidate: (\n    urlPath: string,\n    opts?: {\n      unstable_onlyGenerated?: boolean\n    }\n  ) => Promise<void>\n}\n\n/**\n * Next `API` route handler\n */\nexport type NextApiHandler<T = any> = (\n  req: NextApiRequest,\n  res: NextApiResponse<T>\n) => unknown | Promise<unknown>\n\n/**\n * Utils\n */\nexport function execOnce<T extends (...args: any[]) => ReturnType<T>>(\n  fn: T\n): T {\n  let used = false\n  let result: ReturnType<T>\n\n  return ((...args: any[]) => {\n    if (!used) {\n      used = true\n      result = fn(...args)\n    }\n    return result\n  }) as T\n}\n\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/\nexport const isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url)\n\nexport function getLocationOrigin() {\n  const { protocol, hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? ':' + port : ''}`\n}\n\nexport function getURL() {\n  const { href } = window.location\n  const origin = getLocationOrigin()\n  return href.substring(origin.length)\n}\n\nexport function getDisplayName<P>(Component: ComponentType<P>) {\n  return typeof Component === 'string'\n    ? Component\n    : Component.displayName || Component.name || 'Unknown'\n}\n\nexport function isResSent(res: ServerResponse) {\n  return res.finished || res.headersSent\n}\n\nexport function normalizeRepeatedSlashes(url: string) {\n  const urlParts = url.split('?')\n  const urlNoQuery = urlParts[0]\n\n  return (\n    urlNoQuery\n      // first we replace any non-encoded backslashes with forward\n      // then normalize repeated forward slashes\n      .replace(/\\\\/g, '/')\n      .replace(/\\/\\/+/g, '/') +\n    (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')\n  )\n}\n\nexport async function loadGetInitialProps<\n  C extends BaseContext,\n  IP = {},\n  P = {},\n>(App: NextComponentType<C, IP, P>, ctx: C): Promise<IP> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (App.prototype?.getInitialProps) {\n      const message = `\"${getDisplayName(\n        App\n      )}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`\n      throw new Error(message)\n    }\n  }\n  // when called from _app `ctx` is nested in `ctx`\n  const res = ctx.res || (ctx.ctx && ctx.ctx.res)\n\n  if (!App.getInitialProps) {\n    if (ctx.ctx && ctx.Component) {\n      // @ts-ignore pageProps default\n      return {\n        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),\n      }\n    }\n    return {} as IP\n  }\n\n  const props = await App.getInitialProps(ctx)\n\n  if (res && isResSent(res)) {\n    return props\n  }\n\n  if (!props) {\n    const message = `\"${getDisplayName(\n      App\n    )}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`\n    throw new Error(message)\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (Object.keys(props).length === 0 && !ctx.ctx) {\n      console.warn(\n        `${getDisplayName(\n          App\n        )} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`\n      )\n    }\n  }\n\n  return props\n}\n\nexport const SP = typeof performance !== 'undefined'\nexport const ST =\n  SP &&\n  (['mark', 'measure', 'getEntriesByName'] as const).every(\n    (method) => typeof performance[method] === 'function'\n  )\n\nexport class DecodeError extends Error {}\nexport class NormalizeError extends Error {}\nexport class PageNotFoundError extends Error {\n  code: string\n\n  constructor(page: string) {\n    super()\n    this.code = 'ENOENT'\n    this.name = 'PageNotFoundError'\n    this.message = `Cannot find module for page: ${page}`\n  }\n}\n\nexport class MissingStaticPage extends Error {\n  constructor(page: string, message: string) {\n    super()\n    this.message = `Failed to load static file for page: ${page} ${message}`\n  }\n}\n\nexport class MiddlewareNotFoundError extends Error {\n  code: string\n  constructor() {\n    super()\n    this.code = 'ENOENT'\n    this.message = `Cannot find the middleware module`\n  }\n}\n\nexport interface CacheFs {\n  existsSync: typeof fs.existsSync\n  readFile: typeof fs.promises.readFile\n  readFileSync: typeof fs.readFileSync\n  writeFile(f: string, d: any): Promise<void>\n  mkdir(dir: string): Promise<void | string>\n  stat(f: string): Promise<{ mtime: Date }>\n}\n\nexport function stringifyError(error: Error) {\n  return JSON.stringify({ message: error.message, stack: error.stack })\n}\n"],"names":["WEB_VITALS","execOnce","fn","used","result","args","ABSOLUTE_URL_REGEX","isAbsoluteUrl","url","test","getLocationOrigin","protocol","hostname","port","window","location","getURL","href","origin","substring","length","getDisplayName","Component","displayName","name","isResSent","res","finished","headersSent","normalizeRepeatedSlashes","urlParts","split","urlNoQuery","replace","slice","join","loadGetInitialProps","App","ctx","process","env","NODE_ENV","prototype","getInitialProps","message","Error","pageProps","props","Object","keys","console","warn","SP","performance","ST","every","method","DecodeError","NormalizeError","PageNotFoundError","constructor","page","code","MissingStaticPage","MiddlewareNotFoundError","stringifyError","error","JSON","stringify","stack"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2110, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/lib/etag.ts"],"sourcesContent":["/**\n * FNV-1a Hash implementation\n * @author Travis Webb (tjwebb) <me@traviswebb.com>\n *\n * Ported from https://github.com/tjwebb/fnv-plus/blob/master/index.js\n *\n * Simplified, optimized and add modified for 52 bit, which provides a larger hash space\n * and still making use of Javascript's 53-bit integer space.\n */\nexport const fnv1a52 = (str: string) => {\n  const len = str.length\n  let i = 0,\n    t0 = 0,\n    v0 = 0x2325,\n    t1 = 0,\n    v1 = 0x8422,\n    t2 = 0,\n    v2 = 0x9ce4,\n    t3 = 0,\n    v3 = 0xcbf2\n\n  while (i < len) {\n    v0 ^= str.charCodeAt(i++)\n    t0 = v0 * 435\n    t1 = v1 * 435\n    t2 = v2 * 435\n    t3 = v3 * 435\n    t2 += v0 << 8\n    t3 += v1 << 8\n    t1 += t0 >>> 16\n    v0 = t0 & 65535\n    t2 += t1 >>> 16\n    v1 = t1 & 65535\n    v3 = (t3 + (t2 >>> 16)) & 65535\n    v2 = t2 & 65535\n  }\n\n  return (\n    (v3 & 15) * 281474976710656 +\n    v2 * 4294967296 +\n    v1 * 65536 +\n    (v0 ^ (v3 >> 4))\n  )\n}\n\nexport const generateETag = (payload: string, weak = false) => {\n  const prefix = weak ? 'W/\"' : '\"'\n  return (\n    prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '\"'\n  )\n}\n"],"names":["fnv1a52","str","len","length","i","t0","v0","t1","v1","t2","v2","t3","v3","charCodeAt","generateETag","payload","weak","prefix","toString"],"mappings":"AAAA;;;;;;;;CAQC,GACD;;;;;;AAAO,MAAMA,UAAU,CAACC;IACtB,MAAMC,MAAMD,IAAIE,MAAM;IACtB,IAAIC,IAAI,GACNC,KAAK,GACLC,KAAK,QACLC,KAAK,GACLC,KAAK,QACLC,KAAK,GACLC,KAAK,QACLC,KAAK,GACLC,KAAK;IAEP,MAAOR,IAAIF,IAAK;QACdI,MAAML,IAAIY,UAAU,CAACT;QACrBC,KAAKC,KAAK;QACVC,KAAKC,KAAK;QACVC,KAAKC,KAAK;QACVC,KAAKC,KAAK;QACVH,MAAMH,MAAM;QACZK,MAAMH,MAAM;QACZD,MAAMF,OAAO;QACbC,KAAKD,KAAK;QACVI,MAAMF,OAAO;QACbC,KAAKD,KAAK;QACVK,KAAMD,KAAMF,CAAAA,OAAO,EAAC,IAAM;QAC1BC,KAAKD,KAAK;IACZ;IAEA,OACGG,CAAAA,KAAK,EAAC,IAAK,kBACZF,KAAK,aACLF,KAAK,QACJF,CAAAA,KAAMM,MAAM,CAAC;AAElB,EAAC;AAEM,MAAME,eAAe,CAACC,SAAiBC,OAAO,KAAK;IACxD,MAAMC,SAASD,OAAO,QAAQ;IAC9B,OACEC,SAASjB,QAAQe,SAASG,QAAQ,CAAC,MAAMH,QAAQZ,MAAM,CAACe,QAAQ,CAAC,MAAM;AAE3E,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2151, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/dist/compiled/fresh/index.js"],"sourcesContent":["(()=>{\"use strict\";var e={695:e=>{\n/*!\n * fresh\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\nvar r=/(?:^|,)\\s*?no-cache\\s*?(?:,|$)/;e.exports=fresh;function fresh(e,a){var t=e[\"if-modified-since\"];var s=e[\"if-none-match\"];if(!t&&!s){return false}var i=e[\"cache-control\"];if(i&&r.test(i)){return false}if(s&&s!==\"*\"){var f=a[\"etag\"];if(!f){return false}var n=true;var u=parseTokenList(s);for(var _=0;_<u.length;_++){var o=u[_];if(o===f||o===\"W/\"+f||\"W/\"+o===f){n=false;break}}if(n){return false}}if(t){var p=a[\"last-modified\"];var v=!p||!(parseHttpDate(p)<=parseHttpDate(t));if(v){return false}}return true}function parseHttpDate(e){var r=e&&Date.parse(e);return typeof r===\"number\"?r:NaN}function parseTokenList(e){var r=0;var a=[];var t=0;for(var s=0,i=e.length;s<i;s++){switch(e.charCodeAt(s)){case 32:if(t===r){t=r=s+1}break;case 44:a.push(e.substring(t,r));t=r=s+1;break;default:r=s+1;break}}a.push(e.substring(t,r));return a}}};var r={};function __nccwpck_require__(a){var t=r[a];if(t!==undefined){return t.exports}var s=r[a]={exports:{}};var i=true;try{e[a](s,s.exports,__nccwpck_require__);i=false}finally{if(i)delete r[a]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var a=__nccwpck_require__(695);module.exports=a})();"],"names":[],"mappings":"AAAA,CAAC;IAAK;IAAa,IAAI,IAAE;QAAC,KAAI,CAAA;YAC9B;;;;;CAKC,GACD,IAAI,IAAE;YAAiC,EAAE,OAAO,GAAC;YAAM,SAAS,MAAM,CAAC,EAAC,CAAC;gBAAE,IAAI,IAAE,CAAC,CAAC,oBAAoB;gBAAC,IAAI,IAAE,CAAC,CAAC,gBAAgB;gBAAC,IAAG,CAAC,KAAG,CAAC,GAAE;oBAAC,OAAO;gBAAK;gBAAC,IAAI,IAAE,CAAC,CAAC,gBAAgB;gBAAC,IAAG,KAAG,EAAE,IAAI,CAAC,IAAG;oBAAC,OAAO;gBAAK;gBAAC,IAAG,KAAG,MAAI,KAAI;oBAAC,IAAI,IAAE,CAAC,CAAC,OAAO;oBAAC,IAAG,CAAC,GAAE;wBAAC,OAAO;oBAAK;oBAAC,IAAI,IAAE;oBAAK,IAAI,IAAE,eAAe;oBAAG,IAAI,IAAI,IAAE,GAAE,IAAE,EAAE,MAAM,EAAC,IAAI;wBAAC,IAAI,IAAE,CAAC,CAAC,EAAE;wBAAC,IAAG,MAAI,KAAG,MAAI,OAAK,KAAG,OAAK,MAAI,GAAE;4BAAC,IAAE;4BAAM;wBAAK;oBAAC;oBAAC,IAAG,GAAE;wBAAC,OAAO;oBAAK;gBAAC;gBAAC,IAAG,GAAE;oBAAC,IAAI,IAAE,CAAC,CAAC,gBAAgB;oBAAC,IAAI,IAAE,CAAC,KAAG,CAAC,CAAC,cAAc,MAAI,cAAc,EAAE;oBAAE,IAAG,GAAE;wBAAC,OAAO;oBAAK;gBAAC;gBAAC,OAAO;YAAI;YAAC,SAAS,cAAc,CAAC;gBAAE,IAAI,IAAE,KAAG,KAAK,KAAK,CAAC;gBAAG,OAAO,OAAO,MAAI,WAAS,IAAE;YAAG;YAAC,SAAS,eAAe,CAAC;gBAAE,IAAI,IAAE;gBAAE,IAAI,IAAE,EAAE;gBAAC,IAAI,IAAE;gBAAE,IAAI,IAAI,IAAE,GAAE,IAAE,EAAE,MAAM,EAAC,IAAE,GAAE,IAAI;oBAAC,OAAO,EAAE,UAAU,CAAC;wBAAI,KAAK;4BAAG,IAAG,MAAI,GAAE;gCAAC,IAAE,IAAE,IAAE;4BAAC;4BAAC;wBAAM,KAAK;4BAAG,EAAE,IAAI,CAAC,EAAE,SAAS,CAAC,GAAE;4BAAI,IAAE,IAAE,IAAE;4BAAE;wBAAM;4BAAQ,IAAE,IAAE;4BAAE;oBAAK;gBAAC;gBAAC,EAAE,IAAI,CAAC,EAAE,SAAS,CAAC,GAAE;gBAAI,OAAO;YAAC;QAAC;IAAC;IAAE,IAAI,IAAE,CAAC;IAAE,SAAS,oBAAoB,CAAC;QAAE,IAAI,IAAE,CAAC,CAAC,EAAE;QAAC,IAAG,MAAI,WAAU;YAAC,OAAO,EAAE,OAAO;QAAA;QAAC,IAAI,IAAE,CAAC,CAAC,EAAE,GAAC;YAAC,SAAQ,CAAC;QAAC;QAAE,IAAI,IAAE;QAAK,IAAG;YAAC,CAAC,CAAC,EAAE,CAAC,GAAE,EAAE,OAAO,EAAC;YAAqB,IAAE;QAAK,SAAQ;YAAC,IAAG,GAAE,OAAO,CAAC,CAAC,EAAE;QAAA;QAAC,OAAO,EAAE,OAAO;IAAA;IAAC,IAAG,OAAO,wBAAsB,aAAY,oBAAoB,EAAE,GAAC,kFAAU;IAAI,IAAI,IAAE,oBAAoB;IAAK,OAAO,OAAO,GAAC;AAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2254, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/lib/cache-control.ts"],"sourcesContent":["import { CACHE_ONE_YEAR } from '../../lib/constants'\n\n/**\n * The revalidate option used internally for pages. A value of `false` means\n * that the page should not be revalidated. A number means that the page\n * should be revalidated after the given number of seconds (this also includes\n * `1` which means to revalidate after 1 second). A value of `0` is not a valid\n * value for this option.\n */\nexport type Revalidate = number | false\n\nexport interface CacheControl {\n  revalidate: Revalidate\n  expire: number | undefined\n}\n\nexport function getCacheControlHeader({\n  revalidate,\n  expire,\n}: CacheControl): string {\n  const swrHeader =\n    typeof revalidate === 'number' &&\n    expire !== undefined &&\n    revalidate < expire\n      ? `, stale-while-revalidate=${expire - revalidate}`\n      : ''\n\n  if (revalidate === 0) {\n    return 'private, no-cache, no-store, max-age=0, must-revalidate'\n  } else if (typeof revalidate === 'number') {\n    return `s-maxage=${revalidate}${swrHeader}`\n  }\n\n  return `s-maxage=${CACHE_ONE_YEAR}${swrHeader}`\n}\n"],"names":["CACHE_ONE_YEAR","getCacheControlHeader","revalidate","expire","swrHeader","undefined"],"mappings":";;;;AAAA,SAASA,cAAc,QAAQ,sBAAqB;;AAgB7C,SAASC,sBAAsB,EACpCC,UAAU,EACVC,MAAM,EACO;IACb,MAAMC,YACJ,OAAOF,eAAe,YACtBC,WAAWE,aACXH,aAAaC,SACT,CAAC,yBAAyB,EAAEA,SAASD,YAAY,GACjD;IAEN,IAAIA,eAAe,GAAG;QACpB,OAAO;IACT,OAAO,IAAI,OAAOA,eAAe,UAAU;QACzC,OAAO,CAAC,SAAS,EAAEA,aAAaE,WAAW;IAC7C;IAEA,OAAO,CAAC,SAAS,EAAEJ,yKAAAA,GAAiBI,WAAW;AACjD","ignoreList":[0]}},
    {"offset": {"line": 2273, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/send-payload.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from 'http'\nimport type RenderResult from './render-result'\nimport type { CacheControl } from './lib/cache-control'\n\nimport { isResSent } from '../shared/lib/utils'\nimport { generateETag } from './lib/etag'\nimport fresh from 'next/dist/compiled/fresh'\nimport { getCacheControlHeader } from './lib/cache-control'\nimport { HTML_CONTENT_TYPE_HEADER } from '../lib/constants'\n\nexport function sendEtagResponse(\n  req: IncomingMessage,\n  res: ServerResponse,\n  etag: string | undefined\n): boolean {\n  if (etag) {\n    /**\n     * The server generating a 304 response MUST generate any of the\n     * following header fields that would have been sent in a 200 (OK)\n     * response to the same request: Cache-Control, Content-Location, Date,\n     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1\n     */\n    res.setHeader('ETag', etag)\n  }\n\n  if (fresh(req.headers, { etag })) {\n    res.statusCode = 304\n    res.end()\n    return true\n  }\n\n  return false\n}\n\nexport async function sendRenderResult({\n  req,\n  res,\n  result,\n  generateEtags,\n  poweredByHeader,\n  cacheControl,\n}: {\n  req: IncomingMessage\n  res: ServerResponse\n  result: RenderResult\n  generateEtags: boolean\n  poweredByHeader: boolean\n  cacheControl: CacheControl | undefined\n}): Promise<void> {\n  if (isResSent(res)) {\n    return\n  }\n\n  if (poweredByHeader && result.contentType === HTML_CONTENT_TYPE_HEADER) {\n    res.setHeader('X-Powered-By', 'Next.js')\n  }\n\n  // If cache control is already set on the response we don't\n  // override it to allow users to customize it via next.config\n  if (cacheControl && !res.getHeader('Cache-Control')) {\n    res.setHeader('Cache-Control', getCacheControlHeader(cacheControl))\n  }\n\n  const payload = result.isDynamic ? null : result.toUnchunkedString()\n\n  if (generateEtags && payload !== null) {\n    const etag = generateETag(payload)\n    if (sendEtagResponse(req, res, etag)) {\n      return\n    }\n  }\n\n  if (!res.getHeader('Content-Type') && result.contentType) {\n    res.setHeader('Content-Type', result.contentType)\n  }\n\n  if (payload) {\n    res.setHeader('Content-Length', Buffer.byteLength(payload))\n  }\n\n  if (req.method === 'HEAD') {\n    res.end(null)\n    return\n  }\n\n  if (payload !== null) {\n    res.end(payload)\n    return\n  }\n\n  // Pipe the render result to the response after we get a writer for it.\n  await result.pipeToNodeResponse(res)\n}\n"],"names":["isResSent","generateETag","fresh","getCacheControlHeader","HTML_CONTENT_TYPE_HEADER","sendEtagResponse","req","res","etag","setHeader","headers","statusCode","end","sendRenderResult","result","generateEtags","poweredByHeader","cacheControl","contentType","getHeader","payload","isDynamic","toUnchunkedString","Buffer","byteLength","method","pipeToNodeResponse"],"mappings":";;;;;;AAIA,SAASA,SAAS,QAAQ,sBAAqB;AAC/C,SAASC,YAAY,QAAQ,aAAY;AACzC,OAAOC,WAAW,2BAA0B;AAC5C,SAASC,qBAAqB,QAAQ,sBAAqB;AAC3D,SAASC,wBAAwB,QAAQ,mBAAkB;;;;;;AAEpD,SAASC,iBACdC,GAAoB,EACpBC,GAAmB,EACnBC,IAAwB;IAExB,IAAIA,MAAM;QACR;;;;;KAKC,GACDD,IAAIE,SAAS,CAAC,QAAQD;IACxB;IAEA,QAAIN,qKAAAA,EAAMI,IAAII,OAAO,EAAE;QAAEF;IAAK,IAAI;QAChCD,IAAII,UAAU,GAAG;QACjBJ,IAAIK,GAAG;QACP,OAAO;IACT;IAEA,OAAO;AACT;AAEO,eAAeC,iBAAiB,EACrCP,GAAG,EACHC,GAAG,EACHO,MAAM,EACNC,aAAa,EACbC,eAAe,EACfC,YAAY,EAQb;IACC,QAAIjB,0KAAAA,EAAUO,MAAM;QAClB;IACF;IAEA,IAAIS,mBAAmBF,OAAOI,WAAW,KAAKd,mLAAAA,EAA0B;QACtEG,IAAIE,SAAS,CAAC,gBAAgB;IAChC;IAEA,2DAA2D;IAC3D,6DAA6D;IAC7D,IAAIQ,gBAAgB,CAACV,IAAIY,SAAS,CAAC,kBAAkB;QACnDZ,IAAIE,SAAS,CAAC,qBAAiBN,iMAAAA,EAAsBc;IACvD;IAEA,MAAMG,UAAUN,OAAOO,SAAS,GAAG,OAAOP,OAAOQ,iBAAiB;IAElE,IAAIP,iBAAiBK,YAAY,MAAM;QACrC,MAAMZ,WAAOP,4KAAAA,EAAamB;QAC1B,IAAIf,iBAAiBC,KAAKC,KAAKC,OAAO;YACpC;QACF;IACF;IAEA,IAAI,CAACD,IAAIY,SAAS,CAAC,mBAAmBL,OAAOI,WAAW,EAAE;QACxDX,IAAIE,SAAS,CAAC,gBAAgBK,OAAOI,WAAW;IAClD;IAEA,IAAIE,SAAS;QACXb,IAAIE,SAAS,CAAC,kBAAkBc,OAAOC,UAAU,CAACJ;IACpD;IAEA,IAAId,IAAImB,MAAM,KAAK,QAAQ;QACzBlB,IAAIK,GAAG,CAAC;QACR;IACF;IAEA,IAAIQ,YAAY,MAAM;QACpBb,IAAIK,GAAG,CAACQ;QACR;IACF;IAEA,uEAAuE;IACvE,MAAMN,OAAOY,kBAAkB,CAACnB;AAClC","ignoreList":[0]}},
    {"offset": {"line": 2346, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/dist/compiled/bytes/index.js"],"sourcesContent":["(()=>{\"use strict\";var e={56:e=>{\n/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\ne.exports=bytes;e.exports.format=format;e.exports.parse=parse;var r=/\\B(?=(\\d{3})+(?!\\d))/g;var a=/(?:\\.0*|(\\.[^0]+)0+)$/;var t={b:1,kb:1<<10,mb:1<<20,gb:1<<30,tb:Math.pow(1024,4),pb:Math.pow(1024,5)};var i=/^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;function bytes(e,r){if(typeof e===\"string\"){return parse(e)}if(typeof e===\"number\"){return format(e,r)}return null}function format(e,i){if(!Number.isFinite(e)){return null}var n=Math.abs(e);var o=i&&i.thousandsSeparator||\"\";var s=i&&i.unitSeparator||\"\";var f=i&&i.decimalPlaces!==undefined?i.decimalPlaces:2;var u=Boolean(i&&i.fixedDecimals);var p=i&&i.unit||\"\";if(!p||!t[p.toLowerCase()]){if(n>=t.pb){p=\"PB\"}else if(n>=t.tb){p=\"TB\"}else if(n>=t.gb){p=\"GB\"}else if(n>=t.mb){p=\"MB\"}else if(n>=t.kb){p=\"KB\"}else{p=\"B\"}}var b=e/t[p.toLowerCase()];var l=b.toFixed(f);if(!u){l=l.replace(a,\"$1\")}if(o){l=l.split(\".\").map((function(e,a){return a===0?e.replace(r,o):e})).join(\".\")}return l+s+p}function parse(e){if(typeof e===\"number\"&&!isNaN(e)){return e}if(typeof e!==\"string\"){return null}var r=i.exec(e);var a;var n=\"b\";if(!r){a=parseInt(e,10);n=\"b\"}else{a=parseFloat(r[1]);n=r[4].toLowerCase()}return Math.floor(t[n]*a)}}};var r={};function __nccwpck_require__(a){var t=r[a];if(t!==undefined){return t.exports}var i=r[a]={exports:{}};var n=true;try{e[a](i,i.exports,__nccwpck_require__);n=false}finally{if(n)delete r[a]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var a=__nccwpck_require__(56);module.exports=a})();"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2462, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/size-limit.ts"],"sourcesContent":["import type { SizeLimit } from '../../types'\n\nexport const DEFAULT_MAX_POSTPONED_STATE_SIZE: SizeLimit = '100 MB'\n\nfunction parseSizeLimit(size: SizeLimit): number | undefined {\n  const bytes = (\n    require('next/dist/compiled/bytes') as typeof import('next/dist/compiled/bytes')\n  ).parse(size)\n  if (bytes === null || isNaN(bytes) || bytes < 1) {\n    return undefined\n  }\n  return bytes\n}\n\n/**\n * Parses the maxPostponedStateSize config value, using the default if not provided.\n */\nexport function parseMaxPostponedStateSize(\n  size: SizeLimit | undefined\n): number | undefined {\n  return parseSizeLimit(size ?? DEFAULT_MAX_POSTPONED_STATE_SIZE)\n}\n"],"names":["DEFAULT_MAX_POSTPONED_STATE_SIZE","parseSizeLimit","size","bytes","require","parse","isNaN","undefined","parseMaxPostponedStateSize"],"mappings":";;;;;;AAEO,MAAMA,mCAA8C,SAAQ;AAEnE,SAASC,eAAeC,IAAe;IACrC,MAAMC,QACJC,QAAQ,mGACRC,KAAK,CAACH;IACR,IAAIC,UAAU,QAAQG,MAAMH,UAAUA,QAAQ,GAAG;QAC/C,OAAOI;IACT;IACA,OAAOJ;AACT;AAKO,SAASK,2BACdN,IAA2B;IAE3B,OAAOD,eAAeC,QAAQF;AAChC","ignoreList":[0]}},
    {"offset": {"line": 2504, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/kind-of/index.js"],"sourcesContent":["var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2628, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/is-extendable/index.js"],"sourcesContent":["/*!\n * is-extendable <https://github.com/jonschlinkert/is-extendable>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isExtendable(val) {\n  return typeof val !== 'undefined' && val !== null\n    && (typeof val === 'object' || typeof val === 'function');\n};\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAID,OAAO,OAAO,GAAG,SAAS,aAAa,GAAG;IACxC,OAAO,OAAO,QAAQ,eAAe,QAAQ,QACxC,CAAC,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU;AAC5D","ignoreList":[0]}},
    {"offset": {"line": 2640, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/extend-shallow/index.js"],"sourcesContent":["'use strict';\n\nvar isObject = require('is-extendable');\n\nmodule.exports = function extend(o/*, objects*/) {\n  if (!isObject(o)) { o = {}; }\n\n  var len = arguments.length;\n  for (var i = 1; i < len; i++) {\n    var obj = arguments[i];\n\n    if (isObject(obj)) {\n      assign(o, obj);\n    }\n  }\n  return o;\n};\n\nfunction assign(a, b) {\n  for (var key in b) {\n    if (hasOwn(b, key)) {\n      a[key] = b[key];\n    }\n  }\n}\n\n/**\n * Returns true if the given `key` is an own property of `obj`.\n */\n\nfunction hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,OAAO,OAAO,GAAG,SAAS,OAAO,EAAC,WAAW,GAAX;IAChC,IAAI,CAAC,SAAS,IAAI;QAAE,IAAI,CAAC;IAAG;IAE5B,IAAI,MAAM,UAAU,MAAM;IAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;QAC5B,IAAI,MAAM,SAAS,CAAC,EAAE;QAEtB,IAAI,SAAS,MAAM;YACjB,OAAO,GAAG;QACZ;IACF;IACA,OAAO;AACT;AAEA,SAAS,OAAO,CAAC,EAAE,CAAC;IAClB,IAAK,IAAI,OAAO,EAAG;QACjB,IAAI,OAAO,GAAG,MAAM;YAClB,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI;QACjB;IACF;AACF;AAEA;;CAEC,GAED,SAAS,OAAO,GAAG,EAAE,GAAG;IACtB,OAAO,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK;AACnD","ignoreList":[0]}},
    {"offset": {"line": 2670, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/section-matter/index.js"],"sourcesContent":["'use strict';\n\nvar typeOf = require('kind-of');\nvar extend = require('extend-shallow');\n\n/**\n * Parse sections in `input` with the given `options`.\n *\n * ```js\n * var sections = require('{%= name %}');\n * var result = sections(input, options);\n * // { content: 'Content before sections', sections: [] }\n * ```\n * @param {String|Buffer|Object} `input` If input is an object, it's `content` property must be a string or buffer.\n * @param {Object} options\n * @return {Object} Returns an object with a `content` string and an array of `sections` objects.\n * @api public\n */\n\nmodule.exports = function(input, options) {\n  if (typeof options === 'function') {\n    options = { parse: options };\n  }\n\n  var file = toObject(input);\n  var defaults = {section_delimiter: '---', parse: identity};\n  var opts = extend({}, defaults, options);\n  var delim = opts.section_delimiter;\n  var lines = file.content.split(/\\r?\\n/);\n  var sections = null;\n  var section = createSection();\n  var content = [];\n  var stack = [];\n\n  function initSections(val) {\n    file.content = val;\n    sections = [];\n    content = [];\n  }\n\n  function closeSection(val) {\n    if (stack.length) {\n      section.key = getKey(stack[0], delim);\n      section.content = val;\n      opts.parse(section, sections);\n      sections.push(section);\n      section = createSection();\n      content = [];\n      stack = [];\n    }\n  }\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var len = stack.length;\n    var ln = line.trim();\n\n    if (isDelimiter(ln, delim)) {\n      if (ln.length === 3 && i !== 0) {\n        if (len === 0 || len === 2) {\n          content.push(line);\n          continue;\n        }\n        stack.push(ln);\n        section.data = content.join('\\n');\n        content = [];\n        continue;\n      }\n\n      if (sections === null) {\n        initSections(content.join('\\n'));\n      }\n\n      if (len === 2) {\n        closeSection(content.join('\\n'));\n      }\n\n      stack.push(ln);\n      continue;\n    }\n\n    content.push(line);\n  }\n\n  if (sections === null) {\n    initSections(content.join('\\n'));\n  } else {\n    closeSection(content.join('\\n'));\n  }\n\n  file.sections = sections;\n  return file;\n};\n\nfunction isDelimiter(line, delim) {\n  if (line.slice(0, delim.length) !== delim) {\n    return false;\n  }\n  if (line.charAt(delim.length + 1) === delim.slice(-1)) {\n    return false;\n  }\n  return true;\n}\n\nfunction toObject(input) {\n  if (typeOf(input) !== 'object') {\n    input = { content: input };\n  }\n\n  if (typeof input.content !== 'string' && !isBuffer(input.content)) {\n    throw new TypeError('expected a buffer or string');\n  }\n\n  input.content = input.content.toString();\n  input.sections = [];\n  return input;\n}\n\nfunction getKey(val, delim) {\n  return val ? val.slice(delim.length).trim() : '';\n}\n\nfunction createSection() {\n  return { key: '', data: '', content: '' };\n}\n\nfunction identity(val) {\n  return val;\n}\n\nfunction isBuffer(val) {\n  if (val && val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2797, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/exception.js"],"sourcesContent":["// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result = this.name + ': ';\n\n  result += this.reason || '(unknown reason)';\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\n\nmodule.exports = YAMLException;\n"],"names":[],"mappings":"AAAA,+DAA+D;AAC/D,EAAE;AAGF,SAAS,cAAc,MAAM,EAAE,IAAI;IACjC,oBAAoB;IACpB,MAAM,IAAI,CAAC,IAAI;IAEf,IAAI,CAAC,IAAI,GAAG;IACZ,IAAI,CAAC,MAAM,GAAG;IACd,IAAI,CAAC,IAAI,GAAG;IACZ,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,CAAC,MAAM,IAAI,kBAAkB,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,EAAE;IAEjG,sCAAsC;IACtC,IAAI,MAAM,iBAAiB,EAAE;QAC3B,oBAAoB;QACpB,MAAM,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW;IAChD,OAAO;QACL,gDAAgD;QAChD,IAAI,CAAC,KAAK,GAAG,AAAC,IAAI,QAAS,KAAK,IAAI;IACtC;AACF;AAGA,qBAAqB;AACrB,cAAc,SAAS,GAAG,OAAO,MAAM,CAAC,MAAM,SAAS;AACvD,cAAc,SAAS,CAAC,WAAW,GAAG;AAGtC,cAAc,SAAS,CAAC,QAAQ,GAAG,SAAS,SAAS,OAAO;IAC1D,IAAI,SAAS,IAAI,CAAC,IAAI,GAAG;IAEzB,UAAU,IAAI,CAAC,MAAM,IAAI;IAEzB,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,EAAE;QACzB,UAAU,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ;IACpC;IAEA,OAAO;AACT;AAGA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 2831, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type.js"],"sourcesContent":["'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag          = tag;\n  this.kind         = options['kind']         || null;\n  this.resolve      = options['resolve']      || function () { return true; };\n  this.construct    = options['construct']    || function (data) { return data; };\n  this.instanceOf   = options['instanceOf']   || null;\n  this.predicate    = options['predicate']    || null;\n  this.represent    = options['represent']    || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,IAAI,2BAA2B;IAC7B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,IAAI,kBAAkB;IACpB;IACA;IACA;CACD;AAED,SAAS,oBAAoB,GAAG;IAC9B,IAAI,SAAS,CAAC;IAEd,IAAI,QAAQ,MAAM;QAChB,OAAO,IAAI,CAAC,KAAK,OAAO,CAAC,SAAU,KAAK;YACtC,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,SAAU,KAAK;gBAChC,MAAM,CAAC,OAAO,OAAO,GAAG;YAC1B;QACF;IACF;IAEA,OAAO;AACT;AAEA,SAAS,KAAK,GAAG,EAAE,OAAO;IACxB,UAAU,WAAW,CAAC;IAEtB,OAAO,IAAI,CAAC,SAAS,OAAO,CAAC,SAAU,IAAI;QACzC,IAAI,yBAAyB,OAAO,CAAC,UAAU,CAAC,GAAG;YACjD,MAAM,IAAI,cAAc,qBAAqB,OAAO,gCAAgC,MAAM;QAC5F;IACF;IAEA,8BAA8B;IAC9B,IAAI,CAAC,GAAG,GAAY;IACpB,IAAI,CAAC,IAAI,GAAW,OAAO,CAAC,OAAO,IAAY;IAC/C,IAAI,CAAC,OAAO,GAAQ,OAAO,CAAC,UAAU,IAAS;QAAc,OAAO;IAAM;IAC1E,IAAI,CAAC,SAAS,GAAM,OAAO,CAAC,YAAY,IAAO,SAAU,IAAI;QAAI,OAAO;IAAM;IAC9E,IAAI,CAAC,UAAU,GAAK,OAAO,CAAC,aAAa,IAAM;IAC/C,IAAI,CAAC,SAAS,GAAM,OAAO,CAAC,YAAY,IAAO;IAC/C,IAAI,CAAC,SAAS,GAAM,OAAO,CAAC,YAAY,IAAO;IAC/C,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,eAAe,IAAI;IAC/C,IAAI,CAAC,YAAY,GAAG,oBAAoB,OAAO,CAAC,eAAe,IAAI;IAEnE,IAAI,gBAAgB,OAAO,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,GAAG;QAC7C,MAAM,IAAI,cAAc,mBAAmB,IAAI,CAAC,IAAI,GAAG,yBAAyB,MAAM;IACxF;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 2888, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/common.js"],"sourcesContent":["'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n"],"names":[],"mappings":"AAGA,SAAS,UAAU,OAAO;IACxB,OAAO,AAAC,OAAO,YAAY,eAAiB,YAAY;AAC1D;AAGA,SAAS,SAAS,OAAO;IACvB,OAAO,AAAC,OAAO,YAAY,YAAc,YAAY;AACvD;AAGA,SAAS,QAAQ,QAAQ;IACvB,IAAI,MAAM,OAAO,CAAC,WAAW,OAAO;SAC/B,IAAI,UAAU,WAAW,OAAO,EAAE;IAEvC,OAAO;QAAE;KAAU;AACrB;AAGA,SAAS,OAAO,MAAM,EAAE,MAAM;IAC5B,IAAI,OAAO,QAAQ,KAAK;IAExB,IAAI,QAAQ;QACV,aAAa,OAAO,IAAI,CAAC;QAEzB,IAAK,QAAQ,GAAG,SAAS,WAAW,MAAM,EAAE,QAAQ,QAAQ,SAAS,EAAG;YACtE,MAAM,UAAU,CAAC,MAAM;YACvB,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;QAC3B;IACF;IAEA,OAAO;AACT;AAGA,SAAS,OAAO,MAAM,EAAE,KAAK;IAC3B,IAAI,SAAS,IAAI;IAEjB,IAAK,QAAQ,GAAG,QAAQ,OAAO,SAAS,EAAG;QACzC,UAAU;IACZ;IAEA,OAAO;AACT;AAGA,SAAS,eAAe,MAAM;IAC5B,OAAO,AAAC,WAAW,KAAO,OAAO,iBAAiB,KAAK,IAAI;AAC7D;AAGA,OAAO,OAAO,CAAC,SAAS,GAAQ;AAChC,OAAO,OAAO,CAAC,QAAQ,GAAS;AAChC,OAAO,OAAO,CAAC,OAAO,GAAU;AAChC,OAAO,OAAO,CAAC,MAAM,GAAW;AAChC,OAAO,OAAO,CAAC,cAAc,GAAG;AAChC,OAAO,OAAO,CAAC,MAAM,GAAW","ignoreList":[0]}},
    {"offset": {"line": 2932, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index, length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n"],"names":[],"mappings":"AAEA,wBAAwB,GAExB,IAAI;AACJ,IAAI;AACJ,IAAI;AAGJ,SAAS,YAAY,MAAM,EAAE,IAAI,EAAE,MAAM;IACvC,IAAI,UAAU,EAAE;IAEhB,OAAO,OAAO,CAAC,OAAO,CAAC,SAAU,cAAc;QAC7C,SAAS,YAAY,gBAAgB,MAAM;IAC7C;IAEA,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,SAAU,WAAW;QACxC,OAAO,OAAO,CAAC,SAAU,YAAY,EAAE,aAAa;YAClD,IAAI,aAAa,GAAG,KAAK,YAAY,GAAG,IAAI,aAAa,IAAI,KAAK,YAAY,IAAI,EAAE;gBAClF,QAAQ,IAAI,CAAC;YACf;QACF;QAEA,OAAO,IAAI,CAAC;IACd;IAEA,OAAO,OAAO,MAAM,CAAC,SAAU,IAAI,EAAE,KAAK;QACxC,OAAO,QAAQ,OAAO,CAAC,WAAW,CAAC;IACrC;AACF;AAGA,SAAS;IACP,IAAI,SAAS;QACP,QAAQ,CAAC;QACT,UAAU,CAAC;QACX,SAAS,CAAC;QACV,UAAU,CAAC;IACb,GAAG,OAAO;IAEd,SAAS,YAAY,IAAI;QACvB,MAAM,CAAC,KAAK,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC,GAAG,MAAM,CAAC,WAAW,CAAC,KAAK,GAAG,CAAC,GAAG;IAC/D;IAEA,IAAK,QAAQ,GAAG,SAAS,UAAU,MAAM,EAAE,QAAQ,QAAQ,SAAS,EAAG;QACrE,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC;IAC3B;IACA,OAAO;AACT;AAGA,SAAS,OAAO,UAAU;IACxB,IAAI,CAAC,OAAO,GAAI,WAAW,OAAO,IAAK,EAAE;IACzC,IAAI,CAAC,QAAQ,GAAG,WAAW,QAAQ,IAAI,EAAE;IACzC,IAAI,CAAC,QAAQ,GAAG,WAAW,QAAQ,IAAI,EAAE;IAEzC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAU,IAAI;QAClC,IAAI,KAAK,QAAQ,IAAI,KAAK,QAAQ,KAAK,UAAU;YAC/C,MAAM,IAAI,cAAc;QAC1B;IACF;IAEA,IAAI,CAAC,gBAAgB,GAAG,YAAY,IAAI,EAAE,YAAY,EAAE;IACxD,IAAI,CAAC,gBAAgB,GAAG,YAAY,IAAI,EAAE,YAAY,EAAE;IACxD,IAAI,CAAC,eAAe,GAAI,WAAW,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB;AACjF;AAGA,OAAO,OAAO,GAAG;AAGjB,OAAO,MAAM,GAAG,SAAS;IACvB,IAAI,SAAS;IAEb,OAAQ,UAAU,MAAM;QACtB,KAAK;YACH,UAAU,OAAO,OAAO;YACxB,QAAQ,SAAS,CAAC,EAAE;YACpB;QAEF,KAAK;YACH,UAAU,SAAS,CAAC,EAAE;YACtB,QAAQ,SAAS,CAAC,EAAE;YACpB;QAEF;YACE,MAAM,IAAI,cAAc;IAC5B;IAEA,UAAU,OAAO,OAAO,CAAC;IACzB,QAAQ,OAAO,OAAO,CAAC;IAEvB,IAAI,CAAC,QAAQ,KAAK,CAAC,SAAU,MAAM;QAAI,OAAO,kBAAkB;IAAQ,IAAI;QAC1E,MAAM,IAAI,cAAc;IAC1B;IAEA,IAAI,CAAC,MAAM,KAAK,CAAC,SAAU,IAAI;QAAI,OAAO,gBAAgB;IAAM,IAAI;QAClE,MAAM,IAAI,cAAc;IAC1B;IAEA,OAAO,IAAI,OAAO;QAChB,SAAS;QACT,UAAU;IACZ;AACF;AAGA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 3017, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/str.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,OAAO,OAAO,GAAG,IAAI,KAAK,yBAAyB;IACjD,MAAM;IACN,WAAW,SAAU,IAAI;QAAI,OAAO,SAAS,OAAO,OAAO;IAAI;AACjE","ignoreList":[0]}},
    {"offset": {"line": 3028, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,OAAO,OAAO,GAAG,IAAI,KAAK,yBAAyB;IACjD,MAAM;IACN,WAAW,SAAU,IAAI;QAAI,OAAO,SAAS,OAAO,OAAO,EAAE;IAAE;AACjE","ignoreList":[0]}},
    {"offset": {"line": 3039, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/map.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,OAAO,OAAO,GAAG,IAAI,KAAK,yBAAyB;IACjD,MAAM;IACN,WAAW,SAAU,IAAI;QAAI,OAAO,SAAS,OAAO,OAAO,CAAC;IAAG;AACjE","ignoreList":[0]}},
    {"offset": {"line": 3050, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"],"sourcesContent":["// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n"],"names":[],"mappings":"AAAA,mCAAmC;AACnC,mDAAmD;AAMnD,IAAI;AAGJ,OAAO,OAAO,GAAG,IAAI,OAAO;IAC1B,UAAU;;;;KAIT;AACH","ignoreList":[0]}},
    {"offset": {"line": 3064, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/null.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; }\n  },\n  defaultStyle: 'lowercase'\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,SAAS,gBAAgB,IAAI;IAC3B,IAAI,SAAS,MAAM,OAAO;IAE1B,IAAI,MAAM,KAAK,MAAM;IAErB,OAAO,AAAC,QAAQ,KAAK,SAAS,OACtB,QAAQ,KAAK,CAAC,SAAS,UAAU,SAAS,UAAU,SAAS,MAAM;AAC7E;AAEA,SAAS;IACP,OAAO;AACT;AAEA,SAAS,OAAO,MAAM;IACpB,OAAO,WAAW;AACpB;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,0BAA0B;IAClD,MAAM;IACN,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;QACT,WAAW;YAAc,OAAO;QAAQ;QACxC,WAAW;YAAc,OAAO;QAAQ;QACxC,WAAW;YAAc,OAAO;QAAQ;QACxC,WAAW;YAAc,OAAO;QAAQ;IAC1C;IACA,cAAc;AAChB","ignoreList":[0]}},
    {"offset": {"line": 3101, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,SAAS,mBAAmB,IAAI;IAC9B,IAAI,SAAS,MAAM,OAAO;IAE1B,IAAI,MAAM,KAAK,MAAM;IAErB,OAAO,AAAC,QAAQ,KAAK,CAAC,SAAS,UAAU,SAAS,UAAU,SAAS,MAAM,KACnE,QAAQ,KAAK,CAAC,SAAS,WAAW,SAAS,WAAW,SAAS,OAAO;AAChF;AAEA,SAAS,qBAAqB,IAAI;IAChC,OAAO,SAAS,UACT,SAAS,UACT,SAAS;AAClB;AAEA,SAAS,UAAU,MAAM;IACvB,OAAO,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY;AACpD;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,0BAA0B;IAClD,MAAM;IACN,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;QACT,WAAW,SAAU,MAAM;YAAI,OAAO,SAAS,SAAS;QAAS;QACjE,WAAW,SAAU,MAAM;YAAI,OAAO,SAAS,SAAS;QAAS;QACjE,WAAW,SAAU,MAAM;YAAI,OAAO,SAAS,SAAS;QAAS;IACnE;IACA,cAAc;AAChB","ignoreList":[0]}},
    {"offset": {"line": 3135, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/int.js"],"sourcesContent":["'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n    // base 8\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isOctCode(data.charCodeAt(index))) return false;\n      hasDigits = true;\n    }\n    return hasDigits && ch !== '_';\n  }\n\n  // base 10 (except 0) or base 60\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (ch === ':') break;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  // if !base60 - done;\n  if (ch !== ':') return true;\n\n  // base60 almost not used, no needs to optimize\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch, base, digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value, 16);\n    return sign * parseInt(value, 8);\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n\n    value = 0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += (d * base);\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3287, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/float.js"],"sourcesContent":["'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // 20:59\n  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n\n    value = 0.0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n"],"names":[],"mappings":"AAEA,IAAI;AACJ,IAAI;AAEJ,IAAI,qBAAqB,IAAI,OAC3B,0BAA0B;AAC1B,mEACA,WAAW;AACX,oCAAoC;AACpC,oCACA,QAAQ;AACR,kDACA,OAAO;AACP,6BACA,OAAO;AACP;AAEF,SAAS,iBAAiB,IAAI;IAC5B,IAAI,SAAS,MAAM,OAAO;IAE1B,IAAI,CAAC,mBAAmB,IAAI,CAAC,SACzB,gDAAgD;IAChD,8CAA8C;IAC9C,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,KAAK,KAAK;QACjC,OAAO;IACT;IAEA,OAAO;AACT;AAEA,SAAS,mBAAmB,IAAI;IAC9B,IAAI,OAAO,MAAM,MAAM;IAEvB,QAAS,KAAK,OAAO,CAAC,MAAM,IAAI,WAAW;IAC3C,OAAS,KAAK,CAAC,EAAE,KAAK,MAAM,CAAC,IAAI;IACjC,SAAS,EAAE;IAEX,IAAI,KAAK,OAAO,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG;QAC/B,QAAQ,MAAM,KAAK,CAAC;IACtB;IAEA,IAAI,UAAU,QAAQ;QACpB,OAAO,AAAC,SAAS,IAAK,OAAO,iBAAiB,GAAG,OAAO,iBAAiB;IAE3E,OAAO,IAAI,UAAU,QAAQ;QAC3B,OAAO;IAET,OAAO,IAAI,MAAM,OAAO,CAAC,QAAQ,GAAG;QAClC,MAAM,KAAK,CAAC,KAAK,OAAO,CAAC,SAAU,CAAC;YAClC,OAAO,OAAO,CAAC,WAAW,GAAG;QAC/B;QAEA,QAAQ;QACR,OAAO;QAEP,OAAO,OAAO,CAAC,SAAU,CAAC;YACxB,SAAS,IAAI;YACb,QAAQ;QACV;QAEA,OAAO,OAAO;IAEhB;IACA,OAAO,OAAO,WAAW,OAAO;AAClC;AAGA,IAAI,yBAAyB;AAE7B,SAAS,mBAAmB,MAAM,EAAE,KAAK;IACvC,IAAI;IAEJ,IAAI,MAAM,SAAS;QACjB,OAAQ;YACN,KAAK;gBAAa,OAAO;YACzB,KAAK;gBAAa,OAAO;YACzB,KAAK;gBAAa,OAAO;QAC3B;IACF,OAAO,IAAI,OAAO,iBAAiB,KAAK,QAAQ;QAC9C,OAAQ;YACN,KAAK;gBAAa,OAAO;YACzB,KAAK;gBAAa,OAAO;YACzB,KAAK;gBAAa,OAAO;QAC3B;IACF,OAAO,IAAI,OAAO,iBAAiB,KAAK,QAAQ;QAC9C,OAAQ;YACN,KAAK;gBAAa,OAAO;YACzB,KAAK;gBAAa,OAAO;YACzB,KAAK;gBAAa,OAAO;QAC3B;IACF,OAAO,IAAI,OAAO,cAAc,CAAC,SAAS;QACxC,OAAO;IACT;IAEA,MAAM,OAAO,QAAQ,CAAC;IAEtB,mEAAmE;IACnE,2DAA2D;IAE3D,OAAO,uBAAuB,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,KAAK,QAAQ;AACrE;AAEA,SAAS,QAAQ,MAAM;IACrB,OAAO,AAAC,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,qBAC5C,CAAC,SAAS,MAAM,KAAK,OAAO,cAAc,CAAC,OAAO;AAC3D;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,2BAA2B;IACnD,MAAM;IACN,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;IACX,cAAc;AAChB","ignoreList":[0]}},
    {"offset": {"line": 3384, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js"],"sourcesContent":["// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./failsafe')\n  ],\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n"],"names":[],"mappings":"AAAA,+BAA+B;AAC/B,mDAAmD;AACnD,EAAE;AACF,8EAA8E;AAC9E,2EAA2E;AAC3E,6EAA6E;AAM7E,IAAI;AAGJ,OAAO,OAAO,GAAG,IAAI,OAAO;IAC1B,SAAS;;KAER;IACD,UAAU;;;;;KAKT;AACH","ignoreList":[0]}},
    {"offset": {"line": 3406, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js"],"sourcesContent":["// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./json')\n  ]\n});\n"],"names":[],"mappings":"AAAA,+BAA+B;AAC/B,mDAAmD;AACnD,EAAE;AACF,8EAA8E;AAC9E,mEAAmE;AAMnE,IAAI;AAGJ,OAAO,OAAO,GAAG,IAAI,OAAO;IAC1B,SAAS;;KAER;AACH","ignoreList":[0]}},
    {"offset": {"line": 3421, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,IAAI,mBAAmB,IAAI,OACzB,4BAAqC,WAAW;AAChD,kBAAqC,YAAY;AACjD,mBAAqC,UAAU;AAEjD,IAAI,wBAAwB,IAAI,OAC9B,4BAAqC,WAAW;AAChD,mBAAqC,YAAY;AACjD,mBAAqC,UAAU;AAC/C,qBAAqC,MAAM;AAC3C,kBAAqC,WAAW;AAChD,kBAAqC,aAAa;AAClD,kBAAqC,aAAa;AAClD,qBAAqC,eAAe;AACpD,qCAAqC,kCAAkC;AACvE,2BAAqC,iBAAiB;AAExD,SAAS,qBAAqB,IAAI;IAChC,IAAI,SAAS,MAAM,OAAO;IAC1B,IAAI,iBAAiB,IAAI,CAAC,UAAU,MAAM,OAAO;IACjD,IAAI,sBAAsB,IAAI,CAAC,UAAU,MAAM,OAAO;IACtD,OAAO;AACT;AAEA,SAAS,uBAAuB,IAAI;IAClC,IAAI,OAAO,MAAM,OAAO,KAAK,MAAM,QAAQ,QAAQ,WAAW,GAC1D,QAAQ,MAAM,SAAS,WAAW;IAEtC,QAAQ,iBAAiB,IAAI,CAAC;IAC9B,IAAI,UAAU,MAAM,QAAQ,sBAAsB,IAAI,CAAC;IAEvD,IAAI,UAAU,MAAM,MAAM,IAAI,MAAM;IAEpC,oCAAoC;IAEpC,OAAO,CAAE,KAAK,CAAC,EAAE;IACjB,QAAQ,CAAE,KAAK,CAAC,EAAE,GAAI,GAAG,yBAAyB;IAClD,MAAM,CAAE,KAAK,CAAC,EAAE;IAEhB,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE;QACb,OAAO,IAAI,KAAK,KAAK,GAAG,CAAC,MAAM,OAAO;IACxC;IAEA,qDAAqD;IAErD,OAAO,CAAE,KAAK,CAAC,EAAE;IACjB,SAAS,CAAE,KAAK,CAAC,EAAE;IACnB,SAAS,CAAE,KAAK,CAAC,EAAE;IAEnB,IAAI,KAAK,CAAC,EAAE,EAAE;QACZ,WAAW,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG;QAC7B,MAAO,SAAS,MAAM,GAAG,EAAG;YAC1B,YAAY;QACd;QACA,WAAW,CAAC;IACd;IAEA,wDAAwD;IAExD,IAAI,KAAK,CAAC,EAAE,EAAE;QACZ,UAAU,CAAE,KAAK,CAAC,GAAG;QACrB,YAAY,CAAC,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;QAC5B,QAAQ,CAAC,UAAU,KAAK,SAAS,IAAI,OAAO,wBAAwB;QACpE,IAAI,KAAK,CAAC,EAAE,KAAK,KAAK,QAAQ,CAAC;IACjC;IAEA,OAAO,IAAI,KAAK,KAAK,GAAG,CAAC,MAAM,OAAO,KAAK,MAAM,QAAQ,QAAQ;IAEjE,IAAI,OAAO,KAAK,OAAO,CAAC,KAAK,OAAO,KAAK;IAEzC,OAAO;AACT;AAEA,SAAS,uBAAuB,OAAO,SAAS,GAAV;IACpC,OAAO,OAAO,WAAW;AAC3B;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,+BAA+B;IACvD,MAAM;IACN,SAAS;IACT,WAAW;IACX,YAAY;IACZ,WAAW;AACb","ignoreList":[0]}},
    {"offset": {"line": 3489, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,SAAS,iBAAiB,IAAI;IAC5B,OAAO,SAAS,QAAQ,SAAS;AACnC;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,2BAA2B;IACnD,MAAM;IACN,SAAS;AACX","ignoreList":[0]}},
    {"offset": {"line": 3501, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3601, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,IAAI,kBAAkB,OAAO,SAAS,CAAC,cAAc;AACrD,IAAI,YAAkB,OAAO,SAAS,CAAC,QAAQ;AAE/C,SAAS,gBAAgB,IAAI;IAC3B,IAAI,SAAS,MAAM,OAAO;IAE1B,IAAI,aAAa,EAAE,EAAE,OAAO,QAAQ,MAAM,SAAS,YAC/C,SAAS;IAEb,IAAK,QAAQ,GAAG,SAAS,OAAO,MAAM,EAAE,QAAQ,QAAQ,SAAS,EAAG;QAClE,OAAO,MAAM,CAAC,MAAM;QACpB,aAAa;QAEb,IAAI,UAAU,IAAI,CAAC,UAAU,mBAAmB,OAAO;QAEvD,IAAK,WAAW,KAAM;YACpB,IAAI,gBAAgB,IAAI,CAAC,MAAM,UAAU;gBACvC,IAAI,CAAC,YAAY,aAAa;qBACzB,OAAO;YACd;QACF;QAEA,IAAI,CAAC,YAAY,OAAO;QAExB,IAAI,WAAW,OAAO,CAAC,aAAa,CAAC,GAAG,WAAW,IAAI,CAAC;aACnD,OAAO;IACd;IAEA,OAAO;AACT;AAEA,SAAS,kBAAkB,IAAI;IAC7B,OAAO,SAAS,OAAO,OAAO,EAAE;AAClC;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,0BAA0B;IAClD,MAAM;IACN,SAAS;IACT,WAAW;AACb","ignoreList":[0]}},
    {"offset": {"line": 3635, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,IAAI,YAAY,OAAO,SAAS,CAAC,QAAQ;AAEzC,SAAS,iBAAiB,IAAI;IAC5B,IAAI,SAAS,MAAM,OAAO;IAE1B,IAAI,OAAO,QAAQ,MAAM,MAAM,QAC3B,SAAS;IAEb,SAAS,IAAI,MAAM,OAAO,MAAM;IAEhC,IAAK,QAAQ,GAAG,SAAS,OAAO,MAAM,EAAE,QAAQ,QAAQ,SAAS,EAAG;QAClE,OAAO,MAAM,CAAC,MAAM;QAEpB,IAAI,UAAU,IAAI,CAAC,UAAU,mBAAmB,OAAO;QAEvD,OAAO,OAAO,IAAI,CAAC;QAEnB,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO;QAE9B,MAAM,CAAC,MAAM,GAAG;YAAE,IAAI,CAAC,EAAE;YAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;SAAE;IAC5C;IAEA,OAAO;AACT;AAEA,SAAS,mBAAmB,IAAI;IAC9B,IAAI,SAAS,MAAM,OAAO,EAAE;IAE5B,IAAI,OAAO,QAAQ,MAAM,MAAM,QAC3B,SAAS;IAEb,SAAS,IAAI,MAAM,OAAO,MAAM;IAEhC,IAAK,QAAQ,GAAG,SAAS,OAAO,MAAM,EAAE,QAAQ,QAAQ,SAAS,EAAG;QAClE,OAAO,MAAM,CAAC,MAAM;QAEpB,OAAO,OAAO,IAAI,CAAC;QAEnB,MAAM,CAAC,MAAM,GAAG;YAAE,IAAI,CAAC,EAAE;YAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;SAAE;IAC5C;IAEA,OAAO;AACT;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,2BAA2B;IACnD,MAAM;IACN,SAAS;IACT,WAAW;AACb","ignoreList":[0]}},
    {"offset": {"line": 3676, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/set.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,IAAI,kBAAkB,OAAO,SAAS,CAAC,cAAc;AAErD,SAAS,eAAe,IAAI;IAC1B,IAAI,SAAS,MAAM,OAAO;IAE1B,IAAI,KAAK,SAAS;IAElB,IAAK,OAAO,OAAQ;QAClB,IAAI,gBAAgB,IAAI,CAAC,QAAQ,MAAM;YACrC,IAAI,MAAM,CAAC,IAAI,KAAK,MAAM,OAAO;QACnC;IACF;IAEA,OAAO;AACT;AAEA,SAAS,iBAAiB,IAAI;IAC5B,OAAO,SAAS,OAAO,OAAO,CAAC;AACjC;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,yBAAyB;IACjD,MAAM;IACN,SAAS;IACT,WAAW;AACb","ignoreList":[0]}},
    {"offset": {"line": 3700, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"],"sourcesContent":["// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./core')\n  ],\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n"],"names":[],"mappings":"AAAA,oDAAoD;AACpD,iDAAiD;AACjD,EAAE;AACF,2EAA2E;AAC3E,wEAAwE;AAMxE,IAAI;AAGJ,OAAO,OAAO,GAAG,IAAI,OAAO;IAC1B,SAAS;;KAER;IACD,UAAU;;;KAGT;IACD,UAAU;;;;;KAKT;AACH","ignoreList":[0]}},
    {"offset": {"line": 3725, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return typeof object === 'undefined';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,SAAS;IACP,OAAO;AACT;AAEA,SAAS;IACP,6BAA6B,GAC7B,OAAO;AACT;AAEA,SAAS;IACP,OAAO;AACT;AAEA,SAAS,YAAY,MAAM;IACzB,OAAO,OAAO,WAAW;AAC3B;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,kCAAkC;IAC1D,MAAM;IACN,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;AACb","ignoreList":[0]}},
    {"offset": {"line": 3749, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"],"sourcesContent":["'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptRegExp(data) {\n  if (data === null) return false;\n  if (data.length === 0) return false;\n\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n\n    if (modifiers.length > 3) return false;\n    // if expression starts with /, is should be properly terminated\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n  }\n\n  return true;\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // `/foo/gim` - tail can be maximum 4 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object /*, style*/) {\n  var result = '/' + object.source + '/';\n\n  if (object.global) result += 'g';\n  if (object.multiline) result += 'm';\n  if (object.ignoreCase) result += 'i';\n\n  return result;\n}\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,SAAS,wBAAwB,IAAI;IACnC,IAAI,SAAS,MAAM,OAAO;IAC1B,IAAI,KAAK,MAAM,KAAK,GAAG,OAAO;IAE9B,IAAI,SAAS,MACT,OAAS,cAAc,IAAI,CAAC,OAC5B,YAAY;IAEhB,8EAA8E;IAC9E,qDAAqD;IACrD,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;QACrB,IAAI,MAAM,YAAY,IAAI,CAAC,EAAE;QAE7B,IAAI,UAAU,MAAM,GAAG,GAAG,OAAO;QACjC,gEAAgE;QAChE,IAAI,MAAM,CAAC,OAAO,MAAM,GAAG,UAAU,MAAM,GAAG,EAAE,KAAK,KAAK,OAAO;IACnE;IAEA,OAAO;AACT;AAEA,SAAS,0BAA0B,IAAI;IACrC,IAAI,SAAS,MACT,OAAS,cAAc,IAAI,CAAC,OAC5B,YAAY;IAEhB,2CAA2C;IAC3C,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;QACrB,IAAI,MAAM,YAAY,IAAI,CAAC,EAAE;QAC7B,SAAS,OAAO,KAAK,CAAC,GAAG,OAAO,MAAM,GAAG,UAAU,MAAM,GAAG;IAC9D;IAEA,OAAO,IAAI,OAAO,QAAQ;AAC5B;AAEA,SAAS,0BAA0B,OAAO,SAAS,GAAV;IACvC,IAAI,SAAS,MAAM,OAAO,MAAM,GAAG;IAEnC,IAAI,OAAO,MAAM,EAAE,UAAU;IAC7B,IAAI,OAAO,SAAS,EAAE,UAAU;IAChC,IAAI,OAAO,UAAU,EAAE,UAAU;IAEjC,OAAO;AACT;AAEA,SAAS,SAAS,MAAM;IACtB,OAAO,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY;AACpD;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,+BAA+B;IACvD,MAAM;IACN,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;AACb","ignoreList":[0]}},
    {"offset": {"line": 3793, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/esprima/dist/esprima.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n/* istanbul ignore next */\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n/* istanbul ignore next */\n\telse if(typeof exports === 'object')\n\t\texports[\"esprima\"] = factory();\n\telse\n\t\troot[\"esprima\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/* istanbul ignore if */\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/*\n\t  Copyright JS Foundation and other contributors, https://js.foundation/\n\n\t  Redistribution and use in source and binary forms, with or without\n\t  modification, are permitted provided that the following conditions are met:\n\n\t    * Redistributions of source code must retain the above copyright\n\t      notice, this list of conditions and the following disclaimer.\n\t    * Redistributions in binary form must reproduce the above copyright\n\t      notice, this list of conditions and the following disclaimer in the\n\t      documentation and/or other materials provided with the distribution.\n\n\t  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n\t  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\t  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n\t  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n\t  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n\t  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n\t  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n\t  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t*/\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar comment_handler_1 = __webpack_require__(1);\n\tvar jsx_parser_1 = __webpack_require__(3);\n\tvar parser_1 = __webpack_require__(8);\n\tvar tokenizer_1 = __webpack_require__(15);\n\tfunction parse(code, options, delegate) {\n\t    var commentHandler = null;\n\t    var proxyDelegate = function (node, metadata) {\n\t        if (delegate) {\n\t            delegate(node, metadata);\n\t        }\n\t        if (commentHandler) {\n\t            commentHandler.visit(node, metadata);\n\t        }\n\t    };\n\t    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;\n\t    var collectComment = false;\n\t    if (options) {\n\t        collectComment = (typeof options.comment === 'boolean' && options.comment);\n\t        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);\n\t        if (collectComment || attachComment) {\n\t            commentHandler = new comment_handler_1.CommentHandler();\n\t            commentHandler.attach = attachComment;\n\t            options.comment = true;\n\t            parserDelegate = proxyDelegate;\n\t        }\n\t    }\n\t    var isModule = false;\n\t    if (options && typeof options.sourceType === 'string') {\n\t        isModule = (options.sourceType === 'module');\n\t    }\n\t    var parser;\n\t    if (options && typeof options.jsx === 'boolean' && options.jsx) {\n\t        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);\n\t    }\n\t    else {\n\t        parser = new parser_1.Parser(code, options, parserDelegate);\n\t    }\n\t    var program = isModule ? parser.parseModule() : parser.parseScript();\n\t    var ast = program;\n\t    if (collectComment && commentHandler) {\n\t        ast.comments = commentHandler.comments;\n\t    }\n\t    if (parser.config.tokens) {\n\t        ast.tokens = parser.tokens;\n\t    }\n\t    if (parser.config.tolerant) {\n\t        ast.errors = parser.errorHandler.errors;\n\t    }\n\t    return ast;\n\t}\n\texports.parse = parse;\n\tfunction parseModule(code, options, delegate) {\n\t    var parsingOptions = options || {};\n\t    parsingOptions.sourceType = 'module';\n\t    return parse(code, parsingOptions, delegate);\n\t}\n\texports.parseModule = parseModule;\n\tfunction parseScript(code, options, delegate) {\n\t    var parsingOptions = options || {};\n\t    parsingOptions.sourceType = 'script';\n\t    return parse(code, parsingOptions, delegate);\n\t}\n\texports.parseScript = parseScript;\n\tfunction tokenize(code, options, delegate) {\n\t    var tokenizer = new tokenizer_1.Tokenizer(code, options);\n\t    var tokens;\n\t    tokens = [];\n\t    try {\n\t        while (true) {\n\t            var token = tokenizer.getNextToken();\n\t            if (!token) {\n\t                break;\n\t            }\n\t            if (delegate) {\n\t                token = delegate(token);\n\t            }\n\t            tokens.push(token);\n\t        }\n\t    }\n\t    catch (e) {\n\t        tokenizer.errorHandler.tolerate(e);\n\t    }\n\t    if (tokenizer.errorHandler.tolerant) {\n\t        tokens.errors = tokenizer.errors();\n\t    }\n\t    return tokens;\n\t}\n\texports.tokenize = tokenize;\n\tvar syntax_1 = __webpack_require__(2);\n\texports.Syntax = syntax_1.Syntax;\n\t// Sync with *.json manifests.\n\texports.version = '4.0.1';\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar syntax_1 = __webpack_require__(2);\n\tvar CommentHandler = (function () {\n\t    function CommentHandler() {\n\t        this.attach = false;\n\t        this.comments = [];\n\t        this.stack = [];\n\t        this.leading = [];\n\t        this.trailing = [];\n\t    }\n\t    CommentHandler.prototype.insertInnerComments = function (node, metadata) {\n\t        //  innnerComments for properties empty block\n\t        //  `function a() {/** comments **\\/}`\n\t        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {\n\t            var innerComments = [];\n\t            for (var i = this.leading.length - 1; i >= 0; --i) {\n\t                var entry = this.leading[i];\n\t                if (metadata.end.offset >= entry.start) {\n\t                    innerComments.unshift(entry.comment);\n\t                    this.leading.splice(i, 1);\n\t                    this.trailing.splice(i, 1);\n\t                }\n\t            }\n\t            if (innerComments.length) {\n\t                node.innerComments = innerComments;\n\t            }\n\t        }\n\t    };\n\t    CommentHandler.prototype.findTrailingComments = function (metadata) {\n\t        var trailingComments = [];\n\t        if (this.trailing.length > 0) {\n\t            for (var i = this.trailing.length - 1; i >= 0; --i) {\n\t                var entry_1 = this.trailing[i];\n\t                if (entry_1.start >= metadata.end.offset) {\n\t                    trailingComments.unshift(entry_1.comment);\n\t                }\n\t            }\n\t            this.trailing.length = 0;\n\t            return trailingComments;\n\t        }\n\t        var entry = this.stack[this.stack.length - 1];\n\t        if (entry && entry.node.trailingComments) {\n\t            var firstComment = entry.node.trailingComments[0];\n\t            if (firstComment && firstComment.range[0] >= metadata.end.offset) {\n\t                trailingComments = entry.node.trailingComments;\n\t                delete entry.node.trailingComments;\n\t            }\n\t        }\n\t        return trailingComments;\n\t    };\n\t    CommentHandler.prototype.findLeadingComments = function (metadata) {\n\t        var leadingComments = [];\n\t        var target;\n\t        while (this.stack.length > 0) {\n\t            var entry = this.stack[this.stack.length - 1];\n\t            if (entry && entry.start >= metadata.start.offset) {\n\t                target = entry.node;\n\t                this.stack.pop();\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        if (target) {\n\t            var count = target.leadingComments ? target.leadingComments.length : 0;\n\t            for (var i = count - 1; i >= 0; --i) {\n\t                var comment = target.leadingComments[i];\n\t                if (comment.range[1] <= metadata.start.offset) {\n\t                    leadingComments.unshift(comment);\n\t                    target.leadingComments.splice(i, 1);\n\t                }\n\t            }\n\t            if (target.leadingComments && target.leadingComments.length === 0) {\n\t                delete target.leadingComments;\n\t            }\n\t            return leadingComments;\n\t        }\n\t        for (var i = this.leading.length - 1; i >= 0; --i) {\n\t            var entry = this.leading[i];\n\t            if (entry.start <= metadata.start.offset) {\n\t                leadingComments.unshift(entry.comment);\n\t                this.leading.splice(i, 1);\n\t            }\n\t        }\n\t        return leadingComments;\n\t    };\n\t    CommentHandler.prototype.visitNode = function (node, metadata) {\n\t        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {\n\t            return;\n\t        }\n\t        this.insertInnerComments(node, metadata);\n\t        var trailingComments = this.findTrailingComments(metadata);\n\t        var leadingComments = this.findLeadingComments(metadata);\n\t        if (leadingComments.length > 0) {\n\t            node.leadingComments = leadingComments;\n\t        }\n\t        if (trailingComments.length > 0) {\n\t            node.trailingComments = trailingComments;\n\t        }\n\t        this.stack.push({\n\t            node: node,\n\t            start: metadata.start.offset\n\t        });\n\t    };\n\t    CommentHandler.prototype.visitComment = function (node, metadata) {\n\t        var type = (node.type[0] === 'L') ? 'Line' : 'Block';\n\t        var comment = {\n\t            type: type,\n\t            value: node.value\n\t        };\n\t        if (node.range) {\n\t            comment.range = node.range;\n\t        }\n\t        if (node.loc) {\n\t            comment.loc = node.loc;\n\t        }\n\t        this.comments.push(comment);\n\t        if (this.attach) {\n\t            var entry = {\n\t                comment: {\n\t                    type: type,\n\t                    value: node.value,\n\t                    range: [metadata.start.offset, metadata.end.offset]\n\t                },\n\t                start: metadata.start.offset\n\t            };\n\t            if (node.loc) {\n\t                entry.comment.loc = node.loc;\n\t            }\n\t            node.type = type;\n\t            this.leading.push(entry);\n\t            this.trailing.push(entry);\n\t        }\n\t    };\n\t    CommentHandler.prototype.visit = function (node, metadata) {\n\t        if (node.type === 'LineComment') {\n\t            this.visitComment(node, metadata);\n\t        }\n\t        else if (node.type === 'BlockComment') {\n\t            this.visitComment(node, metadata);\n\t        }\n\t        else if (this.attach) {\n\t            this.visitNode(node, metadata);\n\t        }\n\t    };\n\t    return CommentHandler;\n\t}());\n\texports.CommentHandler = CommentHandler;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.Syntax = {\n\t    AssignmentExpression: 'AssignmentExpression',\n\t    AssignmentPattern: 'AssignmentPattern',\n\t    ArrayExpression: 'ArrayExpression',\n\t    ArrayPattern: 'ArrayPattern',\n\t    ArrowFunctionExpression: 'ArrowFunctionExpression',\n\t    AwaitExpression: 'AwaitExpression',\n\t    BlockStatement: 'BlockStatement',\n\t    BinaryExpression: 'BinaryExpression',\n\t    BreakStatement: 'BreakStatement',\n\t    CallExpression: 'CallExpression',\n\t    CatchClause: 'CatchClause',\n\t    ClassBody: 'ClassBody',\n\t    ClassDeclaration: 'ClassDeclaration',\n\t    ClassExpression: 'ClassExpression',\n\t    ConditionalExpression: 'ConditionalExpression',\n\t    ContinueStatement: 'ContinueStatement',\n\t    DoWhileStatement: 'DoWhileStatement',\n\t    DebuggerStatement: 'DebuggerStatement',\n\t    EmptyStatement: 'EmptyStatement',\n\t    ExportAllDeclaration: 'ExportAllDeclaration',\n\t    ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n\t    ExportNamedDeclaration: 'ExportNamedDeclaration',\n\t    ExportSpecifier: 'ExportSpecifier',\n\t    ExpressionStatement: 'ExpressionStatement',\n\t    ForStatement: 'ForStatement',\n\t    ForOfStatement: 'ForOfStatement',\n\t    ForInStatement: 'ForInStatement',\n\t    FunctionDeclaration: 'FunctionDeclaration',\n\t    FunctionExpression: 'FunctionExpression',\n\t    Identifier: 'Identifier',\n\t    IfStatement: 'IfStatement',\n\t    ImportDeclaration: 'ImportDeclaration',\n\t    ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n\t    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n\t    ImportSpecifier: 'ImportSpecifier',\n\t    Literal: 'Literal',\n\t    LabeledStatement: 'LabeledStatement',\n\t    LogicalExpression: 'LogicalExpression',\n\t    MemberExpression: 'MemberExpression',\n\t    MetaProperty: 'MetaProperty',\n\t    MethodDefinition: 'MethodDefinition',\n\t    NewExpression: 'NewExpression',\n\t    ObjectExpression: 'ObjectExpression',\n\t    ObjectPattern: 'ObjectPattern',\n\t    Program: 'Program',\n\t    Property: 'Property',\n\t    RestElement: 'RestElement',\n\t    ReturnStatement: 'ReturnStatement',\n\t    SequenceExpression: 'SequenceExpression',\n\t    SpreadElement: 'SpreadElement',\n\t    Super: 'Super',\n\t    SwitchCase: 'SwitchCase',\n\t    SwitchStatement: 'SwitchStatement',\n\t    TaggedTemplateExpression: 'TaggedTemplateExpression',\n\t    TemplateElement: 'TemplateElement',\n\t    TemplateLiteral: 'TemplateLiteral',\n\t    ThisExpression: 'ThisExpression',\n\t    ThrowStatement: 'ThrowStatement',\n\t    TryStatement: 'TryStatement',\n\t    UnaryExpression: 'UnaryExpression',\n\t    UpdateExpression: 'UpdateExpression',\n\t    VariableDeclaration: 'VariableDeclaration',\n\t    VariableDeclarator: 'VariableDeclarator',\n\t    WhileStatement: 'WhileStatement',\n\t    WithStatement: 'WithStatement',\n\t    YieldExpression: 'YieldExpression'\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n/* istanbul ignore next */\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar character_1 = __webpack_require__(4);\n\tvar JSXNode = __webpack_require__(5);\n\tvar jsx_syntax_1 = __webpack_require__(6);\n\tvar Node = __webpack_require__(7);\n\tvar parser_1 = __webpack_require__(8);\n\tvar token_1 = __webpack_require__(13);\n\tvar xhtml_entities_1 = __webpack_require__(14);\n\ttoken_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';\n\ttoken_1.TokenName[101 /* Text */] = 'JSXText';\n\t// Fully qualified element name, e.g. <svg:path> returns \"svg:path\"\n\tfunction getQualifiedElementName(elementName) {\n\t    var qualifiedName;\n\t    switch (elementName.type) {\n\t        case jsx_syntax_1.JSXSyntax.JSXIdentifier:\n\t            var id = elementName;\n\t            qualifiedName = id.name;\n\t            break;\n\t        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:\n\t            var ns = elementName;\n\t            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +\n\t                getQualifiedElementName(ns.name);\n\t            break;\n\t        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:\n\t            var expr = elementName;\n\t            qualifiedName = getQualifiedElementName(expr.object) + '.' +\n\t                getQualifiedElementName(expr.property);\n\t            break;\n\t        /* istanbul ignore next */\n\t        default:\n\t            break;\n\t    }\n\t    return qualifiedName;\n\t}\n\tvar JSXParser = (function (_super) {\n\t    __extends(JSXParser, _super);\n\t    function JSXParser(code, options, delegate) {\n\t        return _super.call(this, code, options, delegate) || this;\n\t    }\n\t    JSXParser.prototype.parsePrimaryExpression = function () {\n\t        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);\n\t    };\n\t    JSXParser.prototype.startJSX = function () {\n\t        // Unwind the scanner before the lookahead token.\n\t        this.scanner.index = this.startMarker.index;\n\t        this.scanner.lineNumber = this.startMarker.line;\n\t        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;\n\t    };\n\t    JSXParser.prototype.finishJSX = function () {\n\t        // Prime the next lookahead.\n\t        this.nextToken();\n\t    };\n\t    JSXParser.prototype.reenterJSX = function () {\n\t        this.startJSX();\n\t        this.expectJSX('}');\n\t        // Pop the closing '}' added from the lookahead.\n\t        if (this.config.tokens) {\n\t            this.tokens.pop();\n\t        }\n\t    };\n\t    JSXParser.prototype.createJSXNode = function () {\n\t        this.collectComments();\n\t        return {\n\t            index: this.scanner.index,\n\t            line: this.scanner.lineNumber,\n\t            column: this.scanner.index - this.scanner.lineStart\n\t        };\n\t    };\n\t    JSXParser.prototype.createJSXChildNode = function () {\n\t        return {\n\t            index: this.scanner.index,\n\t            line: this.scanner.lineNumber,\n\t            column: this.scanner.index - this.scanner.lineStart\n\t        };\n\t    };\n\t    JSXParser.prototype.scanXHTMLEntity = function (quote) {\n\t        var result = '&';\n\t        var valid = true;\n\t        var terminated = false;\n\t        var numeric = false;\n\t        var hex = false;\n\t        while (!this.scanner.eof() && valid && !terminated) {\n\t            var ch = this.scanner.source[this.scanner.index];\n\t            if (ch === quote) {\n\t                break;\n\t            }\n\t            terminated = (ch === ';');\n\t            result += ch;\n\t            ++this.scanner.index;\n\t            if (!terminated) {\n\t                switch (result.length) {\n\t                    case 2:\n\t                        // e.g. '&#123;'\n\t                        numeric = (ch === '#');\n\t                        break;\n\t                    case 3:\n\t                        if (numeric) {\n\t                            // e.g. '&#x41;'\n\t                            hex = (ch === 'x');\n\t                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));\n\t                            numeric = numeric && !hex;\n\t                        }\n\t                        break;\n\t                    default:\n\t                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));\n\t                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));\n\t                        break;\n\t                }\n\t            }\n\t        }\n\t        if (valid && terminated && result.length > 2) {\n\t            // e.g. '&#x41;' becomes just '#x41'\n\t            var str = result.substr(1, result.length - 2);\n\t            if (numeric && str.length > 1) {\n\t                result = String.fromCharCode(parseInt(str.substr(1), 10));\n\t            }\n\t            else if (hex && str.length > 2) {\n\t                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));\n\t            }\n\t            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {\n\t                result = xhtml_entities_1.XHTMLEntities[str];\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.\n\t    JSXParser.prototype.lexJSX = function () {\n\t        var cp = this.scanner.source.charCodeAt(this.scanner.index);\n\t        // < > / : = { }\n\t        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {\n\t            var value = this.scanner.source[this.scanner.index++];\n\t            return {\n\t                type: 7 /* Punctuator */,\n\t                value: value,\n\t                lineNumber: this.scanner.lineNumber,\n\t                lineStart: this.scanner.lineStart,\n\t                start: this.scanner.index - 1,\n\t                end: this.scanner.index\n\t            };\n\t        }\n\t        // \" '\n\t        if (cp === 34 || cp === 39) {\n\t            var start = this.scanner.index;\n\t            var quote = this.scanner.source[this.scanner.index++];\n\t            var str = '';\n\t            while (!this.scanner.eof()) {\n\t                var ch = this.scanner.source[this.scanner.index++];\n\t                if (ch === quote) {\n\t                    break;\n\t                }\n\t                else if (ch === '&') {\n\t                    str += this.scanXHTMLEntity(quote);\n\t                }\n\t                else {\n\t                    str += ch;\n\t                }\n\t            }\n\t            return {\n\t                type: 8 /* StringLiteral */,\n\t                value: str,\n\t                lineNumber: this.scanner.lineNumber,\n\t                lineStart: this.scanner.lineStart,\n\t                start: start,\n\t                end: this.scanner.index\n\t            };\n\t        }\n\t        // ... or .\n\t        if (cp === 46) {\n\t            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);\n\t            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);\n\t            var value = (n1 === 46 && n2 === 46) ? '...' : '.';\n\t            var start = this.scanner.index;\n\t            this.scanner.index += value.length;\n\t            return {\n\t                type: 7 /* Punctuator */,\n\t                value: value,\n\t                lineNumber: this.scanner.lineNumber,\n\t                lineStart: this.scanner.lineStart,\n\t                start: start,\n\t                end: this.scanner.index\n\t            };\n\t        }\n\t        // `\n\t        if (cp === 96) {\n\t            // Only placeholder, since it will be rescanned as a real assignment expression.\n\t            return {\n\t                type: 10 /* Template */,\n\t                value: '',\n\t                lineNumber: this.scanner.lineNumber,\n\t                lineStart: this.scanner.lineStart,\n\t                start: this.scanner.index,\n\t                end: this.scanner.index\n\t            };\n\t        }\n\t        // Identifer can not contain backslash (char code 92).\n\t        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {\n\t            var start = this.scanner.index;\n\t            ++this.scanner.index;\n\t            while (!this.scanner.eof()) {\n\t                var ch = this.scanner.source.charCodeAt(this.scanner.index);\n\t                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {\n\t                    ++this.scanner.index;\n\t                }\n\t                else if (ch === 45) {\n\t                    // Hyphen (char code 45) can be part of an identifier.\n\t                    ++this.scanner.index;\n\t                }\n\t                else {\n\t                    break;\n\t                }\n\t            }\n\t            var id = this.scanner.source.slice(start, this.scanner.index);\n\t            return {\n\t                type: 100 /* Identifier */,\n\t                value: id,\n\t                lineNumber: this.scanner.lineNumber,\n\t                lineStart: this.scanner.lineStart,\n\t                start: start,\n\t                end: this.scanner.index\n\t            };\n\t        }\n\t        return this.scanner.lex();\n\t    };\n\t    JSXParser.prototype.nextJSXToken = function () {\n\t        this.collectComments();\n\t        this.startMarker.index = this.scanner.index;\n\t        this.startMarker.line = this.scanner.lineNumber;\n\t        this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n\t        var token = this.lexJSX();\n\t        this.lastMarker.index = this.scanner.index;\n\t        this.lastMarker.line = this.scanner.lineNumber;\n\t        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n\t        if (this.config.tokens) {\n\t            this.tokens.push(this.convertToken(token));\n\t        }\n\t        return token;\n\t    };\n\t    JSXParser.prototype.nextJSXText = function () {\n\t        this.startMarker.index = this.scanner.index;\n\t        this.startMarker.line = this.scanner.lineNumber;\n\t        this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n\t        var start = this.scanner.index;\n\t        var text = '';\n\t        while (!this.scanner.eof()) {\n\t            var ch = this.scanner.source[this.scanner.index];\n\t            if (ch === '{' || ch === '<') {\n\t                break;\n\t            }\n\t            ++this.scanner.index;\n\t            text += ch;\n\t            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n\t                ++this.scanner.lineNumber;\n\t                if (ch === '\\r' && this.scanner.source[this.scanner.index] === '\\n') {\n\t                    ++this.scanner.index;\n\t                }\n\t                this.scanner.lineStart = this.scanner.index;\n\t            }\n\t        }\n\t        this.lastMarker.index = this.scanner.index;\n\t        this.lastMarker.line = this.scanner.lineNumber;\n\t        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n\t        var token = {\n\t            type: 101 /* Text */,\n\t            value: text,\n\t            lineNumber: this.scanner.lineNumber,\n\t            lineStart: this.scanner.lineStart,\n\t            start: start,\n\t            end: this.scanner.index\n\t        };\n\t        if ((text.length > 0) && this.config.tokens) {\n\t            this.tokens.push(this.convertToken(token));\n\t        }\n\t        return token;\n\t    };\n\t    JSXParser.prototype.peekJSXToken = function () {\n\t        var state = this.scanner.saveState();\n\t        this.scanner.scanComments();\n\t        var next = this.lexJSX();\n\t        this.scanner.restoreState(state);\n\t        return next;\n\t    };\n\t    // Expect the next JSX token to match the specified punctuator.\n\t    // If not, an exception will be thrown.\n\t    JSXParser.prototype.expectJSX = function (value) {\n\t        var token = this.nextJSXToken();\n\t        if (token.type !== 7 /* Punctuator */ || token.value !== value) {\n\t            this.throwUnexpectedToken(token);\n\t        }\n\t    };\n\t    // Return true if the next JSX token matches the specified punctuator.\n\t    JSXParser.prototype.matchJSX = function (value) {\n\t        var next = this.peekJSXToken();\n\t        return next.type === 7 /* Punctuator */ && next.value === value;\n\t    };\n\t    JSXParser.prototype.parseJSXIdentifier = function () {\n\t        var node = this.createJSXNode();\n\t        var token = this.nextJSXToken();\n\t        if (token.type !== 100 /* Identifier */) {\n\t            this.throwUnexpectedToken(token);\n\t        }\n\t        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));\n\t    };\n\t    JSXParser.prototype.parseJSXElementName = function () {\n\t        var node = this.createJSXNode();\n\t        var elementName = this.parseJSXIdentifier();\n\t        if (this.matchJSX(':')) {\n\t            var namespace = elementName;\n\t            this.expectJSX(':');\n\t            var name_1 = this.parseJSXIdentifier();\n\t            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));\n\t        }\n\t        else if (this.matchJSX('.')) {\n\t            while (this.matchJSX('.')) {\n\t                var object = elementName;\n\t                this.expectJSX('.');\n\t                var property = this.parseJSXIdentifier();\n\t                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));\n\t            }\n\t        }\n\t        return elementName;\n\t    };\n\t    JSXParser.prototype.parseJSXAttributeName = function () {\n\t        var node = this.createJSXNode();\n\t        var attributeName;\n\t        var identifier = this.parseJSXIdentifier();\n\t        if (this.matchJSX(':')) {\n\t            var namespace = identifier;\n\t            this.expectJSX(':');\n\t            var name_2 = this.parseJSXIdentifier();\n\t            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));\n\t        }\n\t        else {\n\t            attributeName = identifier;\n\t        }\n\t        return attributeName;\n\t    };\n\t    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {\n\t        var node = this.createJSXNode();\n\t        var token = this.nextJSXToken();\n\t        if (token.type !== 8 /* StringLiteral */) {\n\t            this.throwUnexpectedToken(token);\n\t        }\n\t        var raw = this.getTokenRaw(token);\n\t        return this.finalize(node, new Node.Literal(token.value, raw));\n\t    };\n\t    JSXParser.prototype.parseJSXExpressionAttribute = function () {\n\t        var node = this.createJSXNode();\n\t        this.expectJSX('{');\n\t        this.finishJSX();\n\t        if (this.match('}')) {\n\t            this.tolerateError('JSX attributes must only be assigned a non-empty expression');\n\t        }\n\t        var expression = this.parseAssignmentExpression();\n\t        this.reenterJSX();\n\t        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));\n\t    };\n\t    JSXParser.prototype.parseJSXAttributeValue = function () {\n\t        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :\n\t            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();\n\t    };\n\t    JSXParser.prototype.parseJSXNameValueAttribute = function () {\n\t        var node = this.createJSXNode();\n\t        var name = this.parseJSXAttributeName();\n\t        var value = null;\n\t        if (this.matchJSX('=')) {\n\t            this.expectJSX('=');\n\t            value = this.parseJSXAttributeValue();\n\t        }\n\t        return this.finalize(node, new JSXNode.JSXAttribute(name, value));\n\t    };\n\t    JSXParser.prototype.parseJSXSpreadAttribute = function () {\n\t        var node = this.createJSXNode();\n\t        this.expectJSX('{');\n\t        this.expectJSX('...');\n\t        this.finishJSX();\n\t        var argument = this.parseAssignmentExpression();\n\t        this.reenterJSX();\n\t        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));\n\t    };\n\t    JSXParser.prototype.parseJSXAttributes = function () {\n\t        var attributes = [];\n\t        while (!this.matchJSX('/') && !this.matchJSX('>')) {\n\t            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :\n\t                this.parseJSXNameValueAttribute();\n\t            attributes.push(attribute);\n\t        }\n\t        return attributes;\n\t    };\n\t    JSXParser.prototype.parseJSXOpeningElement = function () {\n\t        var node = this.createJSXNode();\n\t        this.expectJSX('<');\n\t        var name = this.parseJSXElementName();\n\t        var attributes = this.parseJSXAttributes();\n\t        var selfClosing = this.matchJSX('/');\n\t        if (selfClosing) {\n\t            this.expectJSX('/');\n\t        }\n\t        this.expectJSX('>');\n\t        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));\n\t    };\n\t    JSXParser.prototype.parseJSXBoundaryElement = function () {\n\t        var node = this.createJSXNode();\n\t        this.expectJSX('<');\n\t        if (this.matchJSX('/')) {\n\t            this.expectJSX('/');\n\t            var name_3 = this.parseJSXElementName();\n\t            this.expectJSX('>');\n\t            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));\n\t        }\n\t        var name = this.parseJSXElementName();\n\t        var attributes = this.parseJSXAttributes();\n\t        var selfClosing = this.matchJSX('/');\n\t        if (selfClosing) {\n\t            this.expectJSX('/');\n\t        }\n\t        this.expectJSX('>');\n\t        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));\n\t    };\n\t    JSXParser.prototype.parseJSXEmptyExpression = function () {\n\t        var node = this.createJSXChildNode();\n\t        this.collectComments();\n\t        this.lastMarker.index = this.scanner.index;\n\t        this.lastMarker.line = this.scanner.lineNumber;\n\t        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n\t        return this.finalize(node, new JSXNode.JSXEmptyExpression());\n\t    };\n\t    JSXParser.prototype.parseJSXExpressionContainer = function () {\n\t        var node = this.createJSXNode();\n\t        this.expectJSX('{');\n\t        var expression;\n\t        if (this.matchJSX('}')) {\n\t            expression = this.parseJSXEmptyExpression();\n\t            this.expectJSX('}');\n\t        }\n\t        else {\n\t            this.finishJSX();\n\t            expression = this.parseAssignmentExpression();\n\t            this.reenterJSX();\n\t        }\n\t        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));\n\t    };\n\t    JSXParser.prototype.parseJSXChildren = function () {\n\t        var children = [];\n\t        while (!this.scanner.eof()) {\n\t            var node = this.createJSXChildNode();\n\t            var token = this.nextJSXText();\n\t            if (token.start < token.end) {\n\t                var raw = this.getTokenRaw(token);\n\t                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));\n\t                children.push(child);\n\t            }\n\t            if (this.scanner.source[this.scanner.index] === '{') {\n\t                var container = this.parseJSXExpressionContainer();\n\t                children.push(container);\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        return children;\n\t    };\n\t    JSXParser.prototype.parseComplexJSXElement = function (el) {\n\t        var stack = [];\n\t        while (!this.scanner.eof()) {\n\t            el.children = el.children.concat(this.parseJSXChildren());\n\t            var node = this.createJSXChildNode();\n\t            var element = this.parseJSXBoundaryElement();\n\t            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {\n\t                var opening = element;\n\t                if (opening.selfClosing) {\n\t                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));\n\t                    el.children.push(child);\n\t                }\n\t                else {\n\t                    stack.push(el);\n\t                    el = { node: node, opening: opening, closing: null, children: [] };\n\t                }\n\t            }\n\t            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {\n\t                el.closing = element;\n\t                var open_1 = getQualifiedElementName(el.opening.name);\n\t                var close_1 = getQualifiedElementName(el.closing.name);\n\t                if (open_1 !== close_1) {\n\t                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);\n\t                }\n\t                if (stack.length > 0) {\n\t                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));\n\t                    el = stack[stack.length - 1];\n\t                    el.children.push(child);\n\t                    stack.pop();\n\t                }\n\t                else {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        return el;\n\t    };\n\t    JSXParser.prototype.parseJSXElement = function () {\n\t        var node = this.createJSXNode();\n\t        var opening = this.parseJSXOpeningElement();\n\t        var children = [];\n\t        var closing = null;\n\t        if (!opening.selfClosing) {\n\t            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });\n\t            children = el.children;\n\t            closing = el.closing;\n\t        }\n\t        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));\n\t    };\n\t    JSXParser.prototype.parseJSXRoot = function () {\n\t        // Pop the opening '<' added from the lookahead.\n\t        if (this.config.tokens) {\n\t            this.tokens.pop();\n\t        }\n\t        this.startJSX();\n\t        var element = this.parseJSXElement();\n\t        this.finishJSX();\n\t        return element;\n\t    };\n\t    JSXParser.prototype.isStartOfExpression = function () {\n\t        return _super.prototype.isStartOfExpression.call(this) || this.match('<');\n\t    };\n\t    return JSXParser;\n\t}(parser_1.Parser));\n\texports.JSXParser = JSXParser;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t// See also tools/generate-unicode-regex.js.\n\tvar Regex = {\n\t    // Unicode v8.0.0 NonAsciiIdentifierStart:\n\t    NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n\t    // Unicode v8.0.0 NonAsciiIdentifierPart:\n\t    NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n\t};\n\texports.Character = {\n\t    /* tslint:disable:no-bitwise */\n\t    fromCodePoint: function (cp) {\n\t        return (cp < 0x10000) ? String.fromCharCode(cp) :\n\t            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +\n\t                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));\n\t    },\n\t    // https://tc39.github.io/ecma262/#sec-white-space\n\t    isWhiteSpace: function (cp) {\n\t        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||\n\t            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);\n\t    },\n\t    // https://tc39.github.io/ecma262/#sec-line-terminators\n\t    isLineTerminator: function (cp) {\n\t        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);\n\t    },\n\t    // https://tc39.github.io/ecma262/#sec-names-and-keywords\n\t    isIdentifierStart: function (cp) {\n\t        return (cp === 0x24) || (cp === 0x5F) ||\n\t            (cp >= 0x41 && cp <= 0x5A) ||\n\t            (cp >= 0x61 && cp <= 0x7A) ||\n\t            (cp === 0x5C) ||\n\t            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));\n\t    },\n\t    isIdentifierPart: function (cp) {\n\t        return (cp === 0x24) || (cp === 0x5F) ||\n\t            (cp >= 0x41 && cp <= 0x5A) ||\n\t            (cp >= 0x61 && cp <= 0x7A) ||\n\t            (cp >= 0x30 && cp <= 0x39) ||\n\t            (cp === 0x5C) ||\n\t            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));\n\t    },\n\t    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals\n\t    isDecimalDigit: function (cp) {\n\t        return (cp >= 0x30 && cp <= 0x39); // 0..9\n\t    },\n\t    isHexDigit: function (cp) {\n\t        return (cp >= 0x30 && cp <= 0x39) ||\n\t            (cp >= 0x41 && cp <= 0x46) ||\n\t            (cp >= 0x61 && cp <= 0x66); // a..f\n\t    },\n\t    isOctalDigit: function (cp) {\n\t        return (cp >= 0x30 && cp <= 0x37); // 0..7\n\t    }\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar jsx_syntax_1 = __webpack_require__(6);\n\t/* tslint:disable:max-classes-per-file */\n\tvar JSXClosingElement = (function () {\n\t    function JSXClosingElement(name) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;\n\t        this.name = name;\n\t    }\n\t    return JSXClosingElement;\n\t}());\n\texports.JSXClosingElement = JSXClosingElement;\n\tvar JSXElement = (function () {\n\t    function JSXElement(openingElement, children, closingElement) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXElement;\n\t        this.openingElement = openingElement;\n\t        this.children = children;\n\t        this.closingElement = closingElement;\n\t    }\n\t    return JSXElement;\n\t}());\n\texports.JSXElement = JSXElement;\n\tvar JSXEmptyExpression = (function () {\n\t    function JSXEmptyExpression() {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;\n\t    }\n\t    return JSXEmptyExpression;\n\t}());\n\texports.JSXEmptyExpression = JSXEmptyExpression;\n\tvar JSXExpressionContainer = (function () {\n\t    function JSXExpressionContainer(expression) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;\n\t        this.expression = expression;\n\t    }\n\t    return JSXExpressionContainer;\n\t}());\n\texports.JSXExpressionContainer = JSXExpressionContainer;\n\tvar JSXIdentifier = (function () {\n\t    function JSXIdentifier(name) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;\n\t        this.name = name;\n\t    }\n\t    return JSXIdentifier;\n\t}());\n\texports.JSXIdentifier = JSXIdentifier;\n\tvar JSXMemberExpression = (function () {\n\t    function JSXMemberExpression(object, property) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;\n\t        this.object = object;\n\t        this.property = property;\n\t    }\n\t    return JSXMemberExpression;\n\t}());\n\texports.JSXMemberExpression = JSXMemberExpression;\n\tvar JSXAttribute = (function () {\n\t    function JSXAttribute(name, value) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;\n\t        this.name = name;\n\t        this.value = value;\n\t    }\n\t    return JSXAttribute;\n\t}());\n\texports.JSXAttribute = JSXAttribute;\n\tvar JSXNamespacedName = (function () {\n\t    function JSXNamespacedName(namespace, name) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;\n\t        this.namespace = namespace;\n\t        this.name = name;\n\t    }\n\t    return JSXNamespacedName;\n\t}());\n\texports.JSXNamespacedName = JSXNamespacedName;\n\tvar JSXOpeningElement = (function () {\n\t    function JSXOpeningElement(name, selfClosing, attributes) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;\n\t        this.name = name;\n\t        this.selfClosing = selfClosing;\n\t        this.attributes = attributes;\n\t    }\n\t    return JSXOpeningElement;\n\t}());\n\texports.JSXOpeningElement = JSXOpeningElement;\n\tvar JSXSpreadAttribute = (function () {\n\t    function JSXSpreadAttribute(argument) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;\n\t        this.argument = argument;\n\t    }\n\t    return JSXSpreadAttribute;\n\t}());\n\texports.JSXSpreadAttribute = JSXSpreadAttribute;\n\tvar JSXText = (function () {\n\t    function JSXText(value, raw) {\n\t        this.type = jsx_syntax_1.JSXSyntax.JSXText;\n\t        this.value = value;\n\t        this.raw = raw;\n\t    }\n\t    return JSXText;\n\t}());\n\texports.JSXText = JSXText;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.JSXSyntax = {\n\t    JSXAttribute: 'JSXAttribute',\n\t    JSXClosingElement: 'JSXClosingElement',\n\t    JSXElement: 'JSXElement',\n\t    JSXEmptyExpression: 'JSXEmptyExpression',\n\t    JSXExpressionContainer: 'JSXExpressionContainer',\n\t    JSXIdentifier: 'JSXIdentifier',\n\t    JSXMemberExpression: 'JSXMemberExpression',\n\t    JSXNamespacedName: 'JSXNamespacedName',\n\t    JSXOpeningElement: 'JSXOpeningElement',\n\t    JSXSpreadAttribute: 'JSXSpreadAttribute',\n\t    JSXText: 'JSXText'\n\t};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar syntax_1 = __webpack_require__(2);\n\t/* tslint:disable:max-classes-per-file */\n\tvar ArrayExpression = (function () {\n\t    function ArrayExpression(elements) {\n\t        this.type = syntax_1.Syntax.ArrayExpression;\n\t        this.elements = elements;\n\t    }\n\t    return ArrayExpression;\n\t}());\n\texports.ArrayExpression = ArrayExpression;\n\tvar ArrayPattern = (function () {\n\t    function ArrayPattern(elements) {\n\t        this.type = syntax_1.Syntax.ArrayPattern;\n\t        this.elements = elements;\n\t    }\n\t    return ArrayPattern;\n\t}());\n\texports.ArrayPattern = ArrayPattern;\n\tvar ArrowFunctionExpression = (function () {\n\t    function ArrowFunctionExpression(params, body, expression) {\n\t        this.type = syntax_1.Syntax.ArrowFunctionExpression;\n\t        this.id = null;\n\t        this.params = params;\n\t        this.body = body;\n\t        this.generator = false;\n\t        this.expression = expression;\n\t        this.async = false;\n\t    }\n\t    return ArrowFunctionExpression;\n\t}());\n\texports.ArrowFunctionExpression = ArrowFunctionExpression;\n\tvar AssignmentExpression = (function () {\n\t    function AssignmentExpression(operator, left, right) {\n\t        this.type = syntax_1.Syntax.AssignmentExpression;\n\t        this.operator = operator;\n\t        this.left = left;\n\t        this.right = right;\n\t    }\n\t    return AssignmentExpression;\n\t}());\n\texports.AssignmentExpression = AssignmentExpression;\n\tvar AssignmentPattern = (function () {\n\t    function AssignmentPattern(left, right) {\n\t        this.type = syntax_1.Syntax.AssignmentPattern;\n\t        this.left = left;\n\t        this.right = right;\n\t    }\n\t    return AssignmentPattern;\n\t}());\n\texports.AssignmentPattern = AssignmentPattern;\n\tvar AsyncArrowFunctionExpression = (function () {\n\t    function AsyncArrowFunctionExpression(params, body, expression) {\n\t        this.type = syntax_1.Syntax.ArrowFunctionExpression;\n\t        this.id = null;\n\t        this.params = params;\n\t        this.body = body;\n\t        this.generator = false;\n\t        this.expression = expression;\n\t        this.async = true;\n\t    }\n\t    return AsyncArrowFunctionExpression;\n\t}());\n\texports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;\n\tvar AsyncFunctionDeclaration = (function () {\n\t    function AsyncFunctionDeclaration(id, params, body) {\n\t        this.type = syntax_1.Syntax.FunctionDeclaration;\n\t        this.id = id;\n\t        this.params = params;\n\t        this.body = body;\n\t        this.generator = false;\n\t        this.expression = false;\n\t        this.async = true;\n\t    }\n\t    return AsyncFunctionDeclaration;\n\t}());\n\texports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;\n\tvar AsyncFunctionExpression = (function () {\n\t    function AsyncFunctionExpression(id, params, body) {\n\t        this.type = syntax_1.Syntax.FunctionExpression;\n\t        this.id = id;\n\t        this.params = params;\n\t        this.body = body;\n\t        this.generator = false;\n\t        this.expression = false;\n\t        this.async = true;\n\t    }\n\t    return AsyncFunctionExpression;\n\t}());\n\texports.AsyncFunctionExpression = AsyncFunctionExpression;\n\tvar AwaitExpression = (function () {\n\t    function AwaitExpression(argument) {\n\t        this.type = syntax_1.Syntax.AwaitExpression;\n\t        this.argument = argument;\n\t    }\n\t    return AwaitExpression;\n\t}());\n\texports.AwaitExpression = AwaitExpression;\n\tvar BinaryExpression = (function () {\n\t    function BinaryExpression(operator, left, right) {\n\t        var logical = (operator === '||' || operator === '&&');\n\t        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;\n\t        this.operator = operator;\n\t        this.left = left;\n\t        this.right = right;\n\t    }\n\t    return BinaryExpression;\n\t}());\n\texports.BinaryExpression = BinaryExpression;\n\tvar BlockStatement = (function () {\n\t    function BlockStatement(body) {\n\t        this.type = syntax_1.Syntax.BlockStatement;\n\t        this.body = body;\n\t    }\n\t    return BlockStatement;\n\t}());\n\texports.BlockStatement = BlockStatement;\n\tvar BreakStatement = (function () {\n\t    function BreakStatement(label) {\n\t        this.type = syntax_1.Syntax.BreakStatement;\n\t        this.label = label;\n\t    }\n\t    return BreakStatement;\n\t}());\n\texports.BreakStatement = BreakStatement;\n\tvar CallExpression = (function () {\n\t    function CallExpression(callee, args) {\n\t        this.type = syntax_1.Syntax.CallExpression;\n\t        this.callee = callee;\n\t        this.arguments = args;\n\t    }\n\t    return CallExpression;\n\t}());\n\texports.CallExpression = CallExpression;\n\tvar CatchClause = (function () {\n\t    function CatchClause(param, body) {\n\t        this.type = syntax_1.Syntax.CatchClause;\n\t        this.param = param;\n\t        this.body = body;\n\t    }\n\t    return CatchClause;\n\t}());\n\texports.CatchClause = CatchClause;\n\tvar ClassBody = (function () {\n\t    function ClassBody(body) {\n\t        this.type = syntax_1.Syntax.ClassBody;\n\t        this.body = body;\n\t    }\n\t    return ClassBody;\n\t}());\n\texports.ClassBody = ClassBody;\n\tvar ClassDeclaration = (function () {\n\t    function ClassDeclaration(id, superClass, body) {\n\t        this.type = syntax_1.Syntax.ClassDeclaration;\n\t        this.id = id;\n\t        this.superClass = superClass;\n\t        this.body = body;\n\t    }\n\t    return ClassDeclaration;\n\t}());\n\texports.ClassDeclaration = ClassDeclaration;\n\tvar ClassExpression = (function () {\n\t    function ClassExpression(id, superClass, body) {\n\t        this.type = syntax_1.Syntax.ClassExpression;\n\t        this.id = id;\n\t        this.superClass = superClass;\n\t        this.body = body;\n\t    }\n\t    return ClassExpression;\n\t}());\n\texports.ClassExpression = ClassExpression;\n\tvar ComputedMemberExpression = (function () {\n\t    function ComputedMemberExpression(object, property) {\n\t        this.type = syntax_1.Syntax.MemberExpression;\n\t        this.computed = true;\n\t        this.object = object;\n\t        this.property = property;\n\t    }\n\t    return ComputedMemberExpression;\n\t}());\n\texports.ComputedMemberExpression = ComputedMemberExpression;\n\tvar ConditionalExpression = (function () {\n\t    function ConditionalExpression(test, consequent, alternate) {\n\t        this.type = syntax_1.Syntax.ConditionalExpression;\n\t        this.test = test;\n\t        this.consequent = consequent;\n\t        this.alternate = alternate;\n\t    }\n\t    return ConditionalExpression;\n\t}());\n\texports.ConditionalExpression = ConditionalExpression;\n\tvar ContinueStatement = (function () {\n\t    function ContinueStatement(label) {\n\t        this.type = syntax_1.Syntax.ContinueStatement;\n\t        this.label = label;\n\t    }\n\t    return ContinueStatement;\n\t}());\n\texports.ContinueStatement = ContinueStatement;\n\tvar DebuggerStatement = (function () {\n\t    function DebuggerStatement() {\n\t        this.type = syntax_1.Syntax.DebuggerStatement;\n\t    }\n\t    return DebuggerStatement;\n\t}());\n\texports.DebuggerStatement = DebuggerStatement;\n\tvar Directive = (function () {\n\t    function Directive(expression, directive) {\n\t        this.type = syntax_1.Syntax.ExpressionStatement;\n\t        this.expression = expression;\n\t        this.directive = directive;\n\t    }\n\t    return Directive;\n\t}());\n\texports.Directive = Directive;\n\tvar DoWhileStatement = (function () {\n\t    function DoWhileStatement(body, test) {\n\t        this.type = syntax_1.Syntax.DoWhileStatement;\n\t        this.body = body;\n\t        this.test = test;\n\t    }\n\t    return DoWhileStatement;\n\t}());\n\texports.DoWhileStatement = DoWhileStatement;\n\tvar EmptyStatement = (function () {\n\t    function EmptyStatement() {\n\t        this.type = syntax_1.Syntax.EmptyStatement;\n\t    }\n\t    return EmptyStatement;\n\t}());\n\texports.EmptyStatement = EmptyStatement;\n\tvar ExportAllDeclaration = (function () {\n\t    function ExportAllDeclaration(source) {\n\t        this.type = syntax_1.Syntax.ExportAllDeclaration;\n\t        this.source = source;\n\t    }\n\t    return ExportAllDeclaration;\n\t}());\n\texports.ExportAllDeclaration = ExportAllDeclaration;\n\tvar ExportDefaultDeclaration = (function () {\n\t    function ExportDefaultDeclaration(declaration) {\n\t        this.type = syntax_1.Syntax.ExportDefaultDeclaration;\n\t        this.declaration = declaration;\n\t    }\n\t    return ExportDefaultDeclaration;\n\t}());\n\texports.ExportDefaultDeclaration = ExportDefaultDeclaration;\n\tvar ExportNamedDeclaration = (function () {\n\t    function ExportNamedDeclaration(declaration, specifiers, source) {\n\t        this.type = syntax_1.Syntax.ExportNamedDeclaration;\n\t        this.declaration = declaration;\n\t        this.specifiers = specifiers;\n\t        this.source = source;\n\t    }\n\t    return ExportNamedDeclaration;\n\t}());\n\texports.ExportNamedDeclaration = ExportNamedDeclaration;\n\tvar ExportSpecifier = (function () {\n\t    function ExportSpecifier(local, exported) {\n\t        this.type = syntax_1.Syntax.ExportSpecifier;\n\t        this.exported = exported;\n\t        this.local = local;\n\t    }\n\t    return ExportSpecifier;\n\t}());\n\texports.ExportSpecifier = ExportSpecifier;\n\tvar ExpressionStatement = (function () {\n\t    function ExpressionStatement(expression) {\n\t        this.type = syntax_1.Syntax.ExpressionStatement;\n\t        this.expression = expression;\n\t    }\n\t    return ExpressionStatement;\n\t}());\n\texports.ExpressionStatement = ExpressionStatement;\n\tvar ForInStatement = (function () {\n\t    function ForInStatement(left, right, body) {\n\t        this.type = syntax_1.Syntax.ForInStatement;\n\t        this.left = left;\n\t        this.right = right;\n\t        this.body = body;\n\t        this.each = false;\n\t    }\n\t    return ForInStatement;\n\t}());\n\texports.ForInStatement = ForInStatement;\n\tvar ForOfStatement = (function () {\n\t    function ForOfStatement(left, right, body) {\n\t        this.type = syntax_1.Syntax.ForOfStatement;\n\t        this.left = left;\n\t        this.right = right;\n\t        this.body = body;\n\t    }\n\t    return ForOfStatement;\n\t}());\n\texports.ForOfStatement = ForOfStatement;\n\tvar ForStatement = (function () {\n\t    function ForStatement(init, test, update, body) {\n\t        this.type = syntax_1.Syntax.ForStatement;\n\t        this.init = init;\n\t        this.test = test;\n\t        this.update = update;\n\t        this.body = body;\n\t    }\n\t    return ForStatement;\n\t}());\n\texports.ForStatement = ForStatement;\n\tvar FunctionDeclaration = (function () {\n\t    function FunctionDeclaration(id, params, body, generator) {\n\t        this.type = syntax_1.Syntax.FunctionDeclaration;\n\t        this.id = id;\n\t        this.params = params;\n\t        this.body = body;\n\t        this.generator = generator;\n\t        this.expression = false;\n\t        this.async = false;\n\t    }\n\t    return FunctionDeclaration;\n\t}());\n\texports.FunctionDeclaration = FunctionDeclaration;\n\tvar FunctionExpression = (function () {\n\t    function FunctionExpression(id, params, body, generator) {\n\t        this.type = syntax_1.Syntax.FunctionExpression;\n\t        this.id = id;\n\t        this.params = params;\n\t        this.body = body;\n\t        this.generator = generator;\n\t        this.expression = false;\n\t        this.async = false;\n\t    }\n\t    return FunctionExpression;\n\t}());\n\texports.FunctionExpression = FunctionExpression;\n\tvar Identifier = (function () {\n\t    function Identifier(name) {\n\t        this.type = syntax_1.Syntax.Identifier;\n\t        this.name = name;\n\t    }\n\t    return Identifier;\n\t}());\n\texports.Identifier = Identifier;\n\tvar IfStatement = (function () {\n\t    function IfStatement(test, consequent, alternate) {\n\t        this.type = syntax_1.Syntax.IfStatement;\n\t        this.test = test;\n\t        this.consequent = consequent;\n\t        this.alternate = alternate;\n\t    }\n\t    return IfStatement;\n\t}());\n\texports.IfStatement = IfStatement;\n\tvar ImportDeclaration = (function () {\n\t    function ImportDeclaration(specifiers, source) {\n\t        this.type = syntax_1.Syntax.ImportDeclaration;\n\t        this.specifiers = specifiers;\n\t        this.source = source;\n\t    }\n\t    return ImportDeclaration;\n\t}());\n\texports.ImportDeclaration = ImportDeclaration;\n\tvar ImportDefaultSpecifier = (function () {\n\t    function ImportDefaultSpecifier(local) {\n\t        this.type = syntax_1.Syntax.ImportDefaultSpecifier;\n\t        this.local = local;\n\t    }\n\t    return ImportDefaultSpecifier;\n\t}());\n\texports.ImportDefaultSpecifier = ImportDefaultSpecifier;\n\tvar ImportNamespaceSpecifier = (function () {\n\t    function ImportNamespaceSpecifier(local) {\n\t        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;\n\t        this.local = local;\n\t    }\n\t    return ImportNamespaceSpecifier;\n\t}());\n\texports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\n\tvar ImportSpecifier = (function () {\n\t    function ImportSpecifier(local, imported) {\n\t        this.type = syntax_1.Syntax.ImportSpecifier;\n\t        this.local = local;\n\t        this.imported = imported;\n\t    }\n\t    return ImportSpecifier;\n\t}());\n\texports.ImportSpecifier = ImportSpecifier;\n\tvar LabeledStatement = (function () {\n\t    function LabeledStatement(label, body) {\n\t        this.type = syntax_1.Syntax.LabeledStatement;\n\t        this.label = label;\n\t        this.body = body;\n\t    }\n\t    return LabeledStatement;\n\t}());\n\texports.LabeledStatement = LabeledStatement;\n\tvar Literal = (function () {\n\t    function Literal(value, raw) {\n\t        this.type = syntax_1.Syntax.Literal;\n\t        this.value = value;\n\t        this.raw = raw;\n\t    }\n\t    return Literal;\n\t}());\n\texports.Literal = Literal;\n\tvar MetaProperty = (function () {\n\t    function MetaProperty(meta, property) {\n\t        this.type = syntax_1.Syntax.MetaProperty;\n\t        this.meta = meta;\n\t        this.property = property;\n\t    }\n\t    return MetaProperty;\n\t}());\n\texports.MetaProperty = MetaProperty;\n\tvar MethodDefinition = (function () {\n\t    function MethodDefinition(key, computed, value, kind, isStatic) {\n\t        this.type = syntax_1.Syntax.MethodDefinition;\n\t        this.key = key;\n\t        this.computed = computed;\n\t        this.value = value;\n\t        this.kind = kind;\n\t        this.static = isStatic;\n\t    }\n\t    return MethodDefinition;\n\t}());\n\texports.MethodDefinition = MethodDefinition;\n\tvar Module = (function () {\n\t    function Module(body) {\n\t        this.type = syntax_1.Syntax.Program;\n\t        this.body = body;\n\t        this.sourceType = 'module';\n\t    }\n\t    return Module;\n\t}());\n\texports.Module = Module;\n\tvar NewExpression = (function () {\n\t    function NewExpression(callee, args) {\n\t        this.type = syntax_1.Syntax.NewExpression;\n\t        this.callee = callee;\n\t        this.arguments = args;\n\t    }\n\t    return NewExpression;\n\t}());\n\texports.NewExpression = NewExpression;\n\tvar ObjectExpression = (function () {\n\t    function ObjectExpression(properties) {\n\t        this.type = syntax_1.Syntax.ObjectExpression;\n\t        this.properties = properties;\n\t    }\n\t    return ObjectExpression;\n\t}());\n\texports.ObjectExpression = ObjectExpression;\n\tvar ObjectPattern = (function () {\n\t    function ObjectPattern(properties) {\n\t        this.type = syntax_1.Syntax.ObjectPattern;\n\t        this.properties = properties;\n\t    }\n\t    return ObjectPattern;\n\t}());\n\texports.ObjectPattern = ObjectPattern;\n\tvar Property = (function () {\n\t    function Property(kind, key, computed, value, method, shorthand) {\n\t        this.type = syntax_1.Syntax.Property;\n\t        this.key = key;\n\t        this.computed = computed;\n\t        this.value = value;\n\t        this.kind = kind;\n\t        this.method = method;\n\t        this.shorthand = shorthand;\n\t    }\n\t    return Property;\n\t}());\n\texports.Property = Property;\n\tvar RegexLiteral = (function () {\n\t    function RegexLiteral(value, raw, pattern, flags) {\n\t        this.type = syntax_1.Syntax.Literal;\n\t        this.value = value;\n\t        this.raw = raw;\n\t        this.regex = { pattern: pattern, flags: flags };\n\t    }\n\t    return RegexLiteral;\n\t}());\n\texports.RegexLiteral = RegexLiteral;\n\tvar RestElement = (function () {\n\t    function RestElement(argument) {\n\t        this.type = syntax_1.Syntax.RestElement;\n\t        this.argument = argument;\n\t    }\n\t    return RestElement;\n\t}());\n\texports.RestElement = RestElement;\n\tvar ReturnStatement = (function () {\n\t    function ReturnStatement(argument) {\n\t        this.type = syntax_1.Syntax.ReturnStatement;\n\t        this.argument = argument;\n\t    }\n\t    return ReturnStatement;\n\t}());\n\texports.ReturnStatement = ReturnStatement;\n\tvar Script = (function () {\n\t    function Script(body) {\n\t        this.type = syntax_1.Syntax.Program;\n\t        this.body = body;\n\t        this.sourceType = 'script';\n\t    }\n\t    return Script;\n\t}());\n\texports.Script = Script;\n\tvar SequenceExpression = (function () {\n\t    function SequenceExpression(expressions) {\n\t        this.type = syntax_1.Syntax.SequenceExpression;\n\t        this.expressions = expressions;\n\t    }\n\t    return SequenceExpression;\n\t}());\n\texports.SequenceExpression = SequenceExpression;\n\tvar SpreadElement = (function () {\n\t    function SpreadElement(argument) {\n\t        this.type = syntax_1.Syntax.SpreadElement;\n\t        this.argument = argument;\n\t    }\n\t    return SpreadElement;\n\t}());\n\texports.SpreadElement = SpreadElement;\n\tvar StaticMemberExpression = (function () {\n\t    function StaticMemberExpression(object, property) {\n\t        this.type = syntax_1.Syntax.MemberExpression;\n\t        this.computed = false;\n\t        this.object = object;\n\t        this.property = property;\n\t    }\n\t    return StaticMemberExpression;\n\t}());\n\texports.StaticMemberExpression = StaticMemberExpression;\n\tvar Super = (function () {\n\t    function Super() {\n\t        this.type = syntax_1.Syntax.Super;\n\t    }\n\t    return Super;\n\t}());\n\texports.Super = Super;\n\tvar SwitchCase = (function () {\n\t    function SwitchCase(test, consequent) {\n\t        this.type = syntax_1.Syntax.SwitchCase;\n\t        this.test = test;\n\t        this.consequent = consequent;\n\t    }\n\t    return SwitchCase;\n\t}());\n\texports.SwitchCase = SwitchCase;\n\tvar SwitchStatement = (function () {\n\t    function SwitchStatement(discriminant, cases) {\n\t        this.type = syntax_1.Syntax.SwitchStatement;\n\t        this.discriminant = discriminant;\n\t        this.cases = cases;\n\t    }\n\t    return SwitchStatement;\n\t}());\n\texports.SwitchStatement = SwitchStatement;\n\tvar TaggedTemplateExpression = (function () {\n\t    function TaggedTemplateExpression(tag, quasi) {\n\t        this.type = syntax_1.Syntax.TaggedTemplateExpression;\n\t        this.tag = tag;\n\t        this.quasi = quasi;\n\t    }\n\t    return TaggedTemplateExpression;\n\t}());\n\texports.TaggedTemplateExpression = TaggedTemplateExpression;\n\tvar TemplateElement = (function () {\n\t    function TemplateElement(value, tail) {\n\t        this.type = syntax_1.Syntax.TemplateElement;\n\t        this.value = value;\n\t        this.tail = tail;\n\t    }\n\t    return TemplateElement;\n\t}());\n\texports.TemplateElement = TemplateElement;\n\tvar TemplateLiteral = (function () {\n\t    function TemplateLiteral(quasis, expressions) {\n\t        this.type = syntax_1.Syntax.TemplateLiteral;\n\t        this.quasis = quasis;\n\t        this.expressions = expressions;\n\t    }\n\t    return TemplateLiteral;\n\t}());\n\texports.TemplateLiteral = TemplateLiteral;\n\tvar ThisExpression = (function () {\n\t    function ThisExpression() {\n\t        this.type = syntax_1.Syntax.ThisExpression;\n\t    }\n\t    return ThisExpression;\n\t}());\n\texports.ThisExpression = ThisExpression;\n\tvar ThrowStatement = (function () {\n\t    function ThrowStatement(argument) {\n\t        this.type = syntax_1.Syntax.ThrowStatement;\n\t        this.argument = argument;\n\t    }\n\t    return ThrowStatement;\n\t}());\n\texports.ThrowStatement = ThrowStatement;\n\tvar TryStatement = (function () {\n\t    function TryStatement(block, handler, finalizer) {\n\t        this.type = syntax_1.Syntax.TryStatement;\n\t        this.block = block;\n\t        this.handler = handler;\n\t        this.finalizer = finalizer;\n\t    }\n\t    return TryStatement;\n\t}());\n\texports.TryStatement = TryStatement;\n\tvar UnaryExpression = (function () {\n\t    function UnaryExpression(operator, argument) {\n\t        this.type = syntax_1.Syntax.UnaryExpression;\n\t        this.operator = operator;\n\t        this.argument = argument;\n\t        this.prefix = true;\n\t    }\n\t    return UnaryExpression;\n\t}());\n\texports.UnaryExpression = UnaryExpression;\n\tvar UpdateExpression = (function () {\n\t    function UpdateExpression(operator, argument, prefix) {\n\t        this.type = syntax_1.Syntax.UpdateExpression;\n\t        this.operator = operator;\n\t        this.argument = argument;\n\t        this.prefix = prefix;\n\t    }\n\t    return UpdateExpression;\n\t}());\n\texports.UpdateExpression = UpdateExpression;\n\tvar VariableDeclaration = (function () {\n\t    function VariableDeclaration(declarations, kind) {\n\t        this.type = syntax_1.Syntax.VariableDeclaration;\n\t        this.declarations = declarations;\n\t        this.kind = kind;\n\t    }\n\t    return VariableDeclaration;\n\t}());\n\texports.VariableDeclaration = VariableDeclaration;\n\tvar VariableDeclarator = (function () {\n\t    function VariableDeclarator(id, init) {\n\t        this.type = syntax_1.Syntax.VariableDeclarator;\n\t        this.id = id;\n\t        this.init = init;\n\t    }\n\t    return VariableDeclarator;\n\t}());\n\texports.VariableDeclarator = VariableDeclarator;\n\tvar WhileStatement = (function () {\n\t    function WhileStatement(test, body) {\n\t        this.type = syntax_1.Syntax.WhileStatement;\n\t        this.test = test;\n\t        this.body = body;\n\t    }\n\t    return WhileStatement;\n\t}());\n\texports.WhileStatement = WhileStatement;\n\tvar WithStatement = (function () {\n\t    function WithStatement(object, body) {\n\t        this.type = syntax_1.Syntax.WithStatement;\n\t        this.object = object;\n\t        this.body = body;\n\t    }\n\t    return WithStatement;\n\t}());\n\texports.WithStatement = WithStatement;\n\tvar YieldExpression = (function () {\n\t    function YieldExpression(argument, delegate) {\n\t        this.type = syntax_1.Syntax.YieldExpression;\n\t        this.argument = argument;\n\t        this.delegate = delegate;\n\t    }\n\t    return YieldExpression;\n\t}());\n\texports.YieldExpression = YieldExpression;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar assert_1 = __webpack_require__(9);\n\tvar error_handler_1 = __webpack_require__(10);\n\tvar messages_1 = __webpack_require__(11);\n\tvar Node = __webpack_require__(7);\n\tvar scanner_1 = __webpack_require__(12);\n\tvar syntax_1 = __webpack_require__(2);\n\tvar token_1 = __webpack_require__(13);\n\tvar ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';\n\tvar Parser = (function () {\n\t    function Parser(code, options, delegate) {\n\t        if (options === void 0) { options = {}; }\n\t        this.config = {\n\t            range: (typeof options.range === 'boolean') && options.range,\n\t            loc: (typeof options.loc === 'boolean') && options.loc,\n\t            source: null,\n\t            tokens: (typeof options.tokens === 'boolean') && options.tokens,\n\t            comment: (typeof options.comment === 'boolean') && options.comment,\n\t            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant\n\t        };\n\t        if (this.config.loc && options.source && options.source !== null) {\n\t            this.config.source = String(options.source);\n\t        }\n\t        this.delegate = delegate;\n\t        this.errorHandler = new error_handler_1.ErrorHandler();\n\t        this.errorHandler.tolerant = this.config.tolerant;\n\t        this.scanner = new scanner_1.Scanner(code, this.errorHandler);\n\t        this.scanner.trackComment = this.config.comment;\n\t        this.operatorPrecedence = {\n\t            ')': 0,\n\t            ';': 0,\n\t            ',': 0,\n\t            '=': 0,\n\t            ']': 0,\n\t            '||': 1,\n\t            '&&': 2,\n\t            '|': 3,\n\t            '^': 4,\n\t            '&': 5,\n\t            '==': 6,\n\t            '!=': 6,\n\t            '===': 6,\n\t            '!==': 6,\n\t            '<': 7,\n\t            '>': 7,\n\t            '<=': 7,\n\t            '>=': 7,\n\t            '<<': 8,\n\t            '>>': 8,\n\t            '>>>': 8,\n\t            '+': 9,\n\t            '-': 9,\n\t            '*': 11,\n\t            '/': 11,\n\t            '%': 11\n\t        };\n\t        this.lookahead = {\n\t            type: 2 /* EOF */,\n\t            value: '',\n\t            lineNumber: this.scanner.lineNumber,\n\t            lineStart: 0,\n\t            start: 0,\n\t            end: 0\n\t        };\n\t        this.hasLineTerminator = false;\n\t        this.context = {\n\t            isModule: false,\n\t            await: false,\n\t            allowIn: true,\n\t            allowStrictDirective: true,\n\t            allowYield: true,\n\t            firstCoverInitializedNameError: null,\n\t            isAssignmentTarget: false,\n\t            isBindingElement: false,\n\t            inFunctionBody: false,\n\t            inIteration: false,\n\t            inSwitch: false,\n\t            labelSet: {},\n\t            strict: false\n\t        };\n\t        this.tokens = [];\n\t        this.startMarker = {\n\t            index: 0,\n\t            line: this.scanner.lineNumber,\n\t            column: 0\n\t        };\n\t        this.lastMarker = {\n\t            index: 0,\n\t            line: this.scanner.lineNumber,\n\t            column: 0\n\t        };\n\t        this.nextToken();\n\t        this.lastMarker = {\n\t            index: this.scanner.index,\n\t            line: this.scanner.lineNumber,\n\t            column: this.scanner.index - this.scanner.lineStart\n\t        };\n\t    }\n\t    Parser.prototype.throwError = function (messageFormat) {\n\t        var values = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            values[_i - 1] = arguments[_i];\n\t        }\n\t        var args = Array.prototype.slice.call(arguments, 1);\n\t        var msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n\t            assert_1.assert(idx < args.length, 'Message reference must be in range');\n\t            return args[idx];\n\t        });\n\t        var index = this.lastMarker.index;\n\t        var line = this.lastMarker.line;\n\t        var column = this.lastMarker.column + 1;\n\t        throw this.errorHandler.createError(index, line, column, msg);\n\t    };\n\t    Parser.prototype.tolerateError = function (messageFormat) {\n\t        var values = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            values[_i - 1] = arguments[_i];\n\t        }\n\t        var args = Array.prototype.slice.call(arguments, 1);\n\t        var msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n\t            assert_1.assert(idx < args.length, 'Message reference must be in range');\n\t            return args[idx];\n\t        });\n\t        var index = this.lastMarker.index;\n\t        var line = this.scanner.lineNumber;\n\t        var column = this.lastMarker.column + 1;\n\t        this.errorHandler.tolerateError(index, line, column, msg);\n\t    };\n\t    // Throw an exception because of the token.\n\t    Parser.prototype.unexpectedTokenError = function (token, message) {\n\t        var msg = message || messages_1.Messages.UnexpectedToken;\n\t        var value;\n\t        if (token) {\n\t            if (!message) {\n\t                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :\n\t                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :\n\t                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :\n\t                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :\n\t                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :\n\t                                    messages_1.Messages.UnexpectedToken;\n\t                if (token.type === 4 /* Keyword */) {\n\t                    if (this.scanner.isFutureReservedWord(token.value)) {\n\t                        msg = messages_1.Messages.UnexpectedReserved;\n\t                    }\n\t                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {\n\t                        msg = messages_1.Messages.StrictReservedWord;\n\t                    }\n\t                }\n\t            }\n\t            value = token.value;\n\t        }\n\t        else {\n\t            value = 'ILLEGAL';\n\t        }\n\t        msg = msg.replace('%0', value);\n\t        if (token && typeof token.lineNumber === 'number') {\n\t            var index = token.start;\n\t            var line = token.lineNumber;\n\t            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;\n\t            var column = token.start - lastMarkerLineStart + 1;\n\t            return this.errorHandler.createError(index, line, column, msg);\n\t        }\n\t        else {\n\t            var index = this.lastMarker.index;\n\t            var line = this.lastMarker.line;\n\t            var column = this.lastMarker.column + 1;\n\t            return this.errorHandler.createError(index, line, column, msg);\n\t        }\n\t    };\n\t    Parser.prototype.throwUnexpectedToken = function (token, message) {\n\t        throw this.unexpectedTokenError(token, message);\n\t    };\n\t    Parser.prototype.tolerateUnexpectedToken = function (token, message) {\n\t        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));\n\t    };\n\t    Parser.prototype.collectComments = function () {\n\t        if (!this.config.comment) {\n\t            this.scanner.scanComments();\n\t        }\n\t        else {\n\t            var comments = this.scanner.scanComments();\n\t            if (comments.length > 0 && this.delegate) {\n\t                for (var i = 0; i < comments.length; ++i) {\n\t                    var e = comments[i];\n\t                    var node = void 0;\n\t                    node = {\n\t                        type: e.multiLine ? 'BlockComment' : 'LineComment',\n\t                        value: this.scanner.source.slice(e.slice[0], e.slice[1])\n\t                    };\n\t                    if (this.config.range) {\n\t                        node.range = e.range;\n\t                    }\n\t                    if (this.config.loc) {\n\t                        node.loc = e.loc;\n\t                    }\n\t                    var metadata = {\n\t                        start: {\n\t                            line: e.loc.start.line,\n\t                            column: e.loc.start.column,\n\t                            offset: e.range[0]\n\t                        },\n\t                        end: {\n\t                            line: e.loc.end.line,\n\t                            column: e.loc.end.column,\n\t                            offset: e.range[1]\n\t                        }\n\t                    };\n\t                    this.delegate(node, metadata);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // From internal representation to an external structure\n\t    Parser.prototype.getTokenRaw = function (token) {\n\t        return this.scanner.source.slice(token.start, token.end);\n\t    };\n\t    Parser.prototype.convertToken = function (token) {\n\t        var t = {\n\t            type: token_1.TokenName[token.type],\n\t            value: this.getTokenRaw(token)\n\t        };\n\t        if (this.config.range) {\n\t            t.range = [token.start, token.end];\n\t        }\n\t        if (this.config.loc) {\n\t            t.loc = {\n\t                start: {\n\t                    line: this.startMarker.line,\n\t                    column: this.startMarker.column\n\t                },\n\t                end: {\n\t                    line: this.scanner.lineNumber,\n\t                    column: this.scanner.index - this.scanner.lineStart\n\t                }\n\t            };\n\t        }\n\t        if (token.type === 9 /* RegularExpression */) {\n\t            var pattern = token.pattern;\n\t            var flags = token.flags;\n\t            t.regex = { pattern: pattern, flags: flags };\n\t        }\n\t        return t;\n\t    };\n\t    Parser.prototype.nextToken = function () {\n\t        var token = this.lookahead;\n\t        this.lastMarker.index = this.scanner.index;\n\t        this.lastMarker.line = this.scanner.lineNumber;\n\t        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n\t        this.collectComments();\n\t        if (this.scanner.index !== this.startMarker.index) {\n\t            this.startMarker.index = this.scanner.index;\n\t            this.startMarker.line = this.scanner.lineNumber;\n\t            this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n\t        }\n\t        var next = this.scanner.lex();\n\t        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);\n\t        if (next && this.context.strict && next.type === 3 /* Identifier */) {\n\t            if (this.scanner.isStrictModeReservedWord(next.value)) {\n\t                next.type = 4 /* Keyword */;\n\t            }\n\t        }\n\t        this.lookahead = next;\n\t        if (this.config.tokens && next.type !== 2 /* EOF */) {\n\t            this.tokens.push(this.convertToken(next));\n\t        }\n\t        return token;\n\t    };\n\t    Parser.prototype.nextRegexToken = function () {\n\t        this.collectComments();\n\t        var token = this.scanner.scanRegExp();\n\t        if (this.config.tokens) {\n\t            // Pop the previous token, '/' or '/='\n\t            // This is added from the lookahead token.\n\t            this.tokens.pop();\n\t            this.tokens.push(this.convertToken(token));\n\t        }\n\t        // Prime the next lookahead.\n\t        this.lookahead = token;\n\t        this.nextToken();\n\t        return token;\n\t    };\n\t    Parser.prototype.createNode = function () {\n\t        return {\n\t            index: this.startMarker.index,\n\t            line: this.startMarker.line,\n\t            column: this.startMarker.column\n\t        };\n\t    };\n\t    Parser.prototype.startNode = function (token, lastLineStart) {\n\t        if (lastLineStart === void 0) { lastLineStart = 0; }\n\t        var column = token.start - token.lineStart;\n\t        var line = token.lineNumber;\n\t        if (column < 0) {\n\t            column += lastLineStart;\n\t            line--;\n\t        }\n\t        return {\n\t            index: token.start,\n\t            line: line,\n\t            column: column\n\t        };\n\t    };\n\t    Parser.prototype.finalize = function (marker, node) {\n\t        if (this.config.range) {\n\t            node.range = [marker.index, this.lastMarker.index];\n\t        }\n\t        if (this.config.loc) {\n\t            node.loc = {\n\t                start: {\n\t                    line: marker.line,\n\t                    column: marker.column,\n\t                },\n\t                end: {\n\t                    line: this.lastMarker.line,\n\t                    column: this.lastMarker.column\n\t                }\n\t            };\n\t            if (this.config.source) {\n\t                node.loc.source = this.config.source;\n\t            }\n\t        }\n\t        if (this.delegate) {\n\t            var metadata = {\n\t                start: {\n\t                    line: marker.line,\n\t                    column: marker.column,\n\t                    offset: marker.index\n\t                },\n\t                end: {\n\t                    line: this.lastMarker.line,\n\t                    column: this.lastMarker.column,\n\t                    offset: this.lastMarker.index\n\t                }\n\t            };\n\t            this.delegate(node, metadata);\n\t        }\n\t        return node;\n\t    };\n\t    // Expect the next token to match the specified punctuator.\n\t    // If not, an exception will be thrown.\n\t    Parser.prototype.expect = function (value) {\n\t        var token = this.nextToken();\n\t        if (token.type !== 7 /* Punctuator */ || token.value !== value) {\n\t            this.throwUnexpectedToken(token);\n\t        }\n\t    };\n\t    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().\n\t    Parser.prototype.expectCommaSeparator = function () {\n\t        if (this.config.tolerant) {\n\t            var token = this.lookahead;\n\t            if (token.type === 7 /* Punctuator */ && token.value === ',') {\n\t                this.nextToken();\n\t            }\n\t            else if (token.type === 7 /* Punctuator */ && token.value === ';') {\n\t                this.nextToken();\n\t                this.tolerateUnexpectedToken(token);\n\t            }\n\t            else {\n\t                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);\n\t            }\n\t        }\n\t        else {\n\t            this.expect(',');\n\t        }\n\t    };\n\t    // Expect the next token to match the specified keyword.\n\t    // If not, an exception will be thrown.\n\t    Parser.prototype.expectKeyword = function (keyword) {\n\t        var token = this.nextToken();\n\t        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {\n\t            this.throwUnexpectedToken(token);\n\t        }\n\t    };\n\t    // Return true if the next token matches the specified punctuator.\n\t    Parser.prototype.match = function (value) {\n\t        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;\n\t    };\n\t    // Return true if the next token matches the specified keyword\n\t    Parser.prototype.matchKeyword = function (keyword) {\n\t        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;\n\t    };\n\t    // Return true if the next token matches the specified contextual keyword\n\t    // (where an identifier is sometimes a keyword depending on the context)\n\t    Parser.prototype.matchContextualKeyword = function (keyword) {\n\t        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;\n\t    };\n\t    // Return true if the next token is an assignment operator\n\t    Parser.prototype.matchAssign = function () {\n\t        if (this.lookahead.type !== 7 /* Punctuator */) {\n\t            return false;\n\t        }\n\t        var op = this.lookahead.value;\n\t        return op === '=' ||\n\t            op === '*=' ||\n\t            op === '**=' ||\n\t            op === '/=' ||\n\t            op === '%=' ||\n\t            op === '+=' ||\n\t            op === '-=' ||\n\t            op === '<<=' ||\n\t            op === '>>=' ||\n\t            op === '>>>=' ||\n\t            op === '&=' ||\n\t            op === '^=' ||\n\t            op === '|=';\n\t    };\n\t    // Cover grammar support.\n\t    //\n\t    // When an assignment expression position starts with an left parenthesis, the determination of the type\n\t    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n\t    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n\t    //\n\t    // There are three productions that can be parsed in a parentheses pair that needs to be determined\n\t    // after the outermost pair is closed. They are:\n\t    //\n\t    //   1. AssignmentExpression\n\t    //   2. BindingElements\n\t    //   3. AssignmentTargets\n\t    //\n\t    // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n\t    // binding element or assignment target.\n\t    //\n\t    // The three productions have the relationship:\n\t    //\n\t    //   BindingElements  AssignmentTargets  AssignmentExpression\n\t    //\n\t    // with a single exception that CoverInitializedName when used directly in an Expression, generates\n\t    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n\t    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n\t    //\n\t    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n\t    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n\t    // the CoverInitializedName check is conducted.\n\t    //\n\t    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n\t    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n\t    // pattern. The CoverInitializedName check is deferred.\n\t    Parser.prototype.isolateCoverGrammar = function (parseFunction) {\n\t        var previousIsBindingElement = this.context.isBindingElement;\n\t        var previousIsAssignmentTarget = this.context.isAssignmentTarget;\n\t        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\n\t        this.context.isBindingElement = true;\n\t        this.context.isAssignmentTarget = true;\n\t        this.context.firstCoverInitializedNameError = null;\n\t        var result = parseFunction.call(this);\n\t        if (this.context.firstCoverInitializedNameError !== null) {\n\t            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);\n\t        }\n\t        this.context.isBindingElement = previousIsBindingElement;\n\t        this.context.isAssignmentTarget = previousIsAssignmentTarget;\n\t        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;\n\t        return result;\n\t    };\n\t    Parser.prototype.inheritCoverGrammar = function (parseFunction) {\n\t        var previousIsBindingElement = this.context.isBindingElement;\n\t        var previousIsAssignmentTarget = this.context.isAssignmentTarget;\n\t        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\n\t        this.context.isBindingElement = true;\n\t        this.context.isAssignmentTarget = true;\n\t        this.context.firstCoverInitializedNameError = null;\n\t        var result = parseFunction.call(this);\n\t        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;\n\t        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;\n\t        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;\n\t        return result;\n\t    };\n\t    Parser.prototype.consumeSemicolon = function () {\n\t        if (this.match(';')) {\n\t            this.nextToken();\n\t        }\n\t        else if (!this.hasLineTerminator) {\n\t            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {\n\t                this.throwUnexpectedToken(this.lookahead);\n\t            }\n\t            this.lastMarker.index = this.startMarker.index;\n\t            this.lastMarker.line = this.startMarker.line;\n\t            this.lastMarker.column = this.startMarker.column;\n\t        }\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-primary-expression\n\t    Parser.prototype.parsePrimaryExpression = function () {\n\t        var node = this.createNode();\n\t        var expr;\n\t        var token, raw;\n\t        switch (this.lookahead.type) {\n\t            case 3 /* Identifier */:\n\t                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {\n\t                    this.tolerateUnexpectedToken(this.lookahead);\n\t                }\n\t                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));\n\t                break;\n\t            case 6 /* NumericLiteral */:\n\t            case 8 /* StringLiteral */:\n\t                if (this.context.strict && this.lookahead.octal) {\n\t                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);\n\t                }\n\t                this.context.isAssignmentTarget = false;\n\t                this.context.isBindingElement = false;\n\t                token = this.nextToken();\n\t                raw = this.getTokenRaw(token);\n\t                expr = this.finalize(node, new Node.Literal(token.value, raw));\n\t                break;\n\t            case 1 /* BooleanLiteral */:\n\t                this.context.isAssignmentTarget = false;\n\t                this.context.isBindingElement = false;\n\t                token = this.nextToken();\n\t                raw = this.getTokenRaw(token);\n\t                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));\n\t                break;\n\t            case 5 /* NullLiteral */:\n\t                this.context.isAssignmentTarget = false;\n\t                this.context.isBindingElement = false;\n\t                token = this.nextToken();\n\t                raw = this.getTokenRaw(token);\n\t                expr = this.finalize(node, new Node.Literal(null, raw));\n\t                break;\n\t            case 10 /* Template */:\n\t                expr = this.parseTemplateLiteral();\n\t                break;\n\t            case 7 /* Punctuator */:\n\t                switch (this.lookahead.value) {\n\t                    case '(':\n\t                        this.context.isBindingElement = false;\n\t                        expr = this.inheritCoverGrammar(this.parseGroupExpression);\n\t                        break;\n\t                    case '[':\n\t                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);\n\t                        break;\n\t                    case '{':\n\t                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);\n\t                        break;\n\t                    case '/':\n\t                    case '/=':\n\t                        this.context.isAssignmentTarget = false;\n\t                        this.context.isBindingElement = false;\n\t                        this.scanner.index = this.startMarker.index;\n\t                        token = this.nextRegexToken();\n\t                        raw = this.getTokenRaw(token);\n\t                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));\n\t                        break;\n\t                    default:\n\t                        expr = this.throwUnexpectedToken(this.nextToken());\n\t                }\n\t                break;\n\t            case 4 /* Keyword */:\n\t                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {\n\t                    expr = this.parseIdentifierName();\n\t                }\n\t                else if (!this.context.strict && this.matchKeyword('let')) {\n\t                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));\n\t                }\n\t                else {\n\t                    this.context.isAssignmentTarget = false;\n\t                    this.context.isBindingElement = false;\n\t                    if (this.matchKeyword('function')) {\n\t                        expr = this.parseFunctionExpression();\n\t                    }\n\t                    else if (this.matchKeyword('this')) {\n\t                        this.nextToken();\n\t                        expr = this.finalize(node, new Node.ThisExpression());\n\t                    }\n\t                    else if (this.matchKeyword('class')) {\n\t                        expr = this.parseClassExpression();\n\t                    }\n\t                    else {\n\t                        expr = this.throwUnexpectedToken(this.nextToken());\n\t                    }\n\t                }\n\t                break;\n\t            default:\n\t                expr = this.throwUnexpectedToken(this.nextToken());\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-array-initializer\n\t    Parser.prototype.parseSpreadElement = function () {\n\t        var node = this.createNode();\n\t        this.expect('...');\n\t        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);\n\t        return this.finalize(node, new Node.SpreadElement(arg));\n\t    };\n\t    Parser.prototype.parseArrayInitializer = function () {\n\t        var node = this.createNode();\n\t        var elements = [];\n\t        this.expect('[');\n\t        while (!this.match(']')) {\n\t            if (this.match(',')) {\n\t                this.nextToken();\n\t                elements.push(null);\n\t            }\n\t            else if (this.match('...')) {\n\t                var element = this.parseSpreadElement();\n\t                if (!this.match(']')) {\n\t                    this.context.isAssignmentTarget = false;\n\t                    this.context.isBindingElement = false;\n\t                    this.expect(',');\n\t                }\n\t                elements.push(element);\n\t            }\n\t            else {\n\t                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));\n\t                if (!this.match(']')) {\n\t                    this.expect(',');\n\t                }\n\t            }\n\t        }\n\t        this.expect(']');\n\t        return this.finalize(node, new Node.ArrayExpression(elements));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-object-initializer\n\t    Parser.prototype.parsePropertyMethod = function (params) {\n\t        this.context.isAssignmentTarget = false;\n\t        this.context.isBindingElement = false;\n\t        var previousStrict = this.context.strict;\n\t        var previousAllowStrictDirective = this.context.allowStrictDirective;\n\t        this.context.allowStrictDirective = params.simple;\n\t        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);\n\t        if (this.context.strict && params.firstRestricted) {\n\t            this.tolerateUnexpectedToken(params.firstRestricted, params.message);\n\t        }\n\t        if (this.context.strict && params.stricted) {\n\t            this.tolerateUnexpectedToken(params.stricted, params.message);\n\t        }\n\t        this.context.strict = previousStrict;\n\t        this.context.allowStrictDirective = previousAllowStrictDirective;\n\t        return body;\n\t    };\n\t    Parser.prototype.parsePropertyMethodFunction = function () {\n\t        var isGenerator = false;\n\t        var node = this.createNode();\n\t        var previousAllowYield = this.context.allowYield;\n\t        this.context.allowYield = true;\n\t        var params = this.parseFormalParameters();\n\t        var method = this.parsePropertyMethod(params);\n\t        this.context.allowYield = previousAllowYield;\n\t        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));\n\t    };\n\t    Parser.prototype.parsePropertyMethodAsyncFunction = function () {\n\t        var node = this.createNode();\n\t        var previousAllowYield = this.context.allowYield;\n\t        var previousAwait = this.context.await;\n\t        this.context.allowYield = false;\n\t        this.context.await = true;\n\t        var params = this.parseFormalParameters();\n\t        var method = this.parsePropertyMethod(params);\n\t        this.context.allowYield = previousAllowYield;\n\t        this.context.await = previousAwait;\n\t        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));\n\t    };\n\t    Parser.prototype.parseObjectPropertyKey = function () {\n\t        var node = this.createNode();\n\t        var token = this.nextToken();\n\t        var key;\n\t        switch (token.type) {\n\t            case 8 /* StringLiteral */:\n\t            case 6 /* NumericLiteral */:\n\t                if (this.context.strict && token.octal) {\n\t                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);\n\t                }\n\t                var raw = this.getTokenRaw(token);\n\t                key = this.finalize(node, new Node.Literal(token.value, raw));\n\t                break;\n\t            case 3 /* Identifier */:\n\t            case 1 /* BooleanLiteral */:\n\t            case 5 /* NullLiteral */:\n\t            case 4 /* Keyword */:\n\t                key = this.finalize(node, new Node.Identifier(token.value));\n\t                break;\n\t            case 7 /* Punctuator */:\n\t                if (token.value === '[') {\n\t                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t                    this.expect(']');\n\t                }\n\t                else {\n\t                    key = this.throwUnexpectedToken(token);\n\t                }\n\t                break;\n\t            default:\n\t                key = this.throwUnexpectedToken(token);\n\t        }\n\t        return key;\n\t    };\n\t    Parser.prototype.isPropertyKey = function (key, value) {\n\t        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||\n\t            (key.type === syntax_1.Syntax.Literal && key.value === value);\n\t    };\n\t    Parser.prototype.parseObjectProperty = function (hasProto) {\n\t        var node = this.createNode();\n\t        var token = this.lookahead;\n\t        var kind;\n\t        var key = null;\n\t        var value = null;\n\t        var computed = false;\n\t        var method = false;\n\t        var shorthand = false;\n\t        var isAsync = false;\n\t        if (token.type === 3 /* Identifier */) {\n\t            var id = token.value;\n\t            this.nextToken();\n\t            computed = this.match('[');\n\t            isAsync = !this.hasLineTerminator && (id === 'async') &&\n\t                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');\n\t            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));\n\t        }\n\t        else if (this.match('*')) {\n\t            this.nextToken();\n\t        }\n\t        else {\n\t            computed = this.match('[');\n\t            key = this.parseObjectPropertyKey();\n\t        }\n\t        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);\n\t        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {\n\t            kind = 'get';\n\t            computed = this.match('[');\n\t            key = this.parseObjectPropertyKey();\n\t            this.context.allowYield = false;\n\t            value = this.parseGetterMethod();\n\t        }\n\t        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {\n\t            kind = 'set';\n\t            computed = this.match('[');\n\t            key = this.parseObjectPropertyKey();\n\t            value = this.parseSetterMethod();\n\t        }\n\t        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {\n\t            kind = 'init';\n\t            computed = this.match('[');\n\t            key = this.parseObjectPropertyKey();\n\t            value = this.parseGeneratorMethod();\n\t            method = true;\n\t        }\n\t        else {\n\t            if (!key) {\n\t                this.throwUnexpectedToken(this.lookahead);\n\t            }\n\t            kind = 'init';\n\t            if (this.match(':') && !isAsync) {\n\t                if (!computed && this.isPropertyKey(key, '__proto__')) {\n\t                    if (hasProto.value) {\n\t                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);\n\t                    }\n\t                    hasProto.value = true;\n\t                }\n\t                this.nextToken();\n\t                value = this.inheritCoverGrammar(this.parseAssignmentExpression);\n\t            }\n\t            else if (this.match('(')) {\n\t                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();\n\t                method = true;\n\t            }\n\t            else if (token.type === 3 /* Identifier */) {\n\t                var id = this.finalize(node, new Node.Identifier(token.value));\n\t                if (this.match('=')) {\n\t                    this.context.firstCoverInitializedNameError = this.lookahead;\n\t                    this.nextToken();\n\t                    shorthand = true;\n\t                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t                    value = this.finalize(node, new Node.AssignmentPattern(id, init));\n\t                }\n\t                else {\n\t                    shorthand = true;\n\t                    value = id;\n\t                }\n\t            }\n\t            else {\n\t                this.throwUnexpectedToken(this.nextToken());\n\t            }\n\t        }\n\t        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));\n\t    };\n\t    Parser.prototype.parseObjectInitializer = function () {\n\t        var node = this.createNode();\n\t        this.expect('{');\n\t        var properties = [];\n\t        var hasProto = { value: false };\n\t        while (!this.match('}')) {\n\t            properties.push(this.parseObjectProperty(hasProto));\n\t            if (!this.match('}')) {\n\t                this.expectCommaSeparator();\n\t            }\n\t        }\n\t        this.expect('}');\n\t        return this.finalize(node, new Node.ObjectExpression(properties));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-template-literals\n\t    Parser.prototype.parseTemplateHead = function () {\n\t        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');\n\t        var node = this.createNode();\n\t        var token = this.nextToken();\n\t        var raw = token.value;\n\t        var cooked = token.cooked;\n\t        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));\n\t    };\n\t    Parser.prototype.parseTemplateElement = function () {\n\t        if (this.lookahead.type !== 10 /* Template */) {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        var node = this.createNode();\n\t        var token = this.nextToken();\n\t        var raw = token.value;\n\t        var cooked = token.cooked;\n\t        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));\n\t    };\n\t    Parser.prototype.parseTemplateLiteral = function () {\n\t        var node = this.createNode();\n\t        var expressions = [];\n\t        var quasis = [];\n\t        var quasi = this.parseTemplateHead();\n\t        quasis.push(quasi);\n\t        while (!quasi.tail) {\n\t            expressions.push(this.parseExpression());\n\t            quasi = this.parseTemplateElement();\n\t            quasis.push(quasi);\n\t        }\n\t        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-grouping-operator\n\t    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {\n\t        switch (expr.type) {\n\t            case syntax_1.Syntax.Identifier:\n\t            case syntax_1.Syntax.MemberExpression:\n\t            case syntax_1.Syntax.RestElement:\n\t            case syntax_1.Syntax.AssignmentPattern:\n\t                break;\n\t            case syntax_1.Syntax.SpreadElement:\n\t                expr.type = syntax_1.Syntax.RestElement;\n\t                this.reinterpretExpressionAsPattern(expr.argument);\n\t                break;\n\t            case syntax_1.Syntax.ArrayExpression:\n\t                expr.type = syntax_1.Syntax.ArrayPattern;\n\t                for (var i = 0; i < expr.elements.length; i++) {\n\t                    if (expr.elements[i] !== null) {\n\t                        this.reinterpretExpressionAsPattern(expr.elements[i]);\n\t                    }\n\t                }\n\t                break;\n\t            case syntax_1.Syntax.ObjectExpression:\n\t                expr.type = syntax_1.Syntax.ObjectPattern;\n\t                for (var i = 0; i < expr.properties.length; i++) {\n\t                    this.reinterpretExpressionAsPattern(expr.properties[i].value);\n\t                }\n\t                break;\n\t            case syntax_1.Syntax.AssignmentExpression:\n\t                expr.type = syntax_1.Syntax.AssignmentPattern;\n\t                delete expr.operator;\n\t                this.reinterpretExpressionAsPattern(expr.left);\n\t                break;\n\t            default:\n\t                // Allow other node type for tolerant parsing.\n\t                break;\n\t        }\n\t    };\n\t    Parser.prototype.parseGroupExpression = function () {\n\t        var expr;\n\t        this.expect('(');\n\t        if (this.match(')')) {\n\t            this.nextToken();\n\t            if (!this.match('=>')) {\n\t                this.expect('=>');\n\t            }\n\t            expr = {\n\t                type: ArrowParameterPlaceHolder,\n\t                params: [],\n\t                async: false\n\t            };\n\t        }\n\t        else {\n\t            var startToken = this.lookahead;\n\t            var params = [];\n\t            if (this.match('...')) {\n\t                expr = this.parseRestElement(params);\n\t                this.expect(')');\n\t                if (!this.match('=>')) {\n\t                    this.expect('=>');\n\t                }\n\t                expr = {\n\t                    type: ArrowParameterPlaceHolder,\n\t                    params: [expr],\n\t                    async: false\n\t                };\n\t            }\n\t            else {\n\t                var arrow = false;\n\t                this.context.isBindingElement = true;\n\t                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);\n\t                if (this.match(',')) {\n\t                    var expressions = [];\n\t                    this.context.isAssignmentTarget = false;\n\t                    expressions.push(expr);\n\t                    while (this.lookahead.type !== 2 /* EOF */) {\n\t                        if (!this.match(',')) {\n\t                            break;\n\t                        }\n\t                        this.nextToken();\n\t                        if (this.match(')')) {\n\t                            this.nextToken();\n\t                            for (var i = 0; i < expressions.length; i++) {\n\t                                this.reinterpretExpressionAsPattern(expressions[i]);\n\t                            }\n\t                            arrow = true;\n\t                            expr = {\n\t                                type: ArrowParameterPlaceHolder,\n\t                                params: expressions,\n\t                                async: false\n\t                            };\n\t                        }\n\t                        else if (this.match('...')) {\n\t                            if (!this.context.isBindingElement) {\n\t                                this.throwUnexpectedToken(this.lookahead);\n\t                            }\n\t                            expressions.push(this.parseRestElement(params));\n\t                            this.expect(')');\n\t                            if (!this.match('=>')) {\n\t                                this.expect('=>');\n\t                            }\n\t                            this.context.isBindingElement = false;\n\t                            for (var i = 0; i < expressions.length; i++) {\n\t                                this.reinterpretExpressionAsPattern(expressions[i]);\n\t                            }\n\t                            arrow = true;\n\t                            expr = {\n\t                                type: ArrowParameterPlaceHolder,\n\t                                params: expressions,\n\t                                async: false\n\t                            };\n\t                        }\n\t                        else {\n\t                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));\n\t                        }\n\t                        if (arrow) {\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (!arrow) {\n\t                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));\n\t                    }\n\t                }\n\t                if (!arrow) {\n\t                    this.expect(')');\n\t                    if (this.match('=>')) {\n\t                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {\n\t                            arrow = true;\n\t                            expr = {\n\t                                type: ArrowParameterPlaceHolder,\n\t                                params: [expr],\n\t                                async: false\n\t                            };\n\t                        }\n\t                        if (!arrow) {\n\t                            if (!this.context.isBindingElement) {\n\t                                this.throwUnexpectedToken(this.lookahead);\n\t                            }\n\t                            if (expr.type === syntax_1.Syntax.SequenceExpression) {\n\t                                for (var i = 0; i < expr.expressions.length; i++) {\n\t                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);\n\t                                }\n\t                            }\n\t                            else {\n\t                                this.reinterpretExpressionAsPattern(expr);\n\t                            }\n\t                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);\n\t                            expr = {\n\t                                type: ArrowParameterPlaceHolder,\n\t                                params: parameters,\n\t                                async: false\n\t                            };\n\t                        }\n\t                    }\n\t                    this.context.isBindingElement = false;\n\t                }\n\t            }\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions\n\t    Parser.prototype.parseArguments = function () {\n\t        this.expect('(');\n\t        var args = [];\n\t        if (!this.match(')')) {\n\t            while (true) {\n\t                var expr = this.match('...') ? this.parseSpreadElement() :\n\t                    this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t                args.push(expr);\n\t                if (this.match(')')) {\n\t                    break;\n\t                }\n\t                this.expectCommaSeparator();\n\t                if (this.match(')')) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        this.expect(')');\n\t        return args;\n\t    };\n\t    Parser.prototype.isIdentifierName = function (token) {\n\t        return token.type === 3 /* Identifier */ ||\n\t            token.type === 4 /* Keyword */ ||\n\t            token.type === 1 /* BooleanLiteral */ ||\n\t            token.type === 5 /* NullLiteral */;\n\t    };\n\t    Parser.prototype.parseIdentifierName = function () {\n\t        var node = this.createNode();\n\t        var token = this.nextToken();\n\t        if (!this.isIdentifierName(token)) {\n\t            this.throwUnexpectedToken(token);\n\t        }\n\t        return this.finalize(node, new Node.Identifier(token.value));\n\t    };\n\t    Parser.prototype.parseNewExpression = function () {\n\t        var node = this.createNode();\n\t        var id = this.parseIdentifierName();\n\t        assert_1.assert(id.name === 'new', 'New expression must start with `new`');\n\t        var expr;\n\t        if (this.match('.')) {\n\t            this.nextToken();\n\t            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {\n\t                var property = this.parseIdentifierName();\n\t                expr = new Node.MetaProperty(id, property);\n\t            }\n\t            else {\n\t                this.throwUnexpectedToken(this.lookahead);\n\t            }\n\t        }\n\t        else {\n\t            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);\n\t            var args = this.match('(') ? this.parseArguments() : [];\n\t            expr = new Node.NewExpression(callee, args);\n\t            this.context.isAssignmentTarget = false;\n\t            this.context.isBindingElement = false;\n\t        }\n\t        return this.finalize(node, expr);\n\t    };\n\t    Parser.prototype.parseAsyncArgument = function () {\n\t        var arg = this.parseAssignmentExpression();\n\t        this.context.firstCoverInitializedNameError = null;\n\t        return arg;\n\t    };\n\t    Parser.prototype.parseAsyncArguments = function () {\n\t        this.expect('(');\n\t        var args = [];\n\t        if (!this.match(')')) {\n\t            while (true) {\n\t                var expr = this.match('...') ? this.parseSpreadElement() :\n\t                    this.isolateCoverGrammar(this.parseAsyncArgument);\n\t                args.push(expr);\n\t                if (this.match(')')) {\n\t                    break;\n\t                }\n\t                this.expectCommaSeparator();\n\t                if (this.match(')')) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        this.expect(')');\n\t        return args;\n\t    };\n\t    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {\n\t        var startToken = this.lookahead;\n\t        var maybeAsync = this.matchContextualKeyword('async');\n\t        var previousAllowIn = this.context.allowIn;\n\t        this.context.allowIn = true;\n\t        var expr;\n\t        if (this.matchKeyword('super') && this.context.inFunctionBody) {\n\t            expr = this.createNode();\n\t            this.nextToken();\n\t            expr = this.finalize(expr, new Node.Super());\n\t            if (!this.match('(') && !this.match('.') && !this.match('[')) {\n\t                this.throwUnexpectedToken(this.lookahead);\n\t            }\n\t        }\n\t        else {\n\t            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);\n\t        }\n\t        while (true) {\n\t            if (this.match('.')) {\n\t                this.context.isBindingElement = false;\n\t                this.context.isAssignmentTarget = true;\n\t                this.expect('.');\n\t                var property = this.parseIdentifierName();\n\t                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));\n\t            }\n\t            else if (this.match('(')) {\n\t                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);\n\t                this.context.isBindingElement = false;\n\t                this.context.isAssignmentTarget = false;\n\t                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();\n\t                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));\n\t                if (asyncArrow && this.match('=>')) {\n\t                    for (var i = 0; i < args.length; ++i) {\n\t                        this.reinterpretExpressionAsPattern(args[i]);\n\t                    }\n\t                    expr = {\n\t                        type: ArrowParameterPlaceHolder,\n\t                        params: args,\n\t                        async: true\n\t                    };\n\t                }\n\t            }\n\t            else if (this.match('[')) {\n\t                this.context.isBindingElement = false;\n\t                this.context.isAssignmentTarget = true;\n\t                this.expect('[');\n\t                var property = this.isolateCoverGrammar(this.parseExpression);\n\t                this.expect(']');\n\t                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));\n\t            }\n\t            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {\n\t                var quasi = this.parseTemplateLiteral();\n\t                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        this.context.allowIn = previousAllowIn;\n\t        return expr;\n\t    };\n\t    Parser.prototype.parseSuper = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('super');\n\t        if (!this.match('[') && !this.match('.')) {\n\t            this.throwUnexpectedToken(this.lookahead);\n\t        }\n\t        return this.finalize(node, new Node.Super());\n\t    };\n\t    Parser.prototype.parseLeftHandSideExpression = function () {\n\t        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');\n\t        var node = this.startNode(this.lookahead);\n\t        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :\n\t            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);\n\t        while (true) {\n\t            if (this.match('[')) {\n\t                this.context.isBindingElement = false;\n\t                this.context.isAssignmentTarget = true;\n\t                this.expect('[');\n\t                var property = this.isolateCoverGrammar(this.parseExpression);\n\t                this.expect(']');\n\t                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));\n\t            }\n\t            else if (this.match('.')) {\n\t                this.context.isBindingElement = false;\n\t                this.context.isAssignmentTarget = true;\n\t                this.expect('.');\n\t                var property = this.parseIdentifierName();\n\t                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));\n\t            }\n\t            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {\n\t                var quasi = this.parseTemplateLiteral();\n\t                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-update-expressions\n\t    Parser.prototype.parseUpdateExpression = function () {\n\t        var expr;\n\t        var startToken = this.lookahead;\n\t        if (this.match('++') || this.match('--')) {\n\t            var node = this.startNode(startToken);\n\t            var token = this.nextToken();\n\t            expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n\t            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {\n\t                this.tolerateError(messages_1.Messages.StrictLHSPrefix);\n\t            }\n\t            if (!this.context.isAssignmentTarget) {\n\t                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\n\t            }\n\t            var prefix = true;\n\t            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));\n\t            this.context.isAssignmentTarget = false;\n\t            this.context.isBindingElement = false;\n\t        }\n\t        else {\n\t            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n\t            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {\n\t                if (this.match('++') || this.match('--')) {\n\t                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {\n\t                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);\n\t                    }\n\t                    if (!this.context.isAssignmentTarget) {\n\t                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\n\t                    }\n\t                    this.context.isAssignmentTarget = false;\n\t                    this.context.isBindingElement = false;\n\t                    var operator = this.nextToken().value;\n\t                    var prefix = false;\n\t                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));\n\t                }\n\t            }\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-unary-operators\n\t    Parser.prototype.parseAwaitExpression = function () {\n\t        var node = this.createNode();\n\t        this.nextToken();\n\t        var argument = this.parseUnaryExpression();\n\t        return this.finalize(node, new Node.AwaitExpression(argument));\n\t    };\n\t    Parser.prototype.parseUnaryExpression = function () {\n\t        var expr;\n\t        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||\n\t            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {\n\t            var node = this.startNode(this.lookahead);\n\t            var token = this.nextToken();\n\t            expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n\t            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));\n\t            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {\n\t                this.tolerateError(messages_1.Messages.StrictDelete);\n\t            }\n\t            this.context.isAssignmentTarget = false;\n\t            this.context.isBindingElement = false;\n\t        }\n\t        else if (this.context.await && this.matchContextualKeyword('await')) {\n\t            expr = this.parseAwaitExpression();\n\t        }\n\t        else {\n\t            expr = this.parseUpdateExpression();\n\t        }\n\t        return expr;\n\t    };\n\t    Parser.prototype.parseExponentiationExpression = function () {\n\t        var startToken = this.lookahead;\n\t        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n\t        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {\n\t            this.nextToken();\n\t            this.context.isAssignmentTarget = false;\n\t            this.context.isBindingElement = false;\n\t            var left = expr;\n\t            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n\t            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-exp-operator\n\t    // https://tc39.github.io/ecma262/#sec-multiplicative-operators\n\t    // https://tc39.github.io/ecma262/#sec-additive-operators\n\t    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators\n\t    // https://tc39.github.io/ecma262/#sec-relational-operators\n\t    // https://tc39.github.io/ecma262/#sec-equality-operators\n\t    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators\n\t    // https://tc39.github.io/ecma262/#sec-binary-logical-operators\n\t    Parser.prototype.binaryPrecedence = function (token) {\n\t        var op = token.value;\n\t        var precedence;\n\t        if (token.type === 7 /* Punctuator */) {\n\t            precedence = this.operatorPrecedence[op] || 0;\n\t        }\n\t        else if (token.type === 4 /* Keyword */) {\n\t            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;\n\t        }\n\t        else {\n\t            precedence = 0;\n\t        }\n\t        return precedence;\n\t    };\n\t    Parser.prototype.parseBinaryExpression = function () {\n\t        var startToken = this.lookahead;\n\t        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);\n\t        var token = this.lookahead;\n\t        var prec = this.binaryPrecedence(token);\n\t        if (prec > 0) {\n\t            this.nextToken();\n\t            this.context.isAssignmentTarget = false;\n\t            this.context.isBindingElement = false;\n\t            var markers = [startToken, this.lookahead];\n\t            var left = expr;\n\t            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n\t            var stack = [left, token.value, right];\n\t            var precedences = [prec];\n\t            while (true) {\n\t                prec = this.binaryPrecedence(this.lookahead);\n\t                if (prec <= 0) {\n\t                    break;\n\t                }\n\t                // Reduce: make a binary expression from the three topmost entries.\n\t                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {\n\t                    right = stack.pop();\n\t                    var operator = stack.pop();\n\t                    precedences.pop();\n\t                    left = stack.pop();\n\t                    markers.pop();\n\t                    var node = this.startNode(markers[markers.length - 1]);\n\t                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));\n\t                }\n\t                // Shift.\n\t                stack.push(this.nextToken().value);\n\t                precedences.push(prec);\n\t                markers.push(this.lookahead);\n\t                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));\n\t            }\n\t            // Final reduce to clean-up the stack.\n\t            var i = stack.length - 1;\n\t            expr = stack[i];\n\t            var lastMarker = markers.pop();\n\t            while (i > 1) {\n\t                var marker = markers.pop();\n\t                var lastLineStart = lastMarker && lastMarker.lineStart;\n\t                var node = this.startNode(marker, lastLineStart);\n\t                var operator = stack[i - 1];\n\t                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));\n\t                i -= 2;\n\t                lastMarker = marker;\n\t            }\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-conditional-operator\n\t    Parser.prototype.parseConditionalExpression = function () {\n\t        var startToken = this.lookahead;\n\t        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);\n\t        if (this.match('?')) {\n\t            this.nextToken();\n\t            var previousAllowIn = this.context.allowIn;\n\t            this.context.allowIn = true;\n\t            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t            this.context.allowIn = previousAllowIn;\n\t            this.expect(':');\n\t            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));\n\t            this.context.isAssignmentTarget = false;\n\t            this.context.isBindingElement = false;\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-assignment-operators\n\t    Parser.prototype.checkPatternParam = function (options, param) {\n\t        switch (param.type) {\n\t            case syntax_1.Syntax.Identifier:\n\t                this.validateParam(options, param, param.name);\n\t                break;\n\t            case syntax_1.Syntax.RestElement:\n\t                this.checkPatternParam(options, param.argument);\n\t                break;\n\t            case syntax_1.Syntax.AssignmentPattern:\n\t                this.checkPatternParam(options, param.left);\n\t                break;\n\t            case syntax_1.Syntax.ArrayPattern:\n\t                for (var i = 0; i < param.elements.length; i++) {\n\t                    if (param.elements[i] !== null) {\n\t                        this.checkPatternParam(options, param.elements[i]);\n\t                    }\n\t                }\n\t                break;\n\t            case syntax_1.Syntax.ObjectPattern:\n\t                for (var i = 0; i < param.properties.length; i++) {\n\t                    this.checkPatternParam(options, param.properties[i].value);\n\t                }\n\t                break;\n\t            default:\n\t                break;\n\t        }\n\t        options.simple = options.simple && (param instanceof Node.Identifier);\n\t    };\n\t    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {\n\t        var params = [expr];\n\t        var options;\n\t        var asyncArrow = false;\n\t        switch (expr.type) {\n\t            case syntax_1.Syntax.Identifier:\n\t                break;\n\t            case ArrowParameterPlaceHolder:\n\t                params = expr.params;\n\t                asyncArrow = expr.async;\n\t                break;\n\t            default:\n\t                return null;\n\t        }\n\t        options = {\n\t            simple: true,\n\t            paramSet: {}\n\t        };\n\t        for (var i = 0; i < params.length; ++i) {\n\t            var param = params[i];\n\t            if (param.type === syntax_1.Syntax.AssignmentPattern) {\n\t                if (param.right.type === syntax_1.Syntax.YieldExpression) {\n\t                    if (param.right.argument) {\n\t                        this.throwUnexpectedToken(this.lookahead);\n\t                    }\n\t                    param.right.type = syntax_1.Syntax.Identifier;\n\t                    param.right.name = 'yield';\n\t                    delete param.right.argument;\n\t                    delete param.right.delegate;\n\t                }\n\t            }\n\t            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {\n\t                this.throwUnexpectedToken(this.lookahead);\n\t            }\n\t            this.checkPatternParam(options, param);\n\t            params[i] = param;\n\t        }\n\t        if (this.context.strict || !this.context.allowYield) {\n\t            for (var i = 0; i < params.length; ++i) {\n\t                var param = params[i];\n\t                if (param.type === syntax_1.Syntax.YieldExpression) {\n\t                    this.throwUnexpectedToken(this.lookahead);\n\t                }\n\t            }\n\t        }\n\t        if (options.message === messages_1.Messages.StrictParamDupe) {\n\t            var token = this.context.strict ? options.stricted : options.firstRestricted;\n\t            this.throwUnexpectedToken(token, options.message);\n\t        }\n\t        return {\n\t            simple: options.simple,\n\t            params: params,\n\t            stricted: options.stricted,\n\t            firstRestricted: options.firstRestricted,\n\t            message: options.message\n\t        };\n\t    };\n\t    Parser.prototype.parseAssignmentExpression = function () {\n\t        var expr;\n\t        if (!this.context.allowYield && this.matchKeyword('yield')) {\n\t            expr = this.parseYieldExpression();\n\t        }\n\t        else {\n\t            var startToken = this.lookahead;\n\t            var token = startToken;\n\t            expr = this.parseConditionalExpression();\n\t            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {\n\t                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {\n\t                    var arg = this.parsePrimaryExpression();\n\t                    this.reinterpretExpressionAsPattern(arg);\n\t                    expr = {\n\t                        type: ArrowParameterPlaceHolder,\n\t                        params: [arg],\n\t                        async: true\n\t                    };\n\t                }\n\t            }\n\t            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {\n\t                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions\n\t                this.context.isAssignmentTarget = false;\n\t                this.context.isBindingElement = false;\n\t                var isAsync = expr.async;\n\t                var list = this.reinterpretAsCoverFormalsList(expr);\n\t                if (list) {\n\t                    if (this.hasLineTerminator) {\n\t                        this.tolerateUnexpectedToken(this.lookahead);\n\t                    }\n\t                    this.context.firstCoverInitializedNameError = null;\n\t                    var previousStrict = this.context.strict;\n\t                    var previousAllowStrictDirective = this.context.allowStrictDirective;\n\t                    this.context.allowStrictDirective = list.simple;\n\t                    var previousAllowYield = this.context.allowYield;\n\t                    var previousAwait = this.context.await;\n\t                    this.context.allowYield = true;\n\t                    this.context.await = isAsync;\n\t                    var node = this.startNode(startToken);\n\t                    this.expect('=>');\n\t                    var body = void 0;\n\t                    if (this.match('{')) {\n\t                        var previousAllowIn = this.context.allowIn;\n\t                        this.context.allowIn = true;\n\t                        body = this.parseFunctionSourceElements();\n\t                        this.context.allowIn = previousAllowIn;\n\t                    }\n\t                    else {\n\t                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t                    }\n\t                    var expression = body.type !== syntax_1.Syntax.BlockStatement;\n\t                    if (this.context.strict && list.firstRestricted) {\n\t                        this.throwUnexpectedToken(list.firstRestricted, list.message);\n\t                    }\n\t                    if (this.context.strict && list.stricted) {\n\t                        this.tolerateUnexpectedToken(list.stricted, list.message);\n\t                    }\n\t                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :\n\t                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));\n\t                    this.context.strict = previousStrict;\n\t                    this.context.allowStrictDirective = previousAllowStrictDirective;\n\t                    this.context.allowYield = previousAllowYield;\n\t                    this.context.await = previousAwait;\n\t                }\n\t            }\n\t            else {\n\t                if (this.matchAssign()) {\n\t                    if (!this.context.isAssignmentTarget) {\n\t                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\n\t                    }\n\t                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {\n\t                        var id = expr;\n\t                        if (this.scanner.isRestrictedWord(id.name)) {\n\t                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);\n\t                        }\n\t                        if (this.scanner.isStrictModeReservedWord(id.name)) {\n\t                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\n\t                        }\n\t                    }\n\t                    if (!this.match('=')) {\n\t                        this.context.isAssignmentTarget = false;\n\t                        this.context.isBindingElement = false;\n\t                    }\n\t                    else {\n\t                        this.reinterpretExpressionAsPattern(expr);\n\t                    }\n\t                    token = this.nextToken();\n\t                    var operator = token.value;\n\t                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));\n\t                    this.context.firstCoverInitializedNameError = null;\n\t                }\n\t            }\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-comma-operator\n\t    Parser.prototype.parseExpression = function () {\n\t        var startToken = this.lookahead;\n\t        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t        if (this.match(',')) {\n\t            var expressions = [];\n\t            expressions.push(expr);\n\t            while (this.lookahead.type !== 2 /* EOF */) {\n\t                if (!this.match(',')) {\n\t                    break;\n\t                }\n\t                this.nextToken();\n\t                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));\n\t            }\n\t            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));\n\t        }\n\t        return expr;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-block\n\t    Parser.prototype.parseStatementListItem = function () {\n\t        var statement;\n\t        this.context.isAssignmentTarget = true;\n\t        this.context.isBindingElement = true;\n\t        if (this.lookahead.type === 4 /* Keyword */) {\n\t            switch (this.lookahead.value) {\n\t                case 'export':\n\t                    if (!this.context.isModule) {\n\t                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);\n\t                    }\n\t                    statement = this.parseExportDeclaration();\n\t                    break;\n\t                case 'import':\n\t                    if (!this.context.isModule) {\n\t                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);\n\t                    }\n\t                    statement = this.parseImportDeclaration();\n\t                    break;\n\t                case 'const':\n\t                    statement = this.parseLexicalDeclaration({ inFor: false });\n\t                    break;\n\t                case 'function':\n\t                    statement = this.parseFunctionDeclaration();\n\t                    break;\n\t                case 'class':\n\t                    statement = this.parseClassDeclaration();\n\t                    break;\n\t                case 'let':\n\t                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();\n\t                    break;\n\t                default:\n\t                    statement = this.parseStatement();\n\t                    break;\n\t            }\n\t        }\n\t        else {\n\t            statement = this.parseStatement();\n\t        }\n\t        return statement;\n\t    };\n\t    Parser.prototype.parseBlock = function () {\n\t        var node = this.createNode();\n\t        this.expect('{');\n\t        var block = [];\n\t        while (true) {\n\t            if (this.match('}')) {\n\t                break;\n\t            }\n\t            block.push(this.parseStatementListItem());\n\t        }\n\t        this.expect('}');\n\t        return this.finalize(node, new Node.BlockStatement(block));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations\n\t    Parser.prototype.parseLexicalBinding = function (kind, options) {\n\t        var node = this.createNode();\n\t        var params = [];\n\t        var id = this.parsePattern(params, kind);\n\t        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {\n\t            if (this.scanner.isRestrictedWord(id.name)) {\n\t                this.tolerateError(messages_1.Messages.StrictVarName);\n\t            }\n\t        }\n\t        var init = null;\n\t        if (kind === 'const') {\n\t            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {\n\t                if (this.match('=')) {\n\t                    this.nextToken();\n\t                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t                }\n\t                else {\n\t                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');\n\t                }\n\t            }\n\t        }\n\t        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {\n\t            this.expect('=');\n\t            init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t        }\n\t        return this.finalize(node, new Node.VariableDeclarator(id, init));\n\t    };\n\t    Parser.prototype.parseBindingList = function (kind, options) {\n\t        var list = [this.parseLexicalBinding(kind, options)];\n\t        while (this.match(',')) {\n\t            this.nextToken();\n\t            list.push(this.parseLexicalBinding(kind, options));\n\t        }\n\t        return list;\n\t    };\n\t    Parser.prototype.isLexicalDeclaration = function () {\n\t        var state = this.scanner.saveState();\n\t        this.scanner.scanComments();\n\t        var next = this.scanner.lex();\n\t        this.scanner.restoreState(state);\n\t        return (next.type === 3 /* Identifier */) ||\n\t            (next.type === 7 /* Punctuator */ && next.value === '[') ||\n\t            (next.type === 7 /* Punctuator */ && next.value === '{') ||\n\t            (next.type === 4 /* Keyword */ && next.value === 'let') ||\n\t            (next.type === 4 /* Keyword */ && next.value === 'yield');\n\t    };\n\t    Parser.prototype.parseLexicalDeclaration = function (options) {\n\t        var node = this.createNode();\n\t        var kind = this.nextToken().value;\n\t        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n\t        var declarations = this.parseBindingList(kind, options);\n\t        this.consumeSemicolon();\n\t        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns\n\t    Parser.prototype.parseBindingRestElement = function (params, kind) {\n\t        var node = this.createNode();\n\t        this.expect('...');\n\t        var arg = this.parsePattern(params, kind);\n\t        return this.finalize(node, new Node.RestElement(arg));\n\t    };\n\t    Parser.prototype.parseArrayPattern = function (params, kind) {\n\t        var node = this.createNode();\n\t        this.expect('[');\n\t        var elements = [];\n\t        while (!this.match(']')) {\n\t            if (this.match(',')) {\n\t                this.nextToken();\n\t                elements.push(null);\n\t            }\n\t            else {\n\t                if (this.match('...')) {\n\t                    elements.push(this.parseBindingRestElement(params, kind));\n\t                    break;\n\t                }\n\t                else {\n\t                    elements.push(this.parsePatternWithDefault(params, kind));\n\t                }\n\t                if (!this.match(']')) {\n\t                    this.expect(',');\n\t                }\n\t            }\n\t        }\n\t        this.expect(']');\n\t        return this.finalize(node, new Node.ArrayPattern(elements));\n\t    };\n\t    Parser.prototype.parsePropertyPattern = function (params, kind) {\n\t        var node = this.createNode();\n\t        var computed = false;\n\t        var shorthand = false;\n\t        var method = false;\n\t        var key;\n\t        var value;\n\t        if (this.lookahead.type === 3 /* Identifier */) {\n\t            var keyToken = this.lookahead;\n\t            key = this.parseVariableIdentifier();\n\t            var init = this.finalize(node, new Node.Identifier(keyToken.value));\n\t            if (this.match('=')) {\n\t                params.push(keyToken);\n\t                shorthand = true;\n\t                this.nextToken();\n\t                var expr = this.parseAssignmentExpression();\n\t                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));\n\t            }\n\t            else if (!this.match(':')) {\n\t                params.push(keyToken);\n\t                shorthand = true;\n\t                value = init;\n\t            }\n\t            else {\n\t                this.expect(':');\n\t                value = this.parsePatternWithDefault(params, kind);\n\t            }\n\t        }\n\t        else {\n\t            computed = this.match('[');\n\t            key = this.parseObjectPropertyKey();\n\t            this.expect(':');\n\t            value = this.parsePatternWithDefault(params, kind);\n\t        }\n\t        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));\n\t    };\n\t    Parser.prototype.parseObjectPattern = function (params, kind) {\n\t        var node = this.createNode();\n\t        var properties = [];\n\t        this.expect('{');\n\t        while (!this.match('}')) {\n\t            properties.push(this.parsePropertyPattern(params, kind));\n\t            if (!this.match('}')) {\n\t                this.expect(',');\n\t            }\n\t        }\n\t        this.expect('}');\n\t        return this.finalize(node, new Node.ObjectPattern(properties));\n\t    };\n\t    Parser.prototype.parsePattern = function (params, kind) {\n\t        var pattern;\n\t        if (this.match('[')) {\n\t            pattern = this.parseArrayPattern(params, kind);\n\t        }\n\t        else if (this.match('{')) {\n\t            pattern = this.parseObjectPattern(params, kind);\n\t        }\n\t        else {\n\t            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {\n\t                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);\n\t            }\n\t            params.push(this.lookahead);\n\t            pattern = this.parseVariableIdentifier(kind);\n\t        }\n\t        return pattern;\n\t    };\n\t    Parser.prototype.parsePatternWithDefault = function (params, kind) {\n\t        var startToken = this.lookahead;\n\t        var pattern = this.parsePattern(params, kind);\n\t        if (this.match('=')) {\n\t            this.nextToken();\n\t            var previousAllowYield = this.context.allowYield;\n\t            this.context.allowYield = true;\n\t            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t            this.context.allowYield = previousAllowYield;\n\t            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));\n\t        }\n\t        return pattern;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-variable-statement\n\t    Parser.prototype.parseVariableIdentifier = function (kind) {\n\t        var node = this.createNode();\n\t        var token = this.nextToken();\n\t        if (token.type === 4 /* Keyword */ && token.value === 'yield') {\n\t            if (this.context.strict) {\n\t                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\n\t            }\n\t            else if (!this.context.allowYield) {\n\t                this.throwUnexpectedToken(token);\n\t            }\n\t        }\n\t        else if (token.type !== 3 /* Identifier */) {\n\t            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {\n\t                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\n\t            }\n\t            else {\n\t                if (this.context.strict || token.value !== 'let' || kind !== 'var') {\n\t                    this.throwUnexpectedToken(token);\n\t                }\n\t            }\n\t        }\n\t        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {\n\t            this.tolerateUnexpectedToken(token);\n\t        }\n\t        return this.finalize(node, new Node.Identifier(token.value));\n\t    };\n\t    Parser.prototype.parseVariableDeclaration = function (options) {\n\t        var node = this.createNode();\n\t        var params = [];\n\t        var id = this.parsePattern(params, 'var');\n\t        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {\n\t            if (this.scanner.isRestrictedWord(id.name)) {\n\t                this.tolerateError(messages_1.Messages.StrictVarName);\n\t            }\n\t        }\n\t        var init = null;\n\t        if (this.match('=')) {\n\t            this.nextToken();\n\t            init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n\t        }\n\t        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {\n\t            this.expect('=');\n\t        }\n\t        return this.finalize(node, new Node.VariableDeclarator(id, init));\n\t    };\n\t    Parser.prototype.parseVariableDeclarationList = function (options) {\n\t        var opt = { inFor: options.inFor };\n\t        var list = [];\n\t        list.push(this.parseVariableDeclaration(opt));\n\t        while (this.match(',')) {\n\t            this.nextToken();\n\t            list.push(this.parseVariableDeclaration(opt));\n\t        }\n\t        return list;\n\t    };\n\t    Parser.prototype.parseVariableStatement = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('var');\n\t        var declarations = this.parseVariableDeclarationList({ inFor: false });\n\t        this.consumeSemicolon();\n\t        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-empty-statement\n\t    Parser.prototype.parseEmptyStatement = function () {\n\t        var node = this.createNode();\n\t        this.expect(';');\n\t        return this.finalize(node, new Node.EmptyStatement());\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-expression-statement\n\t    Parser.prototype.parseExpressionStatement = function () {\n\t        var node = this.createNode();\n\t        var expr = this.parseExpression();\n\t        this.consumeSemicolon();\n\t        return this.finalize(node, new Node.ExpressionStatement(expr));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-if-statement\n\t    Parser.prototype.parseIfClause = function () {\n\t        if (this.context.strict && this.matchKeyword('function')) {\n\t            this.tolerateError(messages_1.Messages.StrictFunction);\n\t        }\n\t        return this.parseStatement();\n\t    };\n\t    Parser.prototype.parseIfStatement = function () {\n\t        var node = this.createNode();\n\t        var consequent;\n\t        var alternate = null;\n\t        this.expectKeyword('if');\n\t        this.expect('(');\n\t        var test = this.parseExpression();\n\t        if (!this.match(')') && this.config.tolerant) {\n\t            this.tolerateUnexpectedToken(this.nextToken());\n\t            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());\n\t        }\n\t        else {\n\t            this.expect(')');\n\t            consequent = this.parseIfClause();\n\t            if (this.matchKeyword('else')) {\n\t                this.nextToken();\n\t                alternate = this.parseIfClause();\n\t            }\n\t        }\n\t        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-do-while-statement\n\t    Parser.prototype.parseDoWhileStatement = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('do');\n\t        var previousInIteration = this.context.inIteration;\n\t        this.context.inIteration = true;\n\t        var body = this.parseStatement();\n\t        this.context.inIteration = previousInIteration;\n\t        this.expectKeyword('while');\n\t        this.expect('(');\n\t        var test = this.parseExpression();\n\t        if (!this.match(')') && this.config.tolerant) {\n\t            this.tolerateUnexpectedToken(this.nextToken());\n\t        }\n\t        else {\n\t            this.expect(')');\n\t            if (this.match(';')) {\n\t                this.nextToken();\n\t            }\n\t        }\n\t        return this.finalize(node, new Node.DoWhileStatement(body, test));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-while-statement\n\t    Parser.prototype.parseWhileStatement = function () {\n\t        var node = this.createNode();\n\t        var body;\n\t        this.expectKeyword('while');\n\t        this.expect('(');\n\t        var test = this.parseExpression();\n\t        if (!this.match(')') && this.config.tolerant) {\n\t            this.tolerateUnexpectedToken(this.nextToken());\n\t            body = this.finalize(this.createNode(), new Node.EmptyStatement());\n\t        }\n\t        else {\n\t            this.expect(')');\n\t            var previousInIteration = this.context.inIteration;\n\t            this.context.inIteration = true;\n\t            body = this.parseStatement();\n\t            this.context.inIteration = previousInIteration;\n\t        }\n\t        return this.finalize(node, new Node.WhileStatement(test, body));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-for-statement\n\t    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\n\t    Parser.prototype.parseForStatement = function () {\n\t        var init = null;\n\t        var test = null;\n\t        var update = null;\n\t        var forIn = true;\n\t        var left, right;\n\t        var node = this.createNode();\n\t        this.expectKeyword('for');\n\t        this.expect('(');\n\t        if (this.match(';')) {\n\t            this.nextToken();\n\t        }\n\t        else {\n\t            if (this.matchKeyword('var')) {\n\t                init = this.createNode();\n\t                this.nextToken();\n\t                var previousAllowIn = this.context.allowIn;\n\t                this.context.allowIn = false;\n\t                var declarations = this.parseVariableDeclarationList({ inFor: true });\n\t                this.context.allowIn = previousAllowIn;\n\t                if (declarations.length === 1 && this.matchKeyword('in')) {\n\t                    var decl = declarations[0];\n\t                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {\n\t                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');\n\t                    }\n\t                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));\n\t                    this.nextToken();\n\t                    left = init;\n\t                    right = this.parseExpression();\n\t                    init = null;\n\t                }\n\t                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {\n\t                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));\n\t                    this.nextToken();\n\t                    left = init;\n\t                    right = this.parseAssignmentExpression();\n\t                    init = null;\n\t                    forIn = false;\n\t                }\n\t                else {\n\t                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));\n\t                    this.expect(';');\n\t                }\n\t            }\n\t            else if (this.matchKeyword('const') || this.matchKeyword('let')) {\n\t                init = this.createNode();\n\t                var kind = this.nextToken().value;\n\t                if (!this.context.strict && this.lookahead.value === 'in') {\n\t                    init = this.finalize(init, new Node.Identifier(kind));\n\t                    this.nextToken();\n\t                    left = init;\n\t                    right = this.parseExpression();\n\t                    init = null;\n\t                }\n\t                else {\n\t                    var previousAllowIn = this.context.allowIn;\n\t                    this.context.allowIn = false;\n\t                    var declarations = this.parseBindingList(kind, { inFor: true });\n\t                    this.context.allowIn = previousAllowIn;\n\t                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {\n\t                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\n\t                        this.nextToken();\n\t                        left = init;\n\t                        right = this.parseExpression();\n\t                        init = null;\n\t                    }\n\t                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {\n\t                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\n\t                        this.nextToken();\n\t                        left = init;\n\t                        right = this.parseAssignmentExpression();\n\t                        init = null;\n\t                        forIn = false;\n\t                    }\n\t                    else {\n\t                        this.consumeSemicolon();\n\t                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                var initStartToken = this.lookahead;\n\t                var previousAllowIn = this.context.allowIn;\n\t                this.context.allowIn = false;\n\t                init = this.inheritCoverGrammar(this.parseAssignmentExpression);\n\t                this.context.allowIn = previousAllowIn;\n\t                if (this.matchKeyword('in')) {\n\t                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {\n\t                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);\n\t                    }\n\t                    this.nextToken();\n\t                    this.reinterpretExpressionAsPattern(init);\n\t                    left = init;\n\t                    right = this.parseExpression();\n\t                    init = null;\n\t                }\n\t                else if (this.matchContextualKeyword('of')) {\n\t                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {\n\t                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);\n\t                    }\n\t                    this.nextToken();\n\t                    this.reinterpretExpressionAsPattern(init);\n\t                    left = init;\n\t                    right = this.parseAssignmentExpression();\n\t                    init = null;\n\t                    forIn = false;\n\t                }\n\t                else {\n\t                    if (this.match(',')) {\n\t                        var initSeq = [init];\n\t                        while (this.match(',')) {\n\t                            this.nextToken();\n\t                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));\n\t                        }\n\t                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));\n\t                    }\n\t                    this.expect(';');\n\t                }\n\t            }\n\t        }\n\t        if (typeof left === 'undefined') {\n\t            if (!this.match(';')) {\n\t                test = this.parseExpression();\n\t            }\n\t            this.expect(';');\n\t            if (!this.match(')')) {\n\t                update = this.parseExpression();\n\t            }\n\t        }\n\t        var body;\n\t        if (!this.match(')') && this.config.tolerant) {\n\t            this.tolerateUnexpectedToken(this.nextToken());\n\t            body = this.finalize(this.createNode(), new Node.EmptyStatement());\n\t        }\n\t        else {\n\t            this.expect(')');\n\t            var previousInIteration = this.context.inIteration;\n\t            this.context.inIteration = true;\n\t            body = this.isolateCoverGrammar(this.parseStatement);\n\t            this.context.inIteration = previousInIteration;\n\t        }\n\t        return (typeof left === 'undefined') ?\n\t            this.finalize(node, new Node.ForStatement(init, test, update, body)) :\n\t            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :\n\t                this.finalize(node, new Node.ForOfStatement(left, right, body));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-continue-statement\n\t    Parser.prototype.parseContinueStatement = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('continue');\n\t        var label = null;\n\t        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {\n\t            var id = this.parseVariableIdentifier();\n\t            label = id;\n\t            var key = '$' + id.name;\n\t            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n\t                this.throwError(messages_1.Messages.UnknownLabel, id.name);\n\t            }\n\t        }\n\t        this.consumeSemicolon();\n\t        if (label === null && !this.context.inIteration) {\n\t            this.throwError(messages_1.Messages.IllegalContinue);\n\t        }\n\t        return this.finalize(node, new Node.ContinueStatement(label));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-break-statement\n\t    Parser.prototype.parseBreakStatement = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('break');\n\t        var label = null;\n\t        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {\n\t            var id = this.parseVariableIdentifier();\n\t            var key = '$' + id.name;\n\t            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n\t                this.throwError(messages_1.Messages.UnknownLabel, id.name);\n\t            }\n\t            label = id;\n\t        }\n\t        this.consumeSemicolon();\n\t        if (label === null && !this.context.inIteration && !this.context.inSwitch) {\n\t            this.throwError(messages_1.Messages.IllegalBreak);\n\t        }\n\t        return this.finalize(node, new Node.BreakStatement(label));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-return-statement\n\t    Parser.prototype.parseReturnStatement = function () {\n\t        if (!this.context.inFunctionBody) {\n\t            this.tolerateError(messages_1.Messages.IllegalReturn);\n\t        }\n\t        var node = this.createNode();\n\t        this.expectKeyword('return');\n\t        var hasArgument = (!this.match(';') && !this.match('}') &&\n\t            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||\n\t            this.lookahead.type === 8 /* StringLiteral */ ||\n\t            this.lookahead.type === 10 /* Template */;\n\t        var argument = hasArgument ? this.parseExpression() : null;\n\t        this.consumeSemicolon();\n\t        return this.finalize(node, new Node.ReturnStatement(argument));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-with-statement\n\t    Parser.prototype.parseWithStatement = function () {\n\t        if (this.context.strict) {\n\t            this.tolerateError(messages_1.Messages.StrictModeWith);\n\t        }\n\t        var node = this.createNode();\n\t        var body;\n\t        this.expectKeyword('with');\n\t        this.expect('(');\n\t        var object = this.parseExpression();\n\t        if (!this.match(')') && this.config.tolerant) {\n\t            this.tolerateUnexpectedToken(this.nextToken());\n\t            body = this.finalize(this.createNode(), new Node.EmptyStatement());\n\t        }\n\t        else {\n\t            this.expect(')');\n\t            body = this.parseStatement();\n\t        }\n\t        return this.finalize(node, new Node.WithStatement(object, body));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-switch-statement\n\t    Parser.prototype.parseSwitchCase = function () {\n\t        var node = this.createNode();\n\t        var test;\n\t        if (this.matchKeyword('default')) {\n\t            this.nextToken();\n\t            test = null;\n\t        }\n\t        else {\n\t            this.expectKeyword('case');\n\t            test = this.parseExpression();\n\t        }\n\t        this.expect(':');\n\t        var consequent = [];\n\t        while (true) {\n\t            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {\n\t                break;\n\t            }\n\t            consequent.push(this.parseStatementListItem());\n\t        }\n\t        return this.finalize(node, new Node.SwitchCase(test, consequent));\n\t    };\n\t    Parser.prototype.parseSwitchStatement = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('switch');\n\t        this.expect('(');\n\t        var discriminant = this.parseExpression();\n\t        this.expect(')');\n\t        var previousInSwitch = this.context.inSwitch;\n\t        this.context.inSwitch = true;\n\t        var cases = [];\n\t        var defaultFound = false;\n\t        this.expect('{');\n\t        while (true) {\n\t            if (this.match('}')) {\n\t                break;\n\t            }\n\t            var clause = this.parseSwitchCase();\n\t            if (clause.test === null) {\n\t                if (defaultFound) {\n\t                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);\n\t                }\n\t                defaultFound = true;\n\t            }\n\t            cases.push(clause);\n\t        }\n\t        this.expect('}');\n\t        this.context.inSwitch = previousInSwitch;\n\t        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-labelled-statements\n\t    Parser.prototype.parseLabelledStatement = function () {\n\t        var node = this.createNode();\n\t        var expr = this.parseExpression();\n\t        var statement;\n\t        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {\n\t            this.nextToken();\n\t            var id = expr;\n\t            var key = '$' + id.name;\n\t            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n\t                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);\n\t            }\n\t            this.context.labelSet[key] = true;\n\t            var body = void 0;\n\t            if (this.matchKeyword('class')) {\n\t                this.tolerateUnexpectedToken(this.lookahead);\n\t                body = this.parseClassDeclaration();\n\t            }\n\t            else if (this.matchKeyword('function')) {\n\t                var token = this.lookahead;\n\t                var declaration = this.parseFunctionDeclaration();\n\t                if (this.context.strict) {\n\t                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);\n\t                }\n\t                else if (declaration.generator) {\n\t                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);\n\t                }\n\t                body = declaration;\n\t            }\n\t            else {\n\t                body = this.parseStatement();\n\t            }\n\t            delete this.context.labelSet[key];\n\t            statement = new Node.LabeledStatement(id, body);\n\t        }\n\t        else {\n\t            this.consumeSemicolon();\n\t            statement = new Node.ExpressionStatement(expr);\n\t        }\n\t        return this.finalize(node, statement);\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-throw-statement\n\t    Parser.prototype.parseThrowStatement = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('throw');\n\t        if (this.hasLineTerminator) {\n\t            this.throwError(messages_1.Messages.NewlineAfterThrow);\n\t        }\n\t        var argument = this.parseExpression();\n\t        this.consumeSemicolon();\n\t        return this.finalize(node, new Node.ThrowStatement(argument));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-try-statement\n\t    Parser.prototype.parseCatchClause = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('catch');\n\t        this.expect('(');\n\t        if (this.match(')')) {\n\t            this.throwUnexpectedToken(this.lookahead);\n\t        }\n\t        var params = [];\n\t        var param = this.parsePattern(params);\n\t        var paramMap = {};\n\t        for (var i = 0; i < params.length; i++) {\n\t            var key = '$' + params[i].value;\n\t            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n\t                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);\n\t            }\n\t            paramMap[key] = true;\n\t        }\n\t        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {\n\t            if (this.scanner.isRestrictedWord(param.name)) {\n\t                this.tolerateError(messages_1.Messages.StrictCatchVariable);\n\t            }\n\t        }\n\t        this.expect(')');\n\t        var body = this.parseBlock();\n\t        return this.finalize(node, new Node.CatchClause(param, body));\n\t    };\n\t    Parser.prototype.parseFinallyClause = function () {\n\t        this.expectKeyword('finally');\n\t        return this.parseBlock();\n\t    };\n\t    Parser.prototype.parseTryStatement = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('try');\n\t        var block = this.parseBlock();\n\t        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;\n\t        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;\n\t        if (!handler && !finalizer) {\n\t            this.throwError(messages_1.Messages.NoCatchOrFinally);\n\t        }\n\t        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-debugger-statement\n\t    Parser.prototype.parseDebuggerStatement = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('debugger');\n\t        this.consumeSemicolon();\n\t        return this.finalize(node, new Node.DebuggerStatement());\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations\n\t    Parser.prototype.parseStatement = function () {\n\t        var statement;\n\t        switch (this.lookahead.type) {\n\t            case 1 /* BooleanLiteral */:\n\t            case 5 /* NullLiteral */:\n\t            case 6 /* NumericLiteral */:\n\t            case 8 /* StringLiteral */:\n\t            case 10 /* Template */:\n\t            case 9 /* RegularExpression */:\n\t                statement = this.parseExpressionStatement();\n\t                break;\n\t            case 7 /* Punctuator */:\n\t                var value = this.lookahead.value;\n\t                if (value === '{') {\n\t                    statement = this.parseBlock();\n\t                }\n\t                else if (value === '(') {\n\t                    statement = this.parseExpressionStatement();\n\t                }\n\t                else if (value === ';') {\n\t                    statement = this.parseEmptyStatement();\n\t                }\n\t                else {\n\t                    statement = this.parseExpressionStatement();\n\t                }\n\t                break;\n\t            case 3 /* Identifier */:\n\t                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();\n\t                break;\n\t            case 4 /* Keyword */:\n\t                switch (this.lookahead.value) {\n\t                    case 'break':\n\t                        statement = this.parseBreakStatement();\n\t                        break;\n\t                    case 'continue':\n\t                        statement = this.parseContinueStatement();\n\t                        break;\n\t                    case 'debugger':\n\t                        statement = this.parseDebuggerStatement();\n\t                        break;\n\t                    case 'do':\n\t                        statement = this.parseDoWhileStatement();\n\t                        break;\n\t                    case 'for':\n\t                        statement = this.parseForStatement();\n\t                        break;\n\t                    case 'function':\n\t                        statement = this.parseFunctionDeclaration();\n\t                        break;\n\t                    case 'if':\n\t                        statement = this.parseIfStatement();\n\t                        break;\n\t                    case 'return':\n\t                        statement = this.parseReturnStatement();\n\t                        break;\n\t                    case 'switch':\n\t                        statement = this.parseSwitchStatement();\n\t                        break;\n\t                    case 'throw':\n\t                        statement = this.parseThrowStatement();\n\t                        break;\n\t                    case 'try':\n\t                        statement = this.parseTryStatement();\n\t                        break;\n\t                    case 'var':\n\t                        statement = this.parseVariableStatement();\n\t                        break;\n\t                    case 'while':\n\t                        statement = this.parseWhileStatement();\n\t                        break;\n\t                    case 'with':\n\t                        statement = this.parseWithStatement();\n\t                        break;\n\t                    default:\n\t                        statement = this.parseExpressionStatement();\n\t                        break;\n\t                }\n\t                break;\n\t            default:\n\t                statement = this.throwUnexpectedToken(this.lookahead);\n\t        }\n\t        return statement;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-function-definitions\n\t    Parser.prototype.parseFunctionSourceElements = function () {\n\t        var node = this.createNode();\n\t        this.expect('{');\n\t        var body = this.parseDirectivePrologues();\n\t        var previousLabelSet = this.context.labelSet;\n\t        var previousInIteration = this.context.inIteration;\n\t        var previousInSwitch = this.context.inSwitch;\n\t        var previousInFunctionBody = this.context.inFunctionBody;\n\t        this.context.labelSet = {};\n\t        this.context.inIteration = false;\n\t        this.context.inSwitch = false;\n\t        this.context.inFunctionBody = true;\n\t        while (this.lookahead.type !== 2 /* EOF */) {\n\t            if (this.match('}')) {\n\t                break;\n\t            }\n\t            body.push(this.parseStatementListItem());\n\t        }\n\t        this.expect('}');\n\t        this.context.labelSet = previousLabelSet;\n\t        this.context.inIteration = previousInIteration;\n\t        this.context.inSwitch = previousInSwitch;\n\t        this.context.inFunctionBody = previousInFunctionBody;\n\t        return this.finalize(node, new Node.BlockStatement(body));\n\t    };\n\t    Parser.prototype.validateParam = function (options, param, name) {\n\t        var key = '$' + name;\n\t        if (this.context.strict) {\n\t            if (this.scanner.isRestrictedWord(name)) {\n\t                options.stricted = param;\n\t                options.message = messages_1.Messages.StrictParamName;\n\t            }\n\t            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n\t                options.stricted = param;\n\t                options.message = messages_1.Messages.StrictParamDupe;\n\t            }\n\t        }\n\t        else if (!options.firstRestricted) {\n\t            if (this.scanner.isRestrictedWord(name)) {\n\t                options.firstRestricted = param;\n\t                options.message = messages_1.Messages.StrictParamName;\n\t            }\n\t            else if (this.scanner.isStrictModeReservedWord(name)) {\n\t                options.firstRestricted = param;\n\t                options.message = messages_1.Messages.StrictReservedWord;\n\t            }\n\t            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n\t                options.stricted = param;\n\t                options.message = messages_1.Messages.StrictParamDupe;\n\t            }\n\t        }\n\t        /* istanbul ignore next */\n\t        if (typeof Object.defineProperty === 'function') {\n\t            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });\n\t        }\n\t        else {\n\t            options.paramSet[key] = true;\n\t        }\n\t    };\n\t    Parser.prototype.parseRestElement = function (params) {\n\t        var node = this.createNode();\n\t        this.expect('...');\n\t        var arg = this.parsePattern(params);\n\t        if (this.match('=')) {\n\t            this.throwError(messages_1.Messages.DefaultRestParameter);\n\t        }\n\t        if (!this.match(')')) {\n\t            this.throwError(messages_1.Messages.ParameterAfterRestParameter);\n\t        }\n\t        return this.finalize(node, new Node.RestElement(arg));\n\t    };\n\t    Parser.prototype.parseFormalParameter = function (options) {\n\t        var params = [];\n\t        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);\n\t        for (var i = 0; i < params.length; i++) {\n\t            this.validateParam(options, params[i], params[i].value);\n\t        }\n\t        options.simple = options.simple && (param instanceof Node.Identifier);\n\t        options.params.push(param);\n\t    };\n\t    Parser.prototype.parseFormalParameters = function (firstRestricted) {\n\t        var options;\n\t        options = {\n\t            simple: true,\n\t            params: [],\n\t            firstRestricted: firstRestricted\n\t        };\n\t        this.expect('(');\n\t        if (!this.match(')')) {\n\t            options.paramSet = {};\n\t            while (this.lookahead.type !== 2 /* EOF */) {\n\t                this.parseFormalParameter(options);\n\t                if (this.match(')')) {\n\t                    break;\n\t                }\n\t                this.expect(',');\n\t                if (this.match(')')) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        this.expect(')');\n\t        return {\n\t            simple: options.simple,\n\t            params: options.params,\n\t            stricted: options.stricted,\n\t            firstRestricted: options.firstRestricted,\n\t            message: options.message\n\t        };\n\t    };\n\t    Parser.prototype.matchAsyncFunction = function () {\n\t        var match = this.matchContextualKeyword('async');\n\t        if (match) {\n\t            var state = this.scanner.saveState();\n\t            this.scanner.scanComments();\n\t            var next = this.scanner.lex();\n\t            this.scanner.restoreState(state);\n\t            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');\n\t        }\n\t        return match;\n\t    };\n\t    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {\n\t        var node = this.createNode();\n\t        var isAsync = this.matchContextualKeyword('async');\n\t        if (isAsync) {\n\t            this.nextToken();\n\t        }\n\t        this.expectKeyword('function');\n\t        var isGenerator = isAsync ? false : this.match('*');\n\t        if (isGenerator) {\n\t            this.nextToken();\n\t        }\n\t        var message;\n\t        var id = null;\n\t        var firstRestricted = null;\n\t        if (!identifierIsOptional || !this.match('(')) {\n\t            var token = this.lookahead;\n\t            id = this.parseVariableIdentifier();\n\t            if (this.context.strict) {\n\t                if (this.scanner.isRestrictedWord(token.value)) {\n\t                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);\n\t                }\n\t            }\n\t            else {\n\t                if (this.scanner.isRestrictedWord(token.value)) {\n\t                    firstRestricted = token;\n\t                    message = messages_1.Messages.StrictFunctionName;\n\t                }\n\t                else if (this.scanner.isStrictModeReservedWord(token.value)) {\n\t                    firstRestricted = token;\n\t                    message = messages_1.Messages.StrictReservedWord;\n\t                }\n\t            }\n\t        }\n\t        var previousAllowAwait = this.context.await;\n\t        var previousAllowYield = this.context.allowYield;\n\t        this.context.await = isAsync;\n\t        this.context.allowYield = !isGenerator;\n\t        var formalParameters = this.parseFormalParameters(firstRestricted);\n\t        var params = formalParameters.params;\n\t        var stricted = formalParameters.stricted;\n\t        firstRestricted = formalParameters.firstRestricted;\n\t        if (formalParameters.message) {\n\t            message = formalParameters.message;\n\t        }\n\t        var previousStrict = this.context.strict;\n\t        var previousAllowStrictDirective = this.context.allowStrictDirective;\n\t        this.context.allowStrictDirective = formalParameters.simple;\n\t        var body = this.parseFunctionSourceElements();\n\t        if (this.context.strict && firstRestricted) {\n\t            this.throwUnexpectedToken(firstRestricted, message);\n\t        }\n\t        if (this.context.strict && stricted) {\n\t            this.tolerateUnexpectedToken(stricted, message);\n\t        }\n\t        this.context.strict = previousStrict;\n\t        this.context.allowStrictDirective = previousAllowStrictDirective;\n\t        this.context.await = previousAllowAwait;\n\t        this.context.allowYield = previousAllowYield;\n\t        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :\n\t            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));\n\t    };\n\t    Parser.prototype.parseFunctionExpression = function () {\n\t        var node = this.createNode();\n\t        var isAsync = this.matchContextualKeyword('async');\n\t        if (isAsync) {\n\t            this.nextToken();\n\t        }\n\t        this.expectKeyword('function');\n\t        var isGenerator = isAsync ? false : this.match('*');\n\t        if (isGenerator) {\n\t            this.nextToken();\n\t        }\n\t        var message;\n\t        var id = null;\n\t        var firstRestricted;\n\t        var previousAllowAwait = this.context.await;\n\t        var previousAllowYield = this.context.allowYield;\n\t        this.context.await = isAsync;\n\t        this.context.allowYield = !isGenerator;\n\t        if (!this.match('(')) {\n\t            var token = this.lookahead;\n\t            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();\n\t            if (this.context.strict) {\n\t                if (this.scanner.isRestrictedWord(token.value)) {\n\t                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);\n\t                }\n\t            }\n\t            else {\n\t                if (this.scanner.isRestrictedWord(token.value)) {\n\t                    firstRestricted = token;\n\t                    message = messages_1.Messages.StrictFunctionName;\n\t                }\n\t                else if (this.scanner.isStrictModeReservedWord(token.value)) {\n\t                    firstRestricted = token;\n\t                    message = messages_1.Messages.StrictReservedWord;\n\t                }\n\t            }\n\t        }\n\t        var formalParameters = this.parseFormalParameters(firstRestricted);\n\t        var params = formalParameters.params;\n\t        var stricted = formalParameters.stricted;\n\t        firstRestricted = formalParameters.firstRestricted;\n\t        if (formalParameters.message) {\n\t            message = formalParameters.message;\n\t        }\n\t        var previousStrict = this.context.strict;\n\t        var previousAllowStrictDirective = this.context.allowStrictDirective;\n\t        this.context.allowStrictDirective = formalParameters.simple;\n\t        var body = this.parseFunctionSourceElements();\n\t        if (this.context.strict && firstRestricted) {\n\t            this.throwUnexpectedToken(firstRestricted, message);\n\t        }\n\t        if (this.context.strict && stricted) {\n\t            this.tolerateUnexpectedToken(stricted, message);\n\t        }\n\t        this.context.strict = previousStrict;\n\t        this.context.allowStrictDirective = previousAllowStrictDirective;\n\t        this.context.await = previousAllowAwait;\n\t        this.context.allowYield = previousAllowYield;\n\t        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :\n\t            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive\n\t    Parser.prototype.parseDirective = function () {\n\t        var token = this.lookahead;\n\t        var node = this.createNode();\n\t        var expr = this.parseExpression();\n\t        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;\n\t        this.consumeSemicolon();\n\t        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));\n\t    };\n\t    Parser.prototype.parseDirectivePrologues = function () {\n\t        var firstRestricted = null;\n\t        var body = [];\n\t        while (true) {\n\t            var token = this.lookahead;\n\t            if (token.type !== 8 /* StringLiteral */) {\n\t                break;\n\t            }\n\t            var statement = this.parseDirective();\n\t            body.push(statement);\n\t            var directive = statement.directive;\n\t            if (typeof directive !== 'string') {\n\t                break;\n\t            }\n\t            if (directive === 'use strict') {\n\t                this.context.strict = true;\n\t                if (firstRestricted) {\n\t                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);\n\t                }\n\t                if (!this.context.allowStrictDirective) {\n\t                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);\n\t                }\n\t            }\n\t            else {\n\t                if (!firstRestricted && token.octal) {\n\t                    firstRestricted = token;\n\t                }\n\t            }\n\t        }\n\t        return body;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-method-definitions\n\t    Parser.prototype.qualifiedPropertyName = function (token) {\n\t        switch (token.type) {\n\t            case 3 /* Identifier */:\n\t            case 8 /* StringLiteral */:\n\t            case 1 /* BooleanLiteral */:\n\t            case 5 /* NullLiteral */:\n\t            case 6 /* NumericLiteral */:\n\t            case 4 /* Keyword */:\n\t                return true;\n\t            case 7 /* Punctuator */:\n\t                return token.value === '[';\n\t            default:\n\t                break;\n\t        }\n\t        return false;\n\t    };\n\t    Parser.prototype.parseGetterMethod = function () {\n\t        var node = this.createNode();\n\t        var isGenerator = false;\n\t        var previousAllowYield = this.context.allowYield;\n\t        this.context.allowYield = !isGenerator;\n\t        var formalParameters = this.parseFormalParameters();\n\t        if (formalParameters.params.length > 0) {\n\t            this.tolerateError(messages_1.Messages.BadGetterArity);\n\t        }\n\t        var method = this.parsePropertyMethod(formalParameters);\n\t        this.context.allowYield = previousAllowYield;\n\t        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));\n\t    };\n\t    Parser.prototype.parseSetterMethod = function () {\n\t        var node = this.createNode();\n\t        var isGenerator = false;\n\t        var previousAllowYield = this.context.allowYield;\n\t        this.context.allowYield = !isGenerator;\n\t        var formalParameters = this.parseFormalParameters();\n\t        if (formalParameters.params.length !== 1) {\n\t            this.tolerateError(messages_1.Messages.BadSetterArity);\n\t        }\n\t        else if (formalParameters.params[0] instanceof Node.RestElement) {\n\t            this.tolerateError(messages_1.Messages.BadSetterRestParameter);\n\t        }\n\t        var method = this.parsePropertyMethod(formalParameters);\n\t        this.context.allowYield = previousAllowYield;\n\t        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));\n\t    };\n\t    Parser.prototype.parseGeneratorMethod = function () {\n\t        var node = this.createNode();\n\t        var isGenerator = true;\n\t        var previousAllowYield = this.context.allowYield;\n\t        this.context.allowYield = true;\n\t        var params = this.parseFormalParameters();\n\t        this.context.allowYield = false;\n\t        var method = this.parsePropertyMethod(params);\n\t        this.context.allowYield = previousAllowYield;\n\t        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-generator-function-definitions\n\t    Parser.prototype.isStartOfExpression = function () {\n\t        var start = true;\n\t        var value = this.lookahead.value;\n\t        switch (this.lookahead.type) {\n\t            case 7 /* Punctuator */:\n\t                start = (value === '[') || (value === '(') || (value === '{') ||\n\t                    (value === '+') || (value === '-') ||\n\t                    (value === '!') || (value === '~') ||\n\t                    (value === '++') || (value === '--') ||\n\t                    (value === '/') || (value === '/='); // regular expression literal\n\t                break;\n\t            case 4 /* Keyword */:\n\t                start = (value === 'class') || (value === 'delete') ||\n\t                    (value === 'function') || (value === 'let') || (value === 'new') ||\n\t                    (value === 'super') || (value === 'this') || (value === 'typeof') ||\n\t                    (value === 'void') || (value === 'yield');\n\t                break;\n\t            default:\n\t                break;\n\t        }\n\t        return start;\n\t    };\n\t    Parser.prototype.parseYieldExpression = function () {\n\t        var node = this.createNode();\n\t        this.expectKeyword('yield');\n\t        var argument = null;\n\t        var delegate = false;\n\t        if (!this.hasLineTerminator) {\n\t            var previousAllowYield = this.context.allowYield;\n\t            this.context.allowYield = false;\n\t            delegate = this.match('*');\n\t            if (delegate) {\n\t                this.nextToken();\n\t                argument = this.parseAssignmentExpression();\n\t            }\n\t            else if (this.isStartOfExpression()) {\n\t                argument = this.parseAssignmentExpression();\n\t            }\n\t            this.context.allowYield = previousAllowYield;\n\t        }\n\t        return this.finalize(node, new Node.YieldExpression(argument, delegate));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-class-definitions\n\t    Parser.prototype.parseClassElement = function (hasConstructor) {\n\t        var token = this.lookahead;\n\t        var node = this.createNode();\n\t        var kind = '';\n\t        var key = null;\n\t        var value = null;\n\t        var computed = false;\n\t        var method = false;\n\t        var isStatic = false;\n\t        var isAsync = false;\n\t        if (this.match('*')) {\n\t            this.nextToken();\n\t        }\n\t        else {\n\t            computed = this.match('[');\n\t            key = this.parseObjectPropertyKey();\n\t            var id = key;\n\t            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {\n\t                token = this.lookahead;\n\t                isStatic = true;\n\t                computed = this.match('[');\n\t                if (this.match('*')) {\n\t                    this.nextToken();\n\t                }\n\t                else {\n\t                    key = this.parseObjectPropertyKey();\n\t                }\n\t            }\n\t            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {\n\t                var punctuator = this.lookahead.value;\n\t                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {\n\t                    isAsync = true;\n\t                    token = this.lookahead;\n\t                    key = this.parseObjectPropertyKey();\n\t                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {\n\t                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);\n\t        if (token.type === 3 /* Identifier */) {\n\t            if (token.value === 'get' && lookaheadPropertyKey) {\n\t                kind = 'get';\n\t                computed = this.match('[');\n\t                key = this.parseObjectPropertyKey();\n\t                this.context.allowYield = false;\n\t                value = this.parseGetterMethod();\n\t            }\n\t            else if (token.value === 'set' && lookaheadPropertyKey) {\n\t                kind = 'set';\n\t                computed = this.match('[');\n\t                key = this.parseObjectPropertyKey();\n\t                value = this.parseSetterMethod();\n\t            }\n\t        }\n\t        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {\n\t            kind = 'init';\n\t            computed = this.match('[');\n\t            key = this.parseObjectPropertyKey();\n\t            value = this.parseGeneratorMethod();\n\t            method = true;\n\t        }\n\t        if (!kind && key && this.match('(')) {\n\t            kind = 'init';\n\t            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();\n\t            method = true;\n\t        }\n\t        if (!kind) {\n\t            this.throwUnexpectedToken(this.lookahead);\n\t        }\n\t        if (kind === 'init') {\n\t            kind = 'method';\n\t        }\n\t        if (!computed) {\n\t            if (isStatic && this.isPropertyKey(key, 'prototype')) {\n\t                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);\n\t            }\n\t            if (!isStatic && this.isPropertyKey(key, 'constructor')) {\n\t                if (kind !== 'method' || !method || (value && value.generator)) {\n\t                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);\n\t                }\n\t                if (hasConstructor.value) {\n\t                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);\n\t                }\n\t                else {\n\t                    hasConstructor.value = true;\n\t                }\n\t                kind = 'constructor';\n\t            }\n\t        }\n\t        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));\n\t    };\n\t    Parser.prototype.parseClassElementList = function () {\n\t        var body = [];\n\t        var hasConstructor = { value: false };\n\t        this.expect('{');\n\t        while (!this.match('}')) {\n\t            if (this.match(';')) {\n\t                this.nextToken();\n\t            }\n\t            else {\n\t                body.push(this.parseClassElement(hasConstructor));\n\t            }\n\t        }\n\t        this.expect('}');\n\t        return body;\n\t    };\n\t    Parser.prototype.parseClassBody = function () {\n\t        var node = this.createNode();\n\t        var elementList = this.parseClassElementList();\n\t        return this.finalize(node, new Node.ClassBody(elementList));\n\t    };\n\t    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {\n\t        var node = this.createNode();\n\t        var previousStrict = this.context.strict;\n\t        this.context.strict = true;\n\t        this.expectKeyword('class');\n\t        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();\n\t        var superClass = null;\n\t        if (this.matchKeyword('extends')) {\n\t            this.nextToken();\n\t            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n\t        }\n\t        var classBody = this.parseClassBody();\n\t        this.context.strict = previousStrict;\n\t        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));\n\t    };\n\t    Parser.prototype.parseClassExpression = function () {\n\t        var node = this.createNode();\n\t        var previousStrict = this.context.strict;\n\t        this.context.strict = true;\n\t        this.expectKeyword('class');\n\t        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;\n\t        var superClass = null;\n\t        if (this.matchKeyword('extends')) {\n\t            this.nextToken();\n\t            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n\t        }\n\t        var classBody = this.parseClassBody();\n\t        this.context.strict = previousStrict;\n\t        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-scripts\n\t    // https://tc39.github.io/ecma262/#sec-modules\n\t    Parser.prototype.parseModule = function () {\n\t        this.context.strict = true;\n\t        this.context.isModule = true;\n\t        this.scanner.isModule = true;\n\t        var node = this.createNode();\n\t        var body = this.parseDirectivePrologues();\n\t        while (this.lookahead.type !== 2 /* EOF */) {\n\t            body.push(this.parseStatementListItem());\n\t        }\n\t        return this.finalize(node, new Node.Module(body));\n\t    };\n\t    Parser.prototype.parseScript = function () {\n\t        var node = this.createNode();\n\t        var body = this.parseDirectivePrologues();\n\t        while (this.lookahead.type !== 2 /* EOF */) {\n\t            body.push(this.parseStatementListItem());\n\t        }\n\t        return this.finalize(node, new Node.Script(body));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-imports\n\t    Parser.prototype.parseModuleSpecifier = function () {\n\t        var node = this.createNode();\n\t        if (this.lookahead.type !== 8 /* StringLiteral */) {\n\t            this.throwError(messages_1.Messages.InvalidModuleSpecifier);\n\t        }\n\t        var token = this.nextToken();\n\t        var raw = this.getTokenRaw(token);\n\t        return this.finalize(node, new Node.Literal(token.value, raw));\n\t    };\n\t    // import {<foo as bar>} ...;\n\t    Parser.prototype.parseImportSpecifier = function () {\n\t        var node = this.createNode();\n\t        var imported;\n\t        var local;\n\t        if (this.lookahead.type === 3 /* Identifier */) {\n\t            imported = this.parseVariableIdentifier();\n\t            local = imported;\n\t            if (this.matchContextualKeyword('as')) {\n\t                this.nextToken();\n\t                local = this.parseVariableIdentifier();\n\t            }\n\t        }\n\t        else {\n\t            imported = this.parseIdentifierName();\n\t            local = imported;\n\t            if (this.matchContextualKeyword('as')) {\n\t                this.nextToken();\n\t                local = this.parseVariableIdentifier();\n\t            }\n\t            else {\n\t                this.throwUnexpectedToken(this.nextToken());\n\t            }\n\t        }\n\t        return this.finalize(node, new Node.ImportSpecifier(local, imported));\n\t    };\n\t    // {foo, bar as bas}\n\t    Parser.prototype.parseNamedImports = function () {\n\t        this.expect('{');\n\t        var specifiers = [];\n\t        while (!this.match('}')) {\n\t            specifiers.push(this.parseImportSpecifier());\n\t            if (!this.match('}')) {\n\t                this.expect(',');\n\t            }\n\t        }\n\t        this.expect('}');\n\t        return specifiers;\n\t    };\n\t    // import <foo> ...;\n\t    Parser.prototype.parseImportDefaultSpecifier = function () {\n\t        var node = this.createNode();\n\t        var local = this.parseIdentifierName();\n\t        return this.finalize(node, new Node.ImportDefaultSpecifier(local));\n\t    };\n\t    // import <* as foo> ...;\n\t    Parser.prototype.parseImportNamespaceSpecifier = function () {\n\t        var node = this.createNode();\n\t        this.expect('*');\n\t        if (!this.matchContextualKeyword('as')) {\n\t            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);\n\t        }\n\t        this.nextToken();\n\t        var local = this.parseIdentifierName();\n\t        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));\n\t    };\n\t    Parser.prototype.parseImportDeclaration = function () {\n\t        if (this.context.inFunctionBody) {\n\t            this.throwError(messages_1.Messages.IllegalImportDeclaration);\n\t        }\n\t        var node = this.createNode();\n\t        this.expectKeyword('import');\n\t        var src;\n\t        var specifiers = [];\n\t        if (this.lookahead.type === 8 /* StringLiteral */) {\n\t            // import 'foo';\n\t            src = this.parseModuleSpecifier();\n\t        }\n\t        else {\n\t            if (this.match('{')) {\n\t                // import {bar}\n\t                specifiers = specifiers.concat(this.parseNamedImports());\n\t            }\n\t            else if (this.match('*')) {\n\t                // import * as foo\n\t                specifiers.push(this.parseImportNamespaceSpecifier());\n\t            }\n\t            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {\n\t                // import foo\n\t                specifiers.push(this.parseImportDefaultSpecifier());\n\t                if (this.match(',')) {\n\t                    this.nextToken();\n\t                    if (this.match('*')) {\n\t                        // import foo, * as foo\n\t                        specifiers.push(this.parseImportNamespaceSpecifier());\n\t                    }\n\t                    else if (this.match('{')) {\n\t                        // import foo, {bar}\n\t                        specifiers = specifiers.concat(this.parseNamedImports());\n\t                    }\n\t                    else {\n\t                        this.throwUnexpectedToken(this.lookahead);\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                this.throwUnexpectedToken(this.nextToken());\n\t            }\n\t            if (!this.matchContextualKeyword('from')) {\n\t                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\n\t                this.throwError(message, this.lookahead.value);\n\t            }\n\t            this.nextToken();\n\t            src = this.parseModuleSpecifier();\n\t        }\n\t        this.consumeSemicolon();\n\t        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-exports\n\t    Parser.prototype.parseExportSpecifier = function () {\n\t        var node = this.createNode();\n\t        var local = this.parseIdentifierName();\n\t        var exported = local;\n\t        if (this.matchContextualKeyword('as')) {\n\t            this.nextToken();\n\t            exported = this.parseIdentifierName();\n\t        }\n\t        return this.finalize(node, new Node.ExportSpecifier(local, exported));\n\t    };\n\t    Parser.prototype.parseExportDeclaration = function () {\n\t        if (this.context.inFunctionBody) {\n\t            this.throwError(messages_1.Messages.IllegalExportDeclaration);\n\t        }\n\t        var node = this.createNode();\n\t        this.expectKeyword('export');\n\t        var exportDeclaration;\n\t        if (this.matchKeyword('default')) {\n\t            // export default ...\n\t            this.nextToken();\n\t            if (this.matchKeyword('function')) {\n\t                // export default function foo () {}\n\t                // export default function () {}\n\t                var declaration = this.parseFunctionDeclaration(true);\n\t                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\n\t            }\n\t            else if (this.matchKeyword('class')) {\n\t                // export default class foo {}\n\t                var declaration = this.parseClassDeclaration(true);\n\t                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\n\t            }\n\t            else if (this.matchContextualKeyword('async')) {\n\t                // export default async function f () {}\n\t                // export default async function () {}\n\t                // export default async x => x\n\t                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();\n\t                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\n\t            }\n\t            else {\n\t                if (this.matchContextualKeyword('from')) {\n\t                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);\n\t                }\n\t                // export default {};\n\t                // export default [];\n\t                // export default (1 + 2);\n\t                var declaration = this.match('{') ? this.parseObjectInitializer() :\n\t                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();\n\t                this.consumeSemicolon();\n\t                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\n\t            }\n\t        }\n\t        else if (this.match('*')) {\n\t            // export * from 'foo';\n\t            this.nextToken();\n\t            if (!this.matchContextualKeyword('from')) {\n\t                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\n\t                this.throwError(message, this.lookahead.value);\n\t            }\n\t            this.nextToken();\n\t            var src = this.parseModuleSpecifier();\n\t            this.consumeSemicolon();\n\t            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));\n\t        }\n\t        else if (this.lookahead.type === 4 /* Keyword */) {\n\t            // export var f = 1;\n\t            var declaration = void 0;\n\t            switch (this.lookahead.value) {\n\t                case 'let':\n\t                case 'const':\n\t                    declaration = this.parseLexicalDeclaration({ inFor: false });\n\t                    break;\n\t                case 'var':\n\t                case 'class':\n\t                case 'function':\n\t                    declaration = this.parseStatementListItem();\n\t                    break;\n\t                default:\n\t                    this.throwUnexpectedToken(this.lookahead);\n\t            }\n\t            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));\n\t        }\n\t        else if (this.matchAsyncFunction()) {\n\t            var declaration = this.parseFunctionDeclaration();\n\t            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));\n\t        }\n\t        else {\n\t            var specifiers = [];\n\t            var source = null;\n\t            var isExportFromIdentifier = false;\n\t            this.expect('{');\n\t            while (!this.match('}')) {\n\t                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');\n\t                specifiers.push(this.parseExportSpecifier());\n\t                if (!this.match('}')) {\n\t                    this.expect(',');\n\t                }\n\t            }\n\t            this.expect('}');\n\t            if (this.matchContextualKeyword('from')) {\n\t                // export {default} from 'foo';\n\t                // export {foo} from 'foo';\n\t                this.nextToken();\n\t                source = this.parseModuleSpecifier();\n\t                this.consumeSemicolon();\n\t            }\n\t            else if (isExportFromIdentifier) {\n\t                // export {default}; // missing fromClause\n\t                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\n\t                this.throwError(message, this.lookahead.value);\n\t            }\n\t            else {\n\t                // export {foo};\n\t                this.consumeSemicolon();\n\t            }\n\t            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));\n\t        }\n\t        return exportDeclaration;\n\t    };\n\t    return Parser;\n\t}());\n\texports.Parser = Parser;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t// Ensure the condition is true, otherwise throw an error.\n\t// This is only to have a better contract semantic, i.e. another safety net\n\t// to catch a logic error. The condition shall be fulfilled in normal case.\n\t// Do NOT use this to enforce a certain condition on any user input.\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tfunction assert(condition, message) {\n\t    /* istanbul ignore if */\n\t    if (!condition) {\n\t        throw new Error('ASSERT: ' + message);\n\t    }\n\t}\n\texports.assert = assert;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/* tslint:disable:max-classes-per-file */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar ErrorHandler = (function () {\n\t    function ErrorHandler() {\n\t        this.errors = [];\n\t        this.tolerant = false;\n\t    }\n\t    ErrorHandler.prototype.recordError = function (error) {\n\t        this.errors.push(error);\n\t    };\n\t    ErrorHandler.prototype.tolerate = function (error) {\n\t        if (this.tolerant) {\n\t            this.recordError(error);\n\t        }\n\t        else {\n\t            throw error;\n\t        }\n\t    };\n\t    ErrorHandler.prototype.constructError = function (msg, column) {\n\t        var error = new Error(msg);\n\t        try {\n\t            throw error;\n\t        }\n\t        catch (base) {\n\t            /* istanbul ignore else */\n\t            if (Object.create && Object.defineProperty) {\n\t                error = Object.create(base);\n\t                Object.defineProperty(error, 'column', { value: column });\n\t            }\n\t        }\n\t        /* istanbul ignore next */\n\t        return error;\n\t    };\n\t    ErrorHandler.prototype.createError = function (index, line, col, description) {\n\t        var msg = 'Line ' + line + ': ' + description;\n\t        var error = this.constructError(msg, col);\n\t        error.index = index;\n\t        error.lineNumber = line;\n\t        error.description = description;\n\t        return error;\n\t    };\n\t    ErrorHandler.prototype.throwError = function (index, line, col, description) {\n\t        throw this.createError(index, line, col, description);\n\t    };\n\t    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {\n\t        var error = this.createError(index, line, col, description);\n\t        if (this.tolerant) {\n\t            this.recordError(error);\n\t        }\n\t        else {\n\t            throw error;\n\t        }\n\t    };\n\t    return ErrorHandler;\n\t}());\n\texports.ErrorHandler = ErrorHandler;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t// Error messages should be identical to V8.\n\texports.Messages = {\n\t    BadGetterArity: 'Getter must not have any formal parameters',\n\t    BadSetterArity: 'Setter must have exactly one formal parameter',\n\t    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',\n\t    ConstructorIsAsync: 'Class constructor may not be an async method',\n\t    ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n\t    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',\n\t    DefaultRestParameter: 'Unexpected token =',\n\t    DuplicateBinding: 'Duplicate binding %0',\n\t    DuplicateConstructor: 'A class may only have one constructor',\n\t    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n\t    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',\n\t    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',\n\t    IllegalBreak: 'Illegal break statement',\n\t    IllegalContinue: 'Illegal continue statement',\n\t    IllegalExportDeclaration: 'Unexpected token',\n\t    IllegalImportDeclaration: 'Unexpected token',\n\t    IllegalLanguageModeDirective: 'Illegal \\'use strict\\' directive in function with non-simple parameter list',\n\t    IllegalReturn: 'Illegal return statement',\n\t    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',\n\t    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',\n\t    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n\t    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n\t    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',\n\t    InvalidModuleSpecifier: 'Unexpected token',\n\t    InvalidRegExp: 'Invalid regular expression',\n\t    LetInLexicalBinding: 'let is disallowed as a lexically bound name',\n\t    MissingFromClause: 'Unexpected token',\n\t    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n\t    NewlineAfterThrow: 'Illegal newline after throw',\n\t    NoAsAfterImportNamespace: 'Unexpected token',\n\t    NoCatchOrFinally: 'Missing catch or finally after try',\n\t    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n\t    Redeclaration: '%0 \\'%1\\' has already been declared',\n\t    StaticPrototype: 'Classes may not have static property named prototype',\n\t    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n\t    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n\t    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',\n\t    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n\t    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n\t    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n\t    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n\t    StrictModeWith: 'Strict mode code may not include a with statement',\n\t    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n\t    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n\t    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n\t    StrictReservedWord: 'Use of future reserved word in strict mode',\n\t    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n\t    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n\t    UnexpectedEOS: 'Unexpected end of input',\n\t    UnexpectedIdentifier: 'Unexpected identifier',\n\t    UnexpectedNumber: 'Unexpected number',\n\t    UnexpectedReserved: 'Unexpected reserved word',\n\t    UnexpectedString: 'Unexpected string',\n\t    UnexpectedTemplate: 'Unexpected quasi %0',\n\t    UnexpectedToken: 'Unexpected token %0',\n\t    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',\n\t    UnknownLabel: 'Undefined label \\'%0\\'',\n\t    UnterminatedRegExp: 'Invalid regular expression: missing /'\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar assert_1 = __webpack_require__(9);\n\tvar character_1 = __webpack_require__(4);\n\tvar messages_1 = __webpack_require__(11);\n\tfunction hexValue(ch) {\n\t    return '0123456789abcdef'.indexOf(ch.toLowerCase());\n\t}\n\tfunction octalValue(ch) {\n\t    return '01234567'.indexOf(ch);\n\t}\n\tvar Scanner = (function () {\n\t    function Scanner(code, handler) {\n\t        this.source = code;\n\t        this.errorHandler = handler;\n\t        this.trackComment = false;\n\t        this.isModule = false;\n\t        this.length = code.length;\n\t        this.index = 0;\n\t        this.lineNumber = (code.length > 0) ? 1 : 0;\n\t        this.lineStart = 0;\n\t        this.curlyStack = [];\n\t    }\n\t    Scanner.prototype.saveState = function () {\n\t        return {\n\t            index: this.index,\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart\n\t        };\n\t    };\n\t    Scanner.prototype.restoreState = function (state) {\n\t        this.index = state.index;\n\t        this.lineNumber = state.lineNumber;\n\t        this.lineStart = state.lineStart;\n\t    };\n\t    Scanner.prototype.eof = function () {\n\t        return this.index >= this.length;\n\t    };\n\t    Scanner.prototype.throwUnexpectedToken = function (message) {\n\t        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }\n\t        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);\n\t    };\n\t    Scanner.prototype.tolerateUnexpectedToken = function (message) {\n\t        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }\n\t        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-comments\n\t    Scanner.prototype.skipSingleLineComment = function (offset) {\n\t        var comments = [];\n\t        var start, loc;\n\t        if (this.trackComment) {\n\t            comments = [];\n\t            start = this.index - offset;\n\t            loc = {\n\t                start: {\n\t                    line: this.lineNumber,\n\t                    column: this.index - this.lineStart - offset\n\t                },\n\t                end: {}\n\t            };\n\t        }\n\t        while (!this.eof()) {\n\t            var ch = this.source.charCodeAt(this.index);\n\t            ++this.index;\n\t            if (character_1.Character.isLineTerminator(ch)) {\n\t                if (this.trackComment) {\n\t                    loc.end = {\n\t                        line: this.lineNumber,\n\t                        column: this.index - this.lineStart - 1\n\t                    };\n\t                    var entry = {\n\t                        multiLine: false,\n\t                        slice: [start + offset, this.index - 1],\n\t                        range: [start, this.index - 1],\n\t                        loc: loc\n\t                    };\n\t                    comments.push(entry);\n\t                }\n\t                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {\n\t                    ++this.index;\n\t                }\n\t                ++this.lineNumber;\n\t                this.lineStart = this.index;\n\t                return comments;\n\t            }\n\t        }\n\t        if (this.trackComment) {\n\t            loc.end = {\n\t                line: this.lineNumber,\n\t                column: this.index - this.lineStart\n\t            };\n\t            var entry = {\n\t                multiLine: false,\n\t                slice: [start + offset, this.index],\n\t                range: [start, this.index],\n\t                loc: loc\n\t            };\n\t            comments.push(entry);\n\t        }\n\t        return comments;\n\t    };\n\t    Scanner.prototype.skipMultiLineComment = function () {\n\t        var comments = [];\n\t        var start, loc;\n\t        if (this.trackComment) {\n\t            comments = [];\n\t            start = this.index - 2;\n\t            loc = {\n\t                start: {\n\t                    line: this.lineNumber,\n\t                    column: this.index - this.lineStart - 2\n\t                },\n\t                end: {}\n\t            };\n\t        }\n\t        while (!this.eof()) {\n\t            var ch = this.source.charCodeAt(this.index);\n\t            if (character_1.Character.isLineTerminator(ch)) {\n\t                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {\n\t                    ++this.index;\n\t                }\n\t                ++this.lineNumber;\n\t                ++this.index;\n\t                this.lineStart = this.index;\n\t            }\n\t            else if (ch === 0x2A) {\n\t                // Block comment ends with '*/'.\n\t                if (this.source.charCodeAt(this.index + 1) === 0x2F) {\n\t                    this.index += 2;\n\t                    if (this.trackComment) {\n\t                        loc.end = {\n\t                            line: this.lineNumber,\n\t                            column: this.index - this.lineStart\n\t                        };\n\t                        var entry = {\n\t                            multiLine: true,\n\t                            slice: [start + 2, this.index - 2],\n\t                            range: [start, this.index],\n\t                            loc: loc\n\t                        };\n\t                        comments.push(entry);\n\t                    }\n\t                    return comments;\n\t                }\n\t                ++this.index;\n\t            }\n\t            else {\n\t                ++this.index;\n\t            }\n\t        }\n\t        // Ran off the end of the file - the whole thing is a comment\n\t        if (this.trackComment) {\n\t            loc.end = {\n\t                line: this.lineNumber,\n\t                column: this.index - this.lineStart\n\t            };\n\t            var entry = {\n\t                multiLine: true,\n\t                slice: [start + 2, this.index],\n\t                range: [start, this.index],\n\t                loc: loc\n\t            };\n\t            comments.push(entry);\n\t        }\n\t        this.tolerateUnexpectedToken();\n\t        return comments;\n\t    };\n\t    Scanner.prototype.scanComments = function () {\n\t        var comments;\n\t        if (this.trackComment) {\n\t            comments = [];\n\t        }\n\t        var start = (this.index === 0);\n\t        while (!this.eof()) {\n\t            var ch = this.source.charCodeAt(this.index);\n\t            if (character_1.Character.isWhiteSpace(ch)) {\n\t                ++this.index;\n\t            }\n\t            else if (character_1.Character.isLineTerminator(ch)) {\n\t                ++this.index;\n\t                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {\n\t                    ++this.index;\n\t                }\n\t                ++this.lineNumber;\n\t                this.lineStart = this.index;\n\t                start = true;\n\t            }\n\t            else if (ch === 0x2F) {\n\t                ch = this.source.charCodeAt(this.index + 1);\n\t                if (ch === 0x2F) {\n\t                    this.index += 2;\n\t                    var comment = this.skipSingleLineComment(2);\n\t                    if (this.trackComment) {\n\t                        comments = comments.concat(comment);\n\t                    }\n\t                    start = true;\n\t                }\n\t                else if (ch === 0x2A) {\n\t                    this.index += 2;\n\t                    var comment = this.skipMultiLineComment();\n\t                    if (this.trackComment) {\n\t                        comments = comments.concat(comment);\n\t                    }\n\t                }\n\t                else {\n\t                    break;\n\t                }\n\t            }\n\t            else if (start && ch === 0x2D) {\n\t                // U+003E is '>'\n\t                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {\n\t                    // '-->' is a single-line comment\n\t                    this.index += 3;\n\t                    var comment = this.skipSingleLineComment(3);\n\t                    if (this.trackComment) {\n\t                        comments = comments.concat(comment);\n\t                    }\n\t                }\n\t                else {\n\t                    break;\n\t                }\n\t            }\n\t            else if (ch === 0x3C && !this.isModule) {\n\t                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {\n\t                    this.index += 4; // `<!--`\n\t                    var comment = this.skipSingleLineComment(4);\n\t                    if (this.trackComment) {\n\t                        comments = comments.concat(comment);\n\t                    }\n\t                }\n\t                else {\n\t                    break;\n\t                }\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        return comments;\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-future-reserved-words\n\t    Scanner.prototype.isFutureReservedWord = function (id) {\n\t        switch (id) {\n\t            case 'enum':\n\t            case 'export':\n\t            case 'import':\n\t            case 'super':\n\t                return true;\n\t            default:\n\t                return false;\n\t        }\n\t    };\n\t    Scanner.prototype.isStrictModeReservedWord = function (id) {\n\t        switch (id) {\n\t            case 'implements':\n\t            case 'interface':\n\t            case 'package':\n\t            case 'private':\n\t            case 'protected':\n\t            case 'public':\n\t            case 'static':\n\t            case 'yield':\n\t            case 'let':\n\t                return true;\n\t            default:\n\t                return false;\n\t        }\n\t    };\n\t    Scanner.prototype.isRestrictedWord = function (id) {\n\t        return id === 'eval' || id === 'arguments';\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-keywords\n\t    Scanner.prototype.isKeyword = function (id) {\n\t        switch (id.length) {\n\t            case 2:\n\t                return (id === 'if') || (id === 'in') || (id === 'do');\n\t            case 3:\n\t                return (id === 'var') || (id === 'for') || (id === 'new') ||\n\t                    (id === 'try') || (id === 'let');\n\t            case 4:\n\t                return (id === 'this') || (id === 'else') || (id === 'case') ||\n\t                    (id === 'void') || (id === 'with') || (id === 'enum');\n\t            case 5:\n\t                return (id === 'while') || (id === 'break') || (id === 'catch') ||\n\t                    (id === 'throw') || (id === 'const') || (id === 'yield') ||\n\t                    (id === 'class') || (id === 'super');\n\t            case 6:\n\t                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n\t                    (id === 'switch') || (id === 'export') || (id === 'import');\n\t            case 7:\n\t                return (id === 'default') || (id === 'finally') || (id === 'extends');\n\t            case 8:\n\t                return (id === 'function') || (id === 'continue') || (id === 'debugger');\n\t            case 10:\n\t                return (id === 'instanceof');\n\t            default:\n\t                return false;\n\t        }\n\t    };\n\t    Scanner.prototype.codePointAt = function (i) {\n\t        var cp = this.source.charCodeAt(i);\n\t        if (cp >= 0xD800 && cp <= 0xDBFF) {\n\t            var second = this.source.charCodeAt(i + 1);\n\t            if (second >= 0xDC00 && second <= 0xDFFF) {\n\t                var first = cp;\n\t                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t            }\n\t        }\n\t        return cp;\n\t    };\n\t    Scanner.prototype.scanHexEscape = function (prefix) {\n\t        var len = (prefix === 'u') ? 4 : 2;\n\t        var code = 0;\n\t        for (var i = 0; i < len; ++i) {\n\t            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {\n\t                code = code * 16 + hexValue(this.source[this.index++]);\n\t            }\n\t            else {\n\t                return null;\n\t            }\n\t        }\n\t        return String.fromCharCode(code);\n\t    };\n\t    Scanner.prototype.scanUnicodeCodePointEscape = function () {\n\t        var ch = this.source[this.index];\n\t        var code = 0;\n\t        // At least, one hex digit is required.\n\t        if (ch === '}') {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        while (!this.eof()) {\n\t            ch = this.source[this.index++];\n\t            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {\n\t                break;\n\t            }\n\t            code = code * 16 + hexValue(ch);\n\t        }\n\t        if (code > 0x10FFFF || ch !== '}') {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        return character_1.Character.fromCodePoint(code);\n\t    };\n\t    Scanner.prototype.getIdentifier = function () {\n\t        var start = this.index++;\n\t        while (!this.eof()) {\n\t            var ch = this.source.charCodeAt(this.index);\n\t            if (ch === 0x5C) {\n\t                // Blackslash (U+005C) marks Unicode escape sequence.\n\t                this.index = start;\n\t                return this.getComplexIdentifier();\n\t            }\n\t            else if (ch >= 0xD800 && ch < 0xDFFF) {\n\t                // Need to handle surrogate pairs.\n\t                this.index = start;\n\t                return this.getComplexIdentifier();\n\t            }\n\t            if (character_1.Character.isIdentifierPart(ch)) {\n\t                ++this.index;\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        return this.source.slice(start, this.index);\n\t    };\n\t    Scanner.prototype.getComplexIdentifier = function () {\n\t        var cp = this.codePointAt(this.index);\n\t        var id = character_1.Character.fromCodePoint(cp);\n\t        this.index += id.length;\n\t        // '\\u' (U+005C, U+0075) denotes an escaped character.\n\t        var ch;\n\t        if (cp === 0x5C) {\n\t            if (this.source.charCodeAt(this.index) !== 0x75) {\n\t                this.throwUnexpectedToken();\n\t            }\n\t            ++this.index;\n\t            if (this.source[this.index] === '{') {\n\t                ++this.index;\n\t                ch = this.scanUnicodeCodePointEscape();\n\t            }\n\t            else {\n\t                ch = this.scanHexEscape('u');\n\t                if (ch === null || ch === '\\\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {\n\t                    this.throwUnexpectedToken();\n\t                }\n\t            }\n\t            id = ch;\n\t        }\n\t        while (!this.eof()) {\n\t            cp = this.codePointAt(this.index);\n\t            if (!character_1.Character.isIdentifierPart(cp)) {\n\t                break;\n\t            }\n\t            ch = character_1.Character.fromCodePoint(cp);\n\t            id += ch;\n\t            this.index += ch.length;\n\t            // '\\u' (U+005C, U+0075) denotes an escaped character.\n\t            if (cp === 0x5C) {\n\t                id = id.substr(0, id.length - 1);\n\t                if (this.source.charCodeAt(this.index) !== 0x75) {\n\t                    this.throwUnexpectedToken();\n\t                }\n\t                ++this.index;\n\t                if (this.source[this.index] === '{') {\n\t                    ++this.index;\n\t                    ch = this.scanUnicodeCodePointEscape();\n\t                }\n\t                else {\n\t                    ch = this.scanHexEscape('u');\n\t                    if (ch === null || ch === '\\\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {\n\t                        this.throwUnexpectedToken();\n\t                    }\n\t                }\n\t                id += ch;\n\t            }\n\t        }\n\t        return id;\n\t    };\n\t    Scanner.prototype.octalToDecimal = function (ch) {\n\t        // \\0 is not octal escape sequence\n\t        var octal = (ch !== '0');\n\t        var code = octalValue(ch);\n\t        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {\n\t            octal = true;\n\t            code = code * 8 + octalValue(this.source[this.index++]);\n\t            // 3 digits are only allowed when string starts\n\t            // with 0, 1, 2, 3\n\t            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {\n\t                code = code * 8 + octalValue(this.source[this.index++]);\n\t            }\n\t        }\n\t        return {\n\t            code: code,\n\t            octal: octal\n\t        };\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-names-and-keywords\n\t    Scanner.prototype.scanIdentifier = function () {\n\t        var type;\n\t        var start = this.index;\n\t        // Backslash (U+005C) starts an escaped character.\n\t        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();\n\t        // There is no keyword or literal with only one character.\n\t        // Thus, it must be an identifier.\n\t        if (id.length === 1) {\n\t            type = 3 /* Identifier */;\n\t        }\n\t        else if (this.isKeyword(id)) {\n\t            type = 4 /* Keyword */;\n\t        }\n\t        else if (id === 'null') {\n\t            type = 5 /* NullLiteral */;\n\t        }\n\t        else if (id === 'true' || id === 'false') {\n\t            type = 1 /* BooleanLiteral */;\n\t        }\n\t        else {\n\t            type = 3 /* Identifier */;\n\t        }\n\t        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {\n\t            var restore = this.index;\n\t            this.index = start;\n\t            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);\n\t            this.index = restore;\n\t        }\n\t        return {\n\t            type: type,\n\t            value: id,\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-punctuators\n\t    Scanner.prototype.scanPunctuator = function () {\n\t        var start = this.index;\n\t        // Check for most common single-character punctuators.\n\t        var str = this.source[this.index];\n\t        switch (str) {\n\t            case '(':\n\t            case '{':\n\t                if (str === '{') {\n\t                    this.curlyStack.push('{');\n\t                }\n\t                ++this.index;\n\t                break;\n\t            case '.':\n\t                ++this.index;\n\t                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {\n\t                    // Spread operator: ...\n\t                    this.index += 2;\n\t                    str = '...';\n\t                }\n\t                break;\n\t            case '}':\n\t                ++this.index;\n\t                this.curlyStack.pop();\n\t                break;\n\t            case ')':\n\t            case ';':\n\t            case ',':\n\t            case '[':\n\t            case ']':\n\t            case ':':\n\t            case '?':\n\t            case '~':\n\t                ++this.index;\n\t                break;\n\t            default:\n\t                // 4-character punctuator.\n\t                str = this.source.substr(this.index, 4);\n\t                if (str === '>>>=') {\n\t                    this.index += 4;\n\t                }\n\t                else {\n\t                    // 3-character punctuators.\n\t                    str = str.substr(0, 3);\n\t                    if (str === '===' || str === '!==' || str === '>>>' ||\n\t                        str === '<<=' || str === '>>=' || str === '**=') {\n\t                        this.index += 3;\n\t                    }\n\t                    else {\n\t                        // 2-character punctuators.\n\t                        str = str.substr(0, 2);\n\t                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||\n\t                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||\n\t                            str === '++' || str === '--' || str === '<<' || str === '>>' ||\n\t                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||\n\t                            str === '<=' || str === '>=' || str === '=>' || str === '**') {\n\t                            this.index += 2;\n\t                        }\n\t                        else {\n\t                            // 1-character punctuators.\n\t                            str = this.source[this.index];\n\t                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n\t                                ++this.index;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t        }\n\t        if (this.index === start) {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        return {\n\t            type: 7 /* Punctuator */,\n\t            value: str,\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals\n\t    Scanner.prototype.scanHexLiteral = function (start) {\n\t        var num = '';\n\t        while (!this.eof()) {\n\t            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {\n\t                break;\n\t            }\n\t            num += this.source[this.index++];\n\t        }\n\t        if (num.length === 0) {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        return {\n\t            type: 6 /* NumericLiteral */,\n\t            value: parseInt('0x' + num, 16),\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    Scanner.prototype.scanBinaryLiteral = function (start) {\n\t        var num = '';\n\t        var ch;\n\t        while (!this.eof()) {\n\t            ch = this.source[this.index];\n\t            if (ch !== '0' && ch !== '1') {\n\t                break;\n\t            }\n\t            num += this.source[this.index++];\n\t        }\n\t        if (num.length === 0) {\n\t            // only 0b or 0B\n\t            this.throwUnexpectedToken();\n\t        }\n\t        if (!this.eof()) {\n\t            ch = this.source.charCodeAt(this.index);\n\t            /* istanbul ignore else */\n\t            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {\n\t                this.throwUnexpectedToken();\n\t            }\n\t        }\n\t        return {\n\t            type: 6 /* NumericLiteral */,\n\t            value: parseInt(num, 2),\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    Scanner.prototype.scanOctalLiteral = function (prefix, start) {\n\t        var num = '';\n\t        var octal = false;\n\t        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {\n\t            octal = true;\n\t            num = '0' + this.source[this.index++];\n\t        }\n\t        else {\n\t            ++this.index;\n\t        }\n\t        while (!this.eof()) {\n\t            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {\n\t                break;\n\t            }\n\t            num += this.source[this.index++];\n\t        }\n\t        if (!octal && num.length === 0) {\n\t            // only 0o or 0O\n\t            this.throwUnexpectedToken();\n\t        }\n\t        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        return {\n\t            type: 6 /* NumericLiteral */,\n\t            value: parseInt(num, 8),\n\t            octal: octal,\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    Scanner.prototype.isImplicitOctalLiteral = function () {\n\t        // Implicit octal, unless there is a non-octal digit.\n\t        // (Annex B.1.1 on Numeric Literals)\n\t        for (var i = this.index + 1; i < this.length; ++i) {\n\t            var ch = this.source[i];\n\t            if (ch === '8' || ch === '9') {\n\t                return false;\n\t            }\n\t            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\n\t                return true;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t    Scanner.prototype.scanNumericLiteral = function () {\n\t        var start = this.index;\n\t        var ch = this.source[start];\n\t        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');\n\t        var num = '';\n\t        if (ch !== '.') {\n\t            num = this.source[this.index++];\n\t            ch = this.source[this.index];\n\t            // Hex number starts with '0x'.\n\t            // Octal number starts with '0'.\n\t            // Octal number in ES6 starts with '0o'.\n\t            // Binary number in ES6 starts with '0b'.\n\t            if (num === '0') {\n\t                if (ch === 'x' || ch === 'X') {\n\t                    ++this.index;\n\t                    return this.scanHexLiteral(start);\n\t                }\n\t                if (ch === 'b' || ch === 'B') {\n\t                    ++this.index;\n\t                    return this.scanBinaryLiteral(start);\n\t                }\n\t                if (ch === 'o' || ch === 'O') {\n\t                    return this.scanOctalLiteral(ch, start);\n\t                }\n\t                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\n\t                    if (this.isImplicitOctalLiteral()) {\n\t                        return this.scanOctalLiteral(ch, start);\n\t                    }\n\t                }\n\t            }\n\t            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n\t                num += this.source[this.index++];\n\t            }\n\t            ch = this.source[this.index];\n\t        }\n\t        if (ch === '.') {\n\t            num += this.source[this.index++];\n\t            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n\t                num += this.source[this.index++];\n\t            }\n\t            ch = this.source[this.index];\n\t        }\n\t        if (ch === 'e' || ch === 'E') {\n\t            num += this.source[this.index++];\n\t            ch = this.source[this.index];\n\t            if (ch === '+' || ch === '-') {\n\t                num += this.source[this.index++];\n\t            }\n\t            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n\t                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n\t                    num += this.source[this.index++];\n\t                }\n\t            }\n\t            else {\n\t                this.throwUnexpectedToken();\n\t            }\n\t        }\n\t        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        return {\n\t            type: 6 /* NumericLiteral */,\n\t            value: parseFloat(num),\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-literals-string-literals\n\t    Scanner.prototype.scanStringLiteral = function () {\n\t        var start = this.index;\n\t        var quote = this.source[start];\n\t        assert_1.assert((quote === '\\'' || quote === '\"'), 'String literal must starts with a quote');\n\t        ++this.index;\n\t        var octal = false;\n\t        var str = '';\n\t        while (!this.eof()) {\n\t            var ch = this.source[this.index++];\n\t            if (ch === quote) {\n\t                quote = '';\n\t                break;\n\t            }\n\t            else if (ch === '\\\\') {\n\t                ch = this.source[this.index++];\n\t                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n\t                    switch (ch) {\n\t                        case 'u':\n\t                            if (this.source[this.index] === '{') {\n\t                                ++this.index;\n\t                                str += this.scanUnicodeCodePointEscape();\n\t                            }\n\t                            else {\n\t                                var unescaped_1 = this.scanHexEscape(ch);\n\t                                if (unescaped_1 === null) {\n\t                                    this.throwUnexpectedToken();\n\t                                }\n\t                                str += unescaped_1;\n\t                            }\n\t                            break;\n\t                        case 'x':\n\t                            var unescaped = this.scanHexEscape(ch);\n\t                            if (unescaped === null) {\n\t                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);\n\t                            }\n\t                            str += unescaped;\n\t                            break;\n\t                        case 'n':\n\t                            str += '\\n';\n\t                            break;\n\t                        case 'r':\n\t                            str += '\\r';\n\t                            break;\n\t                        case 't':\n\t                            str += '\\t';\n\t                            break;\n\t                        case 'b':\n\t                            str += '\\b';\n\t                            break;\n\t                        case 'f':\n\t                            str += '\\f';\n\t                            break;\n\t                        case 'v':\n\t                            str += '\\x0B';\n\t                            break;\n\t                        case '8':\n\t                        case '9':\n\t                            str += ch;\n\t                            this.tolerateUnexpectedToken();\n\t                            break;\n\t                        default:\n\t                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\n\t                                var octToDec = this.octalToDecimal(ch);\n\t                                octal = octToDec.octal || octal;\n\t                                str += String.fromCharCode(octToDec.code);\n\t                            }\n\t                            else {\n\t                                str += ch;\n\t                            }\n\t                            break;\n\t                    }\n\t                }\n\t                else {\n\t                    ++this.lineNumber;\n\t                    if (ch === '\\r' && this.source[this.index] === '\\n') {\n\t                        ++this.index;\n\t                    }\n\t                    this.lineStart = this.index;\n\t                }\n\t            }\n\t            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n\t                break;\n\t            }\n\t            else {\n\t                str += ch;\n\t            }\n\t        }\n\t        if (quote !== '') {\n\t            this.index = start;\n\t            this.throwUnexpectedToken();\n\t        }\n\t        return {\n\t            type: 8 /* StringLiteral */,\n\t            value: str,\n\t            octal: octal,\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components\n\t    Scanner.prototype.scanTemplate = function () {\n\t        var cooked = '';\n\t        var terminated = false;\n\t        var start = this.index;\n\t        var head = (this.source[start] === '`');\n\t        var tail = false;\n\t        var rawOffset = 2;\n\t        ++this.index;\n\t        while (!this.eof()) {\n\t            var ch = this.source[this.index++];\n\t            if (ch === '`') {\n\t                rawOffset = 1;\n\t                tail = true;\n\t                terminated = true;\n\t                break;\n\t            }\n\t            else if (ch === '$') {\n\t                if (this.source[this.index] === '{') {\n\t                    this.curlyStack.push('${');\n\t                    ++this.index;\n\t                    terminated = true;\n\t                    break;\n\t                }\n\t                cooked += ch;\n\t            }\n\t            else if (ch === '\\\\') {\n\t                ch = this.source[this.index++];\n\t                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n\t                    switch (ch) {\n\t                        case 'n':\n\t                            cooked += '\\n';\n\t                            break;\n\t                        case 'r':\n\t                            cooked += '\\r';\n\t                            break;\n\t                        case 't':\n\t                            cooked += '\\t';\n\t                            break;\n\t                        case 'u':\n\t                            if (this.source[this.index] === '{') {\n\t                                ++this.index;\n\t                                cooked += this.scanUnicodeCodePointEscape();\n\t                            }\n\t                            else {\n\t                                var restore = this.index;\n\t                                var unescaped_2 = this.scanHexEscape(ch);\n\t                                if (unescaped_2 !== null) {\n\t                                    cooked += unescaped_2;\n\t                                }\n\t                                else {\n\t                                    this.index = restore;\n\t                                    cooked += ch;\n\t                                }\n\t                            }\n\t                            break;\n\t                        case 'x':\n\t                            var unescaped = this.scanHexEscape(ch);\n\t                            if (unescaped === null) {\n\t                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);\n\t                            }\n\t                            cooked += unescaped;\n\t                            break;\n\t                        case 'b':\n\t                            cooked += '\\b';\n\t                            break;\n\t                        case 'f':\n\t                            cooked += '\\f';\n\t                            break;\n\t                        case 'v':\n\t                            cooked += '\\v';\n\t                            break;\n\t                        default:\n\t                            if (ch === '0') {\n\t                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n\t                                    // Illegal: \\01 \\02 and so on\n\t                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);\n\t                                }\n\t                                cooked += '\\0';\n\t                            }\n\t                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\n\t                                // Illegal: \\1 \\2\n\t                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);\n\t                            }\n\t                            else {\n\t                                cooked += ch;\n\t                            }\n\t                            break;\n\t                    }\n\t                }\n\t                else {\n\t                    ++this.lineNumber;\n\t                    if (ch === '\\r' && this.source[this.index] === '\\n') {\n\t                        ++this.index;\n\t                    }\n\t                    this.lineStart = this.index;\n\t                }\n\t            }\n\t            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n\t                ++this.lineNumber;\n\t                if (ch === '\\r' && this.source[this.index] === '\\n') {\n\t                    ++this.index;\n\t                }\n\t                this.lineStart = this.index;\n\t                cooked += '\\n';\n\t            }\n\t            else {\n\t                cooked += ch;\n\t            }\n\t        }\n\t        if (!terminated) {\n\t            this.throwUnexpectedToken();\n\t        }\n\t        if (!head) {\n\t            this.curlyStack.pop();\n\t        }\n\t        return {\n\t            type: 10 /* Template */,\n\t            value: this.source.slice(start + 1, this.index - rawOffset),\n\t            cooked: cooked,\n\t            head: head,\n\t            tail: tail,\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals\n\t    Scanner.prototype.testRegExp = function (pattern, flags) {\n\t        // The BMP character to use as a replacement for astral symbols when\n\t        // translating an ES6 \"u\"-flagged pattern to an ES5-compatible\n\t        // approximation.\n\t        // Note: replacing with '\\uFFFF' enables false positives in unlikely\n\t        // scenarios. For example, `[\\u{1044f}-\\u{10440}]` is an invalid\n\t        // pattern that would not be detected by this substitution.\n\t        var astralSubstitute = '\\uFFFF';\n\t        var tmp = pattern;\n\t        var self = this;\n\t        if (flags.indexOf('u') >= 0) {\n\t            tmp = tmp\n\t                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\n\t                var codePoint = parseInt($1 || $2, 16);\n\t                if (codePoint > 0x10FFFF) {\n\t                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);\n\t                }\n\t                if (codePoint <= 0xFFFF) {\n\t                    return String.fromCharCode(codePoint);\n\t                }\n\t                return astralSubstitute;\n\t            })\n\t                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, astralSubstitute);\n\t        }\n\t        // First, detect invalid regular expressions.\n\t        try {\n\t            RegExp(tmp);\n\t        }\n\t        catch (e) {\n\t            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);\n\t        }\n\t        // Return a regular expression object for this pattern-flag pair, or\n\t        // `null` in case the current environment doesn't support the flags it\n\t        // uses.\n\t        try {\n\t            return new RegExp(pattern, flags);\n\t        }\n\t        catch (exception) {\n\t            /* istanbul ignore next */\n\t            return null;\n\t        }\n\t    };\n\t    Scanner.prototype.scanRegExpBody = function () {\n\t        var ch = this.source[this.index];\n\t        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');\n\t        var str = this.source[this.index++];\n\t        var classMarker = false;\n\t        var terminated = false;\n\t        while (!this.eof()) {\n\t            ch = this.source[this.index++];\n\t            str += ch;\n\t            if (ch === '\\\\') {\n\t                ch = this.source[this.index++];\n\t                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals\n\t                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n\t                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\n\t                }\n\t                str += ch;\n\t            }\n\t            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\n\t                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\n\t            }\n\t            else if (classMarker) {\n\t                if (ch === ']') {\n\t                    classMarker = false;\n\t                }\n\t            }\n\t            else {\n\t                if (ch === '/') {\n\t                    terminated = true;\n\t                    break;\n\t                }\n\t                else if (ch === '[') {\n\t                    classMarker = true;\n\t                }\n\t            }\n\t        }\n\t        if (!terminated) {\n\t            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\n\t        }\n\t        // Exclude leading and trailing slash.\n\t        return str.substr(1, str.length - 2);\n\t    };\n\t    Scanner.prototype.scanRegExpFlags = function () {\n\t        var str = '';\n\t        var flags = '';\n\t        while (!this.eof()) {\n\t            var ch = this.source[this.index];\n\t            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {\n\t                break;\n\t            }\n\t            ++this.index;\n\t            if (ch === '\\\\' && !this.eof()) {\n\t                ch = this.source[this.index];\n\t                if (ch === 'u') {\n\t                    ++this.index;\n\t                    var restore = this.index;\n\t                    var char = this.scanHexEscape('u');\n\t                    if (char !== null) {\n\t                        flags += char;\n\t                        for (str += '\\\\u'; restore < this.index; ++restore) {\n\t                            str += this.source[restore];\n\t                        }\n\t                    }\n\t                    else {\n\t                        this.index = restore;\n\t                        flags += 'u';\n\t                        str += '\\\\u';\n\t                    }\n\t                    this.tolerateUnexpectedToken();\n\t                }\n\t                else {\n\t                    str += '\\\\';\n\t                    this.tolerateUnexpectedToken();\n\t                }\n\t            }\n\t            else {\n\t                flags += ch;\n\t                str += ch;\n\t            }\n\t        }\n\t        return flags;\n\t    };\n\t    Scanner.prototype.scanRegExp = function () {\n\t        var start = this.index;\n\t        var pattern = this.scanRegExpBody();\n\t        var flags = this.scanRegExpFlags();\n\t        var value = this.testRegExp(pattern, flags);\n\t        return {\n\t            type: 9 /* RegularExpression */,\n\t            value: '',\n\t            pattern: pattern,\n\t            flags: flags,\n\t            regex: value,\n\t            lineNumber: this.lineNumber,\n\t            lineStart: this.lineStart,\n\t            start: start,\n\t            end: this.index\n\t        };\n\t    };\n\t    Scanner.prototype.lex = function () {\n\t        if (this.eof()) {\n\t            return {\n\t                type: 2 /* EOF */,\n\t                value: '',\n\t                lineNumber: this.lineNumber,\n\t                lineStart: this.lineStart,\n\t                start: this.index,\n\t                end: this.index\n\t            };\n\t        }\n\t        var cp = this.source.charCodeAt(this.index);\n\t        if (character_1.Character.isIdentifierStart(cp)) {\n\t            return this.scanIdentifier();\n\t        }\n\t        // Very common: ( and ) and ;\n\t        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {\n\t            return this.scanPunctuator();\n\t        }\n\t        // String literal starts with single quote (U+0027) or double quote (U+0022).\n\t        if (cp === 0x27 || cp === 0x22) {\n\t            return this.scanStringLiteral();\n\t        }\n\t        // Dot (.) U+002E can also start a floating-point number, hence the need\n\t        // to check the next character.\n\t        if (cp === 0x2E) {\n\t            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {\n\t                return this.scanNumericLiteral();\n\t            }\n\t            return this.scanPunctuator();\n\t        }\n\t        if (character_1.Character.isDecimalDigit(cp)) {\n\t            return this.scanNumericLiteral();\n\t        }\n\t        // Template literals start with ` (U+0060) for template head\n\t        // or } (U+007D) for template middle or template tail.\n\t        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {\n\t            return this.scanTemplate();\n\t        }\n\t        // Possible identifier start in a surrogate pair.\n\t        if (cp >= 0xD800 && cp < 0xDFFF) {\n\t            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {\n\t                return this.scanIdentifier();\n\t            }\n\t        }\n\t        return this.scanPunctuator();\n\t    };\n\t    return Scanner;\n\t}());\n\texports.Scanner = Scanner;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.TokenName = {};\n\texports.TokenName[1 /* BooleanLiteral */] = 'Boolean';\n\texports.TokenName[2 /* EOF */] = '<end>';\n\texports.TokenName[3 /* Identifier */] = 'Identifier';\n\texports.TokenName[4 /* Keyword */] = 'Keyword';\n\texports.TokenName[5 /* NullLiteral */] = 'Null';\n\texports.TokenName[6 /* NumericLiteral */] = 'Numeric';\n\texports.TokenName[7 /* Punctuator */] = 'Punctuator';\n\texports.TokenName[8 /* StringLiteral */] = 'String';\n\texports.TokenName[9 /* RegularExpression */] = 'RegularExpression';\n\texports.TokenName[10 /* Template */] = 'Template';\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t// Generated by generate-xhtml-entities.js. DO NOT MODIFY!\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.XHTMLEntities = {\n\t    quot: '\\u0022',\n\t    amp: '\\u0026',\n\t    apos: '\\u0027',\n\t    gt: '\\u003E',\n\t    nbsp: '\\u00A0',\n\t    iexcl: '\\u00A1',\n\t    cent: '\\u00A2',\n\t    pound: '\\u00A3',\n\t    curren: '\\u00A4',\n\t    yen: '\\u00A5',\n\t    brvbar: '\\u00A6',\n\t    sect: '\\u00A7',\n\t    uml: '\\u00A8',\n\t    copy: '\\u00A9',\n\t    ordf: '\\u00AA',\n\t    laquo: '\\u00AB',\n\t    not: '\\u00AC',\n\t    shy: '\\u00AD',\n\t    reg: '\\u00AE',\n\t    macr: '\\u00AF',\n\t    deg: '\\u00B0',\n\t    plusmn: '\\u00B1',\n\t    sup2: '\\u00B2',\n\t    sup3: '\\u00B3',\n\t    acute: '\\u00B4',\n\t    micro: '\\u00B5',\n\t    para: '\\u00B6',\n\t    middot: '\\u00B7',\n\t    cedil: '\\u00B8',\n\t    sup1: '\\u00B9',\n\t    ordm: '\\u00BA',\n\t    raquo: '\\u00BB',\n\t    frac14: '\\u00BC',\n\t    frac12: '\\u00BD',\n\t    frac34: '\\u00BE',\n\t    iquest: '\\u00BF',\n\t    Agrave: '\\u00C0',\n\t    Aacute: '\\u00C1',\n\t    Acirc: '\\u00C2',\n\t    Atilde: '\\u00C3',\n\t    Auml: '\\u00C4',\n\t    Aring: '\\u00C5',\n\t    AElig: '\\u00C6',\n\t    Ccedil: '\\u00C7',\n\t    Egrave: '\\u00C8',\n\t    Eacute: '\\u00C9',\n\t    Ecirc: '\\u00CA',\n\t    Euml: '\\u00CB',\n\t    Igrave: '\\u00CC',\n\t    Iacute: '\\u00CD',\n\t    Icirc: '\\u00CE',\n\t    Iuml: '\\u00CF',\n\t    ETH: '\\u00D0',\n\t    Ntilde: '\\u00D1',\n\t    Ograve: '\\u00D2',\n\t    Oacute: '\\u00D3',\n\t    Ocirc: '\\u00D4',\n\t    Otilde: '\\u00D5',\n\t    Ouml: '\\u00D6',\n\t    times: '\\u00D7',\n\t    Oslash: '\\u00D8',\n\t    Ugrave: '\\u00D9',\n\t    Uacute: '\\u00DA',\n\t    Ucirc: '\\u00DB',\n\t    Uuml: '\\u00DC',\n\t    Yacute: '\\u00DD',\n\t    THORN: '\\u00DE',\n\t    szlig: '\\u00DF',\n\t    agrave: '\\u00E0',\n\t    aacute: '\\u00E1',\n\t    acirc: '\\u00E2',\n\t    atilde: '\\u00E3',\n\t    auml: '\\u00E4',\n\t    aring: '\\u00E5',\n\t    aelig: '\\u00E6',\n\t    ccedil: '\\u00E7',\n\t    egrave: '\\u00E8',\n\t    eacute: '\\u00E9',\n\t    ecirc: '\\u00EA',\n\t    euml: '\\u00EB',\n\t    igrave: '\\u00EC',\n\t    iacute: '\\u00ED',\n\t    icirc: '\\u00EE',\n\t    iuml: '\\u00EF',\n\t    eth: '\\u00F0',\n\t    ntilde: '\\u00F1',\n\t    ograve: '\\u00F2',\n\t    oacute: '\\u00F3',\n\t    ocirc: '\\u00F4',\n\t    otilde: '\\u00F5',\n\t    ouml: '\\u00F6',\n\t    divide: '\\u00F7',\n\t    oslash: '\\u00F8',\n\t    ugrave: '\\u00F9',\n\t    uacute: '\\u00FA',\n\t    ucirc: '\\u00FB',\n\t    uuml: '\\u00FC',\n\t    yacute: '\\u00FD',\n\t    thorn: '\\u00FE',\n\t    yuml: '\\u00FF',\n\t    OElig: '\\u0152',\n\t    oelig: '\\u0153',\n\t    Scaron: '\\u0160',\n\t    scaron: '\\u0161',\n\t    Yuml: '\\u0178',\n\t    fnof: '\\u0192',\n\t    circ: '\\u02C6',\n\t    tilde: '\\u02DC',\n\t    Alpha: '\\u0391',\n\t    Beta: '\\u0392',\n\t    Gamma: '\\u0393',\n\t    Delta: '\\u0394',\n\t    Epsilon: '\\u0395',\n\t    Zeta: '\\u0396',\n\t    Eta: '\\u0397',\n\t    Theta: '\\u0398',\n\t    Iota: '\\u0399',\n\t    Kappa: '\\u039A',\n\t    Lambda: '\\u039B',\n\t    Mu: '\\u039C',\n\t    Nu: '\\u039D',\n\t    Xi: '\\u039E',\n\t    Omicron: '\\u039F',\n\t    Pi: '\\u03A0',\n\t    Rho: '\\u03A1',\n\t    Sigma: '\\u03A3',\n\t    Tau: '\\u03A4',\n\t    Upsilon: '\\u03A5',\n\t    Phi: '\\u03A6',\n\t    Chi: '\\u03A7',\n\t    Psi: '\\u03A8',\n\t    Omega: '\\u03A9',\n\t    alpha: '\\u03B1',\n\t    beta: '\\u03B2',\n\t    gamma: '\\u03B3',\n\t    delta: '\\u03B4',\n\t    epsilon: '\\u03B5',\n\t    zeta: '\\u03B6',\n\t    eta: '\\u03B7',\n\t    theta: '\\u03B8',\n\t    iota: '\\u03B9',\n\t    kappa: '\\u03BA',\n\t    lambda: '\\u03BB',\n\t    mu: '\\u03BC',\n\t    nu: '\\u03BD',\n\t    xi: '\\u03BE',\n\t    omicron: '\\u03BF',\n\t    pi: '\\u03C0',\n\t    rho: '\\u03C1',\n\t    sigmaf: '\\u03C2',\n\t    sigma: '\\u03C3',\n\t    tau: '\\u03C4',\n\t    upsilon: '\\u03C5',\n\t    phi: '\\u03C6',\n\t    chi: '\\u03C7',\n\t    psi: '\\u03C8',\n\t    omega: '\\u03C9',\n\t    thetasym: '\\u03D1',\n\t    upsih: '\\u03D2',\n\t    piv: '\\u03D6',\n\t    ensp: '\\u2002',\n\t    emsp: '\\u2003',\n\t    thinsp: '\\u2009',\n\t    zwnj: '\\u200C',\n\t    zwj: '\\u200D',\n\t    lrm: '\\u200E',\n\t    rlm: '\\u200F',\n\t    ndash: '\\u2013',\n\t    mdash: '\\u2014',\n\t    lsquo: '\\u2018',\n\t    rsquo: '\\u2019',\n\t    sbquo: '\\u201A',\n\t    ldquo: '\\u201C',\n\t    rdquo: '\\u201D',\n\t    bdquo: '\\u201E',\n\t    dagger: '\\u2020',\n\t    Dagger: '\\u2021',\n\t    bull: '\\u2022',\n\t    hellip: '\\u2026',\n\t    permil: '\\u2030',\n\t    prime: '\\u2032',\n\t    Prime: '\\u2033',\n\t    lsaquo: '\\u2039',\n\t    rsaquo: '\\u203A',\n\t    oline: '\\u203E',\n\t    frasl: '\\u2044',\n\t    euro: '\\u20AC',\n\t    image: '\\u2111',\n\t    weierp: '\\u2118',\n\t    real: '\\u211C',\n\t    trade: '\\u2122',\n\t    alefsym: '\\u2135',\n\t    larr: '\\u2190',\n\t    uarr: '\\u2191',\n\t    rarr: '\\u2192',\n\t    darr: '\\u2193',\n\t    harr: '\\u2194',\n\t    crarr: '\\u21B5',\n\t    lArr: '\\u21D0',\n\t    uArr: '\\u21D1',\n\t    rArr: '\\u21D2',\n\t    dArr: '\\u21D3',\n\t    hArr: '\\u21D4',\n\t    forall: '\\u2200',\n\t    part: '\\u2202',\n\t    exist: '\\u2203',\n\t    empty: '\\u2205',\n\t    nabla: '\\u2207',\n\t    isin: '\\u2208',\n\t    notin: '\\u2209',\n\t    ni: '\\u220B',\n\t    prod: '\\u220F',\n\t    sum: '\\u2211',\n\t    minus: '\\u2212',\n\t    lowast: '\\u2217',\n\t    radic: '\\u221A',\n\t    prop: '\\u221D',\n\t    infin: '\\u221E',\n\t    ang: '\\u2220',\n\t    and: '\\u2227',\n\t    or: '\\u2228',\n\t    cap: '\\u2229',\n\t    cup: '\\u222A',\n\t    int: '\\u222B',\n\t    there4: '\\u2234',\n\t    sim: '\\u223C',\n\t    cong: '\\u2245',\n\t    asymp: '\\u2248',\n\t    ne: '\\u2260',\n\t    equiv: '\\u2261',\n\t    le: '\\u2264',\n\t    ge: '\\u2265',\n\t    sub: '\\u2282',\n\t    sup: '\\u2283',\n\t    nsub: '\\u2284',\n\t    sube: '\\u2286',\n\t    supe: '\\u2287',\n\t    oplus: '\\u2295',\n\t    otimes: '\\u2297',\n\t    perp: '\\u22A5',\n\t    sdot: '\\u22C5',\n\t    lceil: '\\u2308',\n\t    rceil: '\\u2309',\n\t    lfloor: '\\u230A',\n\t    rfloor: '\\u230B',\n\t    loz: '\\u25CA',\n\t    spades: '\\u2660',\n\t    clubs: '\\u2663',\n\t    hearts: '\\u2665',\n\t    diams: '\\u2666',\n\t    lang: '\\u27E8',\n\t    rang: '\\u27E9'\n\t};\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar error_handler_1 = __webpack_require__(10);\n\tvar scanner_1 = __webpack_require__(12);\n\tvar token_1 = __webpack_require__(13);\n\tvar Reader = (function () {\n\t    function Reader() {\n\t        this.values = [];\n\t        this.curly = this.paren = -1;\n\t    }\n\t    // A function following one of those tokens is an expression.\n\t    Reader.prototype.beforeFunctionExpression = function (t) {\n\t        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n\t            'return', 'case', 'delete', 'throw', 'void',\n\t            // assignment operators\n\t            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',\n\t            '&=', '|=', '^=', ',',\n\t            // binary/unary operators\n\t            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n\t            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n\t            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;\n\t    };\n\t    // Determine if forward slash (/) is an operator or part of a regular expression\n\t    // https://github.com/mozilla/sweet.js/wiki/design\n\t    Reader.prototype.isRegexStart = function () {\n\t        var previous = this.values[this.values.length - 1];\n\t        var regex = (previous !== null);\n\t        switch (previous) {\n\t            case 'this':\n\t            case ']':\n\t                regex = false;\n\t                break;\n\t            case ')':\n\t                var keyword = this.values[this.paren - 1];\n\t                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');\n\t                break;\n\t            case '}':\n\t                // Dividing a function by anything makes little sense,\n\t                // but we have to check for that.\n\t                regex = false;\n\t                if (this.values[this.curly - 3] === 'function') {\n\t                    // Anonymous function, e.g. function(){} /42\n\t                    var check = this.values[this.curly - 4];\n\t                    regex = check ? !this.beforeFunctionExpression(check) : false;\n\t                }\n\t                else if (this.values[this.curly - 4] === 'function') {\n\t                    // Named function, e.g. function f(){} /42/\n\t                    var check = this.values[this.curly - 5];\n\t                    regex = check ? !this.beforeFunctionExpression(check) : true;\n\t                }\n\t                break;\n\t            default:\n\t                break;\n\t        }\n\t        return regex;\n\t    };\n\t    Reader.prototype.push = function (token) {\n\t        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {\n\t            if (token.value === '{') {\n\t                this.curly = this.values.length;\n\t            }\n\t            else if (token.value === '(') {\n\t                this.paren = this.values.length;\n\t            }\n\t            this.values.push(token.value);\n\t        }\n\t        else {\n\t            this.values.push(null);\n\t        }\n\t    };\n\t    return Reader;\n\t}());\n\tvar Tokenizer = (function () {\n\t    function Tokenizer(code, config) {\n\t        this.errorHandler = new error_handler_1.ErrorHandler();\n\t        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;\n\t        this.scanner = new scanner_1.Scanner(code, this.errorHandler);\n\t        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;\n\t        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;\n\t        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;\n\t        this.buffer = [];\n\t        this.reader = new Reader();\n\t    }\n\t    Tokenizer.prototype.errors = function () {\n\t        return this.errorHandler.errors;\n\t    };\n\t    Tokenizer.prototype.getNextToken = function () {\n\t        if (this.buffer.length === 0) {\n\t            var comments = this.scanner.scanComments();\n\t            if (this.scanner.trackComment) {\n\t                for (var i = 0; i < comments.length; ++i) {\n\t                    var e = comments[i];\n\t                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);\n\t                    var comment = {\n\t                        type: e.multiLine ? 'BlockComment' : 'LineComment',\n\t                        value: value\n\t                    };\n\t                    if (this.trackRange) {\n\t                        comment.range = e.range;\n\t                    }\n\t                    if (this.trackLoc) {\n\t                        comment.loc = e.loc;\n\t                    }\n\t                    this.buffer.push(comment);\n\t                }\n\t            }\n\t            if (!this.scanner.eof()) {\n\t                var loc = void 0;\n\t                if (this.trackLoc) {\n\t                    loc = {\n\t                        start: {\n\t                            line: this.scanner.lineNumber,\n\t                            column: this.scanner.index - this.scanner.lineStart\n\t                        },\n\t                        end: {}\n\t                    };\n\t                }\n\t                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();\n\t                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();\n\t                this.reader.push(token);\n\t                var entry = {\n\t                    type: token_1.TokenName[token.type],\n\t                    value: this.scanner.source.slice(token.start, token.end)\n\t                };\n\t                if (this.trackRange) {\n\t                    entry.range = [token.start, token.end];\n\t                }\n\t                if (this.trackLoc) {\n\t                    loc.end = {\n\t                        line: this.scanner.lineNumber,\n\t                        column: this.scanner.index - this.scanner.lineStart\n\t                    };\n\t                    entry.loc = loc;\n\t                }\n\t                if (token.type === 9 /* RegularExpression */) {\n\t                    var pattern = token.pattern;\n\t                    var flags = token.flags;\n\t                    entry.regex = { pattern: pattern, flags: flags };\n\t                }\n\t                this.buffer.push(entry);\n\t            }\n\t        }\n\t        return this.buffer.shift();\n\t    };\n\t    return Tokenizer;\n\t}());\n\texports.Tokenizer = Tokenizer;\n\n\n/***/ }\n/******/ ])\n});\n;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10356, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js"],"sourcesContent":["'use strict';\n\nvar esprima;\n\n// Browserified version does not have esprima\n//\n// 1. For node.js just require module as deps\n// 2. For browser try to require mudule via external AMD system.\n//    If not found - try to fallback to window.esprima. If not\n//    found too - then fail to parse.\n//\ntry {\n  // workaround to exclude package from browserify list.\n  var _require = require;\n  esprima = _require('esprima');\n} catch (_) {\n  /* eslint-disable no-redeclare */\n  /* global window */\n  if (typeof window !== 'undefined') esprima = window.esprima;\n}\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptFunction(data) {\n  if (data === null) return false;\n\n  try {\n    var source = '(' + data + ')',\n        ast    = esprima.parse(source, { range: true });\n\n    if (ast.type                    !== 'Program'             ||\n        ast.body.length             !== 1                     ||\n        ast.body[0].type            !== 'ExpressionStatement' ||\n        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n          ast.body[0].expression.type !== 'FunctionExpression')) {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction constructJavascriptFunction(data) {\n  /*jslint evil:true*/\n\n  var source = '(' + data + ')',\n      ast    = esprima.parse(source, { range: true }),\n      params = [],\n      body;\n\n  if (ast.type                    !== 'Program'             ||\n      ast.body.length             !== 1                     ||\n      ast.body[0].type            !== 'ExpressionStatement' ||\n      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n        ast.body[0].expression.type !== 'FunctionExpression')) {\n    throw new Error('Failed to resolve function');\n  }\n\n  ast.body[0].expression.params.forEach(function (param) {\n    params.push(param.name);\n  });\n\n  body = ast.body[0].expression.body.range;\n\n  // Esprima's ranges include the first '{' and the last '}' characters on\n  // function expressions. So cut them out.\n  if (ast.body[0].expression.body.type === 'BlockStatement') {\n    /*eslint-disable no-new-func*/\n    return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n  }\n  // ES6 arrow functions can omit the BlockStatement. In that case, just return\n  // the body.\n  /*eslint-disable no-new-func*/\n  return new Function(params, 'return ' + source.slice(body[0], body[1]));\n}\n\nfunction representJavascriptFunction(object /*, style*/) {\n  return object.toString();\n}\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/function', {\n  kind: 'scalar',\n  resolve: resolveJavascriptFunction,\n  construct: constructJavascriptFunction,\n  predicate: isFunction,\n  represent: representJavascriptFunction\n});\n"],"names":[],"mappings":"AAEA,IAAI;AAEJ,6CAA6C;AAC7C,EAAE;AACF,6CAA6C;AAC7C,gEAAgE;AAChE,8DAA8D;AAC9D,qCAAqC;AACrC,EAAE;AACF,IAAI;IACF,sDAAsD;IACtD,IAAI;IACJ;AACF,EAAE,OAAO,GAAG;IACV,+BAA+B,GAC/B,iBAAiB,GACjB;;AACF;AAEA,IAAI;AAEJ,SAAS,0BAA0B,IAAI;IACrC,IAAI,SAAS,MAAM,OAAO;IAE1B,IAAI;QACF,IAAI,SAAS,MAAM,OAAO,KACtB,MAAS,QAAQ,KAAK,CAAC,QAAQ;YAAE,OAAO;QAAK;QAEjD,IAAI,IAAI,IAAI,KAAwB,aAChC,IAAI,IAAI,CAAC,MAAM,KAAiB,KAChC,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,KAAgB,yBAC/B,IAAI,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,KAAK,6BAC/B,IAAI,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,KAAK,sBAAuB;YAC3D,OAAO;QACT;QAEA,OAAO;IACT,EAAE,OAAO,KAAK;QACZ,OAAO;IACT;AACF;AAEA,SAAS,4BAA4B,IAAI;IACvC,kBAAkB,GAElB,IAAI,SAAS,MAAM,OAAO,KACtB,MAAS,QAAQ,KAAK,CAAC,QAAQ;QAAE,OAAO;IAAK,IAC7C,SAAS,EAAE,EACX;IAEJ,IAAI,IAAI,IAAI,KAAwB,aAChC,IAAI,IAAI,CAAC,MAAM,KAAiB,KAChC,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,KAAgB,yBAC/B,IAAI,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,KAAK,6BAC/B,IAAI,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,KAAK,sBAAuB;QAC3D,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,SAAU,KAAK;QACnD,OAAO,IAAI,CAAC,MAAM,IAAI;IACxB;IAEA,OAAO,IAAI,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK;IAExC,wEAAwE;IACxE,yCAAyC;IACzC,IAAI,IAAI,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,KAAK,kBAAkB;QACzD,4BAA4B,GAC5B,OAAO,IAAI,SAAS,QAAQ,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,EAAE,GAAG;IAClE;IACA,6EAA6E;IAC7E,YAAY;IACZ,4BAA4B,GAC5B,OAAO,IAAI,SAAS,QAAQ,YAAY,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;AACvE;AAEA,SAAS,4BAA4B,OAAO,SAAS,GAAV;IACzC,OAAO,OAAO,QAAQ;AACxB;AAEA,SAAS,WAAW,MAAM;IACxB,OAAO,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY;AACpD;AAEA,OAAO,OAAO,GAAG,IAAI,KAAK,iCAAiC;IACzD,MAAM;IACN,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;AACb","ignoreList":[0]}},
    {"offset": {"line": 10424, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"],"sourcesContent":["// JS-YAML's default schema for `load` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on JS-YAML's default safe schema and includes\n// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n//\n// Also this schema is used as default base schema at `Schema.create` function.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = Schema.DEFAULT = new Schema({\n  include: [\n    require('./default_safe')\n  ],\n  explicit: [\n    require('../type/js/undefined'),\n    require('../type/js/regexp'),\n    require('../type/js/function')\n  ]\n});\n"],"names":[],"mappings":"AAAA,gDAAgD;AAChD,iDAAiD;AACjD,EAAE;AACF,qEAAqE;AACrE,4EAA4E;AAC5E,EAAE;AACF,+EAA+E;AAM/E,IAAI;AAGJ,OAAO,OAAO,GAAG,OAAO,OAAO,GAAG,IAAI,OAAO;IAC3C,SAAS;;KAER;IACD,UAAU;;;;KAIT;AACH","ignoreList":[0]}},
    {"offset": {"line": 10446, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/mark.js"],"sourcesContent":["'use strict';\n\n\nvar common = require('./common');\n\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name     = name;\n  this.buffer   = buffer;\n  this.position = position;\n  this.line     = line;\n  this.column   = column;\n}\n\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n\n  if (!this.buffer) return null;\n\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n\n  head = '';\n  start = this.position;\n\n  while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n    start -= 1;\n    if (this.position - start > (maxLength / 2 - 1)) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n    end += 1;\n    if (end - this.position > (maxLength / 2 - 1)) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n         common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\n\nMark.prototype.toString = function toString(compact) {\n  var snippet, where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\n\nmodule.exports = Mark;\n"],"names":[],"mappings":"AAGA,IAAI;AAGJ,SAAS,KAAK,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM;IAChD,IAAI,CAAC,IAAI,GAAO;IAChB,IAAI,CAAC,MAAM,GAAK;IAChB,IAAI,CAAC,QAAQ,GAAG;IAChB,IAAI,CAAC,IAAI,GAAO;IAChB,IAAI,CAAC,MAAM,GAAK;AAClB;AAGA,KAAK,SAAS,CAAC,UAAU,GAAG,SAAS,WAAW,MAAM,EAAE,SAAS;IAC/D,IAAI,MAAM,OAAO,MAAM,KAAK;IAE5B,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO;IAEzB,SAAS,UAAU;IACnB,YAAY,aAAa;IAEzB,OAAO;IACP,QAAQ,IAAI,CAAC,QAAQ;IAErB,MAAO,QAAQ,KAAK,2BAA2B,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,QAAQ,CAAC,EAAG;QAC5F,SAAS;QACT,IAAI,IAAI,CAAC,QAAQ,GAAG,QAAS,YAAY,IAAI,GAAI;YAC/C,OAAO;YACP,SAAS;YACT;QACF;IACF;IAEA,OAAO;IACP,MAAM,IAAI,CAAC,QAAQ;IAEnB,MAAO,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,2BAA2B,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,EAAG;QACrG,OAAO;QACP,IAAI,MAAM,IAAI,CAAC,QAAQ,GAAI,YAAY,IAAI,GAAI;YAC7C,OAAO;YACP,OAAO;YACP;QACF;IACF;IAEA,UAAU,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO;IAEnC,OAAO,OAAO,MAAM,CAAC,KAAK,UAAU,OAAO,UAAU,OAAO,OACrD,OAAO,MAAM,CAAC,KAAK,SAAS,IAAI,CAAC,QAAQ,GAAG,QAAQ,KAAK,MAAM,IAAI;AAC5E;AAGA,KAAK,SAAS,CAAC,QAAQ,GAAG,SAAS,SAAS,OAAO;IACjD,IAAI,SAAS,QAAQ;IAErB,IAAI,IAAI,CAAC,IAAI,EAAE;QACb,SAAS,SAAS,IAAI,CAAC,IAAI,GAAG;IAChC;IAEA,SAAS,aAAa,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC;IAEtE,IAAI,CAAC,SAAS;QACZ,UAAU,IAAI,CAAC,UAAU;QAEzB,IAAI,SAAS;YACX,SAAS,QAAQ;QACnB;IACF;IAEA,OAAO;AACT;AAGA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 10501, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/loader.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar Mark                = require('./mark');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\n// set a property of a literal object, while protecting against prototype pollution,\n// see https://github.com/nodeca/js-yaml/issues/164 for more details\nfunction setProperty(object, key, value) {\n  // used for this specific key only because Object.defineProperty is slow\n  if (key === '__proto__') {\n    Object.defineProperty(object, key, {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: value\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy    = options['legacy']    || false;\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  return new YAMLException(\n    message,\n    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      setProperty(destination, key, source[key]);\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n    setProperty(_result, keyNode, valueNode);\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = {},\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _pos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = {},\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n    _pos = state.position;\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n\n    } else {\n      break; // Reading is done. Go to the epilogue.\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag !== null && state.tag !== '!') {\n    if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nfunction safeLoadAll(input, iterator, options) {\n  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nmodule.exports.loadAll     = loadAll;\nmodule.exports.load        = load;\nmodule.exports.safeLoadAll = safeLoadAll;\nmodule.exports.safeLoad    = safeLoad;\n"],"names":[],"mappings":"AAEA,6CAA6C,GAE7C,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AAGJ,IAAI,kBAAkB,OAAO,SAAS,CAAC,cAAc;AAGrD,IAAI,kBAAoB;AACxB,IAAI,mBAAoB;AACxB,IAAI,mBAAoB;AACxB,IAAI,oBAAoB;AAGxB,IAAI,gBAAiB;AACrB,IAAI,iBAAiB;AACrB,IAAI,gBAAiB;AAGrB,IAAI,wBAAgC;AACpC,IAAI,gCAAgC;AACpC,IAAI,0BAAgC;AACpC,IAAI,qBAAgC;AACpC,IAAI,kBAAgC;AAGpC,SAAS,OAAO,GAAG;IAAI,OAAO,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC;AAAM;AAEnE,SAAS,OAAO,CAAC;IACf,OAAO,AAAC,MAAM,KAAI,MAAM,OAAQ,MAAM,KAAI,MAAM;AAClD;AAEA,SAAS,eAAe,CAAC;IACvB,OAAO,AAAC,MAAM,KAAI,OAAO,OAAQ,MAAM,KAAI,SAAS;AACtD;AAEA,SAAS,aAAa,CAAC;IACrB,OAAO,AAAC,MAAM,KAAI,OAAO,OACjB,MAAM,KAAI,SAAS,OACnB,MAAM,KAAI,MAAM,OAChB,MAAM,KAAI,MAAM;AAC1B;AAEA,SAAS,kBAAkB,CAAC;IAC1B,OAAO,MAAM,KAAI,KAAK,OACf,MAAM,KAAI,KAAK,OACf,MAAM,KAAI,KAAK,OACf,MAAM,KAAI,KAAK,OACf,MAAM,KAAI,KAAK;AACxB;AAEA,SAAS,YAAY,CAAC;IACpB,IAAI;IAEJ,IAAI,AAAC,KAAI,KAAK,OAAM,KAAO,KAAK,KAAI,KAAK,KAAK;QAC5C,OAAO,IAAI;IACb;IAEA,2BAA2B,GAC3B,KAAK,IAAI;IAET,IAAI,AAAC,KAAI,KAAK,OAAM,MAAQ,MAAM,KAAI,KAAK,KAAK;QAC9C,OAAO,KAAK,OAAO;IACrB;IAEA,OAAO,CAAC;AACV;AAEA,SAAS,cAAc,CAAC;IACtB,IAAI,MAAM,KAAI,KAAK,KAAI;QAAE,OAAO;IAAG;IACnC,IAAI,MAAM,KAAI,KAAK,KAAI;QAAE,OAAO;IAAG;IACnC,IAAI,MAAM,KAAI,KAAK,KAAI;QAAE,OAAO;IAAG;IACnC,OAAO;AACT;AAEA,SAAS,gBAAgB,CAAC;IACxB,IAAI,AAAC,KAAI,KAAK,OAAM,KAAO,KAAK,KAAI,KAAK,KAAK;QAC5C,OAAO,IAAI;IACb;IAEA,OAAO,CAAC;AACV;AAEA,SAAS,qBAAqB,CAAC;IAC7B,yBAAyB,GACzB,OAAO,AAAC,MAAM,KAAI,KAAK,MAAM,SACvB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,OAAO,MAAM,SACxB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,SAAS,MAAM,MAC1B,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,MACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,SACtB,AAAC,MAAM,KAAI,KAAK,MAAM,WACtB,AAAC,MAAM,KAAI,KAAK,MAAM,WAAW;AACzC;AAEA,SAAS,kBAAkB,CAAC;IAC1B,IAAI,KAAK,QAAQ;QACf,OAAO,OAAO,YAAY,CAAC;IAC7B;IACA,+BAA+B;IAC/B,4EAA4E;IAC5E,OAAO,OAAO,YAAY,CACxB,CAAC,AAAC,IAAI,YAAa,EAAE,IAAI,QACzB,CAAC,AAAC,IAAI,WAAY,MAAM,IAAI;AAEhC;AAEA,oFAAoF;AACpF,oEAAoE;AACpE,SAAS,YAAY,MAAM,EAAE,GAAG,EAAE,KAAK;IACrC,wEAAwE;IACxE,IAAI,QAAQ,aAAa;QACvB,OAAO,cAAc,CAAC,QAAQ,KAAK;YACjC,cAAc;YACd,YAAY;YACZ,UAAU;YACV,OAAO;QACT;IACF,OAAO;QACL,MAAM,CAAC,IAAI,GAAG;IAChB;AACF;AAEA,IAAI,oBAAoB,IAAI,MAAM,MAAM,2BAA2B;AACnE,IAAI,kBAAkB,IAAI,MAAM;AAChC,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;IAC5B,iBAAiB,CAAC,EAAE,GAAG,qBAAqB,KAAK,IAAI;IACrD,eAAe,CAAC,EAAE,GAAG,qBAAqB;AAC5C;AAGA,SAAS,MAAM,KAAK,EAAE,OAAO;IAC3B,IAAI,CAAC,KAAK,GAAG;IAEb,IAAI,CAAC,QAAQ,GAAI,OAAO,CAAC,WAAW,IAAK;IACzC,IAAI,CAAC,MAAM,GAAM,OAAO,CAAC,SAAS,IAAO;IACzC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,YAAY,IAAI;IACzC,IAAI,CAAC,MAAM,GAAM,OAAO,CAAC,SAAS,IAAO;IACzC,IAAI,CAAC,IAAI,GAAQ,OAAO,CAAC,OAAO,IAAS;IACzC,IAAI,CAAC,QAAQ,GAAI,OAAO,CAAC,WAAW,IAAK;IAEzC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB;IACjD,IAAI,CAAC,OAAO,GAAS,IAAI,CAAC,MAAM,CAAC,eAAe;IAEhD,IAAI,CAAC,MAAM,GAAO,MAAM,MAAM;IAC9B,IAAI,CAAC,QAAQ,GAAK;IAClB,IAAI,CAAC,IAAI,GAAS;IAClB,IAAI,CAAC,SAAS,GAAI;IAClB,IAAI,CAAC,UAAU,GAAG;IAElB,IAAI,CAAC,SAAS,GAAG,EAAE;AAEnB;;;;;;;;cAQY,GAEd;AAGA,SAAS,cAAc,KAAK,EAAE,OAAO;IACnC,OAAO,IAAI,cACT,SACA,IAAI,KAAK,MAAM,QAAQ,EAAE,MAAM,KAAK,EAAE,MAAM,QAAQ,EAAE,MAAM,IAAI,EAAG,MAAM,QAAQ,GAAG,MAAM,SAAS;AACvG;AAEA,SAAS,WAAW,KAAK,EAAE,OAAO;IAChC,MAAM,cAAc,OAAO;AAC7B;AAEA,SAAS,aAAa,KAAK,EAAE,OAAO;IAClC,IAAI,MAAM,SAAS,EAAE;QACnB,MAAM,SAAS,CAAC,IAAI,CAAC,MAAM,cAAc,OAAO;IAClD;AACF;AAGA,IAAI,oBAAoB;IAEtB,MAAM,SAAS,oBAAoB,KAAK,EAAE,IAAI,EAAE,IAAI;QAElD,IAAI,OAAO,OAAO;QAElB,IAAI,MAAM,OAAO,KAAK,MAAM;YAC1B,WAAW,OAAO;QACpB;QAEA,IAAI,KAAK,MAAM,KAAK,GAAG;YACrB,WAAW,OAAO;QACpB;QAEA,QAAQ,uBAAuB,IAAI,CAAC,IAAI,CAAC,EAAE;QAE3C,IAAI,UAAU,MAAM;YAClB,WAAW,OAAO;QACpB;QAEA,QAAQ,SAAS,KAAK,CAAC,EAAE,EAAE;QAC3B,QAAQ,SAAS,KAAK,CAAC,EAAE,EAAE;QAE3B,IAAI,UAAU,GAAG;YACf,WAAW,OAAO;QACpB;QAEA,MAAM,OAAO,GAAG,IAAI,CAAC,EAAE;QACvB,MAAM,eAAe,GAAI,QAAQ;QAEjC,IAAI,UAAU,KAAK,UAAU,GAAG;YAC9B,aAAa,OAAO;QACtB;IACF;IAEA,KAAK,SAAS,mBAAmB,KAAK,EAAE,IAAI,EAAE,IAAI;QAEhD,IAAI,QAAQ;QAEZ,IAAI,KAAK,MAAM,KAAK,GAAG;YACrB,WAAW,OAAO;QACpB;QAEA,SAAS,IAAI,CAAC,EAAE;QAChB,SAAS,IAAI,CAAC,EAAE;QAEhB,IAAI,CAAC,mBAAmB,IAAI,CAAC,SAAS;YACpC,WAAW,OAAO;QACpB;QAEA,IAAI,gBAAgB,IAAI,CAAC,MAAM,MAAM,EAAE,SAAS;YAC9C,WAAW,OAAO,gDAAgD,SAAS;QAC7E;QAEA,IAAI,CAAC,gBAAgB,IAAI,CAAC,SAAS;YACjC,WAAW,OAAO;QACpB;QAEA,MAAM,MAAM,CAAC,OAAO,GAAG;IACzB;AACF;AAGA,SAAS,eAAe,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,SAAS;IAClD,IAAI,WAAW,SAAS,YAAY;IAEpC,IAAI,QAAQ,KAAK;QACf,UAAU,MAAM,KAAK,CAAC,KAAK,CAAC,OAAO;QAEnC,IAAI,WAAW;YACb,IAAK,YAAY,GAAG,UAAU,QAAQ,MAAM,EAAE,YAAY,SAAS,aAAa,EAAG;gBACjF,aAAa,QAAQ,UAAU,CAAC;gBAChC,IAAI,CAAC,CAAC,eAAe,QACd,QAAQ,cAAc,cAAc,QAAS,GAAG;oBACrD,WAAW,OAAO;gBACpB;YACF;QACF,OAAO,IAAI,sBAAsB,IAAI,CAAC,UAAU;YAC9C,WAAW,OAAO;QACpB;QAEA,MAAM,MAAM,IAAI;IAClB;AACF;AAEA,SAAS,cAAc,KAAK,EAAE,WAAW,EAAE,MAAM,EAAE,eAAe;IAChE,IAAI,YAAY,KAAK,OAAO;IAE5B,IAAI,CAAC,OAAO,QAAQ,CAAC,SAAS;QAC5B,WAAW,OAAO;IACpB;IAEA,aAAa,OAAO,IAAI,CAAC;IAEzB,IAAK,QAAQ,GAAG,WAAW,WAAW,MAAM,EAAE,QAAQ,UAAU,SAAS,EAAG;QAC1E,MAAM,UAAU,CAAC,MAAM;QAEvB,IAAI,CAAC,gBAAgB,IAAI,CAAC,aAAa,MAAM;YAC3C,YAAY,aAAa,KAAK,MAAM,CAAC,IAAI;YACzC,eAAe,CAAC,IAAI,GAAG;QACzB;IACF;AACF;AAEA,SAAS,iBAAiB,KAAK,EAAE,OAAO,EAAE,eAAe,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,QAAQ;IACxG,IAAI,OAAO;IAEX,kEAAkE;IAClE,4EAA4E;IAC5E,mEAAmE;IACnE,IAAI,MAAM,OAAO,CAAC,UAAU;QAC1B,UAAU,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC;QAErC,IAAK,QAAQ,GAAG,WAAW,QAAQ,MAAM,EAAE,QAAQ,UAAU,SAAS,EAAG;YACvE,IAAI,MAAM,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG;gBACjC,WAAW,OAAO;YACpB;YAEA,IAAI,OAAO,YAAY,YAAY,OAAO,OAAO,CAAC,MAAM,MAAM,mBAAmB;gBAC/E,OAAO,CAAC,MAAM,GAAG;YACnB;QACF;IACF;IAEA,uDAAuD;IACvD,sDAAsD;IACtD,oEAAoE;IACpE,IAAI,OAAO,YAAY,YAAY,OAAO,aAAa,mBAAmB;QACxE,UAAU;IACZ;IAGA,UAAU,OAAO;IAEjB,IAAI,YAAY,MAAM;QACpB,UAAU,CAAC;IACb;IAEA,IAAI,WAAW,2BAA2B;QACxC,IAAI,MAAM,OAAO,CAAC,YAAY;YAC5B,IAAK,QAAQ,GAAG,WAAW,UAAU,MAAM,EAAE,QAAQ,UAAU,SAAS,EAAG;gBACzE,cAAc,OAAO,SAAS,SAAS,CAAC,MAAM,EAAE;YAClD;QACF,OAAO;YACL,cAAc,OAAO,SAAS,WAAW;QAC3C;IACF,OAAO;QACL,IAAI,CAAC,MAAM,IAAI,IACX,CAAC,gBAAgB,IAAI,CAAC,iBAAiB,YACvC,gBAAgB,IAAI,CAAC,SAAS,UAAU;YAC1C,MAAM,IAAI,GAAG,aAAa,MAAM,IAAI;YACpC,MAAM,QAAQ,GAAG,YAAY,MAAM,QAAQ;YAC3C,WAAW,OAAO;QACpB;QACA,YAAY,SAAS,SAAS;QAC9B,OAAO,eAAe,CAAC,QAAQ;IACjC;IAEA,OAAO;AACT;AAEA,SAAS,cAAc,KAAK;IAC1B,IAAI;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,OAAO,KAAI,MAAM,KAAI;QACvB,MAAM,QAAQ;IAChB,OAAO,IAAI,OAAO,KAAI,MAAM,KAAI;QAC9B,MAAM,QAAQ;QACd,IAAI,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,MAAM,KAAI,MAAM,KAAI;YAC3D,MAAM,QAAQ;QAChB;IACF,OAAO;QACL,WAAW,OAAO;IACpB;IAEA,MAAM,IAAI,IAAI;IACd,MAAM,SAAS,GAAG,MAAM,QAAQ;AAClC;AAEA,SAAS,oBAAoB,KAAK,EAAE,aAAa,EAAE,WAAW;IAC5D,IAAI,aAAa,GACb,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE9C,MAAO,OAAO,EAAG;QACf,MAAO,eAAe,IAAK;YACzB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAC9C;QAEA,IAAI,iBAAiB,OAAO,KAAI,KAAK,KAAI;YACvC,GAAG;gBACD,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;YAC9C,QAAS,OAAO,KAAI,MAAM,OAAM,OAAO,KAAI,MAAM,OAAM,OAAO,EAAG;QACnE;QAEA,IAAI,OAAO,KAAK;YACd,cAAc;YAEd,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;YAC1C;YACA,MAAM,UAAU,GAAG;YAEnB,MAAO,OAAO,KAAI,SAAS,IAAI;gBAC7B,MAAM,UAAU;gBAChB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;YAC9C;QACF,OAAO;YACL;QACF;IACF;IAEA,IAAI,gBAAgB,CAAC,KAAK,eAAe,KAAK,MAAM,UAAU,GAAG,aAAa;QAC5E,aAAa,OAAO;IACtB;IAEA,OAAO;AACT;AAEA,SAAS,sBAAsB,KAAK;IAClC,IAAI,YAAY,MAAM,QAAQ,EAC1B;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC;IAE5B,yDAAyD;IACzD,uEAAuE;IACvE,IAAI,CAAC,OAAO,KAAI,KAAK,OAAM,OAAO,KAAI,KAAK,GAAE,KACzC,OAAO,MAAM,KAAK,CAAC,UAAU,CAAC,YAAY,MAC1C,OAAO,MAAM,KAAK,CAAC,UAAU,CAAC,YAAY,IAAI;QAEhD,aAAa;QAEb,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC;QAE5B,IAAI,OAAO,KAAK,aAAa,KAAK;YAChC,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAEA,SAAS,iBAAiB,KAAK,EAAE,KAAK;IACpC,IAAI,UAAU,GAAG;QACf,MAAM,MAAM,IAAI;IAClB,OAAO,IAAI,QAAQ,GAAG;QACpB,MAAM,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,QAAQ;IAC9C;AACF;AAGA,SAAS,gBAAgB,KAAK,EAAE,UAAU,EAAE,oBAAoB;IAC9D,IAAI,WACA,WACA,cACA,YACA,mBACA,OACA,YACA,aACA,QAAQ,MAAM,IAAI,EAClB,UAAU,MAAM,MAAM,EACtB;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,aAAa,OACb,kBAAkB,OAClB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,OAChB,OAAO,KAAI,KAAK,KAAI;QACtB,OAAO;IACT;IAEA,IAAI,OAAO,KAAI,KAAK,OAAM,OAAO,KAAI,KAAK,KAAI;QAC5C,YAAY,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,GAAG;QAEpD,IAAI,aAAa,cACb,wBAAwB,kBAAkB,YAAY;YACxD,OAAO;QACT;IACF;IAEA,MAAM,IAAI,GAAG;IACb,MAAM,MAAM,GAAG;IACf,eAAe,aAAa,MAAM,QAAQ;IAC1C,oBAAoB;IAEpB,MAAO,OAAO,EAAG;QACf,IAAI,OAAO,KAAI,KAAK,KAAI;YACtB,YAAY,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,GAAG;YAEpD,IAAI,aAAa,cACb,wBAAwB,kBAAkB,YAAY;gBACxD;YACF;QAEF,OAAO,IAAI,OAAO,KAAI,KAAK,KAAI;YAC7B,YAAY,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,GAAG;YAEpD,IAAI,aAAa,YAAY;gBAC3B;YACF;QAEF,OAAO,IAAI,AAAC,MAAM,QAAQ,KAAK,MAAM,SAAS,IAAI,sBAAsB,UAC7D,wBAAwB,kBAAkB,KAAK;YACxD;QAEF,OAAO,IAAI,OAAO,KAAK;YACrB,QAAQ,MAAM,IAAI;YAClB,aAAa,MAAM,SAAS;YAC5B,cAAc,MAAM,UAAU;YAC9B,oBAAoB,OAAO,OAAO,CAAC;YAEnC,IAAI,MAAM,UAAU,IAAI,YAAY;gBAClC,oBAAoB;gBACpB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;gBAC1C;YACF,OAAO;gBACL,MAAM,QAAQ,GAAG;gBACjB,MAAM,IAAI,GAAG;gBACb,MAAM,SAAS,GAAG;gBAClB,MAAM,UAAU,GAAG;gBACnB;YACF;QACF;QAEA,IAAI,mBAAmB;YACrB,eAAe,OAAO,cAAc,YAAY;YAChD,iBAAiB,OAAO,MAAM,IAAI,GAAG;YACrC,eAAe,aAAa,MAAM,QAAQ;YAC1C,oBAAoB;QACtB;QAEA,IAAI,CAAC,eAAe,KAAK;YACvB,aAAa,MAAM,QAAQ,GAAG;QAChC;QAEA,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAC9C;IAEA,eAAe,OAAO,cAAc,YAAY;IAEhD,IAAI,MAAM,MAAM,EAAE;QAChB,OAAO;IACT;IAEA,MAAM,IAAI,GAAG;IACb,MAAM,MAAM,GAAG;IACf,OAAO;AACT;AAEA,SAAS,uBAAuB,KAAK,EAAE,UAAU;IAC/C,IAAI,IACA,cAAc;IAElB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,OAAO,KAAI,KAAK,KAAI;QACtB,OAAO;IACT;IAEA,MAAM,IAAI,GAAG;IACb,MAAM,MAAM,GAAG;IACf,MAAM,QAAQ;IACd,eAAe,aAAa,MAAM,QAAQ;IAE1C,MAAO,CAAC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,CAAC,MAAM,EAAG;QAC1D,IAAI,OAAO,KAAI,KAAK,KAAI;YACtB,eAAe,OAAO,cAAc,MAAM,QAAQ,EAAE;YACpD,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;YAE5C,IAAI,OAAO,KAAI,KAAK,KAAI;gBACtB,eAAe,MAAM,QAAQ;gBAC7B,MAAM,QAAQ;gBACd,aAAa,MAAM,QAAQ;YAC7B,OAAO;gBACL,OAAO;YACT;QAEF,OAAO,IAAI,OAAO,KAAK;YACrB,eAAe,OAAO,cAAc,YAAY;YAChD,iBAAiB,OAAO,oBAAoB,OAAO,OAAO;YAC1D,eAAe,aAAa,MAAM,QAAQ;QAE5C,OAAO,IAAI,MAAM,QAAQ,KAAK,MAAM,SAAS,IAAI,sBAAsB,QAAQ;YAC7E,WAAW,OAAO;QAEpB,OAAO;YACL,MAAM,QAAQ;YACd,aAAa,MAAM,QAAQ;QAC7B;IACF;IAEA,WAAW,OAAO;AACpB;AAEA,SAAS,uBAAuB,KAAK,EAAE,UAAU;IAC/C,IAAI,cACA,YACA,WACA,WACA,KACA;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,OAAO,KAAI,KAAK,KAAI;QACtB,OAAO;IACT;IAEA,MAAM,IAAI,GAAG;IACb,MAAM,MAAM,GAAG;IACf,MAAM,QAAQ;IACd,eAAe,aAAa,MAAM,QAAQ;IAE1C,MAAO,CAAC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,CAAC,MAAM,EAAG;QAC1D,IAAI,OAAO,KAAI,KAAK,KAAI;YACtB,eAAe,OAAO,cAAc,MAAM,QAAQ,EAAE;YACpD,MAAM,QAAQ;YACd,OAAO;QAET,OAAO,IAAI,OAAO,KAAI,KAAK,KAAI;YAC7B,eAAe,OAAO,cAAc,MAAM,QAAQ,EAAE;YACpD,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;YAE5C,IAAI,OAAO,KAAK;gBACd,oBAAoB,OAAO,OAAO;YAElC,+CAA+C;YACjD,OAAO,IAAI,KAAK,OAAO,iBAAiB,CAAC,GAAG,EAAE;gBAC5C,MAAM,MAAM,IAAI,eAAe,CAAC,GAAG;gBACnC,MAAM,QAAQ;YAEhB,OAAO,IAAI,CAAC,MAAM,cAAc,GAAG,IAAI,GAAG;gBACxC,YAAY;gBACZ,YAAY;gBAEZ,MAAO,YAAY,GAAG,YAAa;oBACjC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;oBAE5C,IAAI,CAAC,MAAM,YAAY,GAAG,KAAK,GAAG;wBAChC,YAAY,CAAC,aAAa,CAAC,IAAI;oBAEjC,OAAO;wBACL,WAAW,OAAO;oBACpB;gBACF;gBAEA,MAAM,MAAM,IAAI,kBAAkB;gBAElC,MAAM,QAAQ;YAEhB,OAAO;gBACL,WAAW,OAAO;YACpB;YAEA,eAAe,aAAa,MAAM,QAAQ;QAE5C,OAAO,IAAI,OAAO,KAAK;YACrB,eAAe,OAAO,cAAc,YAAY;YAChD,iBAAiB,OAAO,oBAAoB,OAAO,OAAO;YAC1D,eAAe,aAAa,MAAM,QAAQ;QAE5C,OAAO,IAAI,MAAM,QAAQ,KAAK,MAAM,SAAS,IAAI,sBAAsB,QAAQ;YAC7E,WAAW,OAAO;QAEpB,OAAO;YACL,MAAM,QAAQ;YACd,aAAa,MAAM,QAAQ;QAC7B;IACF;IAEA,WAAW,OAAO;AACpB;AAEA,SAAS,mBAAmB,KAAK,EAAE,UAAU;IAC3C,IAAI,WAAW,MACX,OACA,OAAW,MAAM,GAAG,EACpB,SACA,UAAW,MAAM,MAAM,EACvB,WACA,YACA,QACA,gBACA,WACA,kBAAkB,CAAC,GACnB,SACA,QACA,WACA;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,OAAO,KAAI,KAAK,KAAI;QACtB,aAAa,MAAK,KAAK;QACvB,YAAY;QACZ,UAAU,EAAE;IACd,OAAO,IAAI,OAAO,KAAI,KAAK,KAAI;QAC7B,aAAa,MAAK,KAAK;QACvB,YAAY;QACZ,UAAU,CAAC;IACb,OAAO;QACL,OAAO;IACT;IAEA,IAAI,MAAM,MAAM,KAAK,MAAM;QACzB,MAAM,SAAS,CAAC,MAAM,MAAM,CAAC,GAAG;IAClC;IAEA,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAE5C,MAAO,OAAO,EAAG;QACf,oBAAoB,OAAO,MAAM;QAEjC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;QAE1C,IAAI,OAAO,YAAY;YACrB,MAAM,QAAQ;YACd,MAAM,GAAG,GAAG;YACZ,MAAM,MAAM,GAAG;YACf,MAAM,IAAI,GAAG,YAAY,YAAY;YACrC,MAAM,MAAM,GAAG;YACf,OAAO;QACT,OAAO,IAAI,CAAC,UAAU;YACpB,WAAW,OAAO;QACpB;QAEA,SAAS,UAAU,YAAY;QAC/B,SAAS,iBAAiB;QAE1B,IAAI,OAAO,KAAI,KAAK,KAAI;YACtB,YAAY,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,GAAG;YAEpD,IAAI,aAAa,YAAY;gBAC3B,SAAS,iBAAiB;gBAC1B,MAAM,QAAQ;gBACd,oBAAoB,OAAO,MAAM;YACnC;QACF;QAEA,QAAQ,MAAM,IAAI;QAClB,YAAY,OAAO,YAAY,iBAAiB,OAAO;QACvD,SAAS,MAAM,GAAG;QAClB,UAAU,MAAM,MAAM;QACtB,oBAAoB,OAAO,MAAM;QAEjC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;QAE1C,IAAI,CAAC,kBAAkB,MAAM,IAAI,KAAK,KAAK,KAAK,OAAO,KAAI,KAAK,KAAI;YAClE,SAAS;YACT,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;YAC5C,oBAAoB,OAAO,MAAM;YACjC,YAAY,OAAO,YAAY,iBAAiB,OAAO;YACvD,YAAY,MAAM,MAAM;QAC1B;QAEA,IAAI,WAAW;YACb,iBAAiB,OAAO,SAAS,iBAAiB,QAAQ,SAAS;QACrE,OAAO,IAAI,QAAQ;YACjB,QAAQ,IAAI,CAAC,iBAAiB,OAAO,MAAM,iBAAiB,QAAQ,SAAS;QAC/E,OAAO;YACL,QAAQ,IAAI,CAAC;QACf;QAEA,oBAAoB,OAAO,MAAM;QAEjC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;QAE1C,IAAI,OAAO,KAAI,KAAK,KAAI;YACtB,WAAW;YACX,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAC9C,OAAO;YACL,WAAW;QACb;IACF;IAEA,WAAW,OAAO;AACpB;AAEA,SAAS,gBAAgB,KAAK,EAAE,UAAU;IACxC,IAAI,cACA,SACA,WAAiB,eACjB,iBAAiB,OACjB,iBAAiB,OACjB,aAAiB,YACjB,aAAiB,GACjB,iBAAiB,OACjB,KACA;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,OAAO,KAAI,KAAK,KAAI;QACtB,UAAU;IACZ,OAAO,IAAI,OAAO,KAAI,KAAK,KAAI;QAC7B,UAAU;IACZ,OAAO;QACL,OAAO;IACT;IAEA,MAAM,IAAI,GAAG;IACb,MAAM,MAAM,GAAG;IAEf,MAAO,OAAO,EAAG;QACf,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAE5C,IAAI,OAAO,KAAI,KAAK,OAAM,OAAO,KAAI,KAAK,KAAI;YAC5C,IAAI,kBAAkB,UAAU;gBAC9B,WAAW,AAAC,OAAO,KAAI,KAAK,MAAM,gBAAgB;YACpD,OAAO;gBACL,WAAW,OAAO;YACpB;QAEF,OAAO,IAAI,CAAC,MAAM,gBAAgB,GAAG,KAAK,GAAG;YAC3C,IAAI,QAAQ,GAAG;gBACb,WAAW,OAAO;YACpB,OAAO,IAAI,CAAC,gBAAgB;gBAC1B,aAAa,aAAa,MAAM;gBAChC,iBAAiB;YACnB,OAAO;gBACL,WAAW,OAAO;YACpB;QAEF,OAAO;YACL;QACF;IACF;IAEA,IAAI,eAAe,KAAK;QACtB,GAAG;YAAE,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAAG,QAC7C,eAAe,IAAK;QAE3B,IAAI,OAAO,KAAI,KAAK,KAAI;YACtB,GAAG;gBAAE,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;YAAG,QAC7C,CAAC,OAAO,OAAQ,OAAO,EAAI;QACpC;IACF;IAEA,MAAO,OAAO,EAAG;QACf,cAAc;QACd,MAAM,UAAU,GAAG;QAEnB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;QAE1C,MAAO,CAAC,CAAC,kBAAkB,MAAM,UAAU,GAAG,UAAU,KAChD,OAAO,KAAI,SAAS,IAAK;YAC/B,MAAM,UAAU;YAChB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAC9C;QAEA,IAAI,CAAC,kBAAkB,MAAM,UAAU,GAAG,YAAY;YACpD,aAAa,MAAM,UAAU;QAC/B;QAEA,IAAI,OAAO,KAAK;YACd;YACA;QACF;QAEA,qBAAqB;QACrB,IAAI,MAAM,UAAU,GAAG,YAAY;YAEjC,wBAAwB;YACxB,IAAI,aAAa,eAAe;gBAC9B,MAAM,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,iBAAiB,IAAI,aAAa;YACxE,OAAO,IAAI,aAAa,eAAe;gBACrC,IAAI,gBAAgB;oBAClB,MAAM,MAAM,IAAI;gBAClB;YACF;YAGA;QACF;QAEA,uDAAuD;QACvD,IAAI,SAAS;YAEX,mFAAmF;YACnF,IAAI,eAAe,KAAK;gBACtB,iBAAiB;gBACjB,sDAAsD;gBACtD,MAAM,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,iBAAiB,IAAI,aAAa;YAExE,8BAA8B;YAC9B,OAAO,IAAI,gBAAgB;gBACzB,iBAAiB;gBACjB,MAAM,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,aAAa;YAEnD,mDAAmD;YACnD,OAAO,IAAI,eAAe,GAAG;gBAC3B,IAAI,gBAAgB;oBAClB,MAAM,MAAM,IAAI;gBAClB;YAEF,qDAAqD;YACrD,OAAO;gBACL,MAAM,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM;YACtC;QAEF,6EAA6E;QAC7E,OAAO;YACL,qDAAqD;YACrD,MAAM,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,iBAAiB,IAAI,aAAa;QACxE;QAEA,iBAAiB;QACjB,iBAAiB;QACjB,aAAa;QACb,eAAe,MAAM,QAAQ;QAE7B,MAAO,CAAC,OAAO,OAAQ,OAAO,EAAI;YAChC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAC9C;QAEA,eAAe,OAAO,cAAc,MAAM,QAAQ,EAAE;IACtD;IAEA,OAAO;AACT;AAEA,SAAS,kBAAkB,KAAK,EAAE,UAAU;IAC1C,IAAI,OACA,OAAY,MAAM,GAAG,EACrB,UAAY,MAAM,MAAM,EACxB,UAAY,EAAE,EACd,WACA,WAAY,OACZ;IAEJ,IAAI,MAAM,MAAM,KAAK,MAAM;QACzB,MAAM,SAAS,CAAC,MAAM,MAAM,CAAC,GAAG;IAClC;IAEA,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,MAAO,OAAO,EAAG;QAEf,IAAI,OAAO,KAAI,KAAK,KAAI;YACtB;QACF;QAEA,YAAY,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,GAAG;QAEpD,IAAI,CAAC,aAAa,YAAY;YAC5B;QACF;QAEA,WAAW;QACX,MAAM,QAAQ;QAEd,IAAI,oBAAoB,OAAO,MAAM,CAAC,IAAI;YACxC,IAAI,MAAM,UAAU,IAAI,YAAY;gBAClC,QAAQ,IAAI,CAAC;gBACb,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;gBAC1C;YACF;QACF;QAEA,QAAQ,MAAM,IAAI;QAClB,YAAY,OAAO,YAAY,kBAAkB,OAAO;QACxD,QAAQ,IAAI,CAAC,MAAM,MAAM;QACzB,oBAAoB,OAAO,MAAM,CAAC;QAElC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;QAE1C,IAAI,CAAC,MAAM,IAAI,KAAK,SAAS,MAAM,UAAU,GAAG,UAAU,KAAM,OAAO,GAAI;YACzE,WAAW,OAAO;QACpB,OAAO,IAAI,MAAM,UAAU,GAAG,YAAY;YACxC;QACF;IACF;IAEA,IAAI,UAAU;QACZ,MAAM,GAAG,GAAG;QACZ,MAAM,MAAM,GAAG;QACf,MAAM,IAAI,GAAG;QACb,MAAM,MAAM,GAAG;QACf,OAAO;IACT;IACA,OAAO;AACT;AAEA,SAAS,iBAAiB,KAAK,EAAE,UAAU,EAAE,UAAU;IACrD,IAAI,WACA,cACA,OACA,MACA,OAAgB,MAAM,GAAG,EACzB,UAAgB,MAAM,MAAM,EAC5B,UAAgB,CAAC,GACjB,kBAAkB,CAAC,GACnB,SAAgB,MAChB,UAAgB,MAChB,YAAgB,MAChB,gBAAgB,OAChB,WAAgB,OAChB;IAEJ,IAAI,MAAM,MAAM,KAAK,MAAM;QACzB,MAAM,SAAS,CAAC,MAAM,MAAM,CAAC,GAAG;IAClC;IAEA,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,MAAO,OAAO,EAAG;QACf,YAAY,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,GAAG;QACpD,QAAQ,MAAM,IAAI,EAAE,yBAAyB;QAC7C,OAAO,MAAM,QAAQ;QAErB,EAAE;QACF,yDAAyD;QACzD,+EAA+E;QAC/E,EAAE;QACF,IAAI,CAAC,OAAO,KAAI,KAAK,OAAM,OAAO,KAAI,KAAK,GAAE,KAAK,aAAa,YAAY;YAEzE,IAAI,OAAO,KAAI,KAAK,KAAI;gBACtB,IAAI,eAAe;oBACjB,iBAAiB,OAAO,SAAS,iBAAiB,QAAQ,SAAS;oBACnE,SAAS,UAAU,YAAY;gBACjC;gBAEA,WAAW;gBACX,gBAAgB;gBAChB,eAAe;YAEjB,OAAO,IAAI,eAAe;gBACxB,yDAAyD;gBACzD,gBAAgB;gBAChB,eAAe;YAEjB,OAAO;gBACL,WAAW,OAAO;YACpB;YAEA,MAAM,QAAQ,IAAI;YAClB,KAAK;QAEP,EAAE;QACF,qFAAqF;QACrF,EAAE;QACF,OAAO,IAAI,YAAY,OAAO,YAAY,kBAAkB,OAAO,OAAO;YAExE,IAAI,MAAM,IAAI,KAAK,OAAO;gBACxB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;gBAE1C,MAAO,eAAe,IAAK;oBACzB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;gBAC9C;gBAEA,IAAI,OAAO,KAAI,KAAK,KAAI;oBACtB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;oBAE5C,IAAI,CAAC,aAAa,KAAK;wBACrB,WAAW,OAAO;oBACpB;oBAEA,IAAI,eAAe;wBACjB,iBAAiB,OAAO,SAAS,iBAAiB,QAAQ,SAAS;wBACnE,SAAS,UAAU,YAAY;oBACjC;oBAEA,WAAW;oBACX,gBAAgB;oBAChB,eAAe;oBACf,SAAS,MAAM,GAAG;oBAClB,UAAU,MAAM,MAAM;gBAExB,OAAO,IAAI,UAAU;oBACnB,WAAW,OAAO;gBAEpB,OAAO;oBACL,MAAM,GAAG,GAAG;oBACZ,MAAM,MAAM,GAAG;oBACf,OAAO,MAAM,oCAAoC;gBACnD;YAEF,OAAO,IAAI,UAAU;gBACnB,WAAW,OAAO;YAEpB,OAAO;gBACL,MAAM,GAAG,GAAG;gBACZ,MAAM,MAAM,GAAG;gBACf,OAAO,MAAM,oCAAoC;YACnD;QAEF,OAAO;YACL,OAAO,uCAAuC;QAChD;QAEA,EAAE;QACF,gEAAgE;QAChE,EAAE;QACF,IAAI,MAAM,IAAI,KAAK,SAAS,MAAM,UAAU,GAAG,YAAY;YACzD,IAAI,YAAY,OAAO,YAAY,mBAAmB,MAAM,eAAe;gBACzE,IAAI,eAAe;oBACjB,UAAU,MAAM,MAAM;gBACxB,OAAO;oBACL,YAAY,MAAM,MAAM;gBAC1B;YACF;YAEA,IAAI,CAAC,eAAe;gBAClB,iBAAiB,OAAO,SAAS,iBAAiB,QAAQ,SAAS,WAAW,OAAO;gBACrF,SAAS,UAAU,YAAY;YACjC;YAEA,oBAAoB,OAAO,MAAM,CAAC;YAClC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;QAC5C;QAEA,IAAI,MAAM,UAAU,GAAG,cAAe,OAAO,GAAI;YAC/C,WAAW,OAAO;QACpB,OAAO,IAAI,MAAM,UAAU,GAAG,YAAY;YACxC;QACF;IACF;IAEA,EAAE;IACF,YAAY;IACZ,EAAE;IAEF,gFAAgF;IAChF,IAAI,eAAe;QACjB,iBAAiB,OAAO,SAAS,iBAAiB,QAAQ,SAAS;IACrE;IAEA,gCAAgC;IAChC,IAAI,UAAU;QACZ,MAAM,GAAG,GAAG;QACZ,MAAM,MAAM,GAAG;QACf,MAAM,IAAI,GAAG;QACb,MAAM,MAAM,GAAG;IACjB;IAEA,OAAO;AACT;AAEA,SAAS,gBAAgB,KAAK;IAC5B,IAAI,WACA,aAAa,OACb,UAAa,OACb,WACA,SACA;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,OAAO,KAAI,KAAK,KAAI,OAAO;IAE/B,IAAI,MAAM,GAAG,KAAK,MAAM;QACtB,WAAW,OAAO;IACpB;IAEA,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAE5C,IAAI,OAAO,KAAI,KAAK,KAAI;QACtB,aAAa;QACb,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAE9C,OAAO,IAAI,OAAO,KAAI,KAAK,KAAI;QAC7B,UAAU;QACV,YAAY;QACZ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAE9C,OAAO;QACL,YAAY;IACd;IAEA,YAAY,MAAM,QAAQ;IAE1B,IAAI,YAAY;QACd,GAAG;YAAE,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAAG,QAC7C,OAAO,KAAK,OAAO,KAAI,KAAK,IAAI;QAEvC,IAAI,MAAM,QAAQ,GAAG,MAAM,MAAM,EAAE;YACjC,UAAU,MAAM,KAAK,CAAC,KAAK,CAAC,WAAW,MAAM,QAAQ;YACrD,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAC9C,OAAO;YACL,WAAW,OAAO;QACpB;IACF,OAAO;QACL,MAAO,OAAO,KAAK,CAAC,aAAa,IAAK;YAEpC,IAAI,OAAO,KAAI,KAAK,KAAI;gBACtB,IAAI,CAAC,SAAS;oBACZ,YAAY,MAAM,KAAK,CAAC,KAAK,CAAC,YAAY,GAAG,MAAM,QAAQ,GAAG;oBAE9D,IAAI,CAAC,mBAAmB,IAAI,CAAC,YAAY;wBACvC,WAAW,OAAO;oBACpB;oBAEA,UAAU;oBACV,YAAY,MAAM,QAAQ,GAAG;gBAC/B,OAAO;oBACL,WAAW,OAAO;gBACpB;YACF;YAEA,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAC9C;QAEA,UAAU,MAAM,KAAK,CAAC,KAAK,CAAC,WAAW,MAAM,QAAQ;QAErD,IAAI,wBAAwB,IAAI,CAAC,UAAU;YACzC,WAAW,OAAO;QACpB;IACF;IAEA,IAAI,WAAW,CAAC,gBAAgB,IAAI,CAAC,UAAU;QAC7C,WAAW,OAAO,8CAA8C;IAClE;IAEA,IAAI,YAAY;QACd,MAAM,GAAG,GAAG;IAEd,OAAO,IAAI,gBAAgB,IAAI,CAAC,MAAM,MAAM,EAAE,YAAY;QACxD,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,UAAU,GAAG;IAExC,OAAO,IAAI,cAAc,KAAK;QAC5B,MAAM,GAAG,GAAG,MAAM;IAEpB,OAAO,IAAI,cAAc,MAAM;QAC7B,MAAM,GAAG,GAAG,uBAAuB;IAErC,OAAO;QACL,WAAW,OAAO,4BAA4B,YAAY;IAC5D;IAEA,OAAO;AACT;AAEA,SAAS,mBAAmB,KAAK;IAC/B,IAAI,WACA;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,OAAO,KAAI,KAAK,KAAI,OAAO;IAE/B,IAAI,MAAM,MAAM,KAAK,MAAM;QACzB,WAAW,OAAO;IACpB;IAEA,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAC5C,YAAY,MAAM,QAAQ;IAE1B,MAAO,OAAO,KAAK,CAAC,aAAa,OAAO,CAAC,kBAAkB,IAAK;QAC9D,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAC9C;IAEA,IAAI,MAAM,QAAQ,KAAK,WAAW;QAChC,WAAW,OAAO;IACpB;IAEA,MAAM,MAAM,GAAG,MAAM,KAAK,CAAC,KAAK,CAAC,WAAW,MAAM,QAAQ;IAC1D,OAAO;AACT;AAEA,SAAS,UAAU,KAAK;IACtB,IAAI,WAAW,OACX;IAEJ,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;IAE1C,IAAI,OAAO,KAAI,KAAK,KAAI,OAAO;IAE/B,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAC5C,YAAY,MAAM,QAAQ;IAE1B,MAAO,OAAO,KAAK,CAAC,aAAa,OAAO,CAAC,kBAAkB,IAAK;QAC9D,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;IAC9C;IAEA,IAAI,MAAM,QAAQ,KAAK,WAAW;QAChC,WAAW,OAAO;IACpB;IAEA,QAAQ,MAAM,KAAK,CAAC,KAAK,CAAC,WAAW,MAAM,QAAQ;IAEnD,IAAI,CAAC,gBAAgB,IAAI,CAAC,MAAM,SAAS,EAAE,QAAQ;QACjD,WAAW,OAAO,yBAAyB,QAAQ;IACrD;IAEA,MAAM,MAAM,GAAG,MAAM,SAAS,CAAC,MAAM;IACrC,oBAAoB,OAAO,MAAM,CAAC;IAClC,OAAO;AACT;AAEA,SAAS,YAAY,KAAK,EAAE,YAAY,EAAE,WAAW,EAAE,WAAW,EAAE,YAAY;IAC9E,IAAI,kBACA,mBACA,uBACA,eAAe,GACf,YAAa,OACb,aAAa,OACb,WACA,cACA,MACA,YACA;IAEJ,IAAI,MAAM,QAAQ,KAAK,MAAM;QAC3B,MAAM,QAAQ,CAAC,QAAQ;IACzB;IAEA,MAAM,GAAG,GAAM;IACf,MAAM,MAAM,GAAG;IACf,MAAM,IAAI,GAAK;IACf,MAAM,MAAM,GAAG;IAEf,mBAAmB,oBAAoB,wBACrC,sBAAsB,eACtB,qBAAsB;IAExB,IAAI,aAAa;QACf,IAAI,oBAAoB,OAAO,MAAM,CAAC,IAAI;YACxC,YAAY;YAEZ,IAAI,MAAM,UAAU,GAAG,cAAc;gBACnC,eAAe;YACjB,OAAO,IAAI,MAAM,UAAU,KAAK,cAAc;gBAC5C,eAAe;YACjB,OAAO,IAAI,MAAM,UAAU,GAAG,cAAc;gBAC1C,eAAe,CAAC;YAClB;QACF;IACF;IAEA,IAAI,iBAAiB,GAAG;QACtB,MAAO,gBAAgB,UAAU,mBAAmB,OAAQ;YAC1D,IAAI,oBAAoB,OAAO,MAAM,CAAC,IAAI;gBACxC,YAAY;gBACZ,wBAAwB;gBAExB,IAAI,MAAM,UAAU,GAAG,cAAc;oBACnC,eAAe;gBACjB,OAAO,IAAI,MAAM,UAAU,KAAK,cAAc;oBAC5C,eAAe;gBACjB,OAAO,IAAI,MAAM,UAAU,GAAG,cAAc;oBAC1C,eAAe,CAAC;gBAClB;YACF,OAAO;gBACL,wBAAwB;YAC1B;QACF;IACF;IAEA,IAAI,uBAAuB;QACzB,wBAAwB,aAAa;IACvC;IAEA,IAAI,iBAAiB,KAAK,sBAAsB,aAAa;QAC3D,IAAI,oBAAoB,eAAe,qBAAqB,aAAa;YACvE,aAAa;QACf,OAAO;YACL,aAAa,eAAe;QAC9B;QAEA,cAAc,MAAM,QAAQ,GAAG,MAAM,SAAS;QAE9C,IAAI,iBAAiB,GAAG;YACtB,IAAI,yBACA,CAAC,kBAAkB,OAAO,gBACzB,iBAAiB,OAAO,aAAa,WAAW,KACjD,mBAAmB,OAAO,aAAa;gBACzC,aAAa;YACf,OAAO;gBACL,IAAI,AAAC,qBAAqB,gBAAgB,OAAO,eAC7C,uBAAuB,OAAO,eAC9B,uBAAuB,OAAO,aAAa;oBAC7C,aAAa;gBAEf,OAAO,IAAI,UAAU,QAAQ;oBAC3B,aAAa;oBAEb,IAAI,MAAM,GAAG,KAAK,QAAQ,MAAM,MAAM,KAAK,MAAM;wBAC/C,WAAW,OAAO;oBACpB;gBAEF,OAAO,IAAI,gBAAgB,OAAO,YAAY,oBAAoB,cAAc;oBAC9E,aAAa;oBAEb,IAAI,MAAM,GAAG,KAAK,MAAM;wBACtB,MAAM,GAAG,GAAG;oBACd;gBACF;gBAEA,IAAI,MAAM,MAAM,KAAK,MAAM;oBACzB,MAAM,SAAS,CAAC,MAAM,MAAM,CAAC,GAAG,MAAM,MAAM;gBAC9C;YACF;QACF,OAAO,IAAI,iBAAiB,GAAG;YAC7B,0FAA0F;YAC1F,mDAAmD;YACnD,aAAa,yBAAyB,kBAAkB,OAAO;QACjE;IACF;IAEA,IAAI,MAAM,GAAG,KAAK,QAAQ,MAAM,GAAG,KAAK,KAAK;QAC3C,IAAI,MAAM,GAAG,KAAK,KAAK;YACrB,kEAAkE;YAClE,oEAAoE;YACpE,EAAE;YACF,4EAA4E;YAC5E,yCAAyC;YACzC,EAAE;YACF,IAAI,MAAM,MAAM,KAAK,QAAQ,MAAM,IAAI,KAAK,UAAU;gBACpD,WAAW,OAAO,sEAAsE,MAAM,IAAI,GAAG;YACvG;YAEA,IAAK,YAAY,GAAG,eAAe,MAAM,aAAa,CAAC,MAAM,EAAE,YAAY,cAAc,aAAa,EAAG;gBACvG,OAAO,MAAM,aAAa,CAAC,UAAU;gBAErC,IAAI,KAAK,OAAO,CAAC,MAAM,MAAM,GAAG;oBAC9B,MAAM,MAAM,GAAG,KAAK,SAAS,CAAC,MAAM,MAAM;oBAC1C,MAAM,GAAG,GAAG,KAAK,GAAG;oBACpB,IAAI,MAAM,MAAM,KAAK,MAAM;wBACzB,MAAM,SAAS,CAAC,MAAM,MAAM,CAAC,GAAG,MAAM,MAAM;oBAC9C;oBACA;gBACF;YACF;QACF,OAAO,IAAI,gBAAgB,IAAI,CAAC,MAAM,OAAO,CAAC,MAAM,IAAI,IAAI,WAAW,EAAE,MAAM,GAAG,GAAG;YACnF,OAAO,MAAM,OAAO,CAAC,MAAM,IAAI,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC;YAEzD,IAAI,MAAM,MAAM,KAAK,QAAQ,KAAK,IAAI,KAAK,MAAM,IAAI,EAAE;gBACrD,WAAW,OAAO,kCAAkC,MAAM,GAAG,GAAG,0BAA0B,KAAK,IAAI,GAAG,aAAa,MAAM,IAAI,GAAG;YAClI;YAEA,IAAI,CAAC,KAAK,OAAO,CAAC,MAAM,MAAM,GAAG;gBAC/B,WAAW,OAAO,kCAAkC,MAAM,GAAG,GAAG;YAClE,OAAO;gBACL,MAAM,MAAM,GAAG,KAAK,SAAS,CAAC,MAAM,MAAM;gBAC1C,IAAI,MAAM,MAAM,KAAK,MAAM;oBACzB,MAAM,SAAS,CAAC,MAAM,MAAM,CAAC,GAAG,MAAM,MAAM;gBAC9C;YACF;QACF,OAAO;YACL,WAAW,OAAO,mBAAmB,MAAM,GAAG,GAAG;QACnD;IACF;IAEA,IAAI,MAAM,QAAQ,KAAK,MAAM;QAC3B,MAAM,QAAQ,CAAC,SAAS;IAC1B;IACA,OAAO,MAAM,GAAG,KAAK,QAAS,MAAM,MAAM,KAAK,QAAQ;AACzD;AAEA,SAAS,aAAa,KAAK;IACzB,IAAI,gBAAgB,MAAM,QAAQ,EAC9B,WACA,eACA,eACA,gBAAgB,OAChB;IAEJ,MAAM,OAAO,GAAG;IAChB,MAAM,eAAe,GAAG,MAAM,MAAM;IACpC,MAAM,MAAM,GAAG,CAAC;IAChB,MAAM,SAAS,GAAG,CAAC;IAEnB,MAAO,CAAC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,CAAC,MAAM,EAAG;QAC1D,oBAAoB,OAAO,MAAM,CAAC;QAElC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ;QAE1C,IAAI,MAAM,UAAU,GAAG,KAAK,OAAO,KAAI,KAAK,KAAI;YAC9C;QACF;QAEA,gBAAgB;QAChB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAC5C,YAAY,MAAM,QAAQ;QAE1B,MAAO,OAAO,KAAK,CAAC,aAAa,IAAK;YACpC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;QAC9C;QAEA,gBAAgB,MAAM,KAAK,CAAC,KAAK,CAAC,WAAW,MAAM,QAAQ;QAC3D,gBAAgB,EAAE;QAElB,IAAI,cAAc,MAAM,GAAG,GAAG;YAC5B,WAAW,OAAO;QACpB;QAEA,MAAO,OAAO,EAAG;YACf,MAAO,eAAe,IAAK;gBACzB,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;YAC9C;YAEA,IAAI,OAAO,KAAI,KAAK,KAAI;gBACtB,GAAG;oBAAE,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;gBAAG,QAC7C,OAAO,KAAK,CAAC,OAAO,IAAK;gBAChC;YACF;YAEA,IAAI,OAAO,KAAK;YAEhB,YAAY,MAAM,QAAQ;YAE1B,MAAO,OAAO,KAAK,CAAC,aAAa,IAAK;gBACpC,KAAK,MAAM,KAAK,CAAC,UAAU,CAAC,EAAE,MAAM,QAAQ;YAC9C;YAEA,cAAc,IAAI,CAAC,MAAM,KAAK,CAAC,KAAK,CAAC,WAAW,MAAM,QAAQ;QAChE;QAEA,IAAI,OAAO,GAAG,cAAc;QAE5B,IAAI,gBAAgB,IAAI,CAAC,mBAAmB,gBAAgB;YAC1D,iBAAiB,CAAC,cAAc,CAAC,OAAO,eAAe;QACzD,OAAO;YACL,aAAa,OAAO,iCAAiC,gBAAgB;QACvE;IACF;IAEA,oBAAoB,OAAO,MAAM,CAAC;IAElC,IAAI,MAAM,UAAU,KAAK,KACrB,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,MAAU,KAAI,KAAK,OACxD,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,GAAG,OAAO,KAAI,KAAK,OACxD,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,GAAG,OAAO,KAAI,KAAK,KAAI;QAC9D,MAAM,QAAQ,IAAI;QAClB,oBAAoB,OAAO,MAAM,CAAC;IAEpC,OAAO,IAAI,eAAe;QACxB,WAAW,OAAO;IACpB;IAEA,YAAY,OAAO,MAAM,UAAU,GAAG,GAAG,mBAAmB,OAAO;IACnE,oBAAoB,OAAO,MAAM,CAAC;IAElC,IAAI,MAAM,eAAe,IACrB,8BAA8B,IAAI,CAAC,MAAM,KAAK,CAAC,KAAK,CAAC,eAAe,MAAM,QAAQ,IAAI;QACxF,aAAa,OAAO;IACtB;IAEA,MAAM,SAAS,CAAC,IAAI,CAAC,MAAM,MAAM;IAEjC,IAAI,MAAM,QAAQ,KAAK,MAAM,SAAS,IAAI,sBAAsB,QAAQ;QAEtE,IAAI,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,MAAM,KAAI,KAAK,KAAI;YAC1D,MAAM,QAAQ,IAAI;YAClB,oBAAoB,OAAO,MAAM,CAAC;QACpC;QACA;IACF;IAEA,IAAI,MAAM,QAAQ,GAAI,MAAM,MAAM,GAAG,GAAI;QACvC,WAAW,OAAO;IACpB,OAAO;QACL;IACF;AACF;AAGA,SAAS,cAAc,KAAK,EAAE,OAAO;IACnC,QAAQ,OAAO;IACf,UAAU,WAAW,CAAC;IAEtB,IAAI,MAAM,MAAM,KAAK,GAAG;QAEtB,iCAAiC;QACjC,IAAI,MAAM,UAAU,CAAC,MAAM,MAAM,GAAG,OAAO,KAAI,MAAM,OACjD,MAAM,UAAU,CAAC,MAAM,MAAM,GAAG,OAAO,KAAI,MAAM,KAAI;YACvD,SAAS;QACX;QAEA,YAAY;QACZ,IAAI,MAAM,UAAU,CAAC,OAAO,QAAQ;YAClC,QAAQ,MAAM,KAAK,CAAC;QACtB;IACF;IAEA,IAAI,QAAQ,IAAI,MAAM,OAAO;IAE7B,IAAI,UAAU,MAAM,OAAO,CAAC;IAE5B,IAAI,YAAY,CAAC,GAAG;QAClB,MAAM,QAAQ,GAAG;QACjB,WAAW,OAAO;IACpB;IAEA,0EAA0E;IAC1E,MAAM,KAAK,IAAI;IAEf,MAAO,MAAM,KAAK,CAAC,UAAU,CAAC,MAAM,QAAQ,MAAM,KAAI,SAAS,IAAI;QACjE,MAAM,UAAU,IAAI;QACpB,MAAM,QAAQ,IAAI;IACpB;IAEA,MAAO,MAAM,QAAQ,GAAI,MAAM,MAAM,GAAG,EAAI;QAC1C,aAAa;IACf;IAEA,OAAO,MAAM,SAAS;AACxB;AAGA,SAAS,QAAQ,KAAK,EAAE,QAAQ,EAAE,OAAO;IACvC,IAAI,aAAa,QAAQ,OAAO,aAAa,YAAY,OAAO,YAAY,aAAa;QACvF,UAAU;QACV,WAAW;IACb;IAEA,IAAI,YAAY,cAAc,OAAO;IAErC,IAAI,OAAO,aAAa,YAAY;QAClC,OAAO;IACT;IAEA,IAAK,IAAI,QAAQ,GAAG,SAAS,UAAU,MAAM,EAAE,QAAQ,QAAQ,SAAS,EAAG;QACzE,SAAS,SAAS,CAAC,MAAM;IAC3B;AACF;AAGA,SAAS,KAAK,KAAK,EAAE,OAAO;IAC1B,IAAI,YAAY,cAAc,OAAO;IAErC,IAAI,UAAU,MAAM,KAAK,GAAG;QAC1B,6BAA6B,GAC7B,OAAO;IACT,OAAO,IAAI,UAAU,MAAM,KAAK,GAAG;QACjC,OAAO,SAAS,CAAC,EAAE;IACrB;IACA,MAAM,IAAI,cAAc;AAC1B;AAGA,SAAS,YAAY,KAAK,EAAE,QAAQ,EAAE,OAAO;IAC3C,IAAI,OAAO,aAAa,YAAY,aAAa,QAAQ,OAAO,YAAY,aAAa;QACvF,UAAU;QACV,WAAW;IACb;IAEA,OAAO,QAAQ,OAAO,UAAU,OAAO,MAAM,CAAC;QAAE,QAAQ;IAAoB,GAAG;AACjF;AAGA,SAAS,SAAS,KAAK,EAAE,OAAO;IAC9B,OAAO,KAAK,OAAO,OAAO,MAAM,CAAC;QAAE,QAAQ;IAAoB,GAAG;AACpE;AAGA,OAAO,OAAO,CAAC,OAAO,GAAO;AAC7B,OAAO,OAAO,CAAC,IAAI,GAAU;AAC7B,OAAO,OAAO,CAAC,WAAW,GAAG;AAC7B,OAAO,OAAO,CAAC,QAAQ,GAAM","ignoreList":[0]}},
    {"offset": {"line": 11673, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml/dumper.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnt mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c)\n    // byte-order-mark\n    && c !== 0xFEFF\n    // b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// Simplified test for values allowed after the first character in plain style.\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF\n    // - c-flow-indicator\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // - \":\" - \"#\"\n    // /* An ns-char preceding */ \"#\"\n    && c !== CHAR_COLON\n    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // - | ? | : | , | [ | ] | { | }\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | # | & | * | ! | | | = | > | ' | \"\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | % | @ | `)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string)\n      ? STYLE_PLAIN : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//     No ending newline => unaffected; already using strip \"-\" chomping.\n//     Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n    if (!state.noCompatMode &&\n        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i);\n    // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n      nextChar = string.charCodeAt(i + 1);\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n        // Advance index one extra since we already used that char here.\n        i++; continue;\n      }\n    }\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char)\n      ? string[i]\n      : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n      if (block && (state.dump.length !== 0)) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12311, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/lib/js-yaml.js"],"sourcesContent":["'use strict';\n\n\nvar loader = require('./js-yaml/loader');\nvar dumper = require('./js-yaml/dumper');\n\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\n\nmodule.exports.Type                = require('./js-yaml/type');\nmodule.exports.Schema              = require('./js-yaml/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');\nmodule.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.safeLoad            = loader.safeLoad;\nmodule.exports.safeLoadAll         = loader.safeLoadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.safeDump            = dumper.safeDump;\nmodule.exports.YAMLException       = require('./js-yaml/exception');\n\n// Deprecated schema names from JS-YAML 2.0.x\nmodule.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\nmodule.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n// Deprecated functions from JS-YAML 1.x.x\nmodule.exports.scan           = deprecated('scan');\nmodule.exports.parse          = deprecated('parse');\nmodule.exports.compose        = deprecated('compose');\nmodule.exports.addConstructor = deprecated('addConstructor');\n"],"names":[],"mappings":"AAGA,IAAI;AACJ,IAAI;AAGJ,SAAS,WAAW,IAAI;IACtB,OAAO;QACL,MAAM,IAAI,MAAM,cAAc,OAAO;IACvC;AACF;AAGA,OAAO,OAAO,CAAC,IAAI;AACnB,OAAO,OAAO,CAAC,MAAM;AACrB,OAAO,OAAO,CAAC,eAAe;AAC9B,OAAO,OAAO,CAAC,WAAW;AAC1B,OAAO,OAAO,CAAC,WAAW;AAC1B,OAAO,OAAO,CAAC,mBAAmB;AAClC,OAAO,OAAO,CAAC,mBAAmB;AAClC,OAAO,OAAO,CAAC,IAAI,GAAkB,OAAO,IAAI;AAChD,OAAO,OAAO,CAAC,OAAO,GAAe,OAAO,OAAO;AACnD,OAAO,OAAO,CAAC,QAAQ,GAAc,OAAO,QAAQ;AACpD,OAAO,OAAO,CAAC,WAAW,GAAW,OAAO,WAAW;AACvD,OAAO,OAAO,CAAC,IAAI,GAAkB,OAAO,IAAI;AAChD,OAAO,OAAO,CAAC,QAAQ,GAAc,OAAO,QAAQ;AACpD,OAAO,OAAO,CAAC,aAAa;AAE5B,6CAA6C;AAC7C,OAAO,OAAO,CAAC,cAAc;AAC7B,OAAO,OAAO,CAAC,WAAW;AAC1B,OAAO,OAAO,CAAC,cAAc;AAE7B,0CAA0C;AAC1C,OAAO,OAAO,CAAC,IAAI,GAAa,WAAW;AAC3C,OAAO,OAAO,CAAC,KAAK,GAAY,WAAW;AAC3C,OAAO,OAAO,CAAC,OAAO,GAAU,WAAW;AAC3C,OAAO,OAAO,CAAC,cAAc,GAAG,WAAW","ignoreList":[0]}},
    {"offset": {"line": 12345, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/node_modules/js-yaml/index.js"],"sourcesContent":["'use strict';\n\n\nvar yaml = require('./lib/js-yaml.js');\n\n\nmodule.exports = yaml;\n"],"names":[],"mappings":"AAGA,IAAI;AAGJ,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 12351, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/lib/engines.js"],"sourcesContent":["'use strict';\n\nconst yaml = require('js-yaml');\n\n/**\n * Default engines\n */\n\nconst engines = exports = module.exports;\n\n/**\n * YAML\n */\n\nengines.yaml = {\n  parse: yaml.safeLoad.bind(yaml),\n  stringify: yaml.safeDump.bind(yaml)\n};\n\n/**\n * JSON\n */\n\nengines.json = {\n  parse: JSON.parse.bind(JSON),\n  stringify: function(obj, options) {\n    const opts = Object.assign({replacer: null, space: 2}, options);\n    return JSON.stringify(obj, opts.replacer, opts.space);\n  }\n};\n\n/**\n * JavaScript\n */\n\nengines.javascript = {\n  parse: function parse(str, options, wrap) {\n    /* eslint no-eval: 0 */\n    try {\n      if (wrap !== false) {\n        str = '(function() {\\nreturn ' + str.trim() + ';\\n}());';\n      }\n      return eval(str) || {};\n    } catch (err) {\n      if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {\n        return parse(str, options, false);\n      }\n      throw new SyntaxError(err);\n    }\n  },\n  stringify: function() {\n    throw new Error('stringifying JavaScript is not supported');\n  }\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;CAEC,GAED,MAAM,UAAU,UAAU,OAAO,OAAO;AAExC;;CAEC,GAED,QAAQ,IAAI,GAAG;IACb,OAAO,KAAK,QAAQ,CAAC,IAAI,CAAC;IAC1B,WAAW,KAAK,QAAQ,CAAC,IAAI,CAAC;AAChC;AAEA;;CAEC,GAED,QAAQ,IAAI,GAAG;IACb,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC;IACvB,WAAW,SAAS,GAAG,EAAE,OAAO;QAC9B,MAAM,OAAO,OAAO,MAAM,CAAC;YAAC,UAAU;YAAM,OAAO;QAAC,GAAG;QACvD,OAAO,KAAK,SAAS,CAAC,KAAK,KAAK,QAAQ,EAAE,KAAK,KAAK;IACtD;AACF;AAEA;;CAEC,GAED,QAAQ,UAAU,GAAG;IACnB,OAAO,SAAS,MAAM,GAAG,EAAE,OAAO,EAAE,IAAI;QACtC,qBAAqB,GACrB,IAAI;YACF,IAAI,SAAS,OAAO;gBAClB,MAAM,2BAA2B,IAAI,IAAI,KAAK;YAChD;YACA,OAAO,KAAK,QAAQ,CAAC;QACvB,EAAE,OAAO,KAAK;YACZ,IAAI,SAAS,SAAS,2BAA2B,IAAI,CAAC,IAAI,OAAO,GAAG;gBAClE,OAAO,MAAM,KAAK,SAAS;YAC7B;YACA,MAAM,IAAI,YAAY;QACxB;IACF;IACA,WAAW;QACT,MAAM,IAAI,MAAM;IAClB;AACF","ignoreList":[0]}},
    {"offset": {"line": 12397, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/strip-bom-string/index.js"],"sourcesContent":["/*!\n * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>\n *\n * Copyright (c) 2015, 2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(str) {\n  if (typeof str === 'string' && str.charAt(0) === '\\ufeff') {\n    return str.slice(1);\n  }\n  return str;\n};\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAID,OAAO,OAAO,GAAG,SAAS,GAAG;IAC3B,IAAI,OAAO,QAAQ,YAAY,IAAI,MAAM,CAAC,OAAO,UAAU;QACzD,OAAO,IAAI,KAAK,CAAC;IACnB;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 12412, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/lib/utils.js"],"sourcesContent":["'use strict';\n\nconst stripBom = require('strip-bom-string');\nconst typeOf = require('kind-of');\n\nexports.define = function(obj, key, val) {\n  Reflect.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: val\n  });\n};\n\n/**\n * Returns true if `val` is a buffer\n */\n\nexports.isBuffer = function(val) {\n  return typeOf(val) === 'buffer';\n};\n\n/**\n * Returns true if `val` is an object\n */\n\nexports.isObject = function(val) {\n  return typeOf(val) === 'object';\n};\n\n/**\n * Cast `input` to a buffer\n */\n\nexports.toBuffer = function(input) {\n  return typeof input === 'string' ? Buffer.from(input) : input;\n};\n\n/**\n * Cast `val` to a string.\n */\n\nexports.toString = function(input) {\n  if (exports.isBuffer(input)) return stripBom(String(input));\n  if (typeof input !== 'string') {\n    throw new TypeError('expected input to be a string or buffer');\n  }\n  return stripBom(input);\n};\n\n/**\n * Cast `val` to an array.\n */\n\nexports.arrayify = function(val) {\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n};\n\n/**\n * Returns true if `str` starts with `substr`.\n */\n\nexports.startsWith = function(str, substr, len) {\n  if (typeof len !== 'number') len = substr.length;\n  return str.slice(0, len) === substr;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,QAAQ,MAAM,GAAG,SAAS,GAAG,EAAE,GAAG,EAAE,GAAG;IACrC,QAAQ,cAAc,CAAC,KAAK,KAAK;QAC/B,YAAY;QACZ,cAAc;QACd,UAAU;QACV,OAAO;IACT;AACF;AAEA;;CAEC,GAED,QAAQ,QAAQ,GAAG,SAAS,GAAG;IAC7B,OAAO,OAAO,SAAS;AACzB;AAEA;;CAEC,GAED,QAAQ,QAAQ,GAAG,SAAS,GAAG;IAC7B,OAAO,OAAO,SAAS;AACzB;AAEA;;CAEC,GAED,QAAQ,QAAQ,GAAG,SAAS,KAAK;IAC/B,OAAO,OAAO,UAAU,WAAW,OAAO,IAAI,CAAC,SAAS;AAC1D;AAEA;;CAEC,GAED,QAAQ,QAAQ,GAAG,SAAS,KAAK;IAC/B,IAAI,QAAQ,QAAQ,CAAC,QAAQ,OAAO,SAAS,OAAO;IACpD,IAAI,OAAO,UAAU,UAAU;QAC7B,MAAM,IAAI,UAAU;IACtB;IACA,OAAO,SAAS;AAClB;AAEA;;CAEC,GAED,QAAQ,QAAQ,GAAG,SAAS,GAAG;IAC7B,OAAO,MAAO,MAAM,OAAO,CAAC,OAAO,MAAM;QAAC;KAAI,GAAI,EAAE;AACtD;AAEA;;CAEC,GAED,QAAQ,UAAU,GAAG,SAAS,GAAG,EAAE,MAAM,EAAE,GAAG;IAC5C,IAAI,OAAO,QAAQ,UAAU,MAAM,OAAO,MAAM;IAChD,OAAO,IAAI,KAAK,CAAC,GAAG,SAAS;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 12463, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/lib/defaults.js"],"sourcesContent":["'use strict';\n\nconst engines = require('./engines');\nconst utils = require('./utils');\n\nmodule.exports = function(options) {\n  const opts = Object.assign({}, options);\n\n  // ensure that delimiters are an array\n  opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || '---');\n  if (opts.delimiters.length === 1) {\n    opts.delimiters.push(opts.delimiters[0]);\n  }\n\n  opts.language = (opts.language || opts.lang || 'yaml').toLowerCase();\n  opts.engines = Object.assign({}, engines, opts.parsers, opts.engines);\n  return opts;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,OAAO;IAC/B,MAAM,OAAO,OAAO,MAAM,CAAC,CAAC,GAAG;IAE/B,sCAAsC;IACtC,KAAK,UAAU,GAAG,MAAM,QAAQ,CAAC,KAAK,MAAM,IAAI,KAAK,UAAU,IAAI;IACnE,IAAI,KAAK,UAAU,CAAC,MAAM,KAAK,GAAG;QAChC,KAAK,UAAU,CAAC,IAAI,CAAC,KAAK,UAAU,CAAC,EAAE;IACzC;IAEA,KAAK,QAAQ,GAAG,CAAC,KAAK,QAAQ,IAAI,KAAK,IAAI,IAAI,MAAM,EAAE,WAAW;IAClE,KAAK,OAAO,GAAG,OAAO,MAAM,CAAC,CAAC,GAAG,SAAS,KAAK,OAAO,EAAE,KAAK,OAAO;IACpE,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 12480, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/lib/engine.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function(name, options) {\n  let engine = options.engines[name] || options.engines[aliase(name)];\n  if (typeof engine === 'undefined') {\n    throw new Error('gray-matter engine \"' + name + '\" is not registered');\n  }\n  if (typeof engine === 'function') {\n    engine = { parse: engine };\n  }\n  return engine;\n};\n\nfunction aliase(name) {\n  switch (name.toLowerCase()) {\n    case 'js':\n    case 'javascript':\n      return 'javascript';\n    case 'coffee':\n    case 'coffeescript':\n    case 'cson':\n      return 'coffee';\n    case 'yaml':\n    case 'yml':\n      return 'yaml';\n    default: {\n      return name;\n    }\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,IAAI,EAAE,OAAO;IACrC,IAAI,SAAS,QAAQ,OAAO,CAAC,KAAK,IAAI,QAAQ,OAAO,CAAC,OAAO,MAAM;IACnE,IAAI,OAAO,WAAW,aAAa;QACjC,MAAM,IAAI,MAAM,yBAAyB,OAAO;IAClD;IACA,IAAI,OAAO,WAAW,YAAY;QAChC,SAAS;YAAE,OAAO;QAAO;IAC3B;IACA,OAAO;AACT;AAEA,SAAS,OAAO,IAAI;IAClB,OAAQ,KAAK,WAAW;QACtB,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;QACL,KAAK;YACH,OAAO;QACT,KAAK;QACL,KAAK;YACH,OAAO;QACT;YAAS;gBACP,OAAO;YACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 12514, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/lib/stringify.js"],"sourcesContent":["'use strict';\n\nconst typeOf = require('kind-of');\nconst getEngine = require('./engine');\nconst defaults = require('./defaults');\n\nmodule.exports = function(file, data, options) {\n  if (data == null && options == null) {\n    switch (typeOf(file)) {\n      case 'object':\n        data = file.data;\n        options = {};\n        break;\n      case 'string':\n        return file;\n      default: {\n        throw new TypeError('expected file to be a string or object');\n      }\n    }\n  }\n\n  const str = file.content;\n  const opts = defaults(options);\n  if (data == null) {\n    if (!opts.data) return file;\n    data = opts.data;\n  }\n\n  const language = file.language || opts.language;\n  const engine = getEngine(language, opts);\n  if (typeof engine.stringify !== 'function') {\n    throw new TypeError('expected \"' + language + '.stringify\" to be a function');\n  }\n\n  data = Object.assign({}, file.data, data);\n  const open = opts.delimiters[0];\n  const close = opts.delimiters[1];\n  const matter = engine.stringify(data, options).trim();\n  let buf = '';\n\n  if (matter !== '{}') {\n    buf = newline(open) + newline(matter) + newline(close);\n  }\n\n  if (typeof file.excerpt === 'string' && file.excerpt !== '') {\n    if (str.indexOf(file.excerpt.trim()) === -1) {\n      buf += newline(file.excerpt) + newline(close);\n    }\n  }\n\n  return buf + newline(str);\n};\n\nfunction newline(str) {\n  return str.slice(-1) !== '\\n' ? str + '\\n' : str;\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,IAAI,EAAE,IAAI,EAAE,OAAO;IAC3C,IAAI,QAAQ,QAAQ,WAAW,MAAM;QACnC,OAAQ,OAAO;YACb,KAAK;gBACH,OAAO,KAAK,IAAI;gBAChB,UAAU,CAAC;gBACX;YACF,KAAK;gBACH,OAAO;YACT;gBAAS;oBACP,MAAM,IAAI,UAAU;gBACtB;QACF;IACF;IAEA,MAAM,MAAM,KAAK,OAAO;IACxB,MAAM,OAAO,SAAS;IACtB,IAAI,QAAQ,MAAM;QAChB,IAAI,CAAC,KAAK,IAAI,EAAE,OAAO;QACvB,OAAO,KAAK,IAAI;IAClB;IAEA,MAAM,WAAW,KAAK,QAAQ,IAAI,KAAK,QAAQ;IAC/C,MAAM,SAAS,UAAU,UAAU;IACnC,IAAI,OAAO,OAAO,SAAS,KAAK,YAAY;QAC1C,MAAM,IAAI,UAAU,eAAe,WAAW;IAChD;IAEA,OAAO,OAAO,MAAM,CAAC,CAAC,GAAG,KAAK,IAAI,EAAE;IACpC,MAAM,OAAO,KAAK,UAAU,CAAC,EAAE;IAC/B,MAAM,QAAQ,KAAK,UAAU,CAAC,EAAE;IAChC,MAAM,SAAS,OAAO,SAAS,CAAC,MAAM,SAAS,IAAI;IACnD,IAAI,MAAM;IAEV,IAAI,WAAW,MAAM;QACnB,MAAM,QAAQ,QAAQ,QAAQ,UAAU,QAAQ;IAClD;IAEA,IAAI,OAAO,KAAK,OAAO,KAAK,YAAY,KAAK,OAAO,KAAK,IAAI;QAC3D,IAAI,IAAI,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,QAAQ,CAAC,GAAG;YAC3C,OAAO,QAAQ,KAAK,OAAO,IAAI,QAAQ;QACzC;IACF;IAEA,OAAO,MAAM,QAAQ;AACvB;AAEA,SAAS,QAAQ,GAAG;IAClB,OAAO,IAAI,KAAK,CAAC,CAAC,OAAO,OAAO,MAAM,OAAO;AAC/C","ignoreList":[0]}},
    {"offset": {"line": 12565, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/lib/excerpt.js"],"sourcesContent":["'use strict';\n\nconst defaults = require('./defaults');\n\nmodule.exports = function(file, options) {\n  const opts = defaults(options);\n\n  if (file.data == null) {\n    file.data = {};\n  }\n\n  if (typeof opts.excerpt === 'function') {\n    return opts.excerpt(file, opts);\n  }\n\n  const sep = file.data.excerpt_separator || opts.excerpt_separator;\n  if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {\n    return file;\n  }\n\n  const delimiter = typeof opts.excerpt === 'string'\n    ? opts.excerpt\n    : (sep || opts.delimiters[0]);\n\n  // if enabled, get the excerpt defined after front-matter\n  const idx = file.content.indexOf(delimiter);\n  if (idx !== -1) {\n    file.excerpt = file.content.slice(0, idx);\n  }\n\n  return file;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,IAAI,EAAE,OAAO;IACrC,MAAM,OAAO,SAAS;IAEtB,IAAI,KAAK,IAAI,IAAI,MAAM;QACrB,KAAK,IAAI,GAAG,CAAC;IACf;IAEA,IAAI,OAAO,KAAK,OAAO,KAAK,YAAY;QACtC,OAAO,KAAK,OAAO,CAAC,MAAM;IAC5B;IAEA,MAAM,MAAM,KAAK,IAAI,CAAC,iBAAiB,IAAI,KAAK,iBAAiB;IACjE,IAAI,OAAO,QAAQ,CAAC,KAAK,OAAO,KAAK,SAAS,KAAK,OAAO,IAAI,IAAI,GAAG;QACnE,OAAO;IACT;IAEA,MAAM,YAAY,OAAO,KAAK,OAAO,KAAK,WACtC,KAAK,OAAO,GACX,OAAO,KAAK,UAAU,CAAC,EAAE;IAE9B,yDAAyD;IACzD,MAAM,MAAM,KAAK,OAAO,CAAC,OAAO,CAAC;IACjC,IAAI,QAAQ,CAAC,GAAG;QACd,KAAK,OAAO,GAAG,KAAK,OAAO,CAAC,KAAK,CAAC,GAAG;IACvC;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 12590, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/lib/to-file.js"],"sourcesContent":["'use strict';\n\nconst typeOf = require('kind-of');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\n/**\n * Normalize the given value to ensure an object is returned\n * with the expected properties.\n */\n\nmodule.exports = function(file) {\n  if (typeOf(file) !== 'object') {\n    file = { content: file };\n  }\n\n  if (typeOf(file.data) !== 'object') {\n    file.data = {};\n  }\n\n  // if file was passed as an object, ensure that\n  // \"file.content\" is set\n  if (file.contents && file.content == null) {\n    file.content = file.contents;\n  }\n\n  // set non-enumerable properties on the file object\n  utils.define(file, 'orig', utils.toBuffer(file.content));\n  utils.define(file, 'language', file.language || '');\n  utils.define(file, 'matter', file.matter || '');\n  utils.define(file, 'stringify', function(data, options) {\n    if (options && options.language) {\n      file.language = options.language;\n    }\n    return stringify(file, data, options);\n  });\n\n  // strip BOM and ensure that \"file.content\" is a string\n  file.content = utils.toString(file.content);\n  file.isEmpty = false;\n  file.excerpt = '';\n  return file;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;;CAGC,GAED,OAAO,OAAO,GAAG,SAAS,IAAI;IAC5B,IAAI,OAAO,UAAU,UAAU;QAC7B,OAAO;YAAE,SAAS;QAAK;IACzB;IAEA,IAAI,OAAO,KAAK,IAAI,MAAM,UAAU;QAClC,KAAK,IAAI,GAAG,CAAC;IACf;IAEA,+CAA+C;IAC/C,wBAAwB;IACxB,IAAI,KAAK,QAAQ,IAAI,KAAK,OAAO,IAAI,MAAM;QACzC,KAAK,OAAO,GAAG,KAAK,QAAQ;IAC9B;IAEA,mDAAmD;IACnD,MAAM,MAAM,CAAC,MAAM,QAAQ,MAAM,QAAQ,CAAC,KAAK,OAAO;IACtD,MAAM,MAAM,CAAC,MAAM,YAAY,KAAK,QAAQ,IAAI;IAChD,MAAM,MAAM,CAAC,MAAM,UAAU,KAAK,MAAM,IAAI;IAC5C,MAAM,MAAM,CAAC,MAAM,aAAa,SAAS,IAAI,EAAE,OAAO;QACpD,IAAI,WAAW,QAAQ,QAAQ,EAAE;YAC/B,KAAK,QAAQ,GAAG,QAAQ,QAAQ;QAClC;QACA,OAAO,UAAU,MAAM,MAAM;IAC/B;IAEA,uDAAuD;IACvD,KAAK,OAAO,GAAG,MAAM,QAAQ,CAAC,KAAK,OAAO;IAC1C,KAAK,OAAO,GAAG;IACf,KAAK,OAAO,GAAG;IACf,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 12630, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst getEngine = require('./engine');\nconst defaults = require('./defaults');\n\nmodule.exports = function(language, str, options) {\n  const opts = defaults(options);\n  const engine = getEngine(language, opts);\n  if (typeof engine.parse !== 'function') {\n    throw new TypeError('expected \"' + language + '.parse\" to be a function');\n  }\n  return engine.parse(str, opts);\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,QAAQ,EAAE,GAAG,EAAE,OAAO;IAC9C,MAAM,OAAO,SAAS;IACtB,MAAM,SAAS,UAAU,UAAU;IACnC,IAAI,OAAO,OAAO,KAAK,KAAK,YAAY;QACtC,MAAM,IAAI,UAAU,eAAe,WAAW;IAChD;IACA,OAAO,OAAO,KAAK,CAAC,KAAK;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 12644, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/gray-matter/index.js"],"sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst sections = require('section-matter');\nconst defaults = require('./lib/defaults');\nconst stringify = require('./lib/stringify');\nconst excerpt = require('./lib/excerpt');\nconst engines = require('./lib/engines');\nconst toFile = require('./lib/to-file');\nconst parse = require('./lib/parse');\nconst utils = require('./lib/utils');\n\n/**\n * Takes a string or object with `content` property, extracts\n * and parses front-matter from the string, then returns an object\n * with `data`, `content` and other [useful properties](#returned-object).\n *\n * ```js\n * const matter = require('gray-matter');\n * console.log(matter('---\\ntitle: Home\\n---\\nOther stuff'));\n * //=> { data: { title: 'Home'}, content: 'Other stuff' }\n * ```\n * @param {Object|String} `input` String, or object with `content` string\n * @param {Object} `options`\n * @return {Object}\n * @api public\n */\n\nfunction matter(input, options) {\n  if (input === '') {\n    return { data: {}, content: input, excerpt: '', orig: input };\n  }\n\n  let file = toFile(input);\n  const cached = matter.cache[file.content];\n\n  if (!options) {\n    if (cached) {\n      file = Object.assign({}, cached);\n      file.orig = cached.orig;\n      return file;\n    }\n\n    // only cache if there are no options passed. if we cache when options\n    // are passed, we would need to also cache options values, which would\n    // negate any performance benefits of caching\n    matter.cache[file.content] = file;\n  }\n\n  return parseMatter(file, options);\n}\n\n/**\n * Parse front matter\n */\n\nfunction parseMatter(file, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n  const close = '\\n' + opts.delimiters[1];\n  let str = file.content;\n\n  if (opts.language) {\n    file.language = opts.language;\n  }\n\n  // get the length of the opening delimiter\n  const openLen = open.length;\n  if (!utils.startsWith(str, open, openLen)) {\n    excerpt(file, opts);\n    return file;\n  }\n\n  // if the next character after the opening delimiter is\n  // a character from the delimiter, then it's not a front-\n  // matter delimiter\n  if (str.charAt(openLen) === open.slice(-1)) {\n    return file;\n  }\n\n  // strip the opening delimiter\n  str = str.slice(openLen);\n  const len = str.length;\n\n  // use the language defined after first delimiter, if it exists\n  const language = matter.language(str, opts);\n  if (language.name) {\n    file.language = language.name;\n    str = str.slice(language.raw.length);\n  }\n\n  // get the index of the closing delimiter\n  let closeIndex = str.indexOf(close);\n  if (closeIndex === -1) {\n    closeIndex = len;\n  }\n\n  // get the raw front-matter block\n  file.matter = str.slice(0, closeIndex);\n\n  const block = file.matter.replace(/^\\s*#[^\\n]+/gm, '').trim();\n  if (block === '') {\n    file.isEmpty = true;\n    file.empty = file.content;\n    file.data = {};\n  } else {\n\n    // create file.data by parsing the raw file.matter block\n    file.data = parse(file.language, file.matter, opts);\n  }\n\n  // update file.content\n  if (closeIndex === len) {\n    file.content = '';\n  } else {\n    file.content = str.slice(closeIndex + close.length);\n    if (file.content[0] === '\\r') {\n      file.content = file.content.slice(1);\n    }\n    if (file.content[0] === '\\n') {\n      file.content = file.content.slice(1);\n    }\n  }\n\n  excerpt(file, opts);\n\n  if (opts.sections === true || typeof opts.section === 'function') {\n    sections(file, opts.section);\n  }\n  return file;\n}\n\n/**\n * Expose engines\n */\n\nmatter.engines = engines;\n\n/**\n * Stringify an object to YAML or the specified language, and\n * append it to the given string. By default, only YAML and JSON\n * can be stringified. See the [engines](#engines) section to learn\n * how to stringify other languages.\n *\n * ```js\n * console.log(matter.stringify('foo bar baz', {title: 'Home'}));\n * // results in:\n * // ---\n * // title: Home\n * // ---\n * // foo bar baz\n * ```\n * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.\n * @param {Object} `data` Front matter to stringify.\n * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].\n * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.\n * @api public\n */\n\nmatter.stringify = function(file, data, options) {\n  if (typeof file === 'string') file = matter(file, options);\n  return stringify(file, data, options);\n};\n\n/**\n * Synchronously read a file from the file system and parse\n * front matter. Returns the same object as the [main function](#matter).\n *\n * ```js\n * const file = matter.read('./content/blog-post.md');\n * ```\n * @param {String} `filepath` file path of the file to read.\n * @param {Object} `options` [Options](#options) to pass to gray-matter.\n * @return {Object} Returns [an object](#returned-object) with `data` and `content`\n * @api public\n */\n\nmatter.read = function(filepath, options) {\n  const str = fs.readFileSync(filepath, 'utf8');\n  const file = matter(str, options);\n  file.path = filepath;\n  return file;\n};\n\n/**\n * Returns true if the given `string` has front matter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Boolean} True if front matter exists.\n * @api public\n */\n\nmatter.test = function(str, options) {\n  return utils.startsWith(str, defaults(options).delimiters[0]);\n};\n\n/**\n * Detect the language to use, if one is defined after the\n * first front-matter delimiter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed\n */\n\nmatter.language = function(str, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n\n  if (matter.test(str)) {\n    str = str.slice(open.length);\n  }\n\n  const language = str.slice(0, str.search(/\\r?\\n/));\n  return {\n    raw: language,\n    name: language ? language.trim() : ''\n  };\n};\n\n/**\n * Expose `matter`\n */\n\nmatter.cache = {};\nmatter.clearCache = function() {\n  matter.cache = {};\n};\nmodule.exports = matter;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12837, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/entities.generated.ts"],"sourcesContent":["/**\n * Auto-generated HTML entity mappings for CommonMark compliance\n * Generated from https://html.spec.whatwg.org/entities.json\n * Generated by scripts/generate-entities.ts\n * \n * Simple object mapping entity names to Unicode characters.\n * Stores only lowercase versions when case variants map to the same Unicode (saves ~8.8 KB).\n * Case-sensitive entities (where uppercase/lowercase differ) are stored with both keys.\n */\n\nexport const NAMED_CODES_TO_UNICODE: Record<string, string> = {\n  \"af\":\"\",\n  \"applyfunction\":\"\",\n  \"ic\":\"\",\n  \"invisiblecomma\":\"\",\n  \"invisibletimes\":\"\",\n  \"it\":\"\",\n  \"lrm\":\"\",\n  \"negativemediumspace\":\"\",\n  \"negativethickspace\":\"\",\n  \"negativethinspace\":\"\",\n  \"negativeverythinspace\":\"\",\n  \"nobreak\":\"\",\n  \"rlm\":\"\",\n  \"shy\":\"\",\n  \"zerowidthspace\":\"\",\n  \"zwj\":\"\",\n  \"zwnj\":\"\",\n  \"downbreve\":\"\",\n  \"tdot\":\"\",\n  \"tripledot\":\"\",\n  \"dotdot\":\"\",\n  \"tab\":\"\t\",\n  \"newline\":\"\\n\",\n  \"emsp\":\"\",\n  \"emsp13\":\"\",\n  \"emsp14\":\"\",\n  \"ensp\":\"\",\n  \"hairsp\":\"\",\n  \"mediumspace\":\"\",\n  \"puncsp\":\"\",\n  \"thinsp\":\"\",\n  \"thinspace\":\"\",\n  \"verythinspace\":\"\",\n  \"nbsp\":\"\",\n  \"nonbreakingspace\":\"\",\n  \"numsp\":\"\",\n  \"thickspace\":\"\",\n  \"oline\":\"\",\n  \"overbar\":\"\",\n  \"lowbar\":\"_\",\n  \"underbar\":\"_\",\n  \"dash\":\"\",\n  \"hyphen\":\"\",\n  \"ndash\":\"\",\n  \"mdash\":\"\",\n  \"horbar\":\"\",\n  \"comma\":\",\",\n  \"semi\":\";\",\n  \"bsemi\":\"\",\n  \"colon\":\":\",\n  \"Colone\":\"\",\n  \"excl\":\"!\",\n  \"iexcl\":\"\",\n  \"quest\":\"?\",\n  \"iquest\":\"\",\n  \"period\":\".\",\n  \"nldr\":\"\",\n  \"hellip\":\"\",\n  \"mldr\":\"\",\n  \"centerdot\":\"\",\n  \"middot\":\"\",\n  \"apos\":\"'\",\n  \"lsquo\":\"\",\n  \"opencurlyquote\":\"\",\n  \"closecurlyquote\":\"\",\n  \"rsquo\":\"\",\n  \"rsquor\":\"\",\n  \"lsquor\":\"\",\n  \"sbquo\":\"\",\n  \"lsaquo\":\"\",\n  \"rsaquo\":\"\",\n  \"quot\":\"\\\"\",\n  \"ldquo\":\"\",\n  \"opencurlydoublequote\":\"\",\n  \"closecurlydoublequote\":\"\",\n  \"rdquo\":\"\",\n  \"rdquor\":\"\",\n  \"bdquo\":\"\",\n  \"ldquor\":\"\",\n  \"laquo\":\"\",\n  \"raquo\":\"\",\n  \"lpar\":\"(\",\n  \"rpar\":\")\",\n  \"lbrack\":\"[\",\n  \"lsqb\":\"[\",\n  \"rbrack\":\"]\",\n  \"rsqb\":\"]\",\n  \"lbrace\":\"{\",\n  \"lcub\":\"{\",\n  \"rbrace\":\"}\",\n  \"rcub\":\"}\",\n  \"lceil\":\"\",\n  \"leftceiling\":\"\",\n  \"rceil\":\"\",\n  \"rightceiling\":\"\",\n  \"leftfloor\":\"\",\n  \"lfloor\":\"\",\n  \"rfloor\":\"\",\n  \"rightfloor\":\"\",\n  \"lopar\":\"\",\n  \"ropar\":\"\",\n  \"lbrke\":\"\",\n  \"rbrke\":\"\",\n  \"lbrkslu\":\"\",\n  \"rbrksld\":\"\",\n  \"lbrksld\":\"\",\n  \"rbrkslu\":\"\",\n  \"langd\":\"\",\n  \"rangd\":\"\",\n  \"lparlt\":\"\",\n  \"rpargt\":\"\",\n  \"gtlpar\":\"\",\n  \"ltrpar\":\"\",\n  \"leftdoublebracket\":\"\",\n  \"lobrk\":\"\",\n  \"rightdoublebracket\":\"\",\n  \"robrk\":\"\",\n  \"lang\":\"\",\n  \"langle\":\"\",\n  \"leftanglebracket\":\"\",\n  \"rang\":\"\",\n  \"rangle\":\"\",\n  \"rightanglebracket\":\"\",\n  \"Lang\":\"\",\n  \"Rang\":\"\",\n  \"loang\":\"\",\n  \"roang\":\"\",\n  \"lbbrk\":\"\",\n  \"rbbrk\":\"\",\n  \"Verbar\":\"\",\n  \"Vert\":\"\",\n  \"sect\":\"\",\n  \"para\":\"\",\n  \"commat\":\"@\",\n  \"ast\":\"*\",\n  \"midast\":\"*\",\n  \"sol\":\"/\",\n  \"bsol\":\"\\\\\",\n  \"amp\":\"&\",\n  \"num\":\"#\",\n  \"percnt\":\"%\",\n  \"permil\":\"\",\n  \"pertenk\":\"\",\n  \"dagger\":\"\",\n  \"Dagger\":\"\",\n  \"ddagger\":\"\",\n  \"bull\":\"\",\n  \"bullet\":\"\",\n  \"hybull\":\"\",\n  \"prime\":\"\",\n  \"Prime\":\"\",\n  \"tprime\":\"\",\n  \"qprime\":\"\",\n  \"backprime\":\"\",\n  \"bprime\":\"\",\n  \"caret\":\"\",\n  \"diacriticalgrave\":\"`\",\n  \"grave\":\"`\",\n  \"acute\":\"\",\n  \"diacriticalacute\":\"\",\n  \"diacriticaltilde\":\"\",\n  \"tilde\":\"\",\n  \"hat\":\"^\",\n  \"macr\":\"\",\n  \"strns\":\"\",\n  \"breve\":\"\",\n  \"diacriticaldot\":\"\",\n  \"dot\":\"\",\n  \"die\":\"\",\n  \"Dot\":\"\",\n  \"doubledot\":\"\",\n  \"uml\":\"\",\n  \"ring\":\"\",\n  \"dblac\":\"\",\n  \"diacriticaldoubleacute\":\"\",\n  \"cedil\":\"\",\n  \"cedilla\":\"\",\n  \"ogon\":\"\",\n  \"circ\":\"\",\n  \"caron\":\"\",\n  \"hacek\":\"\",\n  \"deg\":\"\",\n  \"copy\":\"\",\n  \"circledr\":\"\",\n  \"reg\":\"\",\n  \"copysr\":\"\",\n  \"weierp\":\"\",\n  \"wp\":\"\",\n  \"rx\":\"\",\n  \"mho\":\"\",\n  \"iiota\":\"\",\n  \"larr\":\"\",\n  \"leftarrow\":\"\",\n  \"shortleftarrow\":\"\",\n  \"slarr\":\"\",\n  \"nlarr\":\"\",\n  \"nleftarrow\":\"\",\n  \"rarr\":\"\",\n  \"rightarrow\":\"\",\n  \"shortrightarrow\":\"\",\n  \"srarr\":\"\",\n  \"nrarr\":\"\",\n  \"nrightarrow\":\"\",\n  \"shortuparrow\":\"\",\n  \"uarr\":\"\",\n  \"uparrow\":\"\",\n  \"darr\":\"\",\n  \"downarrow\":\"\",\n  \"shortdownarrow\":\"\",\n  \"harr\":\"\",\n  \"leftrightarrow\":\"\",\n  \"nharr\":\"\",\n  \"nleftrightarrow\":\"\",\n  \"updownarrow\":\"\",\n  \"varr\":\"\",\n  \"nwarr\":\"\",\n  \"nwarrow\":\"\",\n  \"upperleftarrow\":\"\",\n  \"nearr\":\"\",\n  \"nearrow\":\"\",\n  \"upperrightarrow\":\"\",\n  \"lowerrightarrow\":\"\",\n  \"searr\":\"\",\n  \"searrow\":\"\",\n  \"lowerleftarrow\":\"\",\n  \"swarr\":\"\",\n  \"swarrow\":\"\",\n  \"rarrw\":\"\",\n  \"rightsquigarrow\":\"\",\n  \"nrarrw\":\"\",\n  \"Larr\":\"\",\n  \"twoheadleftarrow\":\"\",\n  \"Uarr\":\"\",\n  \"Rarr\":\"\",\n  \"twoheadrightarrow\":\"\",\n  \"Darr\":\"\",\n  \"larrtl\":\"\",\n  \"leftarrowtail\":\"\",\n  \"rarrtl\":\"\",\n  \"rightarrowtail\":\"\",\n  \"leftteearrow\":\"\",\n  \"mapstoleft\":\"\",\n  \"mapstoup\":\"\",\n  \"upteearrow\":\"\",\n  \"map\":\"\",\n  \"mapsto\":\"\",\n  \"rightteearrow\":\"\",\n  \"downteearrow\":\"\",\n  \"mapstodown\":\"\",\n  \"hookleftarrow\":\"\",\n  \"larrhk\":\"\",\n  \"hookrightarrow\":\"\",\n  \"rarrhk\":\"\",\n  \"larrlp\":\"\",\n  \"looparrowleft\":\"\",\n  \"looparrowright\":\"\",\n  \"rarrlp\":\"\",\n  \"harrw\":\"\",\n  \"leftrightsquigarrow\":\"\",\n  \"lsh\":\"\",\n  \"rsh\":\"\",\n  \"ldsh\":\"\",\n  \"rdsh\":\"\",\n  \"crarr\":\"\",\n  \"cularr\":\"\",\n  \"curvearrowleft\":\"\",\n  \"curarr\":\"\",\n  \"curvearrowright\":\"\",\n  \"circlearrowleft\":\"\",\n  \"olarr\":\"\",\n  \"circlearrowright\":\"\",\n  \"orarr\":\"\",\n  \"leftharpoonup\":\"\",\n  \"leftvector\":\"\",\n  \"lharu\":\"\",\n  \"downleftvector\":\"\",\n  \"leftharpoondown\":\"\",\n  \"lhard\":\"\",\n  \"rightupvector\":\"\",\n  \"uharr\":\"\",\n  \"upharpoonright\":\"\",\n  \"leftupvector\":\"\",\n  \"uharl\":\"\",\n  \"upharpoonleft\":\"\",\n  \"rharu\":\"\",\n  \"rightharpoonup\":\"\",\n  \"rightvector\":\"\",\n  \"downrightvector\":\"\",\n  \"rhard\":\"\",\n  \"rightharpoondown\":\"\",\n  \"dharr\":\"\",\n  \"downharpoonright\":\"\",\n  \"rightdownvector\":\"\",\n  \"dharl\":\"\",\n  \"downharpoonleft\":\"\",\n  \"leftdownvector\":\"\",\n  \"rightarrowleftarrow\":\"\",\n  \"rightleftarrows\":\"\",\n  \"rlarr\":\"\",\n  \"udarr\":\"\",\n  \"uparrowdownarrow\":\"\",\n  \"leftarrowrightarrow\":\"\",\n  \"leftrightarrows\":\"\",\n  \"lrarr\":\"\",\n  \"leftleftarrows\":\"\",\n  \"llarr\":\"\",\n  \"upuparrows\":\"\",\n  \"uuarr\":\"\",\n  \"rightrightarrows\":\"\",\n  \"rrarr\":\"\",\n  \"ddarr\":\"\",\n  \"downdownarrows\":\"\",\n  \"leftrightharpoons\":\"\",\n  \"lrhar\":\"\",\n  \"reverseequilibrium\":\"\",\n  \"equilibrium\":\"\",\n  \"rightleftharpoons\":\"\",\n  \"rlhar\":\"\",\n  \"doubleleftarrow\":\"\",\n  \"lArr\":\"\",\n  \"Leftarrow\":\"\",\n  \"nlArr\":\"\",\n  \"nLeftarrow\":\"\",\n  \"doubleuparrow\":\"\",\n  \"uArr\":\"\",\n  \"Uparrow\":\"\",\n  \"doublerightarrow\":\"\",\n  \"implies\":\"\",\n  \"rArr\":\"\",\n  \"Rightarrow\":\"\",\n  \"nrArr\":\"\",\n  \"nRightarrow\":\"\",\n  \"dArr\":\"\",\n  \"doubledownarrow\":\"\",\n  \"Downarrow\":\"\",\n  \"doubleleftrightarrow\":\"\",\n  \"hArr\":\"\",\n  \"iff\":\"\",\n  \"Leftrightarrow\":\"\",\n  \"nhArr\":\"\",\n  \"nLeftrightarrow\":\"\",\n  \"doubleupdownarrow\":\"\",\n  \"Updownarrow\":\"\",\n  \"vArr\":\"\",\n  \"nwArr\":\"\",\n  \"neArr\":\"\",\n  \"seArr\":\"\",\n  \"swArr\":\"\",\n  \"laarr\":\"\",\n  \"lleftarrow\":\"\",\n  \"raarr\":\"\",\n  \"rrightarrow\":\"\",\n  \"zigrarr\":\"\",\n  \"larrb\":\"\",\n  \"leftarrowbar\":\"\",\n  \"rarrb\":\"\",\n  \"rightarrowbar\":\"\",\n  \"downarrowuparrow\":\"\",\n  \"duarr\":\"\",\n  \"loarr\":\"\",\n  \"roarr\":\"\",\n  \"hoarr\":\"\",\n  \"forall\":\"\",\n  \"comp\":\"\",\n  \"complement\":\"\",\n  \"part\":\"\",\n  \"partiald\":\"\",\n  \"npart\":\"\",\n  \"exist\":\"\",\n  \"exists\":\"\",\n  \"nexist\":\"\",\n  \"nexists\":\"\",\n  \"notexists\":\"\",\n  \"empty\":\"\",\n  \"emptyset\":\"\",\n  \"emptyv\":\"\",\n  \"varnothing\":\"\",\n  \"del\":\"\",\n  \"nabla\":\"\",\n  \"element\":\"\",\n  \"in\":\"\",\n  \"isin\":\"\",\n  \"isinv\":\"\",\n  \"notelement\":\"\",\n  \"notin\":\"\",\n  \"notinva\":\"\",\n  \"ni\":\"\",\n  \"niv\":\"\",\n  \"reverseelement\":\"\",\n  \"suchthat\":\"\",\n  \"notni\":\"\",\n  \"notniva\":\"\",\n  \"notreverseelement\":\"\",\n  \"backepsilon\":\"\",\n  \"bepsi\":\"\",\n  \"prod\":\"\",\n  \"product\":\"\",\n  \"coprod\":\"\",\n  \"coproduct\":\"\",\n  \"sum\":\"\",\n  \"plus\":\"+\",\n  \"plusminus\":\"\",\n  \"plusmn\":\"\",\n  \"pm\":\"\",\n  \"div\":\"\",\n  \"divide\":\"\",\n  \"times\":\"\",\n  \"lt\":\"<\",\n  \"nless\":\"\",\n  \"nlt\":\"\",\n  \"notless\":\"\",\n  \"nvlt\":\"<\",\n  \"equals\":\"=\",\n  \"ne\":\"\",\n  \"notequal\":\"\",\n  \"bne\":\"=\",\n  \"equal\":\"\",\n  \"gt\":\">\",\n  \"ngt\":\"\",\n  \"ngtr\":\"\",\n  \"notgreater\":\"\",\n  \"nvgt\":\">\",\n  \"not\":\"\",\n  \"verbar\":\"|\",\n  \"vert\":\"|\",\n  \"verticalline\":\"|\",\n  \"brvbar\":\"\",\n  \"minus\":\"\",\n  \"minusplus\":\"\",\n  \"mnplus\":\"\",\n  \"mp\":\"\",\n  \"dotplus\":\"\",\n  \"plusdo\":\"\",\n  \"frasl\":\"\",\n  \"backslash\":\"\",\n  \"setminus\":\"\",\n  \"setmn\":\"\",\n  \"smallsetminus\":\"\",\n  \"ssetmn\":\"\",\n  \"lowast\":\"\",\n  \"compfn\":\"\",\n  \"smallcircle\":\"\",\n  \"radic\":\"\",\n  \"sqrt\":\"\",\n  \"prop\":\"\",\n  \"proportional\":\"\",\n  \"propto\":\"\",\n  \"varpropto\":\"\",\n  \"vprop\":\"\",\n  \"infin\":\"\",\n  \"angrt\":\"\",\n  \"ang\":\"\",\n  \"angle\":\"\",\n  \"nang\":\"\",\n  \"angmsd\":\"\",\n  \"measuredangle\":\"\",\n  \"angsph\":\"\",\n  \"mid\":\"\",\n  \"shortmid\":\"\",\n  \"smid\":\"\",\n  \"verticalbar\":\"\",\n  \"nmid\":\"\",\n  \"notverticalbar\":\"\",\n  \"nshortmid\":\"\",\n  \"nsmid\":\"\",\n  \"doubleverticalbar\":\"\",\n  \"par\":\"\",\n  \"parallel\":\"\",\n  \"shortparallel\":\"\",\n  \"spar\":\"\",\n  \"notdoubleverticalbar\":\"\",\n  \"npar\":\"\",\n  \"nparallel\":\"\",\n  \"nshortparallel\":\"\",\n  \"nspar\":\"\",\n  \"and\":\"\",\n  \"wedge\":\"\",\n  \"or\":\"\",\n  \"vee\":\"\",\n  \"cap\":\"\",\n  \"caps\":\"\",\n  \"cup\":\"\",\n  \"cups\":\"\",\n  \"int\":\"\",\n  \"integral\":\"\",\n  \"Int\":\"\",\n  \"iiint\":\"\",\n  \"tint\":\"\",\n  \"iiiint\":\"\",\n  \"qint\":\"\",\n  \"conint\":\"\",\n  \"contourintegral\":\"\",\n  \"oint\":\"\",\n  \"Conint\":\"\",\n  \"doublecontourintegral\":\"\",\n  \"cconint\":\"\",\n  \"cwint\":\"\",\n  \"clockwisecontourintegral\":\"\",\n  \"cwconint\":\"\",\n  \"awconint\":\"\",\n  \"counterclockwisecontourintegral\":\"\",\n  \"there4\":\"\",\n  \"therefore\":\"\",\n  \"becaus\":\"\",\n  \"because\":\"\",\n  \"ratio\":\"\",\n  \"Colon\":\"\",\n  \"proportion\":\"\",\n  \"dotminus\":\"\",\n  \"minusd\":\"\",\n  \"mddot\":\"\",\n  \"homtht\":\"\",\n  \"sim\":\"\",\n  \"thicksim\":\"\",\n  \"thksim\":\"\",\n  \"Tilde\":\"\",\n  \"nottilde\":\"\",\n  \"nsim\":\"\",\n  \"nvsim\":\"\",\n  \"backsim\":\"\",\n  \"bsim\":\"\",\n  \"race\":\"\",\n  \"ac\":\"\",\n  \"mstpos\":\"\",\n  \"ace\":\"\",\n  \"acd\":\"\",\n  \"verticaltilde\":\"\",\n  \"wr\":\"\",\n  \"wreath\":\"\",\n  \"eqsim\":\"\",\n  \"equaltilde\":\"\",\n  \"esim\":\"\",\n  \"nesim\":\"\",\n  \"notequaltilde\":\"\",\n  \"sime\":\"\",\n  \"simeq\":\"\",\n  \"tildeequal\":\"\",\n  \"nottildeequal\":\"\",\n  \"nsime\":\"\",\n  \"nsimeq\":\"\",\n  \"cong\":\"\",\n  \"tildefullequal\":\"\",\n  \"ncong\":\"\",\n  \"nottildefullequal\":\"\",\n  \"simne\":\"\",\n  \"ap\":\"\",\n  \"approx\":\"\",\n  \"asymp\":\"\",\n  \"thickapprox\":\"\",\n  \"thkap\":\"\",\n  \"tildetilde\":\"\",\n  \"nap\":\"\",\n  \"napprox\":\"\",\n  \"nottildetilde\":\"\",\n  \"ape\":\"\",\n  \"approxeq\":\"\",\n  \"apid\":\"\",\n  \"napid\":\"\",\n  \"backcong\":\"\",\n  \"bcong\":\"\",\n  \"asympeq\":\"\",\n  \"CupCap\":\"\",\n  \"notcupcap\":\"\",\n  \"nvap\":\"\",\n  \"bump\":\"\",\n  \"Bumpeq\":\"\",\n  \"humpdownhump\":\"\",\n  \"nbump\":\"\",\n  \"nothumpdownhump\":\"\",\n  \"bumpe\":\"\",\n  \"bumpeq\":\"\",\n  \"humpequal\":\"\",\n  \"nbumpe\":\"\",\n  \"nothumpequal\":\"\",\n  \"doteq\":\"\",\n  \"dotequal\":\"\",\n  \"esdot\":\"\",\n  \"nedot\":\"\",\n  \"doteqdot\":\"\",\n  \"eDot\":\"\",\n  \"efdot\":\"\",\n  \"fallingdotseq\":\"\",\n  \"erdot\":\"\",\n  \"risingdotseq\":\"\",\n  \"assign\":\"\",\n  \"colone\":\"\",\n  \"coloneq\":\"\",\n  \"ecolon\":\"\",\n  \"eqcolon\":\"\",\n  \"ecir\":\"\",\n  \"eqcirc\":\"\",\n  \"circeq\":\"\",\n  \"cire\":\"\",\n  \"wedgeq\":\"\",\n  \"veeeq\":\"\",\n  \"triangleq\":\"\",\n  \"trie\":\"\",\n  \"equest\":\"\",\n  \"questeq\":\"\",\n  \"congruent\":\"\",\n  \"equiv\":\"\",\n  \"nequiv\":\"\",\n  \"notcongruent\":\"\",\n  \"bnequiv\":\"\",\n  \"le\":\"\",\n  \"leq\":\"\",\n  \"nle\":\"\",\n  \"nleq\":\"\",\n  \"notlessequal\":\"\",\n  \"nvle\":\"\",\n  \"ge\":\"\",\n  \"geq\":\"\",\n  \"greaterequal\":\"\",\n  \"nge\":\"\",\n  \"ngeq\":\"\",\n  \"notgreaterequal\":\"\",\n  \"nvge\":\"\",\n  \"lE\":\"\",\n  \"leqq\":\"\",\n  \"lessfullequal\":\"\",\n  \"nlE\":\"\",\n  \"nleqq\":\"\",\n  \"gE\":\"\",\n  \"geqq\":\"\",\n  \"greaterfullequal\":\"\",\n  \"ngE\":\"\",\n  \"ngeqq\":\"\",\n  \"notgreaterfullequal\":\"\",\n  \"lnE\":\"\",\n  \"lneqq\":\"\",\n  \"lvertneqq\":\"\",\n  \"lvne\":\"\",\n  \"gnE\":\"\",\n  \"gneqq\":\"\",\n  \"gvertneqq\":\"\",\n  \"gvne\":\"\",\n  \"ll\":\"\",\n  \"Lt\":\"\",\n  \"nestedlessless\":\"\",\n  \"nltv\":\"\",\n  \"notlessless\":\"\",\n  \"nLt\":\"\",\n  \"gg\":\"\",\n  \"Gt\":\"\",\n  \"nestedgreatergreater\":\"\",\n  \"ngtv\":\"\",\n  \"notgreatergreater\":\"\",\n  \"nGt\":\"\",\n  \"between\":\"\",\n  \"twixt\":\"\",\n  \"lesssim\":\"\",\n  \"lesstilde\":\"\",\n  \"lsim\":\"\",\n  \"nlsim\":\"\",\n  \"notlesstilde\":\"\",\n  \"greatertilde\":\"\",\n  \"gsim\":\"\",\n  \"gtrsim\":\"\",\n  \"ngsim\":\"\",\n  \"notgreatertilde\":\"\",\n  \"lessgreater\":\"\",\n  \"lessgtr\":\"\",\n  \"lg\":\"\",\n  \"notlessgreater\":\"\",\n  \"ntlg\":\"\",\n  \"gl\":\"\",\n  \"greaterless\":\"\",\n  \"gtrless\":\"\",\n  \"notgreaterless\":\"\",\n  \"ntgl\":\"\",\n  \"pr\":\"\",\n  \"prec\":\"\",\n  \"precedes\":\"\",\n  \"notprecedes\":\"\",\n  \"npr\":\"\",\n  \"nprec\":\"\",\n  \"sc\":\"\",\n  \"succ\":\"\",\n  \"succeeds\":\"\",\n  \"notsucceeds\":\"\",\n  \"nsc\":\"\",\n  \"nsucc\":\"\",\n  \"prcue\":\"\",\n  \"preccurlyeq\":\"\",\n  \"precedesslantequal\":\"\",\n  \"notprecedesslantequal\":\"\",\n  \"nprcue\":\"\",\n  \"sccue\":\"\",\n  \"succcurlyeq\":\"\",\n  \"succeedsslantequal\":\"\",\n  \"notsucceedsslantequal\":\"\",\n  \"nsccue\":\"\",\n  \"precedestilde\":\"\",\n  \"precsim\":\"\",\n  \"prsim\":\"\",\n  \"scsim\":\"\",\n  \"succeedstilde\":\"\",\n  \"succsim\":\"\",\n  \"notsucceedstilde\":\"\",\n  \"sub\":\"\",\n  \"subset\":\"\",\n  \"nsub\":\"\",\n  \"notsubset\":\"\",\n  \"nsubset\":\"\",\n  \"vnsub\":\"\",\n  \"sup\":\"\",\n  \"superset\":\"\",\n  \"supset\":\"\",\n  \"nsup\":\"\",\n  \"notsuperset\":\"\",\n  \"nsupset\":\"\",\n  \"vnsup\":\"\",\n  \"sube\":\"\",\n  \"subseteq\":\"\",\n  \"subsetequal\":\"\",\n  \"notsubsetequal\":\"\",\n  \"nsube\":\"\",\n  \"nsubseteq\":\"\",\n  \"supe\":\"\",\n  \"supersetequal\":\"\",\n  \"supseteq\":\"\",\n  \"notsupersetequal\":\"\",\n  \"nsupe\":\"\",\n  \"nsupseteq\":\"\",\n  \"subne\":\"\",\n  \"subsetneq\":\"\",\n  \"varsubsetneq\":\"\",\n  \"vsubne\":\"\",\n  \"supne\":\"\",\n  \"supsetneq\":\"\",\n  \"varsupsetneq\":\"\",\n  \"vsupne\":\"\",\n  \"cupdot\":\"\",\n  \"unionplus\":\"\",\n  \"uplus\":\"\",\n  \"sqsub\":\"\",\n  \"sqsubset\":\"\",\n  \"squaresubset\":\"\",\n  \"notsquaresubset\":\"\",\n  \"sqsup\":\"\",\n  \"sqsupset\":\"\",\n  \"squaresuperset\":\"\",\n  \"notsquaresuperset\":\"\",\n  \"sqsube\":\"\",\n  \"sqsubseteq\":\"\",\n  \"squaresubsetequal\":\"\",\n  \"notsquaresubsetequal\":\"\",\n  \"nsqsube\":\"\",\n  \"sqsupe\":\"\",\n  \"sqsupseteq\":\"\",\n  \"squaresupersetequal\":\"\",\n  \"notsquaresupersetequal\":\"\",\n  \"nsqsupe\":\"\",\n  \"sqcap\":\"\",\n  \"sqcaps\":\"\",\n  \"squareintersection\":\"\",\n  \"sqcup\":\"\",\n  \"sqcups\":\"\",\n  \"squareunion\":\"\",\n  \"circleplus\":\"\",\n  \"oplus\":\"\",\n  \"circleminus\":\"\",\n  \"ominus\":\"\",\n  \"circletimes\":\"\",\n  \"otimes\":\"\",\n  \"osol\":\"\",\n  \"circledot\":\"\",\n  \"odot\":\"\",\n  \"circledcirc\":\"\",\n  \"ocir\":\"\",\n  \"circledast\":\"\",\n  \"oast\":\"\",\n  \"circleddash\":\"\",\n  \"odash\":\"\",\n  \"boxplus\":\"\",\n  \"plusb\":\"\",\n  \"boxminus\":\"\",\n  \"minusb\":\"\",\n  \"boxtimes\":\"\",\n  \"timesb\":\"\",\n  \"dotsquare\":\"\",\n  \"sdotb\":\"\",\n  \"righttee\":\"\",\n  \"vdash\":\"\",\n  \"nvdash\":\"\",\n  \"dashv\":\"\",\n  \"lefttee\":\"\",\n  \"downtee\":\"\",\n  \"top\":\"\",\n  \"bot\":\"\",\n  \"bottom\":\"\",\n  \"perp\":\"\",\n  \"uptee\":\"\",\n  \"models\":\"\",\n  \"doublerighttee\":\"\",\n  \"vDash\":\"\",\n  \"nvDash\":\"\",\n  \"Vdash\":\"\",\n  \"nVdash\":\"\",\n  \"vvdash\":\"\",\n  \"VDash\":\"\",\n  \"nVDash\":\"\",\n  \"prurel\":\"\",\n  \"lefttriangle\":\"\",\n  \"vartriangleleft\":\"\",\n  \"vltri\":\"\",\n  \"nltri\":\"\",\n  \"notlefttriangle\":\"\",\n  \"ntriangleleft\":\"\",\n  \"righttriangle\":\"\",\n  \"vartriangleright\":\"\",\n  \"vrtri\":\"\",\n  \"notrighttriangle\":\"\",\n  \"nrtri\":\"\",\n  \"ntriangleright\":\"\",\n  \"lefttriangleequal\":\"\",\n  \"ltrie\":\"\",\n  \"trianglelefteq\":\"\",\n  \"nltrie\":\"\",\n  \"notlefttriangleequal\":\"\",\n  \"ntrianglelefteq\":\"\",\n  \"nvltrie\":\"\",\n  \"righttriangleequal\":\"\",\n  \"rtrie\":\"\",\n  \"trianglerighteq\":\"\",\n  \"notrighttriangleequal\":\"\",\n  \"nrtrie\":\"\",\n  \"ntrianglerighteq\":\"\",\n  \"nvrtrie\":\"\",\n  \"origof\":\"\",\n  \"imof\":\"\",\n  \"multimap\":\"\",\n  \"mumap\":\"\",\n  \"hercon\":\"\",\n  \"intcal\":\"\",\n  \"intercal\":\"\",\n  \"veebar\":\"\",\n  \"barvee\":\"\",\n  \"angrtvb\":\"\",\n  \"lrtri\":\"\",\n  \"bigwedge\":\"\",\n  \"Wedge\":\"\",\n  \"xwedge\":\"\",\n  \"bigvee\":\"\",\n  \"Vee\":\"\",\n  \"xvee\":\"\",\n  \"bigcap\":\"\",\n  \"intersection\":\"\",\n  \"xcap\":\"\",\n  \"bigcup\":\"\",\n  \"union\":\"\",\n  \"xcup\":\"\",\n  \"diam\":\"\",\n  \"diamond\":\"\",\n  \"sdot\":\"\",\n  \"sstarf\":\"\",\n  \"Star\":\"\",\n  \"divideontimes\":\"\",\n  \"divonx\":\"\",\n  \"bowtie\":\"\",\n  \"ltimes\":\"\",\n  \"rtimes\":\"\",\n  \"leftthreetimes\":\"\",\n  \"lthree\":\"\",\n  \"rightthreetimes\":\"\",\n  \"rthree\":\"\",\n  \"backsimeq\":\"\",\n  \"bsime\":\"\",\n  \"curlyvee\":\"\",\n  \"cuvee\":\"\",\n  \"curlywedge\":\"\",\n  \"cuwed\":\"\",\n  \"Sub\":\"\",\n  \"Subset\":\"\",\n  \"Sup\":\"\",\n  \"Supset\":\"\",\n  \"Cap\":\"\",\n  \"Cup\":\"\",\n  \"fork\":\"\",\n  \"pitchfork\":\"\",\n  \"epar\":\"\",\n  \"lessdot\":\"\",\n  \"ltdot\":\"\",\n  \"gtdot\":\"\",\n  \"gtrdot\":\"\",\n  \"Ll\":\"\",\n  \"nll\":\"\",\n  \"Gg\":\"\",\n  \"ggg\":\"\",\n  \"ngg\":\"\",\n  \"leg\":\"\",\n  \"lesg\":\"\",\n  \"lesseqgtr\":\"\",\n  \"lessequalgreater\":\"\",\n  \"gel\":\"\",\n  \"gesl\":\"\",\n  \"greaterequalless\":\"\",\n  \"gtreqless\":\"\",\n  \"cuepr\":\"\",\n  \"curlyeqprec\":\"\",\n  \"cuesc\":\"\",\n  \"curlyeqsucc\":\"\",\n  \"lnsim\":\"\",\n  \"gnsim\":\"\",\n  \"precnsim\":\"\",\n  \"prnsim\":\"\",\n  \"scnsim\":\"\",\n  \"succnsim\":\"\",\n  \"vellip\":\"\",\n  \"ctdot\":\"\",\n  \"utdot\":\"\",\n  \"dtdot\":\"\",\n  \"disin\":\"\",\n  \"isinsv\":\"\",\n  \"isins\":\"\",\n  \"isindot\":\"\",\n  \"notindot\":\"\",\n  \"notinvc\":\"\",\n  \"notinvb\":\"\",\n  \"isine\":\"\",\n  \"notine\":\"\",\n  \"nisd\":\"\",\n  \"xnis\":\"\",\n  \"nis\":\"\",\n  \"notnivc\":\"\",\n  \"notnivb\":\"\",\n  \"barwed\":\"\",\n  \"barwedge\":\"\",\n  \"Barwed\":\"\",\n  \"doublebarwedge\":\"\",\n  \"drcrop\":\"\",\n  \"dlcrop\":\"\",\n  \"urcrop\":\"\",\n  \"ulcrop\":\"\",\n  \"bnot\":\"\",\n  \"profline\":\"\",\n  \"profsurf\":\"\",\n  \"telrec\":\"\",\n  \"target\":\"\",\n  \"ulcorn\":\"\",\n  \"ulcorner\":\"\",\n  \"urcorn\":\"\",\n  \"urcorner\":\"\",\n  \"dlcorn\":\"\",\n  \"llcorner\":\"\",\n  \"drcorn\":\"\",\n  \"lrcorner\":\"\",\n  \"frown\":\"\",\n  \"sfrown\":\"\",\n  \"smile\":\"\",\n  \"ssmile\":\"\",\n  \"cylcty\":\"\",\n  \"profalar\":\"\",\n  \"topbot\":\"\",\n  \"ovbar\":\"\",\n  \"solbar\":\"\",\n  \"angzarr\":\"\",\n  \"lmoust\":\"\",\n  \"lmoustache\":\"\",\n  \"rmoust\":\"\",\n  \"rmoustache\":\"\",\n  \"overbracket\":\"\",\n  \"tbrk\":\"\",\n  \"bbrk\":\"\",\n  \"underbracket\":\"\",\n  \"bbrktbrk\":\"\",\n  \"overparenthesis\":\"\",\n  \"underparenthesis\":\"\",\n  \"overbrace\":\"\",\n  \"underbrace\":\"\",\n  \"trpezium\":\"\",\n  \"elinters\":\"\",\n  \"blank\":\"\",\n  \"boxh\":\"\",\n  \"horizontalline\":\"\",\n  \"boxv\":\"\",\n  \"boxdr\":\"\",\n  \"boxdl\":\"\",\n  \"boxur\":\"\",\n  \"boxul\":\"\",\n  \"boxvr\":\"\",\n  \"boxvl\":\"\",\n  \"boxhd\":\"\",\n  \"boxhu\":\"\",\n  \"boxvh\":\"\",\n  \"boxH\":\"\",\n  \"boxV\":\"\",\n  \"boxdR\":\"\",\n  \"boxDr\":\"\",\n  \"boxDR\":\"\",\n  \"boxdL\":\"\",\n  \"boxDl\":\"\",\n  \"boxDL\":\"\",\n  \"boxuR\":\"\",\n  \"boxUr\":\"\",\n  \"boxUR\":\"\",\n  \"boxuL\":\"\",\n  \"boxUl\":\"\",\n  \"boxUL\":\"\",\n  \"boxvR\":\"\",\n  \"boxVr\":\"\",\n  \"boxVR\":\"\",\n  \"boxvL\":\"\",\n  \"boxVl\":\"\",\n  \"boxVL\":\"\",\n  \"boxHd\":\"\",\n  \"boxhD\":\"\",\n  \"boxHD\":\"\",\n  \"boxHu\":\"\",\n  \"boxhU\":\"\",\n  \"boxHU\":\"\",\n  \"boxvH\":\"\",\n  \"boxVh\":\"\",\n  \"boxVH\":\"\",\n  \"uhblk\":\"\",\n  \"lhblk\":\"\",\n  \"block\":\"\",\n  \"blk14\":\"\",\n  \"blk12\":\"\",\n  \"blk34\":\"\",\n  \"squ\":\"\",\n  \"square\":\"\",\n  \"blacksquare\":\"\",\n  \"filledverysmallsquare\":\"\",\n  \"squarf\":\"\",\n  \"squf\":\"\",\n  \"emptyverysmallsquare\":\"\",\n  \"rect\":\"\",\n  \"marker\":\"\",\n  \"fltns\":\"\",\n  \"bigtriangleup\":\"\",\n  \"xutri\":\"\",\n  \"blacktriangle\":\"\",\n  \"utrif\":\"\",\n  \"triangle\":\"\",\n  \"utri\":\"\",\n  \"blacktriangleright\":\"\",\n  \"rtrif\":\"\",\n  \"rtri\":\"\",\n  \"triangleright\":\"\",\n  \"bigtriangledown\":\"\",\n  \"xdtri\":\"\",\n  \"blacktriangledown\":\"\",\n  \"dtrif\":\"\",\n  \"dtri\":\"\",\n  \"triangledown\":\"\",\n  \"blacktriangleleft\":\"\",\n  \"ltrif\":\"\",\n  \"ltri\":\"\",\n  \"triangleleft\":\"\",\n  \"loz\":\"\",\n  \"lozenge\":\"\",\n  \"cir\":\"\",\n  \"tridot\":\"\",\n  \"bigcirc\":\"\",\n  \"xcirc\":\"\",\n  \"ultri\":\"\",\n  \"urtri\":\"\",\n  \"lltri\":\"\",\n  \"emptysmallsquare\":\"\",\n  \"filledsmallsquare\":\"\",\n  \"bigstar\":\"\",\n  \"starf\":\"\",\n  \"star\":\"\",\n  \"phone\":\"\",\n  \"female\":\"\",\n  \"male\":\"\",\n  \"spades\":\"\",\n  \"spadesuit\":\"\",\n  \"clubs\":\"\",\n  \"clubsuit\":\"\",\n  \"hearts\":\"\",\n  \"heartsuit\":\"\",\n  \"diamondsuit\":\"\",\n  \"diams\":\"\",\n  \"sung\":\"\",\n  \"check\":\"\",\n  \"checkmark\":\"\",\n  \"cross\":\"\",\n  \"malt\":\"\",\n  \"maltese\":\"\",\n  \"sext\":\"\",\n  \"verticalseparator\":\"\",\n  \"bsolhsub\":\"\",\n  \"suphsol\":\"\",\n  \"longleftarrow\":\"\",\n  \"xlarr\":\"\",\n  \"longrightarrow\":\"\",\n  \"xrarr\":\"\",\n  \"longleftrightarrow\":\"\",\n  \"xharr\":\"\",\n  \"doublelongleftarrow\":\"\",\n  \"Longleftarrow\":\"\",\n  \"xlArr\":\"\",\n  \"doublelongrightarrow\":\"\",\n  \"Longrightarrow\":\"\",\n  \"xrArr\":\"\",\n  \"doublelongleftrightarrow\":\"\",\n  \"Longleftrightarrow\":\"\",\n  \"xhArr\":\"\",\n  \"longmapsto\":\"\",\n  \"xmap\":\"\",\n  \"dzigrarr\":\"\",\n  \"nvlarr\":\"\",\n  \"nvrarr\":\"\",\n  \"nvharr\":\"\",\n  \"Map\":\"\",\n  \"lbarr\":\"\",\n  \"bkarow\":\"\",\n  \"lBarr\":\"\",\n  \"dbkarow\":\"\",\n  \"rBarr\":\"\",\n  \"drbkarow\":\"\",\n  \"rbarr\":\"\",\n  \"RBarr\":\"\",\n  \"ddotrahd\":\"\",\n  \"uparrowbar\":\"\",\n  \"downarrowbar\":\"\",\n  \"Rarrtl\":\"\",\n  \"latail\":\"\",\n  \"ratail\":\"\",\n  \"lAtail\":\"\",\n  \"rAtail\":\"\",\n  \"larrfs\":\"\",\n  \"rarrfs\":\"\",\n  \"larrbfs\":\"\",\n  \"rarrbfs\":\"\",\n  \"nwarhk\":\"\",\n  \"nearhk\":\"\",\n  \"hksearow\":\"\",\n  \"searhk\":\"\",\n  \"hkswarow\":\"\",\n  \"swarhk\":\"\",\n  \"nwnear\":\"\",\n  \"nesear\":\"\",\n  \"toea\":\"\",\n  \"seswar\":\"\",\n  \"tosa\":\"\",\n  \"swnwar\":\"\",\n  \"rarrc\":\"\",\n  \"nrarrc\":\"\",\n  \"cudarrr\":\"\",\n  \"ldca\":\"\",\n  \"rdca\":\"\",\n  \"cudarrl\":\"\",\n  \"larrpl\":\"\",\n  \"curarrm\":\"\",\n  \"cularrp\":\"\",\n  \"rarrpl\":\"\",\n  \"harrcir\":\"\",\n  \"uarrocir\":\"\",\n  \"lurdshar\":\"\",\n  \"ldrushar\":\"\",\n  \"leftrightvector\":\"\",\n  \"rightupdownvector\":\"\",\n  \"downleftrightvector\":\"\",\n  \"leftupdownvector\":\"\",\n  \"leftvectorbar\":\"\",\n  \"rightvectorbar\":\"\",\n  \"rightupvectorbar\":\"\",\n  \"rightdownvectorbar\":\"\",\n  \"downleftvectorbar\":\"\",\n  \"downrightvectorbar\":\"\",\n  \"leftupvectorbar\":\"\",\n  \"leftdownvectorbar\":\"\",\n  \"leftteevector\":\"\",\n  \"rightteevector\":\"\",\n  \"rightupteevector\":\"\",\n  \"rightdownteevector\":\"\",\n  \"downleftteevector\":\"\",\n  \"downrightteevector\":\"\",\n  \"leftupteevector\":\"\",\n  \"leftdownteevector\":\"\",\n  \"lhar\":\"\",\n  \"uhar\":\"\",\n  \"rhar\":\"\",\n  \"dhar\":\"\",\n  \"luruhar\":\"\",\n  \"ldrdhar\":\"\",\n  \"ruluhar\":\"\",\n  \"rdldhar\":\"\",\n  \"lharul\":\"\",\n  \"llhard\":\"\",\n  \"rharul\":\"\",\n  \"lrhard\":\"\",\n  \"udhar\":\"\",\n  \"upequilibrium\":\"\",\n  \"duhar\":\"\",\n  \"reverseupequilibrium\":\"\",\n  \"roundimplies\":\"\",\n  \"erarr\":\"\",\n  \"simrarr\":\"\",\n  \"larrsim\":\"\",\n  \"rarrsim\":\"\",\n  \"rarrap\":\"\",\n  \"ltlarr\":\"\",\n  \"gtrarr\":\"\",\n  \"subrarr\":\"\",\n  \"suplarr\":\"\",\n  \"lfisht\":\"\",\n  \"rfisht\":\"\",\n  \"ufisht\":\"\",\n  \"dfisht\":\"\",\n  \"vzigzag\":\"\",\n  \"vangrt\":\"\",\n  \"angrtvbd\":\"\",\n  \"ange\":\"\",\n  \"range\":\"\",\n  \"dwangle\":\"\",\n  \"uwangle\":\"\",\n  \"angmsdaa\":\"\",\n  \"angmsdab\":\"\",\n  \"angmsdac\":\"\",\n  \"angmsdad\":\"\",\n  \"angmsdae\":\"\",\n  \"angmsdaf\":\"\",\n  \"angmsdag\":\"\",\n  \"angmsdah\":\"\",\n  \"bemptyv\":\"\",\n  \"demptyv\":\"\",\n  \"cemptyv\":\"\",\n  \"raemptyv\":\"\",\n  \"laemptyv\":\"\",\n  \"ohbar\":\"\",\n  \"omid\":\"\",\n  \"opar\":\"\",\n  \"operp\":\"\",\n  \"olcross\":\"\",\n  \"odsold\":\"\",\n  \"olcir\":\"\",\n  \"ofcir\":\"\",\n  \"olt\":\"\",\n  \"ogt\":\"\",\n  \"cirscir\":\"\",\n  \"cirE\":\"\",\n  \"solb\":\"\",\n  \"bsolb\":\"\",\n  \"boxbox\":\"\",\n  \"trisb\":\"\",\n  \"rtriltri\":\"\",\n  \"lefttrianglebar\":\"\",\n  \"notlefttrianglebar\":\"\",\n  \"righttrianglebar\":\"\",\n  \"notrighttrianglebar\":\"\",\n  \"iinfin\":\"\",\n  \"infintie\":\"\",\n  \"nvinfin\":\"\",\n  \"eparsl\":\"\",\n  \"smeparsl\":\"\",\n  \"eqvparsl\":\"\",\n  \"blacklozenge\":\"\",\n  \"lozf\":\"\",\n  \"ruledelayed\":\"\",\n  \"dsol\":\"\",\n  \"bigodot\":\"\",\n  \"xodot\":\"\",\n  \"bigoplus\":\"\",\n  \"xoplus\":\"\",\n  \"bigotimes\":\"\",\n  \"xotime\":\"\",\n  \"biguplus\":\"\",\n  \"xuplus\":\"\",\n  \"bigsqcup\":\"\",\n  \"xsqcup\":\"\",\n  \"fpartint\":\"\",\n  \"cirfnint\":\"\",\n  \"awint\":\"\",\n  \"rppolint\":\"\",\n  \"scpolint\":\"\",\n  \"npolint\":\"\",\n  \"pointint\":\"\",\n  \"quatint\":\"\",\n  \"intlarhk\":\"\",\n  \"pluscir\":\"\",\n  \"plusacir\":\"\",\n  \"simplus\":\"\",\n  \"plusdu\":\"\",\n  \"plussim\":\"\",\n  \"plustwo\":\"\",\n  \"mcomma\":\"\",\n  \"minusdu\":\"\",\n  \"loplus\":\"\",\n  \"roplus\":\"\",\n  \"Cross\":\"\",\n  \"timesd\":\"\",\n  \"timesbar\":\"\",\n  \"smashp\":\"\",\n  \"lotimes\":\"\",\n  \"rotimes\":\"\",\n  \"otimesas\":\"\",\n  \"Otimes\":\"\",\n  \"odiv\":\"\",\n  \"triplus\":\"\",\n  \"triminus\":\"\",\n  \"tritime\":\"\",\n  \"intprod\":\"\",\n  \"iprod\":\"\",\n  \"amalg\":\"\",\n  \"capdot\":\"\",\n  \"ncup\":\"\",\n  \"ncap\":\"\",\n  \"capand\":\"\",\n  \"cupor\":\"\",\n  \"cupcap\":\"\",\n  \"capcup\":\"\",\n  \"cupbrcap\":\"\",\n  \"capbrcup\":\"\",\n  \"cupcup\":\"\",\n  \"capcap\":\"\",\n  \"ccups\":\"\",\n  \"ccaps\":\"\",\n  \"ccupssm\":\"\",\n  \"And\":\"\",\n  \"Or\":\"\",\n  \"andand\":\"\",\n  \"oror\":\"\",\n  \"orslope\":\"\",\n  \"andslope\":\"\",\n  \"andv\":\"\",\n  \"orv\":\"\",\n  \"andd\":\"\",\n  \"ord\":\"\",\n  \"wedbar\":\"\",\n  \"sdote\":\"\",\n  \"simdot\":\"\",\n  \"congdot\":\"\",\n  \"ncongdot\":\"\",\n  \"easter\":\"\",\n  \"apacir\":\"\",\n  \"apE\":\"\",\n  \"nape\":\"\",\n  \"eplus\":\"\",\n  \"pluse\":\"\",\n  \"Esim\":\"\",\n  \"ddotseq\":\"\",\n  \"eddot\":\"\",\n  \"equivdd\":\"\",\n  \"ltcir\":\"\",\n  \"gtcir\":\"\",\n  \"ltquest\":\"\",\n  \"gtquest\":\"\",\n  \"leqslant\":\"\",\n  \"les\":\"\",\n  \"lessslantequal\":\"\",\n  \"nleqslant\":\"\",\n  \"nles\":\"\",\n  \"notlessslantequal\":\"\",\n  \"geqslant\":\"\",\n  \"ges\":\"\",\n  \"greaterslantequal\":\"\",\n  \"ngeqslant\":\"\",\n  \"nges\":\"\",\n  \"notgreaterslantequal\":\"\",\n  \"lesdot\":\"\",\n  \"gesdot\":\"\",\n  \"lesdoto\":\"\",\n  \"gesdoto\":\"\",\n  \"lesdotor\":\"\",\n  \"gesdotol\":\"\",\n  \"lap\":\"\",\n  \"lessapprox\":\"\",\n  \"gap\":\"\",\n  \"gtrapprox\":\"\",\n  \"lne\":\"\",\n  \"lneq\":\"\",\n  \"gne\":\"\",\n  \"gneq\":\"\",\n  \"lnap\":\"\",\n  \"lnapprox\":\"\",\n  \"gnap\":\"\",\n  \"gnapprox\":\"\",\n  \"lEg\":\"\",\n  \"lesseqqgtr\":\"\",\n  \"gEl\":\"\",\n  \"gtreqqless\":\"\",\n  \"lsime\":\"\",\n  \"gsime\":\"\",\n  \"lsimg\":\"\",\n  \"gsiml\":\"\",\n  \"lge\":\"\",\n  \"gle\":\"\",\n  \"lesges\":\"\",\n  \"gesles\":\"\",\n  \"els\":\"\",\n  \"eqslantless\":\"\",\n  \"egs\":\"\",\n  \"eqslantgtr\":\"\",\n  \"elsdot\":\"\",\n  \"egsdot\":\"\",\n  \"el\":\"\",\n  \"eg\":\"\",\n  \"siml\":\"\",\n  \"simg\":\"\",\n  \"simle\":\"\",\n  \"simge\":\"\",\n  \"lessless\":\"\",\n  \"notnestedlessless\":\"\",\n  \"greatergreater\":\"\",\n  \"notnestedgreatergreater\":\"\",\n  \"glj\":\"\",\n  \"gla\":\"\",\n  \"ltcc\":\"\",\n  \"gtcc\":\"\",\n  \"lescc\":\"\",\n  \"gescc\":\"\",\n  \"smt\":\"\",\n  \"lat\":\"\",\n  \"smte\":\"\",\n  \"smtes\":\"\",\n  \"late\":\"\",\n  \"lates\":\"\",\n  \"bumpE\":\"\",\n  \"pre\":\"\",\n  \"precedesequal\":\"\",\n  \"preceq\":\"\",\n  \"notprecedesequal\":\"\",\n  \"npre\":\"\",\n  \"npreceq\":\"\",\n  \"sce\":\"\",\n  \"succeedsequal\":\"\",\n  \"succeq\":\"\",\n  \"notsucceedsequal\":\"\",\n  \"nsce\":\"\",\n  \"nsucceq\":\"\",\n  \"prE\":\"\",\n  \"scE\":\"\",\n  \"precneqq\":\"\",\n  \"prne\":\"\",\n  \"scne\":\"\",\n  \"succneqq\":\"\",\n  \"prap\":\"\",\n  \"precapprox\":\"\",\n  \"scap\":\"\",\n  \"succapprox\":\"\",\n  \"precnapprox\":\"\",\n  \"prnap\":\"\",\n  \"scnap\":\"\",\n  \"succnapprox\":\"\",\n  \"Pr\":\"\",\n  \"Sc\":\"\",\n  \"subdot\":\"\",\n  \"supdot\":\"\",\n  \"subplus\":\"\",\n  \"supplus\":\"\",\n  \"submult\":\"\",\n  \"supmult\":\"\",\n  \"subedot\":\"\",\n  \"supedot\":\"\",\n  \"subE\":\"\",\n  \"subseteqq\":\"\",\n  \"nsubE\":\"\",\n  \"nsubseteqq\":\"\",\n  \"supE\":\"\",\n  \"supseteqq\":\"\",\n  \"nsupE\":\"\",\n  \"nsupseteqq\":\"\",\n  \"subsim\":\"\",\n  \"supsim\":\"\",\n  \"subnE\":\"\",\n  \"subsetneqq\":\"\",\n  \"varsubsetneqq\":\"\",\n  \"vsubnE\":\"\",\n  \"supnE\":\"\",\n  \"supsetneqq\":\"\",\n  \"varsupsetneqq\":\"\",\n  \"vsupnE\":\"\",\n  \"csub\":\"\",\n  \"csup\":\"\",\n  \"csube\":\"\",\n  \"csupe\":\"\",\n  \"subsup\":\"\",\n  \"supsub\":\"\",\n  \"subsub\":\"\",\n  \"supsup\":\"\",\n  \"suphsub\":\"\",\n  \"supdsub\":\"\",\n  \"forkv\":\"\",\n  \"topfork\":\"\",\n  \"mlcp\":\"\",\n  \"Dashv\":\"\",\n  \"doublelefttee\":\"\",\n  \"vdashl\":\"\",\n  \"barv\":\"\",\n  \"vbar\":\"\",\n  \"vbarv\":\"\",\n  \"Vbar\":\"\",\n  \"Not\":\"\",\n  \"bNot\":\"\",\n  \"rnmid\":\"\",\n  \"cirmid\":\"\",\n  \"midcir\":\"\",\n  \"topcir\":\"\",\n  \"nhpar\":\"\",\n  \"parsim\":\"\",\n  \"parsl\":\"\",\n  \"nparsl\":\"\",\n  \"flat\":\"\",\n  \"natur\":\"\",\n  \"natural\":\"\",\n  \"sharp\":\"\",\n  \"curren\":\"\",\n  \"cent\":\"\",\n  \"dollar\":\"$\",\n  \"pound\":\"\",\n  \"yen\":\"\",\n  \"euro\":\"\",\n  \"sup1\":\"\",\n  \"frac12\":\"\",\n  \"half\":\"\",\n  \"frac13\":\"\",\n  \"frac14\":\"\",\n  \"frac15\":\"\",\n  \"frac16\":\"\",\n  \"frac18\":\"\",\n  \"sup2\":\"\",\n  \"frac23\":\"\",\n  \"frac25\":\"\",\n  \"sup3\":\"\",\n  \"frac34\":\"\",\n  \"frac35\":\"\",\n  \"frac38\":\"\",\n  \"frac45\":\"\",\n  \"frac56\":\"\",\n  \"frac58\":\"\",\n  \"frac78\":\"\",\n  \"afr\":\"\",\n  \"aopf\":\"\",\n  \"ascr\":\"\",\n  \"Afr\":\"\",\n  \"Aopf\":\"\",\n  \"Ascr\":\"\",\n  \"ordf\":\"\",\n  \"aacute\":\"\",\n  \"Aacute\":\"\",\n  \"agrave\":\"\",\n  \"Agrave\":\"\",\n  \"abreve\":\"\",\n  \"Abreve\":\"\",\n  \"acirc\":\"\",\n  \"Acirc\":\"\",\n  \"aring\":\"\",\n  \"angst\":\"\",\n  \"Aring\":\"\",\n  \"auml\":\"\",\n  \"Auml\":\"\",\n  \"atilde\":\"\",\n  \"Atilde\":\"\",\n  \"aogon\":\"\",\n  \"Aogon\":\"\",\n  \"amacr\":\"\",\n  \"Amacr\":\"\",\n  \"aelig\":\"\",\n  \"AElig\":\"\",\n  \"bfr\":\"\",\n  \"bopf\":\"\",\n  \"bscr\":\"\",\n  \"bernou\":\"\",\n  \"bernoullis\":\"\",\n  \"Bfr\":\"\",\n  \"Bopf\":\"\",\n  \"Bscr\":\"\",\n  \"cfr\":\"\",\n  \"copf\":\"\",\n  \"cscr\":\"\",\n  \"cayleys\":\"\",\n  \"Cfr\":\"\",\n  \"complexes\":\"\",\n  \"Copf\":\"\",\n  \"Cscr\":\"\",\n  \"cacute\":\"\",\n  \"Cacute\":\"\",\n  \"ccirc\":\"\",\n  \"Ccirc\":\"\",\n  \"ccaron\":\"\",\n  \"Ccaron\":\"\",\n  \"cdot\":\"\",\n  \"Cdot\":\"\",\n  \"ccedil\":\"\",\n  \"Ccedil\":\"\",\n  \"incare\":\"\",\n  \"dfr\":\"\",\n  \"differentiald\":\"\",\n  \"dopf\":\"\",\n  \"dscr\":\"\",\n  \"capitaldifferentiald\":\"\",\n  \"dd\":\"\",\n  \"DD\":\"\",\n  \"Dfr\":\"\",\n  \"Dopf\":\"\",\n  \"Dscr\":\"\",\n  \"dcaron\":\"\",\n  \"Dcaron\":\"\",\n  \"dstrok\":\"\",\n  \"Dstrok\":\"\",\n  \"eth\":\"\",\n  \"ETH\":\"\",\n  \"ee\":\"\",\n  \"efr\":\"\",\n  \"eopf\":\"\",\n  \"escr\":\"\",\n  \"exponentiale\":\"\",\n  \"Efr\":\"\",\n  \"Eopf\":\"\",\n  \"Escr\":\"\",\n  \"expectation\":\"\",\n  \"eacute\":\"\",\n  \"Eacute\":\"\",\n  \"egrave\":\"\",\n  \"Egrave\":\"\",\n  \"ecirc\":\"\",\n  \"Ecirc\":\"\",\n  \"ecaron\":\"\",\n  \"Ecaron\":\"\",\n  \"euml\":\"\",\n  \"Euml\":\"\",\n  \"edot\":\"\",\n  \"Edot\":\"\",\n  \"eogon\":\"\",\n  \"Eogon\":\"\",\n  \"emacr\":\"\",\n  \"Emacr\":\"\",\n  \"ffr\":\"\",\n  \"fopf\":\"\",\n  \"fscr\":\"\",\n  \"Ffr\":\"\",\n  \"Fopf\":\"\",\n  \"fouriertrf\":\"\",\n  \"Fscr\":\"\",\n  \"fflig\":\"\",\n  \"ffilig\":\"\",\n  \"ffllig\":\"\",\n  \"filig\":\"\",\n  \"fjlig\":\"fj\",\n  \"fllig\":\"\",\n  \"fnof\":\"\",\n  \"gfr\":\"\",\n  \"gopf\":\"\",\n  \"gscr\":\"\",\n  \"Gfr\":\"\",\n  \"Gopf\":\"\",\n  \"Gscr\":\"\",\n  \"gacute\":\"\",\n  \"gbreve\":\"\",\n  \"Gbreve\":\"\",\n  \"gcirc\":\"\",\n  \"Gcirc\":\"\",\n  \"gdot\":\"\",\n  \"Gdot\":\"\",\n  \"gcedil\":\"\",\n  \"hfr\":\"\",\n  \"hopf\":\"\",\n  \"hscr\":\"\",\n  \"planckh\":\"\",\n  \"hamilt\":\"\",\n  \"Hfr\":\"\",\n  \"hilbertspace\":\"\",\n  \"Hopf\":\"\",\n  \"Hscr\":\"\",\n  \"poincareplane\":\"\",\n  \"quaternions\":\"\",\n  \"hcirc\":\"\",\n  \"Hcirc\":\"\",\n  \"hbar\":\"\",\n  \"hslash\":\"\",\n  \"hstrok\":\"\",\n  \"planck\":\"\",\n  \"plankv\":\"\",\n  \"Hstrok\":\"\",\n  \"ifr\":\"\",\n  \"ii\":\"\",\n  \"imaginaryi\":\"\",\n  \"iopf\":\"\",\n  \"iscr\":\"\",\n  \"Ifr\":\"\",\n  \"im\":\"\",\n  \"image\":\"\",\n  \"imagline\":\"\",\n  \"imagpart\":\"\",\n  \"Iopf\":\"\",\n  \"Iscr\":\"\",\n  \"iacute\":\"\",\n  \"Iacute\":\"\",\n  \"igrave\":\"\",\n  \"Igrave\":\"\",\n  \"icirc\":\"\",\n  \"Icirc\":\"\",\n  \"iuml\":\"\",\n  \"Iuml\":\"\",\n  \"itilde\":\"\",\n  \"Itilde\":\"\",\n  \"idot\":\"\",\n  \"iogon\":\"\",\n  \"Iogon\":\"\",\n  \"imacr\":\"\",\n  \"Imacr\":\"\",\n  \"ijlig\":\"\",\n  \"IJlig\":\"\",\n  \"imath\":\"\",\n  \"inodot\":\"\",\n  \"jfr\":\"\",\n  \"jopf\":\"\",\n  \"jscr\":\"\",\n  \"Jfr\":\"\",\n  \"Jopf\":\"\",\n  \"Jscr\":\"\",\n  \"jcirc\":\"\",\n  \"Jcirc\":\"\",\n  \"jmath\":\"\",\n  \"kfr\":\"\",\n  \"kopf\":\"\",\n  \"kscr\":\"\",\n  \"Kfr\":\"\",\n  \"Kopf\":\"\",\n  \"Kscr\":\"\",\n  \"kcedil\":\"\",\n  \"Kcedil\":\"\",\n  \"ell\":\"\",\n  \"lfr\":\"\",\n  \"lopf\":\"\",\n  \"lscr\":\"\",\n  \"lagran\":\"\",\n  \"laplacetrf\":\"\",\n  \"Lfr\":\"\",\n  \"Lopf\":\"\",\n  \"Lscr\":\"\",\n  \"lacute\":\"\",\n  \"Lacute\":\"\",\n  \"lcaron\":\"\",\n  \"Lcaron\":\"\",\n  \"lcedil\":\"\",\n  \"Lcedil\":\"\",\n  \"lstrok\":\"\",\n  \"Lstrok\":\"\",\n  \"lmidot\":\"\",\n  \"Lmidot\":\"\",\n  \"mfr\":\"\",\n  \"mopf\":\"\",\n  \"mscr\":\"\",\n  \"mellintrf\":\"\",\n  \"Mfr\":\"\",\n  \"Mopf\":\"\",\n  \"Mscr\":\"\",\n  \"phmmat\":\"\",\n  \"nfr\":\"\",\n  \"nopf\":\"\",\n  \"nscr\":\"\",\n  \"naturals\":\"\",\n  \"Nfr\":\"\",\n  \"Nopf\":\"\",\n  \"Nscr\":\"\",\n  \"nacute\":\"\",\n  \"Nacute\":\"\",\n  \"ncaron\":\"\",\n  \"Ncaron\":\"\",\n  \"ntilde\":\"\",\n  \"Ntilde\":\"\",\n  \"ncedil\":\"\",\n  \"Ncedil\":\"\",\n  \"numero\":\"\",\n  \"eng\":\"\",\n  \"ENG\":\"\",\n  \"ofr\":\"\",\n  \"oopf\":\"\",\n  \"order\":\"\",\n  \"orderof\":\"\",\n  \"oscr\":\"\",\n  \"Ofr\":\"\",\n  \"Oopf\":\"\",\n  \"Oscr\":\"\",\n  \"ordm\":\"\",\n  \"oacute\":\"\",\n  \"Oacute\":\"\",\n  \"ograve\":\"\",\n  \"Ograve\":\"\",\n  \"ocirc\":\"\",\n  \"Ocirc\":\"\",\n  \"ouml\":\"\",\n  \"Ouml\":\"\",\n  \"odblac\":\"\",\n  \"Odblac\":\"\",\n  \"otilde\":\"\",\n  \"Otilde\":\"\",\n  \"oslash\":\"\",\n  \"Oslash\":\"\",\n  \"omacr\":\"\",\n  \"Omacr\":\"\",\n  \"oelig\":\"\",\n  \"OElig\":\"\",\n  \"pfr\":\"\",\n  \"popf\":\"\",\n  \"pscr\":\"\",\n  \"Pfr\":\"\",\n  \"Popf\":\"\",\n  \"primes\":\"\",\n  \"Pscr\":\"\",\n  \"qfr\":\"\",\n  \"qopf\":\"\",\n  \"qscr\":\"\",\n  \"Qfr\":\"\",\n  \"Qopf\":\"\",\n  \"Qscr\":\"\",\n  \"rationals\":\"\",\n  \"kgreen\":\"\",\n  \"rfr\":\"\",\n  \"ropf\":\"\",\n  \"rscr\":\"\",\n  \"re\":\"\",\n  \"real\":\"\",\n  \"realine\":\"\",\n  \"realpart\":\"\",\n  \"reals\":\"\",\n  \"Rfr\":\"\",\n  \"Ropf\":\"\",\n  \"Rscr\":\"\",\n  \"racute\":\"\",\n  \"Racute\":\"\",\n  \"rcaron\":\"\",\n  \"Rcaron\":\"\",\n  \"rcedil\":\"\",\n  \"Rcedil\":\"\",\n  \"sfr\":\"\",\n  \"sopf\":\"\",\n  \"sscr\":\"\",\n  \"Sfr\":\"\",\n  \"Sopf\":\"\",\n  \"Sscr\":\"\",\n  \"circleds\":\"\",\n  \"os\":\"\",\n  \"sacute\":\"\",\n  \"Sacute\":\"\",\n  \"scirc\":\"\",\n  \"Scirc\":\"\",\n  \"scaron\":\"\",\n  \"Scaron\":\"\",\n  \"scedil\":\"\",\n  \"Scedil\":\"\",\n  \"szlig\":\"\",\n  \"tfr\":\"\",\n  \"topf\":\"\",\n  \"tscr\":\"\",\n  \"Tfr\":\"\",\n  \"Topf\":\"\",\n  \"Tscr\":\"\",\n  \"tcaron\":\"\",\n  \"Tcaron\":\"\",\n  \"tcedil\":\"\",\n  \"Tcedil\":\"\",\n  \"trade\":\"\",\n  \"tstrok\":\"\",\n  \"Tstrok\":\"\",\n  \"ufr\":\"\",\n  \"uopf\":\"\",\n  \"uscr\":\"\",\n  \"Ufr\":\"\",\n  \"Uopf\":\"\",\n  \"Uscr\":\"\",\n  \"uacute\":\"\",\n  \"Uacute\":\"\",\n  \"ugrave\":\"\",\n  \"Ugrave\":\"\",\n  \"ubreve\":\"\",\n  \"Ubreve\":\"\",\n  \"ucirc\":\"\",\n  \"Ucirc\":\"\",\n  \"uring\":\"\",\n  \"Uring\":\"\",\n  \"uuml\":\"\",\n  \"Uuml\":\"\",\n  \"udblac\":\"\",\n  \"Udblac\":\"\",\n  \"utilde\":\"\",\n  \"Utilde\":\"\",\n  \"uogon\":\"\",\n  \"Uogon\":\"\",\n  \"umacr\":\"\",\n  \"Umacr\":\"\",\n  \"vfr\":\"\",\n  \"vopf\":\"\",\n  \"vscr\":\"\",\n  \"Vfr\":\"\",\n  \"Vopf\":\"\",\n  \"Vscr\":\"\",\n  \"wfr\":\"\",\n  \"wopf\":\"\",\n  \"wscr\":\"\",\n  \"Wfr\":\"\",\n  \"Wopf\":\"\",\n  \"Wscr\":\"\",\n  \"wcirc\":\"\",\n  \"Wcirc\":\"\",\n  \"xfr\":\"\",\n  \"xopf\":\"\",\n  \"xscr\":\"\",\n  \"Xfr\":\"\",\n  \"Xopf\":\"\",\n  \"Xscr\":\"\",\n  \"yfr\":\"\",\n  \"yopf\":\"\",\n  \"yscr\":\"\",\n  \"Yfr\":\"\",\n  \"Yopf\":\"\",\n  \"Yscr\":\"\",\n  \"yacute\":\"\",\n  \"Yacute\":\"\",\n  \"ycirc\":\"\",\n  \"Ycirc\":\"\",\n  \"yuml\":\"\",\n  \"Yuml\":\"\",\n  \"zfr\":\"\",\n  \"zopf\":\"\",\n  \"zscr\":\"\",\n  \"integers\":\"\",\n  \"zeetrf\":\"\",\n  \"Zfr\":\"\",\n  \"Zopf\":\"\",\n  \"Zscr\":\"\",\n  \"zacute\":\"\",\n  \"Zacute\":\"\",\n  \"zcaron\":\"\",\n  \"Zcaron\":\"\",\n  \"zdot\":\"\",\n  \"Zdot\":\"\",\n  \"imped\":\"\",\n  \"thorn\":\"\",\n  \"THORN\":\"\",\n  \"napos\":\"\",\n  \"alpha\":\"\",\n  \"Alpha\":\"\",\n  \"beta\":\"\",\n  \"Beta\":\"\",\n  \"gamma\":\"\",\n  \"Gamma\":\"\",\n  \"delta\":\"\",\n  \"Delta\":\"\",\n  \"epsi\":\"\",\n  \"epsilon\":\"\",\n  \"epsiv\":\"\",\n  \"straightepsilon\":\"\",\n  \"varepsilon\":\"\",\n  \"Epsilon\":\"\",\n  \"digamma\":\"\",\n  \"gammad\":\"\",\n  \"Gammad\":\"\",\n  \"zeta\":\"\",\n  \"Zeta\":\"\",\n  \"eta\":\"\",\n  \"Eta\":\"\",\n  \"theta\":\"\",\n  \"thetasym\":\"\",\n  \"thetav\":\"\",\n  \"vartheta\":\"\",\n  \"Theta\":\"\",\n  \"iota\":\"\",\n  \"Iota\":\"\",\n  \"kappa\":\"\",\n  \"kappav\":\"\",\n  \"varkappa\":\"\",\n  \"Kappa\":\"\",\n  \"lambda\":\"\",\n  \"Lambda\":\"\",\n  \"mu\":\"\",\n  \"micro\":\"\",\n  \"Mu\":\"\",\n  \"nu\":\"\",\n  \"Nu\":\"\",\n  \"xi\":\"\",\n  \"Xi\":\"\",\n  \"omicron\":\"\",\n  \"Omicron\":\"\",\n  \"pi\":\"\",\n  \"piv\":\"\",\n  \"varpi\":\"\",\n  \"Pi\":\"\",\n  \"rho\":\"\",\n  \"rhov\":\"\",\n  \"varrho\":\"\",\n  \"Rho\":\"\",\n  \"sigma\":\"\",\n  \"Sigma\":\"\",\n  \"sigmaf\":\"\",\n  \"sigmav\":\"\",\n  \"varsigma\":\"\",\n  \"tau\":\"\",\n  \"Tau\":\"\",\n  \"upsi\":\"\",\n  \"upsilon\":\"\",\n  \"Upsilon\":\"\",\n  \"Upsi\":\"\",\n  \"upsih\":\"\",\n  \"phi\":\"\",\n  \"phiv\":\"\",\n  \"straightphi\":\"\",\n  \"varphi\":\"\",\n  \"Phi\":\"\",\n  \"chi\":\"\",\n  \"Chi\":\"\",\n  \"psi\":\"\",\n  \"Psi\":\"\",\n  \"omega\":\"\",\n  \"ohm\":\"\",\n  \"Omega\":\"\",\n  \"acy\":\"\",\n  \"Acy\":\"\",\n  \"bcy\":\"\",\n  \"Bcy\":\"\",\n  \"vcy\":\"\",\n  \"Vcy\":\"\",\n  \"gcy\":\"\",\n  \"Gcy\":\"\",\n  \"gjcy\":\"\",\n  \"GJcy\":\"\",\n  \"dcy\":\"\",\n  \"Dcy\":\"\",\n  \"djcy\":\"\",\n  \"DJcy\":\"\",\n  \"iecy\":\"\",\n  \"IEcy\":\"\",\n  \"iocy\":\"\",\n  \"IOcy\":\"\",\n  \"jukcy\":\"\",\n  \"Jukcy\":\"\",\n  \"zhcy\":\"\",\n  \"ZHcy\":\"\",\n  \"zcy\":\"\",\n  \"Zcy\":\"\",\n  \"dscy\":\"\",\n  \"DScy\":\"\",\n  \"icy\":\"\",\n  \"Icy\":\"\",\n  \"iukcy\":\"\",\n  \"Iukcy\":\"\",\n  \"yicy\":\"\",\n  \"YIcy\":\"\",\n  \"jcy\":\"\",\n  \"Jcy\":\"\",\n  \"jsercy\":\"\",\n  \"Jsercy\":\"\",\n  \"kcy\":\"\",\n  \"Kcy\":\"\",\n  \"kjcy\":\"\",\n  \"KJcy\":\"\",\n  \"lcy\":\"\",\n  \"Lcy\":\"\",\n  \"ljcy\":\"\",\n  \"LJcy\":\"\",\n  \"mcy\":\"\",\n  \"Mcy\":\"\",\n  \"ncy\":\"\",\n  \"Ncy\":\"\",\n  \"njcy\":\"\",\n  \"NJcy\":\"\",\n  \"ocy\":\"\",\n  \"Ocy\":\"\",\n  \"pcy\":\"\",\n  \"Pcy\":\"\",\n  \"rcy\":\"\",\n  \"Rcy\":\"\",\n  \"scy\":\"\",\n  \"Scy\":\"\",\n  \"tcy\":\"\",\n  \"Tcy\":\"\",\n  \"tshcy\":\"\",\n  \"TSHcy\":\"\",\n  \"ucy\":\"\",\n  \"Ucy\":\"\",\n  \"ubrcy\":\"\",\n  \"Ubrcy\":\"\",\n  \"fcy\":\"\",\n  \"Fcy\":\"\",\n  \"khcy\":\"\",\n  \"KHcy\":\"\",\n  \"tscy\":\"\",\n  \"TScy\":\"\",\n  \"chcy\":\"\",\n  \"CHcy\":\"\",\n  \"dzcy\":\"\",\n  \"DZcy\":\"\",\n  \"shcy\":\"\",\n  \"SHcy\":\"\",\n  \"shchcy\":\"\",\n  \"SHCHcy\":\"\",\n  \"hardcy\":\"\",\n  \"HARDcy\":\"\",\n  \"ycy\":\"\",\n  \"Ycy\":\"\",\n  \"softcy\":\"\",\n  \"SOFTcy\":\"\",\n  \"ecy\":\"\",\n  \"Ecy\":\"\",\n  \"yucy\":\"\",\n  \"YUcy\":\"\",\n  \"yacy\":\"\",\n  \"YAcy\":\"\",\n  \"alefsym\":\"\",\n  \"aleph\":\"\",\n  \"beth\":\"\",\n  \"gimel\":\"\",\n  \"daleth\":\"\"\n}\n\n/**\n * Decode a named entity using the lookup table.\n * Returns the decoded character or undefined if not found.\n * This function enables browser builds to swap in DOM-based decoding.\n */\nexport function decodeEntity(name: string): string | undefined {\n  return NAMED_CODES_TO_UNICODE[name] || NAMED_CODES_TO_UNICODE[name.toLowerCase()]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 14954, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/react.tsx","file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/constants.ts","file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/types.ts","file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/utils.ts","file:///C:/code/AnDDoanf/anddoanf/node_modules/markdown-to-jsx/dist/src/parse.ts"],"sourcesContent":["/** @jsxRuntime classic */\n/** @jsx h */\n\nimport * as React from 'react'\nimport * as $ from './constants'\nimport * as parse from './parse'\nimport { MarkdownToJSX, RuleType } from './types'\nimport * as util from './utils'\n\nexport { parser } from './parse'\n\nexport { RuleType, type MarkdownToJSX } from './types'\nexport { sanitizer, slugify } from './utils'\n\nconst TRIM_STARTING_NEWLINES = /^\\n+/\n\n/**\n * React context for sharing compiler options across Markdown components\n * @lang zh  Markdown  React \n * @lang hi Markdown          React \n *\n * Note: This is undefined in React Server Component environments where createContext is not available.\n * @lang zh  createContext  React Server Component  undefined\n * @lang hi : React Server Component    undefined   createContext   \n */\nexport const MarkdownContext:\n  | React.Context<MarkdownToJSX.Options | undefined>\n  | undefined =\n  typeof React.createContext !== 'undefined'\n    ? React.createContext<MarkdownToJSX.Options | undefined>(undefined)\n    : undefined\n\n// Import shared HTML to JSX conversion utilities\nimport { htmlAttrsToJSXProps } from './utils'\n\n// Helper function for URL encoding backslashes and backticks per CommonMark spec\nfunction encodeUrlTarget(target: string): string {\n  // Fast path: check if encoding is needed\n  let needsEncoding = false\n  for (let i = 0; i < target.length; i++) {\n    const code = target.charCodeAt(i)\n    if (code > 127 || code === $.CHAR_BACKSLASH || code === $.CHAR_BACKTICK) {\n      needsEncoding = true\n      break\n    }\n  }\n  if (!needsEncoding) return target\n\n  // Encode character by character, preserving existing percent-encoded sequences\n  let result = ''\n  for (let i = 0; i < target.length; i++) {\n    const char = target[i]\n    if (\n      char === '%' &&\n      i + 2 < target.length &&\n      /[0-9A-Fa-f]/.test(target[i + 1]) &&\n      /[0-9A-Fa-f]/.test(target[i + 2])\n    ) {\n      // Preserve existing percent-encoded sequence\n      result += target[i] + target[i + 1] + target[i + 2]\n      i += 2\n    } else if (char.charCodeAt(0) === $.CHAR_BACKSLASH) {\n      result += '%5C'\n    } else if (char.charCodeAt(0) === $.CHAR_BACKTICK) {\n      result += '%60'\n    } else {\n      const code = char.charCodeAt(0)\n      result += code > 127 ? encodeURIComponent(char) : char\n    }\n  }\n  return result\n}\n\nfunction render(\n  node: MarkdownToJSX.ASTNode,\n  output: MarkdownToJSX.ASTRender,\n  state: MarkdownToJSX.State,\n  h: (tag: any, props: any, ...children: any[]) => any,\n  sanitize: (value: string, tag: string, attribute: string) => string | null,\n  slug: (input: string, defaultFn: (input: string) => string) => string,\n  refs: { [key: string]: { target: string; title: string } },\n  options: MarkdownToJSX.Options\n): React.ReactNode {\n  switch (node.type) {\n    case RuleType.blockQuote: {\n      const props = {\n        key: state.key,\n      } as Record<string, unknown>\n\n      if (node.alert) {\n        props.className =\n          'markdown-alert-' + slug(node.alert.toLowerCase(), util.slugify)\n\n        node.children.unshift({\n          attrs: {},\n          children: [{ type: RuleType.text, text: node.alert }],\n          verbatim: true,\n          type: RuleType.htmlBlock,\n          tag: 'header',\n        })\n      }\n\n      return h('blockquote', props, output(node.children, state))\n    }\n\n    case RuleType.breakLine:\n      return <br key={state.key} />\n\n    case RuleType.breakThematic:\n      return <hr key={state.key} />\n\n    case RuleType.frontmatter:\n      if (options.preserveFrontmatter) {\n        return <pre key={state.key}>{node.text}</pre>\n      }\n      return null\n\n    case RuleType.codeBlock:\n      // Decode entity references in language name (per CommonMark spec)\n      const decodedLang = node.lang\n        ? util.decodeEntityReferences(node.lang)\n        : ''\n      return (\n        <pre key={state.key}>\n          <code\n            {...htmlAttrsToJSXProps(node.attrs || {})}\n            className={\n              decodedLang ? `language-${decodedLang} lang-${decodedLang}` : ''\n            }\n          >\n            {node.text}\n          </code>\n        </pre>\n      )\n\n    case RuleType.codeInline:\n      return <code key={state.key}>{node.text}</code>\n\n    case RuleType.footnoteReference:\n      return (\n        <a key={state.key} href={sanitize(node.target, 'a', 'href')}>\n          <sup key={state.key}>{node.text}</sup>\n        </a>\n      )\n\n    case RuleType.gfmTask:\n      return (\n        <input\n          checked={node.completed}\n          key={state.key}\n          readOnly\n          type=\"checkbox\"\n        />\n      )\n\n    case RuleType.heading:\n      return h(\n        `h${node.level}`,\n        { id: node.id, key: state.key },\n        output(node.children, state)\n      )\n\n    case RuleType.htmlBlock: {\n      const htmlNode = node as MarkdownToJSX.HTMLNode\n\n      // Apply options.tagfilter: escape dangerous tags\n      if (options.tagfilter && util.shouldFilterTag(htmlNode.tag)) {\n        let tagText: string\n        if ('rawText' in htmlNode && typeof htmlNode.rawText === 'string') {\n          // Use raw text as-is, React will escape it\n          tagText = htmlNode.rawText\n        } else {\n          // Simple attribute formatting for filtered tags\n          let attrStr = ''\n          if (htmlNode.attrs) {\n            for (const [key, value] of Object.entries(htmlNode.attrs)) {\n              if (value === true) {\n                attrStr += ` ${key}`\n              } else if (\n                value !== undefined &&\n                value !== null &&\n                value !== false\n              ) {\n                attrStr += ` ${key}=\"${String(value)}\"`\n              }\n            }\n          }\n          tagText = `<${htmlNode.tag}${attrStr}>`\n        }\n        // Pass unescaped tag as text child - React will escape it automatically\n        return h('span', { key: state.key }, tagText)\n      }\n\n      if (htmlNode.rawText && htmlNode.verbatim) {\n        // For verbatim blocks, always use rawText for rendering (CommonMark compliance)\n        // Children are available for renderRule but default rendering uses rawText\n        const tagLower = (htmlNode.tag as string).toLowerCase()\n        const isType1Block = parse.isType1Block(tagLower)\n\n        const containsHTMLTags = /<[a-z][^>]{0,100}>/i.test(htmlNode.rawText)\n        const containsPreTags = /<\\/?pre\\b/i.test(htmlNode.rawText)\n\n        if (isType1Block && !containsHTMLTags) {\n          let textContent = htmlNode.rawText.replace(\n            new RegExp('\\\\s*</' + tagLower + '>\\\\s*$', 'i'),\n            ''\n          )\n          if (options.tagfilter) {\n            textContent = util.applyTagFilterToText(textContent)\n          }\n          return h(node.tag, { key: state.key, ...node.attrs }, textContent)\n        }\n\n        if (containsPreTags) {\n          const innerHtml = options.tagfilter\n            ? util.applyTagFilterToText(htmlNode.rawText)\n            : htmlNode.rawText\n          return h(node.tag, {\n            key: state.key,\n            ...node.attrs,\n            dangerouslySetInnerHTML: { __html: innerHtml },\n          })\n        }\n        // For other verbatim blocks, re-parse rawText for JSX compilation\n        // (children are available for renderRule but default uses rawText)\n        const parseOptions: parse.ParseOptions = {\n          slugify: (input: string) => slug(input, util.slugify),\n          sanitizer: sanitize,\n          tagfilter: true,\n        }\n        const cleanedText = htmlNode.rawText\n          .replace(/>\\s+</g, '><')\n          .replace(/\\n+/g, ' ')\n          .trim()\n\n        // Avoid infinite recursion: if cleanedText is just the same HTML tag we're processing,\n        // render as an empty element\n        const selfTagRegex = new RegExp(\n          `^<${htmlNode.tag}(\\\\s[^>]*)?>(\\\\s*</${htmlNode.tag}>)?$`,\n          'i'\n        )\n        if (selfTagRegex.test(cleanedText)) {\n          return h(node.tag, { key: state.key, ...node.attrs })\n        }\n\n        function processNode(\n          node: MarkdownToJSX.ASTNode\n        ): MarkdownToJSX.ASTNode[] {\n          if (\n            node.type === RuleType.htmlSelfClosing &&\n            'isClosingTag' in node &&\n            (\n              node as MarkdownToJSX.HTMLSelfClosingNode & {\n                isClosingTag?: boolean\n              }\n            ).isClosingTag\n          )\n            return []\n          if (node.type === RuleType.paragraph) {\n            const children = (node as MarkdownToJSX.ParagraphNode).children\n            return children ? children.flatMap(processNode) : []\n          }\n          if (node.type === RuleType.text) {\n            return (node as MarkdownToJSX.TextNode).text?.trim() ? [node] : []\n          }\n          if (\n            node.type === RuleType.htmlBlock &&\n            (node as MarkdownToJSX.HTMLNode).children\n          ) {\n            return [\n              {\n                ...node,\n                children: node.children?.flatMap(processNode),\n              } as MarkdownToJSX.HTMLNode,\n            ]\n          }\n          return [node]\n        }\n\n        const astNodes = parse.parseMarkdown(\n          cleanedText,\n          { inline: false, refs: refs, inHTML: false },\n          parseOptions\n        )\n\n        // Check if rawText represents the FULL outer block (starts with opening tag\n        // and ends with closing tag of the same element, with no content after)\n        // In this case, render the parsed nodes directly without adding another wrapper\n        const tagLowerCheck = (htmlNode.tag as string).toLowerCase()\n        const closingTag = '</' + tagLowerCheck + '>'\n        const startsWithOwnTag = new RegExp(\n          `^<${htmlNode.tag}(\\\\s|>)`,\n          'i'\n        ).test(cleanedText)\n        const endsWithClosingTag = cleanedText\n          .toLowerCase()\n          .trimEnd()\n          .endsWith(closingTag)\n        const isFullOuterBlock = startsWithOwnTag && endsWithClosingTag\n\n        const hasNoAttrs =\n          !htmlNode.attrs || Object.keys(htmlNode.attrs).length === 0\n        const hasChildren = htmlNode.children && htmlNode.children.length > 0\n\n        // Case 1: rawText contains full outer block AND no parsed attrs\n        // Skip wrapper and render the parsed nodes directly (attrs are in rawText)\n        if (isFullOuterBlock && hasNoAttrs) {\n          return output(astNodes.flatMap(processNode), state)\n        }\n\n        // Case 2: rawText contains full outer block AND we have parsed attrs (#781)\n        // Use children array instead of re-parsing rawText to avoid duplication\n        // The children contain the inner content without the outer tags\n        if (isFullOuterBlock && hasChildren) {\n          return h(\n            node.tag,\n            { key: state.key, ...node.attrs },\n            output(htmlNode.children, state)\n          )\n        }\n\n        return h(\n          node.tag,\n          { key: state.key, ...node.attrs },\n          output(astNodes.flatMap(processNode), state)\n        )\n      }\n      return h(\n        node.tag,\n        { key: state.key, ...node.attrs },\n        node.children ? output(node.children, state) : ''\n      )\n    }\n\n    case RuleType.htmlSelfClosing: {\n      const htmlNode = node as MarkdownToJSX.HTMLSelfClosingNode\n\n      // Apply options.tagfilter: escape dangerous self-closing tags\n      if (options.tagfilter && util.shouldFilterTag(htmlNode.tag)) {\n        let tagText: string\n        if ('rawText' in htmlNode && typeof htmlNode.rawText === 'string') {\n          // Use raw text as-is, React will escape it\n          tagText = htmlNode.rawText\n        } else {\n          // Simple attribute formatting for filtered self-closing tags\n          let attrStr = ''\n          if (htmlNode.attrs) {\n            for (const [key, value] of Object.entries(htmlNode.attrs)) {\n              if (value === true) {\n                attrStr += ` ${key}`\n              } else if (\n                value !== undefined &&\n                value !== null &&\n                value !== false\n              ) {\n                attrStr += ` ${key}=\"${String(value)}\"`\n              }\n            }\n          }\n          tagText = `<${htmlNode.tag}${attrStr} />`\n        }\n        // Pass unescaped tag as text child - React will escape it automatically\n        return h('span', { key: state.key }, tagText)\n      }\n\n      return h(node.tag, { key: state.key, ...node.attrs })\n    }\n\n    case RuleType.image: {\n      return (\n        <img\n          key={state.key}\n          alt={node.alt && node.alt.length > 0 ? node.alt : undefined}\n          title={node.title || undefined}\n          src={sanitize(node.target, 'img', 'src')}\n        />\n      )\n    }\n\n    case RuleType.link: {\n      const props: Record<string, unknown> = { key: state.key }\n      if (node.target != null) {\n        // Entity references are already decoded during parsing (per CommonMark spec)\n        // URL-encode backslashes and backticks (per CommonMark spec)\n        props.href = encodeUrlTarget(node.target)\n      }\n      if (node.title) {\n        // Entity references are already decoded during parsing (per CommonMark spec)\n        props.title = node.title\n      }\n      return h('a', props, output(node.children, state))\n    }\n\n    case RuleType.table: {\n      const table = node as MarkdownToJSX.TableNode\n      return (\n        <table key={state.key}>\n          <thead>\n            <tr>\n              {table.header.map(function generateHeaderCell(content, i) {\n                return (\n                  <th\n                    key={i}\n                    style={\n                      table.align[i] == null\n                        ? {}\n                        : { textAlign: table.align[i] }\n                    }\n                  >\n                    {output(content, state)}\n                  </th>\n                )\n              })}\n            </tr>\n          </thead>\n\n          <tbody>\n            {table.cells.map(function generateTableRow(row, i) {\n              return (\n                <tr key={i}>\n                  {row.map(function generateTableCell(content, c) {\n                    return (\n                      <td\n                        key={c}\n                        style={\n                          table.align[c] == null\n                            ? {}\n                            : { textAlign: table.align[c] }\n                        }\n                      >\n                        {output(content, state)}\n                      </td>\n                    )\n                  })}\n                </tr>\n              )\n            })}\n          </tbody>\n        </table>\n      )\n    }\n\n    case RuleType.text:\n      return node.text\n\n    case RuleType.textFormatted:\n      return h(\n        node.tag as MarkdownToJSX.HTMLTags,\n        { key: state.key },\n        output(node.children, state)\n      )\n\n    case RuleType.orderedList:\n    case RuleType.unorderedList: {\n      const Tag = node.type === RuleType.orderedList ? 'ol' : 'ul'\n\n      return (\n        <Tag\n          key={state.key}\n          start={node.type === RuleType.orderedList ? node.start : undefined}\n        >\n          {node.items.map(function generateListItem(item, i) {\n            return <li key={i}>{output(item, state)}</li>\n          })}\n        </Tag>\n      )\n    }\n\n    case RuleType.paragraph:\n      return <p key={state.key}>{output(node.children, state)}</p>\n\n    case RuleType.ref:\n      // Reference definitions should not be rendered (they're consumed during parsing)\n      return null\n\n    default:\n      return null\n  }\n}\n\nconst createRenderer = (\n  userRender: MarkdownToJSX.Options['renderRule'],\n  h: (\n    tag: string,\n    props: Parameters<MarkdownToJSX.CreateElement>[1] & {\n      className?: string\n      id?: string\n    },\n    ...children: any[]\n  ) => any,\n  sanitize: (value: string, tag: string, attribute: string) => string | null,\n  slug: (input: string, defaultFn: (input: string) => string) => string,\n  refs: { [key: string]: { target: string; title: string } },\n  options: MarkdownToJSX.Options\n) => {\n  const renderRule = (\n    node: MarkdownToJSX.ASTNode,\n    renderChildren: (children: MarkdownToJSX.ASTNode[]) => React.ReactNode,\n    state: MarkdownToJSX.State\n  ) => {\n    const defaultRender = () =>\n      render(node, renderChildren, state, h, sanitize, slug, refs, options)\n    return userRender\n      ? userRender(defaultRender, node, renderChildren, state)\n      : defaultRender()\n  }\n  const handleStackOverflow = (ast: MarkdownToJSX.ASTNode[]) =>\n    ast.map(node => ('text' in node ? node.text : ''))\n  const renderer = (\n    ast: MarkdownToJSX.ASTNode[],\n    state: MarkdownToJSX.State = {}\n  ) => {\n    const depth = (state.renderDepth || 0) + 1\n    if (depth > 2500) return handleStackOverflow(ast)\n    state.renderDepth = depth\n\n    const oldKey = state.key,\n      result: React.ReactNode[] = []\n    let lastWasString = false\n    for (let i = 0; i < ast.length; i++) {\n      state.key = i\n      const nodeOut = renderRule(ast[i], renderer, state),\n        isString = typeof nodeOut === 'string'\n      if (isString && lastWasString) {\n        // Concatenate consecutive strings\n        result[result.length - 1] += nodeOut\n      } else if (nodeOut !== null) {\n        if (Array.isArray(nodeOut)) {\n          // Use loop instead of spread for better performance\n          for (let j = 0; j < nodeOut.length; j++) {\n            result.push(nodeOut[j])\n          }\n        } else {\n          result.push(nodeOut)\n        }\n      }\n      lastWasString = isString\n    }\n    state.key = oldKey\n    state.renderDepth = depth - 1\n    return result\n  }\n  return renderer\n}\n\nconst cx = (...args) => args.filter(Boolean).join(' ')\n\nconst get = (source, path, fallback) => {\n  let result = source,\n    segments = path.split('.'),\n    i = 0\n  while (i < segments.length) {\n    result = result?.[segments[i]]\n    if (result === undefined) break\n    i++\n  }\n  return result || fallback\n}\n\nconst getTag = (tag, overrides) => {\n  const override = get(overrides, tag, undefined)\n  return !override\n    ? tag\n    : typeof override === 'function' ||\n        (typeof override === 'object' && 'render' in override)\n      ? override\n      : get(overrides, `${tag}.component`, tag)\n}\n\n/**\n * Convert AST nodes to React JSX elements\n * @lang zh  AST  React JSX \n * @lang hi AST   React JSX   \n *\n * @param ast - Array of AST nodes to render\n * @lang zh @param ast -  AST \n * @lang hi @param ast -     AST   \n * @param options - Compiler options\n * @lang zh @param options - \n * @lang hi @param options -  \n * @returns React JSX element(s)\n * @lang zh @returns React JSX \n * @lang hi @returns React JSX (s)\n */\nexport function astToJSX(\n  ast: MarkdownToJSX.ASTNode[],\n  options?: MarkdownToJSX.Options\n): React.ReactNode {\n  const opts = { ...(options || {}) }\n  opts.overrides = opts.overrides || {}\n\n  const slug = opts.slugify || util.slugify\n  const sanitize = opts.sanitizer || util.sanitizer\n  const createElement = opts.createElement || React.createElement\n\n  // Recursive compile function for HTML content\n  const compileHTML = (input: string) =>\n    compiler(input, { ...opts, wrapper: null })\n\n  // JSX custom pragma\n  // eslint-disable-next-line no-unused-vars\n  function h(\n    // locally we always will render a known string tag\n    tag: MarkdownToJSX.HTMLTags,\n    props: Parameters<MarkdownToJSX.CreateElement>[1] & {\n      className?: string\n      id?: string\n    },\n    ...children\n  ) {\n    const overrideProps = get(opts.overrides, `${tag}.props`, {})\n\n    // Convert HTML attributes to JSX props and compile any HTML content\n    const jsxProps = htmlAttrsToJSXProps(props || {})\n    if (compileHTML) {\n      for (const [key, value] of Object.entries(jsxProps)) {\n        if (\n          typeof value === 'string' &&\n          value.length > 0 &&\n          value[0] === '<' &&\n          (parse.HTML_BLOCK_ELEMENT_START_R_ATTR.test(value) ||\n            parse.UPPERCASE_TAG_R.test(value) ||\n            parse.parseHTMLTag(value, 0))\n        ) {\n          jsxProps[key] = compileHTML(value.trim())\n        }\n      }\n    }\n\n    return createElement(\n      getTag(tag, opts.overrides),\n      {\n        ...jsxProps,\n        ...overrideProps,\n        className:\n          cx(jsxProps?.className, overrideProps.className) || undefined,\n      },\n      ...children\n    )\n  }\n\n  // Post-process AST for JSX compatibility: combine HTML blocks with following paragraphs\n  // when the HTML block contains <pre> tags (to keep pre content as plain text)\n  const postProcessedAst: MarkdownToJSX.ASTNode[] = []\n  for (let i = 0; i < ast.length; i++) {\n    const node = ast[i]\n    if (\n      node.type === RuleType.htmlBlock &&\n      'rawText' in node &&\n      node.rawText &&\n      /<\\/?pre\\b/i.test(node.rawText) &&\n      i + 1 < ast.length &&\n      ast[i + 1].type === RuleType.paragraph &&\n      'removedClosingTags' in ast[i + 1] &&\n      (\n        ast[i + 1] as MarkdownToJSX.ParagraphNode & {\n          removedClosingTags?: MarkdownToJSX.ASTNode[]\n        }\n      ).removedClosingTags\n    ) {\n      const htmlNode = node as MarkdownToJSX.HTMLNode,\n        paragraphNode = ast[i + 1] as MarkdownToJSX.ParagraphNode & {\n          removedClosingTags?: MarkdownToJSX.ASTNode[]\n        }\n      function extractText(nodes: MarkdownToJSX.ASTNode[]): string {\n        let text = ''\n        for (const n of nodes) {\n          const type = n.type\n          if (type === RuleType.text) text += (n as MarkdownToJSX.TextNode).text\n          else if (\n            type === RuleType.htmlSelfClosing &&\n            'rawText' in n &&\n            (n as MarkdownToJSX.HTMLSelfClosingNode & { rawText?: string })\n              .rawText\n          )\n            text += (\n              n as MarkdownToJSX.HTMLSelfClosingNode & { rawText?: string }\n            ).rawText!\n          else if (type === RuleType.textFormatted) {\n            const formattedNode = n as MarkdownToJSX.FormattedTextNode\n            const marker =\n              formattedNode.tag === 'em'\n                ? '_'\n                : formattedNode.tag === 'strong'\n                  ? '**'\n                  : ''\n            text += marker + extractText(formattedNode.children) + marker\n          } else if ('children' in n && n.children)\n            text += extractText(n.children)\n        }\n        return text\n      }\n      let combinedText = extractText(paragraphNode.children)\n      if (paragraphNode.removedClosingTags) {\n        combinedText += paragraphNode.removedClosingTags\n          .filter(\n            (tag: MarkdownToJSX.ASTNode) =>\n              tag.type === RuleType.htmlSelfClosing &&\n              'rawText' in tag &&\n              (\n                tag as MarkdownToJSX.HTMLSelfClosingNode & {\n                  rawText?: string\n                }\n              ).rawText &&\n              (\n                tag as MarkdownToJSX.HTMLSelfClosingNode & {\n                  rawText?: string\n                }\n              ).rawText!.indexOf(`</${htmlNode.tag}>`) === -1\n          )\n          .map((tag: MarkdownToJSX.ASTNode) =>\n            tag.type === RuleType.htmlSelfClosing && 'rawText' in tag\n              ? (\n                  tag as MarkdownToJSX.HTMLSelfClosingNode & {\n                    rawText?: string\n                  }\n                ).rawText || ''\n              : ''\n          )\n          .join('')\n      }\n      htmlNode.rawText = (htmlNode.rawText || '') + '\\n' + combinedText\n      htmlNode.text = htmlNode.rawText // @deprecated - use rawText instead\n      i++ // Skip paragraph\n    }\n    postProcessedAst.push(node)\n  }\n  ast = postProcessedAst\n\n  const parseOptions: parse.ParseOptions = {\n    ...opts,\n    slugify: i => slug(i, util.slugify),\n    sanitizer: sanitize,\n    tagfilter: opts.tagfilter !== false,\n  }\n\n  const refs =\n    ast[0] && ast[0].type === RuleType.refCollection\n      ? (ast[0] as MarkdownToJSX.ReferenceCollectionNode).refs\n      : {}\n\n  const emitter = createRenderer(opts.renderRule, h, sanitize, slug, refs, opts)\n\n  const arr = emitter(ast, {\n    inline: opts.forceInline,\n    refs: refs,\n  }) as React.ReactNode[]\n\n  // Extract footnotes from refs (keys starting with '^')\n  const footnoteEntries: { identifier: string; footnote: string }[] = []\n  for (const key in refs) {\n    if (key.charCodeAt(0) === $.CHAR_CARET) {\n      footnoteEntries.push({ identifier: key, footnote: refs[key].target })\n    }\n  }\n\n  if (footnoteEntries.length) {\n    arr.push(\n      <footer key=\"footer\">\n        {footnoteEntries.map(function createFootnote(def) {\n          const identifierWithoutCaret =\n            def.identifier.charCodeAt(0) === $.CHAR_CARET\n              ? def.identifier.slice(1)\n              : def.identifier\n          const footnoteAstNodes = parse.parseMarkdown(\n            def.footnote,\n            { inline: true, refs: refs },\n            parseOptions\n          )\n          return h(\n            'div',\n            {\n              id: slug(identifierWithoutCaret, util.slugify),\n              key: def.identifier,\n            },\n            identifierWithoutCaret + ': ',\n            emitter(footnoteAstNodes, { inline: true, refs: refs })\n          )\n        })}\n      </footer>\n    )\n  }\n\n  if (opts.wrapper === null) {\n    return arr\n  }\n\n  const wrapper = opts.wrapper || (opts.forceInline ? 'span' : 'div')\n  let jsx: React.ReactNode\n\n  if (arr.length > 1 || opts.forceWrapper) {\n    jsx = arr\n  } else if (arr.length === 1) {\n    return arr[0]\n  } else {\n    return null\n  }\n\n  return createElement(\n    wrapper,\n    { key: 'outer', ...opts.wrapperProps },\n    jsx\n  ) as React.JSX.Element\n}\n\n/**\n * Compile markdown string to React JSX elements\n * @lang zh  Markdown  React JSX \n * @lang hi Markdown   React JSX    \n *\n * @param markdown - Markdown string to compile\n * @lang zh @param markdown -  Markdown \n * @lang hi @param markdown -     Markdown \n * @param options - Compiler options\n * @lang zh @param options - \n * @lang hi @param options -  \n * @returns React JSX element(s)\n * @lang zh @returns React JSX \n * @lang hi @returns React JSX (s)\n */\nexport function compiler(\n  markdown: string = '',\n  options: MarkdownToJSX.Options = {}\n): React.ReactNode {\n  const opts = { ...(options || {}) }\n  opts.overrides = opts.overrides || {}\n\n  const slug = opts.slugify || util.slugify\n  const sanitize = opts.sanitizer || util.sanitizer\n\n  function compile(input: string): React.ReactNode {\n    const inline =\n      opts.forceInline ||\n      (!opts.forceBlock && !util.SHOULD_RENDER_AS_BLOCK_R.test(input))\n    const parseOptions: parse.ParseOptions = {\n      ...opts,\n      slugify: i => slug(i, util.slugify),\n      sanitizer: sanitize,\n      tagfilter: opts.tagfilter !== false,\n    }\n\n    // First pass: collect all reference definitions\n    // This ensures refs are available during inline parsing, even when they appear after their usage\n    if (!inline) {\n      parse.collectReferenceDefinitions(input, refs, parseOptions)\n    }\n\n    // Inline trimEnd: trim trailing newlines and carriage returns\n    let processedInput = input\n    if (!inline) {\n      let e = processedInput.length\n      while (\n        e > 0 &&\n        (processedInput[e - 1] === '\\n' || processedInput[e - 1] === '\\r')\n      )\n        e--\n      processedInput = processedInput.slice(0, e)\n      processedInput = `${processedInput.replace(TRIM_STARTING_NEWLINES, '')}\\n\\n`\n    }\n\n    // In streaming mode, strip trailing incomplete HTML tags to prevent infinite recursion\n    if (opts.optimizeForStreaming) {\n      // Find last '<' that doesn't have a matching '>'\n      let lastLt = processedInput.lastIndexOf('<')\n      if (lastLt !== -1) {\n        let afterLt = processedInput.slice(lastLt)\n        // Check if there's a complete tag (has '>')\n        if (afterLt.indexOf('>') === -1) {\n          // Incomplete tag - truncate before it\n          processedInput = processedInput.slice(0, lastLt)\n        }\n      }\n    }\n\n    let astNodes = parse.parseMarkdown(\n      inline ? input : processedInput,\n      { inline: inline, refs: refs },\n      parseOptions\n    )\n\n    return astToJSX(astNodes, {\n      ...parseOptions,\n      forceInline: inline,\n    })\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof markdown !== 'string') {\n      throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`)\n    }\n\n    if (Object.prototype.toString.call(opts.overrides) !== '[object Object]') {\n      throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`)\n    }\n  }\n\n  const refs: { [key: string]: { target: string; title: string | undefined } } =\n    {}\n\n  const jsx = compile(markdown)\n\n  return jsx\n}\n\n/**\n * React context provider for sharing compiler options across Markdown components\n * @lang zh  Markdown  React \n * @lang hi Markdown          React  \n *\n * @param options - Default compiler options to share\n * @lang zh @param options - \n * @lang hi @param options -       \n * @param children - React children\n * @lang zh @param children - React \n * @lang hi @param children - React  \n */\nexport const MarkdownProvider: React.FC<{\n  options?: MarkdownToJSX.Options\n  children: React.ReactNode\n}> = ({ options, children }) => {\n  if (!MarkdownContext) {\n    return children as React.ReactElement\n  }\n  return React.createElement(\n    MarkdownContext.Provider,\n    { value: options },\n    children\n  )\n}\n\n/**\n * A React component for easy markdown rendering. Feed the markdown content as a direct child\n * and the rest is taken care of automatically. Supports memoization for optimal performance.\n * @lang zh  Markdown  React  Markdown \n * @lang hi  markdown     React  markdown                          \n *\n * @param children - Markdown string content\n * @lang zh @param children - Markdown \n * @lang hi @param children - Markdown  \n * @param options - Compiler options\n * @lang zh @param options - \n * @lang hi @param options -  \n * @param props - Additional HTML attributes for the wrapper element\n * @lang zh @param props -  HTML \n * @lang hi @param props -      HTML \n */\nexport const Markdown: React.FC<\n  Omit<React.HTMLAttributes<Element>, 'children'> & {\n    children?: string | null\n    options?: MarkdownToJSX.Options\n  }\n> = ({ children: rawChildren, options, ...props }) => {\n  const hasHooks = typeof React.useContext !== 'undefined'\n\n  // RSC path: direct execution\n  if (!hasHooks) {\n    const mergedOptions = {\n      ...options,\n      overrides: {\n        ...options?.overrides,\n      },\n      wrapperProps: {\n        ...options?.wrapperProps,\n        ...props,\n      } as React.JSX.IntrinsicAttributes,\n    }\n    const content =\n      rawChildren === null || rawChildren === undefined ? '' : rawChildren\n    return compiler(content, mergedOptions) as React.ReactElement\n  }\n\n  // Client path: existing hook-based implementation\n  const contextOptions = React.useContext(MarkdownContext!)\n  const mergedOptions = React.useMemo(\n    () => ({\n      ...contextOptions,\n      ...options,\n      overrides: {\n        ...contextOptions?.overrides,\n        ...options?.overrides,\n      },\n      wrapperProps: {\n        ...contextOptions?.wrapperProps,\n        ...options?.wrapperProps,\n        ...props,\n      } as React.JSX.IntrinsicAttributes,\n    }),\n    [contextOptions, options, props]\n  )\n\n  const content =\n    rawChildren === null || rawChildren === undefined ? '' : rawChildren\n\n  const jsx = React.useMemo(\n    () => compiler(content, mergedOptions),\n    [content, mergedOptions]\n  )\n\n  return jsx as React.ReactElement\n}\n\n// MarkdownToJSX namespace moved to types.ts\n\nexport default Markdown\n","// Character codes\nexport const CHAR_SPACE = 32\nexport const CHAR_TAB = 9\nexport const CHAR_CR = 13\nexport const CHAR_NEWLINE = 10\nexport const CHAR_BACKTICK = 96\nexport const CHAR_TILDE = 126\nexport const CHAR_BRACKET_OPEN = 91\nexport const CHAR_CARET = 94\nexport const CHAR_GT = 62\nexport const CHAR_HASH = 35\nexport const CHAR_PERCENT = 37\nexport const CHAR_DASH = 45\nexport const CHAR_EQ = 61\nexport const CHAR_BACKSLASH = 92\nexport const CHAR_ASTERISK = 42\nexport const CHAR_UNDERSCORE = 95\nexport const CHAR_LT = 60\nexport const CHAR_AT = 64\nexport const CHAR_BRACKET_CLOSE = 93\nexport const CHAR_EXCLAMATION = 33\nexport const CHAR_AMPERSAND = 38\nexport const CHAR_COLON = 58\nexport const CHAR_F = 70\nexport const CHAR_f = 102\nexport const CHAR_H = 104\nexport const CHAR_W = 119\nexport const CHAR_t = 116\nexport const CHAR_p = 112\nexport const CHAR_s = 115\nexport const CHAR_NBSP = 160\nexport const CHAR_FF = 12\nexport const CHAR_COMMA = 44\nexport const CHAR_SEMICOLON = 59\nexport const CHAR_QUESTION = 63\nexport const CHAR_PERIOD = 46\nexport const CHAR_SLASH = 47\nexport const CHAR_SINGLE_QUOTE = 39\nexport const CHAR_DOUBLE_QUOTE = 34\nexport const CHAR_PLUS = 43\nexport const CHAR_PIPE = 124\nexport const CHAR_BRACE_OPEN = 123 // {\nexport const CHAR_BRACE_CLOSE = 125 // }\nexport const CHAR_PAREN_OPEN = 40 // (\nexport const CHAR_PAREN_CLOSE = 41 // )\nexport const CHAR_x = 120\nexport const CHAR_X = 88\n// Character code ranges for common character classes\nexport const CHAR_DIGIT_0 = 48\nexport const CHAR_DIGIT_9 = 57\nexport const CHAR_A = 65\nexport const CHAR_Z = 90\nexport const CHAR_a = 97\nexport const CHAR_z = 122\nexport const CHAR_ASCII_BOUNDARY = 128\n// Case conversion offset: difference between uppercase and lowercase ASCII letters\nexport const CHAR_CASE_OFFSET = 32 // 'A' (65) to 'a' (97) = 32\n","// Re-export React for convenience since types reference it\nimport * as React from 'react'\n\n/**\n * Analogous to `node.type`. Please note that the values here may change at any time,\n * so do not hard code against the value directly.\n */\nconst RuleTypeConst = {\n  blockQuote: 0,\n  breakLine: 1,\n  breakThematic: 2,\n  codeBlock: 3,\n  codeInline: 4,\n  footnote: 5,\n  footnoteReference: 6,\n  frontmatter: 7,\n  gfmTask: 8,\n  heading: 9,\n  htmlBlock: 10,\n  htmlComment: 11,\n  htmlSelfClosing: 12,\n  image: 13,\n  link: 14,\n  orderedList: 15,\n  paragraph: 16,\n  ref: 17,\n  refCollection: 18,\n  table: 19,\n  text: 20,\n  textFormatted: 21,\n  unorderedList: 22,\n} as const\n\nif (process.env.NODE_ENV === 'test') {\n  // In test mode, use strings for better debugging\n  Object.keys(RuleTypeConst).forEach(key => (RuleTypeConst[key] = key))\n}\n\ntype RuleTypeValue = (typeof RuleTypeConst)[keyof typeof RuleTypeConst]\n\n/**\n * markdown-to-jsx types and interfaces\n * @lang zh markdown-to-jsx \n * @lang hi markdown-to-jsx   \n */\ndeclare namespace MarkdownToJSX {\n  /**\n   * RequireAtLeastOne<{ ... }> <- only requires at least one key\n   * @lang zh RequireAtLeastOne<{ ... }> <- \n   * @lang hi RequireAtLeastOne<{ ... }> <-         \n   */\n  type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n    T,\n    Exclude<keyof T, Keys>\n  > &\n    {\n      [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n  /**\n   * React.createElement function type\n   * @lang zh React.createElement \n   * @lang hi React.createElement  \n   */\n  export type CreateElement = typeof React.createElement\n\n  /**\n   * HTML tag names that can be used in JSX\n   * @lang zh  JSX  HTML \n   * @lang hi HTML    JSX      \n   */\n  export type HTMLTags = keyof React.JSX.IntrinsicElements & (string & {})\n\n  /**\n   * Parser and renderer state\n   * @lang zh \n   * @lang hi    \n   */\n  export type State = {\n    /** true if the current content is inside anchor link grammar */\n    /** @lang zh  true */\n    /** @lang hi true          */\n    inAnchor?: boolean\n    /** true if inside a blockquote */\n    /** @lang zh  true */\n    /** @lang hi true      */\n    inBlockQuote?: boolean\n    /** true if parsing in an HTML context */\n    /** @lang zh  HTML  true */\n    /** @lang hi true  HTML       */\n    inHTML?: boolean\n    /** true if in a list */\n    /** @lang zh  true */\n    /** @lang hi true     */\n    inList?: boolean\n    /** true if parsing in an inline context (subset of rules around formatting and links) */\n    /** @lang zh  true */\n    /** @lang hi true         (        ) */\n    inline?: boolean\n\n    /** use this for the `key` prop */\n    /** @lang zh  `key`  */\n    /** @lang hi `key` prop      */\n    key?: string | number\n    /** reference definitions (footnotes are stored with '^' prefix) */\n    /** @lang zh  '^'  */\n    /** @lang hi   ( '^'     ) */\n    refs?: { [key: string]: { target: string; title: string | undefined } }\n    /** current recursion depth during rendering */\n    /** @lang zh  */\n    /** @lang hi       */\n    renderDepth?: number\n  }\n\n  /**\n   * Blockquote node in the AST\n   * @lang zh AST \n   * @lang hi AST   \n   */\n  export interface BlockQuoteNode {\n    /** Optional alert type (Note, Tip, Warning, etc.) */\n    /** @lang zh  (Note, Tip, Warning ) */\n    /** @lang hi    (Note, Tip, Warning, ) */\n    alert?: string\n    /** Child nodes within the blockquote */\n    /** @lang zh  */\n    /** @lang hi      */\n    children: MarkdownToJSX.ASTNode[]\n    type: typeof RuleType.blockQuote\n  }\n\n  /**\n   * Hard line break node\n   * @lang zh \n   * @lang hi    \n   */\n  export interface BreakLineNode {\n    type: typeof RuleType.breakLine\n  }\n\n  /**\n   * Thematic break (horizontal rule) node\n   * @lang zh \n   * @lang hi   ( ) \n   */\n  export interface BreakThematicNode {\n    type: typeof RuleType.breakThematic\n  }\n\n  /**\n   * Code block node (fenced code blocks)\n   * @lang zh \n   * @lang hi    (  )\n   */\n  export interface CodeBlockNode {\n    type: typeof RuleType.codeBlock\n    /** HTML attributes for the code block */\n    /** @lang zh  HTML  */\n    /** @lang hi     HTML  */\n    attrs?: React.JSX.IntrinsicAttributes\n    /** Programming language identifier */\n    /** @lang zh  */\n    /** @lang hi    */\n    lang?: string\n    /** Code content */\n    /** @lang zh  */\n    /** @lang hi   */\n    text: string\n  }\n\n  /**\n   * Inline code node\n   * @lang zh \n   * @lang hi   \n   */\n  export interface CodeInlineNode {\n    type: typeof RuleType.codeInline\n    /** Code text */\n    /** @lang zh  */\n    /** @lang hi   */\n    text: string\n  }\n\n  /**\n   * Footnote definition node (not rendered, stored in refCollection)\n   * @lang zh  refCollection \n   * @lang hi    (   , refCollection  )\n   */\n  export interface FootnoteNode {\n    type: typeof RuleType.footnote\n  }\n\n  /**\n   * Footnote reference node\n   * @lang zh \n   * @lang hi   \n   */\n  export interface FootnoteReferenceNode {\n    type: typeof RuleType.footnoteReference\n    /** Link target (anchor) */\n    /** @lang zh  */\n    /** @lang hi   () */\n    target: string\n    /** Display text */\n    /** @lang zh  */\n    /** @lang hi   */\n    text: string\n  }\n\n  /**\n   * YAML frontmatter node\n   * @lang zh YAML \n   * @lang hi YAML  \n   */\n  export interface FrontmatterNode {\n    type: typeof RuleType.frontmatter\n    /** Frontmatter content */\n    /** @lang zh  */\n    /** @lang hi   */\n    text: string\n  }\n\n  /**\n   * GFM task list item node\n   * @lang zh GFM \n   * @lang hi GFM    \n   */\n  export interface GFMTaskNode {\n    type: typeof RuleType.gfmTask\n    /** Whether the task is completed */\n    /** @lang zh  */\n    /** @lang hi     */\n    completed: boolean\n  }\n\n  /**\n   * Heading node\n   * @lang zh \n   * @lang hi  \n   */\n  export interface HeadingNode {\n    type: typeof RuleType.heading\n    /** Child nodes (text content) */\n    /** @lang zh  */\n    /** @lang hi   ( ) */\n    children: MarkdownToJSX.ASTNode[]\n    /** Generated HTML ID for anchor linking */\n    /** @lang zh  HTML ID */\n    /** @lang hi        HTML ID */\n    id: string\n    /** Heading level (1-6) */\n    /** @lang zh  (1-6) */\n    /** @lang hi   (1-6) */\n    level: 1 | 2 | 3 | 4 | 5 | 6\n  }\n\n  /**\n   * HTML comment node\n   * @lang zh HTML \n   * @lang hi HTML  \n   */\n  export interface HTMLCommentNode {\n    type: typeof RuleType.htmlComment\n    /** Comment text */\n    /** @lang zh  */\n    /** @lang hi   */\n    text: string\n  }\n\n  /**\n   * Image node\n   * @lang zh \n   * @lang hi  \n   */\n  export interface ImageNode {\n    type: typeof RuleType.image\n    /** Alt text */\n    /** @lang zh  */\n    /** @lang hi Alt  */\n    alt?: string\n    /** Image URL */\n    /** @lang zh  URL */\n    /** @lang hi  URL */\n    target: string\n    /** Title attribute */\n    /** @lang zh  */\n    /** @lang hi   */\n    title?: string\n  }\n\n  /**\n   * Link node\n   * @lang zh \n   * @lang hi  \n   */\n  export interface LinkNode {\n    type: typeof RuleType.link\n    /** Child nodes (link text) */\n    /** @lang zh  */\n    /** @lang hi   ( ) */\n    children: MarkdownToJSX.ASTNode[]\n    /** Link URL (null for reference links without definition) */\n    /** @lang zh  URL null */\n    /** @lang hi  URL (       null) */\n    target: string | null\n    /** Title attribute */\n    /** @lang zh  */\n    /** @lang hi   */\n    title?: string\n  }\n\n  /**\n   * Ordered list node\n   * @lang zh \n   * @lang hi   \n   */\n  export interface OrderedListNode {\n    type: typeof RuleType.orderedList\n    /** Array of list items, each item is an array of nodes */\n    /** @lang zh  */\n    /** @lang hi    ,        */\n    items: MarkdownToJSX.ASTNode[][]\n    /** Starting number for the list */\n    /** @lang zh  */\n    /** @lang hi      */\n    start?: number\n  }\n\n  /**\n   * Unordered list node\n   * @lang zh \n   * @lang hi   \n   */\n  export interface UnorderedListNode {\n    type: typeof RuleType.unorderedList\n    /** Array of list items, each item is an array of nodes */\n    /** @lang zh  */\n    /** @lang hi    ,        */\n    items: MarkdownToJSX.ASTNode[][]\n  }\n\n  /**\n   * Paragraph node\n   * @lang zh \n   * @lang hi  \n   */\n  export interface ParagraphNode {\n    type: typeof RuleType.paragraph\n    /** Child nodes */\n    /** @lang zh  */\n    /** @lang hi   */\n    children: MarkdownToJSX.ASTNode[]\n  }\n\n  /**\n   * Reference definition node (not rendered, stored in refCollection)\n   * @lang zh  refCollection \n   * @lang hi    (   , refCollection  )\n   */\n  export interface ReferenceNode {\n    type: typeof RuleType.ref\n  }\n\n  /**\n   * Reference collection node (appears at AST root, includes footnotes with '^' prefix)\n   * @lang zh  AST  '^' \n   * @lang hi    (AST     , '^'      )\n   */\n  export interface ReferenceCollectionNode {\n    type: typeof RuleType.refCollection\n    /** Map of reference labels to their definitions */\n    /** @lang zh  */\n    /** @lang hi        */\n    refs: { [key: string]: { target: string; title: string | undefined } }\n  }\n\n  /**\n   * Table node\n   * @lang zh \n   * @lang hi  \n   */\n  export interface TableNode {\n    type: typeof RuleType.table\n    /**\n     * alignment for each table column\n     * @lang zh \n     * @lang hi      \n     */\n    align: ('left' | 'right' | 'center')[]\n    /** Table cells (3D array: rows -> cells -> nodes) */\n    /** @lang zh  ->  ->  */\n    /** @lang hi   (3D :  ->  -> ) */\n    cells: MarkdownToJSX.ASTNode[][][]\n    /** Table header row */\n    /** @lang zh  */\n    /** @lang hi    */\n    header: MarkdownToJSX.ASTNode[][]\n  }\n\n  /**\n   * Plain text node\n   * @lang zh \n   * @lang hi   \n   */\n  export interface TextNode {\n    type: typeof RuleType.text\n    /** Text content */\n    /** @lang zh  */\n    /** @lang hi   */\n    text: string\n  }\n\n  /**\n   * Formatted text node (bold, italic, etc.)\n   * @lang zh \n   * @lang hi      (, , )\n   */\n  export interface FormattedTextNode {\n    type: typeof RuleType.textFormatted\n    /**\n     * the corresponding html tag\n     * @lang zh  HTML \n     * @lang hi  HTML \n     */\n    tag: string\n    /** Child nodes */\n    /** @lang zh  */\n    /** @lang hi   */\n    children: MarkdownToJSX.ASTNode[]\n  }\n\n  /**\n   * HTML block node (includes JSX components)\n   * @lang zh HTML  JSX \n   * @lang hi HTML   (JSX   )\n   */\n  export interface HTMLNode {\n    type: typeof RuleType.htmlBlock\n    /** Parsed HTML attributes */\n    /** @lang zh  HTML  */\n    /** @lang hi    HTML  */\n    attrs?: Record<string, any>\n    /** Parsed child nodes (always parsed, even for verbatim blocks) */\n    /** @lang zh  */\n    /** @lang hi      (    ,    verbatim    ) */\n    children?: ASTNode[] | undefined\n    /** Whether this is a verbatim block (script, style, pre, etc.) */\n    /** @lang zh scriptstylepre  */\n    /** @lang hi    verbatim   (script, style, pre, ) */\n    verbatim?: boolean\n    /** Original raw attribute string */\n    /** @lang zh  */\n    /** @lang hi  raw   */\n    rawAttrs?: string\n    /** Original raw HTML content (for verbatim blocks) */\n    /** @lang zh  HTML  */\n    /** @lang hi  raw HTML  (verbatim   ) */\n    rawText?: string | undefined\n    /** @deprecated Use `rawText` instead. This property will be removed in a future major version. */\n    /** @lang zh @deprecated  `rawText`  */\n    /** @lang hi @deprecated    `rawText`              */\n    text?: string | undefined\n    /** HTML tag name */\n    /** @lang zh HTML  */\n    /** @lang hi HTML   */\n    tag: string\n  }\n\n  /**\n   * Self-closing HTML tag node\n   * @lang zh  HTML \n   * @lang hi -   HTML  \n   */\n  export interface HTMLSelfClosingNode {\n    type: typeof RuleType.htmlSelfClosing\n    /** Parsed HTML attributes */\n    /** @lang zh  HTML  */\n    /** @lang hi    HTML  */\n    attrs?: Record<string, any>\n    /** Whether this is a closing tag */\n    /** @lang zh  */\n    /** @lang hi         */\n    isClosingTag?: boolean\n    /** HTML tag name */\n    /** @lang zh HTML  */\n    /** @lang hi HTML   */\n    tag: string\n    /** Original raw HTML content */\n    /** @lang zh  HTML  */\n    /** @lang hi  raw HTML  */\n    rawText?: string\n  }\n\n  /**\n   * Union type of all possible AST node types\n   * @lang zh  AST \n   * @lang hi   AST     \n   */\n  export type ASTNode =\n    | BlockQuoteNode\n    | BreakLineNode\n    | BreakThematicNode\n    | CodeBlockNode\n    | CodeInlineNode\n    | FootnoteNode\n    | FootnoteReferenceNode\n    | FrontmatterNode\n    | GFMTaskNode\n    | HeadingNode\n    | HTMLCommentNode\n    | ImageNode\n    | LinkNode\n    | OrderedListNode\n    | UnorderedListNode\n    | ParagraphNode\n    | ReferenceNode\n    | ReferenceCollectionNode\n    | TableNode\n    | TextNode\n    | FormattedTextNode\n    | HTMLNode\n    | HTMLSelfClosingNode\n\n  /**\n   * Function type for rendering AST nodes\n   * @lang zh  AST \n   * @lang hi AST        \n   */\n  export type ASTRender = (\n    ast: MarkdownToJSX.ASTNode | MarkdownToJSX.ASTNode[],\n    state: MarkdownToJSX.State\n  ) => React.ReactNode\n\n  /**\n   * Override configuration for HTML tags or custom components\n   * @lang zh HTML \n   * @lang hi HTML        \n   */\n  export type Override =\n    | RequireAtLeastOne<{\n        component: React.ElementType\n        props: Object\n      }>\n    | React.ElementType\n\n  /**\n   * Map of HTML tags and custom components to their override configurations\n   * @lang zh HTML \n   * @lang hi HTML          \n   */\n  export type Overrides = {\n    [tag in HTMLTags]?: Override\n  } & {\n    [customComponent: string]: Override\n  }\n\n  /**\n   * Compiler options\n   * @lang zh \n   * @lang hi  \n   */\n  export type Options = Partial<{\n    /**\n     * Ultimate control over the output of all rendered JSX.\n     * @lang zh  JSX \n     * @lang hi     JSX    \n     */\n    createElement: (\n      tag: Parameters<CreateElement>[0],\n      props: React.JSX.IntrinsicAttributes,\n      ...children: React.ReactNode[]\n    ) => React.ReactNode\n\n    /**\n     * The library automatically generates an anchor tag for bare URLs included in the markdown\n     * document, but this behavior can be disabled if desired.\n     * @lang zh  Markdown  URL \n     * @lang hi  markdown     URLs           ,             \n     */\n    disableAutoLink: boolean\n\n    /**\n     * Disable the compiler's best-effort transcription of provided raw HTML\n     * into JSX-equivalent. This is the functionality that prevents the need to\n     * use `dangerouslySetInnerHTML` in React.\n     * @lang zh  HTML  JSX  React  `dangerouslySetInnerHTML`\n     * @lang hi      raw HTML  JSX-               React  `dangerouslySetInnerHTML`        \n     */\n    disableParsingRawHTML: boolean\n\n    /**\n     * Enable GFM tagfilter extension to filter potentially dangerous HTML tags.\n     * When enabled, the following tags are escaped: title, textarea, style, xmp,\n     * iframe, noembed, noframes, script, plaintext.\n     * https://github.github.com/gfm/#disallowed-raw-html-extension-\n     * @lang zh  GFM tagfilter  HTML titletextareastylexmpiframenoembednoframesscriptplaintext\n     * @lang hi   HTML       GFM tagfilter      ,      : title, textarea, style, xmp, iframe, noembed, noframes, script, plaintext\n     * @default true\n     */\n    tagfilter?: boolean\n\n    /**\n     * Forces the compiler to have space between hash sign and the header text which\n     * is explicitly stated in the most of the markdown specs.\n     * https://github.github.com/gfm/#atx-heading\n     * `The opening sequence of # characters must be followed by a space or by the end of line.`\n     * @lang zh  Markdown \n     * @lang hi                ,   markdown        \n     */\n    enforceAtxHeadings: boolean\n\n    /**\n     * ** SECURITY WARNING: STRONGLY DISCOURAGED FOR USER INPUTS**\n     *\n     * When enabled, attempts to eval expressions in JSX props that cannot be serialized\n     * as JSON (functions, variables, complex expressions). This uses `eval()` which can\n     * execute arbitrary code.\n     *\n     * **ONLY use this option when:**\n     * - The markdown source is completely trusted (e.g., your own documentation)\n     * - You control all JSX components and their props\n     * - The content is NOT user-generated or user-editable\n     *\n     * **DO NOT use this option when:**\n     * - Processing user-submitted markdown\n     * - Rendering untrusted content\n     * - Building public-facing applications with user content\n     *\n     * Example unsafe input: `<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     * When disabled (default), unserializable expressions remain as strings that can be\n     * safely inspected or handled on a case-by-case basis via custom renderRule logic.\n     *\n     * @lang zh ** **\n     *\n     *  JSX  JSON  `eval()`\n     *\n     * ****\n     * - Markdown \n     * -  JSX \n     * - \n     *\n     * ****\n     * -  Markdown\n     * - \n     * - \n     *\n     * `<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     *  renderRule \n     *\n     * @lang hi **  :      **\n     *\n     *   , JSX props  expressions  eval       JSON          (, ,  expressions)  `eval()`            \n     *\n     * **        :**\n     * - Markdown       (  ,   )\n     * -   JSX    props    \n     * -  -  -   \n     *\n     * **        :**\n     * - -   markdown     \n     * -      \n     * -    -      \n     *\n     *   : `<Component onClick={() => fetch('/admin/delete-all')} />`\n     *\n     *    (),  expressions         renderRule             --     \n     *\n     * @default false\n     */\n    evalUnserializableExpressions?: boolean\n\n    /**\n     * Forces the compiler to always output content with a block-level wrapper\n     * (`<p>` or any block-level syntax your markdown already contains.)\n     * @lang zh `<p>`  Markdown \n     * @lang hi    -            (`<p>`   markdown       - )\n     */\n    forceBlock: boolean\n\n    /**\n     * Forces the compiler to always output content with an inline wrapper (`<span>`)\n     * @lang zh `<span>`\n     * @lang hi      (`<span>`)          \n     */\n    forceInline: boolean\n\n    /**\n     * Forces the compiler to wrap results, even if there is only a single\n     * child or no children.\n     * @lang zh \n     * @lang hi           ,           \n     */\n    forceWrapper: boolean\n\n    /**\n     * Selectively control the output of particular HTML tags as they would be\n     * emitted by the compiler.\n     * @lang zh  HTML \n     * @lang hi     HTML             \n     */\n    overrides: Overrides\n\n    /**\n     * Allows for full control over rendering of particular rules.\n     * For example, to implement a LaTeX renderer such as `react-katex`:\n     *\n     * ```\n     * renderRule(next, node, renderChildren, state) {\n     *   if (node.type === RuleType.codeBlock && node.lang === 'latex') {\n     *     return (\n     *       <TeX as=\"div\" key={state.key}>\n     *         {String.raw`${node.text}`}\n     *       </TeX>\n     *     )\n     *   }\n     *\n     *   return next();\n     * }\n     * ```\n     *\n     * Thar be dragons obviously, but you can do a lot with this\n     * (have fun!) To see how things work internally, check the `render`\n     * method in source for a particular rule.\n     * @lang zh  `react-katex`  LaTeX \n     *\n     *  `render` \n     * @lang hi              , `react-katex`  LaTeX      :\n     *\n     *     ,          ( !)            ,        `render`  \n     */\n    renderRule: (\n      /** Resume normal processing, call this function as a fallback if you are not returning custom JSX. */\n      /** @lang zh  JSX */\n      /** @lang hi      ,    JSX                */\n      next: () => React.ReactNode,\n      /** the current AST node, use `RuleType` against `node.type` for identification */\n      /** @lang zh  AST  `RuleType`  `node.type`  */\n      /** @lang hi  AST ,    `node.type`   `RuleType`    */\n      node: ASTNode,\n      /** use as `renderChildren(node.children)` for block nodes */\n      /** @lang zh  `renderChildren(node.children)` */\n      /** @lang hi     `renderChildren(node.children)`      */\n      renderChildren: ASTRender,\n      /** contains `key` which should be supplied to the topmost JSX element */\n      /** @lang zh  JSX  `key` */\n      /** @lang hi `key`      JSX       */\n      state: State\n    ) => React.ReactNode\n\n    /**\n     * Override the built-in sanitizer function for URLs, etc if desired. The built-in version is available as a library\n     export called `sanitizer`.\n     * @lang zh  URL  `sanitizer` \n     * @lang hi     URLs    -      -  `sanitizer`   export     \n     */\n    sanitizer: (value: string, tag: string, attribute: string) => string | null\n\n    /**\n     * Override normalization of non-URI-safe characters for use in generating\n     * HTML IDs for anchor linking purposes.\n     * @lang zh  URI  HTML ID\n     * @lang hi      HTML IDs       -URI-      \n     */\n    slugify: (input: string, defaultFn: (input: string) => string) => string\n\n    /**\n     * Declare the type of the wrapper to be used when there are multiple\n     * children to render. Set to `null` to get an array of children back\n     * without any wrapper, or use `React.Fragment` to get a React element\n     * that won't show up in the DOM.\n     * @lang zh  `null`  `React.Fragment`  DOM  React \n     * @lang hi         children         children        `null`   ,  DOM      React      `React.Fragment`   \n     */\n    wrapper: React.ElementType | null\n\n    /**\n     * Props to apply to the wrapper element.\n     * @lang zh \n     * @lang hi        props\n     */\n    wrapperProps?: React.JSX.IntrinsicAttributes\n\n    /**\n     * Preserve frontmatter in the output by rendering it as a <pre> element.\n     * By default, frontmatter is parsed but not rendered.\n     * @lang zh  <pre> \n     * @lang hi  <pre>               ,            \n     * @default false\n     */\n    preserveFrontmatter?: boolean\n\n    /**\n     * Optimize rendering for streaming scenarios where markdown content arrives\n     * incrementally (e.g., from LLM APIs). When enabled, incomplete inline syntax\n     * is suppressed to avoid displaying raw markdown characters while waiting\n     * for the closing delimiter to arrive.\n     *\n     * Fenced code blocks render normally with content visible as it streams.\n     *\n     * @lang zh  Markdown  LLM API Markdown \n     *\n     * \n     *\n     * @lang hi           markdown       (, LLM API )   ,                   markdown    \n     *\n     *                 \n     *\n     * @default false\n     *\n     * @example\n     * ```tsx\n     * // Streaming markdown example\n     * function StreamingMarkdown({ content }) {\n     *   return (\n     *     <Markdown options={{ optimizeForStreaming: true }}>\n     *       {content}\n     *     </Markdown>\n     *   )\n     * }\n     * ```\n     */\n    optimizeForStreaming?: boolean\n  }>\n}\n\nexport const RuleType: typeof RuleTypeConst = RuleTypeConst\nexport type RuleType = RuleTypeValue\n\nexport type RequireAtLeastOne<\n  T,\n  Keys extends keyof T = keyof T,\n> = MarkdownToJSX.RequireAtLeastOne<T, Keys>\n\nexport { MarkdownToJSX }\n","import { NAMED_CODES_TO_UNICODE as util, decodeEntity } from '#entities'\nimport * as $ from './constants'\n\n/**\n * Parse frontmatter bounds and validate YAML\n *\n * @param input - Input string to parse\n * @returns Object with end position and YAML validity, or null if no frontmatter\n */\nexport function parseFrontmatterBounds(\n  input: string\n): { endPos: number; hasValidYaml: boolean } | null {\n  if (!startsWith(input, '---')) return null\n  let pos = 3\n  while (pos < input.length && (input[pos] === ' ' || input[pos] === '\\t'))\n    pos++\n  // Handle both LF and CRLF line endings\n  if (pos < input.length && input[pos] === '\\r') pos++\n  if (pos >= input.length || input[pos] !== '\\n') return null\n  pos++\n\n  let hasValidYaml = false\n  while (pos < input.length) {\n    const lineStart = pos\n    // Find line end, handling CRLF\n    while (pos < input.length && input[pos] !== '\\n' && input[pos] !== '\\r')\n      pos++\n    if (pos >= input.length) break\n    const lineEnd = pos\n    // Skip CR if present\n    if (input[pos] === '\\r') pos++\n    // Skip LF\n    if (pos < input.length && input[pos] === '\\n') pos++\n    if (startsWith(input, '---', lineStart))\n      return { endPos: pos, hasValidYaml }\n    // Check if line contains ':' anywhere\n    // OPTIMIZATION: Use indexOf directly to avoid slice allocation\n    const colonIndex = input.indexOf(':', lineStart)\n    if (colonIndex !== -1 && colonIndex < lineEnd) hasValidYaml = true\n  }\n  return null\n}\n\n/**\n * Named HTML entity codes to unicode character mapping\n * Pre-computed from generated entity set\n * Numeric references (&#123; and &#xAB;) are fully supported without any mapping.\n * Unknown named entities pass through as literal text (CommonMark-compliant).\n * @lang zh  HTML  Unicode \n * \n * &#123;  &#xAB;\n *  CommonMark\n * @lang hi  HTML    Unicode   \n *       -  \n *   (&#123;  &#xAB;)         \n *            (CommonMark-)\n */\nexport const NAMED_CODES_TO_UNICODE: Record<string, string> = util\n\n/**\n * Regex for matching HTML character references (&entity; or &#123; or &#xAB;)\n * Matches: & followed by entity name or # followed by decimal or hex digits, ending with ;\n * @lang zh  HTML &entity;  &#123;  &#xAB;\n * &  #  ; \n * @lang hi HTML         (&entity;  &#123;  &#xAB;)\n * : &      #      , ;     \n */\nexport const HTML_CHAR_CODE_R: RegExp =\n  /&([a-zA-Z0-9]+|#[0-9]{1,7}|#x[0-9a-fA-F]{1,6});/gi\n\n/**\n * Regex for determining if markdown content should be rendered as block-level\n * Matches: newlines, list items, headings, indented content, thematic breaks, blockquotes\n * @lang zh  Markdown \n * \n * @lang hi        markdown   -       \n * :  ,  , ,  ,  , \n */\n// Mapping of lowercase HTML attributes to JSX prop names\n// Shared between React and Solid renderers (Vue uses HTML attributes directly)\nexport const HTML_TO_JSX_MAP: Record<string, string> = {\n  class: 'className',\n  for: 'htmlFor',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  autocomplete: 'autoComplete',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  charset: 'charSet',\n  classid: 'classId',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  crossorigin: 'crossOrigin',\n  enctype: 'encType',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formmethod: 'formMethod',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  hreflang: 'hrefLang',\n  inputmode: 'inputMode',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  marginheight: 'marginHeight',\n  marginwidth: 'marginWidth',\n  maxlength: 'maxLength',\n  mediagroup: 'mediaGroup',\n  minlength: 'minLength',\n  novalidate: 'noValidate',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  spellcheck: 'spellCheck',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  tabindex: 'tabIndex',\n  usemap: 'useMap',\n}\n\n/**\n * Convert HTML attributes to JSX props\n * Maps HTML attribute names (e.g., \"class\", \"for\") to JSX prop names (e.g., \"className\", \"htmlFor\")\n *\n * @param attrs - HTML attributes object\n * @returns JSX props object\n */\nexport function htmlAttrsToJSXProps(\n  attrs: Record<string, any>\n): Record<string, any> {\n  var jsxProps: Record<string, any> = {}\n\n  for (var key in attrs) {\n    var keyLower = key.toLowerCase()\n    var mappedKey = HTML_TO_JSX_MAP[keyLower]\n    jsxProps[mappedKey || key] = attrs[key]\n  }\n\n  return jsxProps\n}\n\nexport const SHOULD_RENDER_AS_BLOCK_R: RegExp =\n  /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/\n\n/**\n * Decode HTML entity references to Unicode characters\n *\n * @param text - The text containing HTML entities\n * @returns The decoded text\n */\nexport function decodeEntityReferences(text: string): string {\n  if (text.indexOf('&') === -1) return text\n\n  return text.replace(HTML_CHAR_CODE_R, (full, inner) => {\n    // Named entity lookup via swappable decoder\n    // In browser builds, this uses DOM; in Node, uses lookup table\n    var entity = decodeEntity(inner)\n    if (entity) return entity\n\n    // Numeric entities (always computed, no lookup needed)\n    if (inner[0] === '#') {\n      var code =\n        inner[1] === 'x' || inner[1] === 'X'\n          ? parseInt(inner.slice(2), 16)\n          : parseInt(inner.slice(1), 10)\n\n      if (code === 0 || (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff) {\n        return '\\uFFFD'\n      }\n      return code <= 0xffff\n        ? String.fromCharCode(code)\n        : String.fromCharCode(\n            0xd800 + ((code - 0x10000) >> 10),\n            0xdc00 + ((code - 0x10000) & 0x3ff)\n          )\n    }\n\n    return full\n  })\n}\n\nexport const SANITIZE_R: RegExp = /(javascript|vbscript|data(?!:image)):/i\n\n/**\n * Sanitize URLs and other input values to prevent XSS attacks.\n * Filters out javascript:, vbscript:, and data: URLs (except data:image).\n *\n * @lang zh  URL  XSS  javascript:vbscript:  data: URLdata:image \n * @lang hi XSS      URLs         javascript:, vbscript:,  data: URLs     (data:image  )\n *\n * @param input - The URL or value to sanitize\n * @lang zh @param input -  URL \n * @lang hi @param input -     URL  \n * @returns Sanitized value, or null if unsafe\n * @lang zh @returns  null\n * @lang hi @returns    ,     null\n */\nexport function sanitizer(input: string): string | null {\n  if (SANITIZE_R.test(input)) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Input contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n        input\n      )\n    }\n    return null\n  }\n\n  if (input.indexOf('%') === -1) return input\n\n  try {\n    const decoded = decodeURIComponent(input).replace(/[^A-Za-z0-9/:]/g, '')\n    if (SANITIZE_R.test(decoded)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'Input contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n          decoded\n        )\n      }\n      return null\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Input could not be decoded due to malformed syntax or characters, it will not be rendered.',\n        input\n      )\n    }\n    return null\n  }\n\n  return input\n}\n\n// Character replacement lookup table for slugify (Unicode to ASCII)\nvar slugifyReplaceTable: Record<number, string> = {}\nvar codes: number[], i: number\ncodes = [192, 193, 194, 195, 196, 197, 224, 225, 226, 227, 228, 229, 230, 198]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'a'\nslugifyReplaceTable[231] = slugifyReplaceTable[199] = 'c'\nslugifyReplaceTable[240] = slugifyReplaceTable[208] = 'd'\ncodes = [200, 201, 202, 203, 233, 232, 234, 235]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'e'\ncodes = [207, 239, 206, 238, 205, 237, 204, 236]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'i'\nslugifyReplaceTable[209] = slugifyReplaceTable[241] = 'n'\ncodes = [248, 216, 339, 338, 213, 245, 212, 244, 211, 243, 210, 242]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'o'\ncodes = [220, 252, 219, 251, 218, 250, 217, 249]\nfor (i = 0; i < codes.length; i++) slugifyReplaceTable[codes[i]] = 'u'\nslugifyReplaceTable[376] =\n  slugifyReplaceTable[255] =\n  slugifyReplaceTable[221] =\n  slugifyReplaceTable[253] =\n    'y'\n\n/**\n * Check if a character code is alphanumeric (0-9, A-Z, a-z)\n *\n * @param code - Character code to check\n * @returns True if alphanumeric\n */\nexport function isAlnumCode(code: number): boolean {\n  return (\n    (code >= $.CHAR_DIGIT_0 && code <= $.CHAR_DIGIT_9) ||\n    (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n    (code >= $.CHAR_a && code <= $.CHAR_z)\n  )\n}\n\n/**\n * Convert a string to a URL-safe slug by normalizing characters and replacing spaces with hyphens.\n * Based on https://stackoverflow.com/a/18123682/1141611\n * Not complete, but probably good enough.\n *\n * @lang zh  URL \n * @lang hi              URL- slug      ,    \n *\n * @param str - String to slugify\n * @lang zh @param str - \n * @lang hi @param str - slugify    \n * @returns URL-safe slug\n * @lang zh @returns URL \n * @lang hi @returns URL- slug\n */\nexport function slugify(str: string): string {\n  var parts: string[] = []\n  for (var i = 0; i < str.length; i++) {\n    var code = str.charCodeAt(i)\n    if (isAlnumCode(code)) {\n      if (code >= $.CHAR_A && code <= $.CHAR_Z) {\n        parts.push(String.fromCharCode(code + $.CHAR_CASE_OFFSET))\n      } else {\n        parts.push(str[i])\n      }\n    } else if (code === $.CHAR_SPACE || code === $.CHAR_DASH) {\n      parts.push('-')\n    } else {\n      var replacement = slugifyReplaceTable[code]\n      if (replacement) parts.push(replacement)\n    }\n  }\n  return parts.join('')\n}\n\n/**\n * Check if a string includes a substring\n *\n * @param str - String to search in\n * @param search - Substring to search for\n * @returns True if substring is found\n */\nexport function includes(str: string, search: string): boolean {\n  return str.indexOf(search) !== -1\n}\n\n/**\n * Check if a string starts with a prefix\n *\n * @param str - String to check\n * @param prefix - Prefix to check for\n * @param pos - Optional starting position\n * @returns True if string starts with prefix\n */\nexport function startsWith(str: string, prefix: string, pos?: number): boolean {\n  return str.startsWith(prefix, pos)\n}\n\n/**\n * Check if a string ends with a suffix\n *\n * @param str - String to check\n * @param suffix - Suffix to check for\n * @param pos - Optional ending position\n * @returns True if string ends with suffix\n */\nexport function endsWith(str: string, suffix: string, pos?: number): boolean {\n  return str.startsWith(\n    suffix,\n    (pos === undefined ? str.length : pos) - suffix.length\n  )\n}\n\n// Known void elements (HTML5 and SVG) that don't require closing tag or />\n// Use Set for O(1) lookups instead of O(n) array.includes()\nexport const VOID_ELEMENTS: Set<string> = new Set([\n  // HTML5 void elements\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  // SVG void elements\n  'circle',\n  'ellipse',\n  'line',\n  'path',\n  'polygon',\n  'polyline',\n  'rect',\n  'use',\n  'stop',\n  'animate',\n  'animateTransform',\n  'set',\n])\n\n/**\n * Check if an element is a void element (doesn't require closing tag)\n *\n * @param tagName - HTML tag name\n * @returns True if void element\n */\nexport function isVoidElement(tagName: string): boolean {\n  let lowerTag = tagName.toLowerCase()\n  if (VOID_ELEMENTS.has(lowerTag)) return true\n  // Handle SVG namespace prefixes like svg:circle\n  const colonIndex = lowerTag.indexOf(':')\n  if (colonIndex !== -1) {\n    lowerTag = lowerTag.slice(colonIndex + 1)\n    return VOID_ELEMENTS.has(lowerTag)\n  }\n  return false\n}\n\n/** Attributes that should be sanitized for security */\nexport const ATTRIBUTES_TO_SANITIZE: readonly string[] = [\n  'src',\n  'href',\n  'data',\n  'formAction',\n  'srcDoc',\n  'action',\n]\n\n// Character classification flags (bitfield)\nconst CHAR_WHITESPACE = 1\nconst CHAR_PUNCTUATION = 2\n\n// Inline character type constants\n// const INLINE_CHAR_TYPE_NORMAL = 0\nconst INLINE_CHAR_TYPE_SPECIAL = 1\nconst INLINE_CHAR_TYPE_ESCAPE = 2\nconst INLINE_CHAR_TYPE_DELIMITER = 3\nconst INLINE_CHAR_TYPE_LINK = 4\n\n// Lookup table for ASCII characters (0-127)\nexport const charClassTable: Uint8Array = (function () {\n  const t = new Uint8Array(128)\n  let i\n  t[$.CHAR_TAB] =\n    t[$.CHAR_NEWLINE] =\n    t[$.CHAR_FF] =\n    t[$.CHAR_CR] =\n    t[$.CHAR_SPACE] =\n      CHAR_WHITESPACE\n  for (i = $.CHAR_EXCLAMATION; i <= $.CHAR_SLASH; i++) t[i] = CHAR_PUNCTUATION\n  for (i = $.CHAR_COLON; i <= $.CHAR_AT; i++) t[i] = CHAR_PUNCTUATION\n  for (i = $.CHAR_BRACKET_OPEN; i <= $.CHAR_BACKTICK; i++)\n    t[i] = CHAR_PUNCTUATION\n  for (i = $.CHAR_BRACE_OPEN; i <= $.CHAR_TILDE; i++) t[i] = CHAR_PUNCTUATION\n  return t\n})()\n\n// Lookup table for inline character types (0-127): 0=normal, 1=special, 2=escape, 3=delimiter, 4=link\nexport const inlineCharTypeTable: Uint8Array = (function () {\n  const t = new Uint8Array(128)\n  t[$.CHAR_BACKSLASH] = INLINE_CHAR_TYPE_ESCAPE\n  t[$.CHAR_BRACKET_OPEN] = INLINE_CHAR_TYPE_LINK\n  t[$.CHAR_ASTERISK] =\n    t[$.CHAR_UNDERSCORE] =\n    t[$.CHAR_TILDE] =\n    t[$.CHAR_EQ] =\n      INLINE_CHAR_TYPE_DELIMITER\n  t[$.CHAR_BACKTICK] =\n    t[$.CHAR_LT] =\n    t[$.CHAR_AT] =\n    t[$.CHAR_BRACKET_CLOSE] =\n    t[$.CHAR_NEWLINE] =\n    t[$.CHAR_SPACE] =\n    t[$.CHAR_EXCLAMATION] =\n      INLINE_CHAR_TYPE_SPECIAL\n  t[$.CHAR_f] = t[$.CHAR_H] = t[$.CHAR_W] = INLINE_CHAR_TYPE_SPECIAL\n  return t\n})()\n\nexport function isASCIIPunctuation(code: number): boolean {\n  return (\n    code < $.CHAR_ASCII_BOUNDARY &&\n    (charClassTable[code] & CHAR_PUNCTUATION) !== 0\n  )\n}\n\nexport function isASCIIWhitespace(code: number): boolean {\n  return (\n    code < $.CHAR_ASCII_BOUNDARY &&\n    (charClassTable[code] & CHAR_WHITESPACE) !== 0\n  )\n}\n\n// Unicode property escapes for spec-compliant character classification\n// Per GFM spec Section 2.1: \"A punctuation character is a character in the general Unicode categories\n// Pc, Pd, Pe, Pf, Pi, Po, or Ps\" - this is \\p{P}\n// BUT also includes some currency symbols and other symbols per the spec's explicit list\nconst UNICODE_PUNCT_R = /[\\p{P}\\p{S}]/u\nconst UNICODE_WHITESPACE_R = /\\p{Zs}/u\n\nexport function isUnicodeWhitespace(c: string): boolean {\n  if (!c) return true\n  const code = c.charCodeAt(0)\n  return code < $.CHAR_ASCII_BOUNDARY\n    ? (charClassTable[code] & CHAR_WHITESPACE) !== 0\n    : UNICODE_WHITESPACE_R.test(c)\n}\n\nexport function isUnicodePunctuation(c: string | number): boolean {\n  if (typeof c === 'number')\n    return (\n      c < $.CHAR_ASCII_BOUNDARY && (charClassTable[c] & CHAR_PUNCTUATION) !== 0\n    )\n  if (!c) return false\n  const code = c.charCodeAt(0)\n  return code < $.CHAR_ASCII_BOUNDARY\n    ? (charClassTable[code] & CHAR_PUNCTUATION) !== 0\n    : UNICODE_PUNCT_R.test(c)\n}\n\n/**\n * Find the end of the current line\n * Optimized: Pure indexOf is faster than hybrid approach - JS engine optimizes it better\n * Handles CRLF by returning position before \\r when followed by \\n\n */\nexport function findLineEnd(source: string, startPos: number): number {\n  const newlinePos = source.indexOf('\\n', startPos)\n  if (newlinePos === -1) return source.length\n  if (newlinePos > 0 && source.charCodeAt(newlinePos - 1) === $.CHAR_CR) {\n    return newlinePos - 1\n  }\n  return newlinePos\n}\n\nvar crlfParts: string[] = []\n\n/**\n * Normalize input text for parsing:\n * - Replace CRLF and CR line endings with LF\n * - Replace null bytes (U+0000) with replacement character (U+FFFD) per CommonMark spec\n * Returns original string if no transformations needed (fast path)\n */\nexport function normalizeInput(text: string): string {\n  var firstCR = text.indexOf('\\r')\n  var firstNull = text.indexOf('\\x00')\n\n  if (firstCR === -1 && firstNull === -1) return text\n\n  var len = text.length\n  crlfParts.length = 0\n  var start = 0\n  var i = 0\n\n  if (firstCR === -1) {\n    i = firstNull\n  } else if (firstNull === -1) {\n    i = firstCR\n  } else {\n    i = firstCR < firstNull ? firstCR : firstNull\n  }\n\n  for (; i < len; i++) {\n    var code = text.charCodeAt(i)\n    if (code === $.CHAR_CR) {\n      if (start < i) crlfParts.push(text.slice(start, i))\n      if (i + 1 < len && text.charCodeAt(i + 1) === $.CHAR_NEWLINE) {\n        i++\n      }\n      crlfParts.push('\\n')\n      start = i + 1\n    } else if (code === 0) {\n      if (start < i) crlfParts.push(text.slice(start, i))\n      crlfParts.push('\\uFFFD')\n      start = i + 1\n    }\n  }\n  if (start < len) crlfParts.push(text.slice(start))\n  return crlfParts.join('')\n}\n\n/**\n * @deprecated Use normalizeInput instead\n * Normalize CRLF and CR line endings to LF\n * Returns original string if no CR characters are present (fast path)\n */\nexport function normalizeCRLF(text: string): string {\n  return normalizeInput(text)\n}\n\n/**\n * Skip whitespace characters\n */\nexport function skipWhitespace(\n  source: string,\n  pos: number,\n  maxPos?: number\n): number {\n  const end = maxPos ?? source.length\n  while (pos < end && (source[pos] === ' ' || source[pos] === '\\t')) pos++\n  return pos\n}\n\n/**\n * Fast check if object has any enumerable properties\n * Optimized alternative to Object.keys(obj).length > 0\n */\nexport function hasKeys(obj: Record<string, any> | null | undefined): boolean {\n  if (!obj) return false\n  for (var key in obj) {\n    return true\n  }\n  return false\n}\n\n/**\n * Extract plain text from AST nodes (for image alt text, heading slugs, etc.)\n * Shared between JSX and HTML renderers\n */\n/**\n * Get nested property from object using dot notation path\n */\nexport function get(source: any, path: string, fallback: any): any {\n  var result = source\n  var segments = path.split('.')\n  var i = 0\n  while (i < segments.length) {\n    result = result?.[segments[i]]\n    if (result === undefined) break\n    i++\n  }\n  return result || fallback\n}\n\n/**\n * Get tag name from override object, supporting both string and component object overrides\n */\nexport function getTag<\n  T extends string | { component?: string; props?: Record<string, any> },\n>(tag: string, overrides?: Record<string, T>): string {\n  if (!overrides) return tag\n  const override = get(overrides, tag, undefined)\n  if (typeof override === 'string') return override\n  if (typeof override === 'object' && override.component)\n    return override.component\n  return tag\n}\n\n/**\n * Get override props from override object\n */\nexport function getOverrideProps<\n  T extends string | { component?: string; props?: Record<string, any> },\n>(\n  tag: string,\n  overrides?: Record<string, T>\n): Record<string, string | number | boolean> {\n  if (!overrides) return {}\n  const override = get(overrides, tag, undefined)\n  return typeof override === 'object' && override.props ? override.props : {}\n}\n\nexport function extractPlainText(nodes: Array<any>, RuleType: any): string {\n  var result = ''\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var node = nodes[i],\n      type = node.type\n    if (type === RuleType.text || type === RuleType.codeInline) {\n      var text = node.text\n      if (text) result += text\n    } else if (type === RuleType.textFormatted || type === RuleType.link) {\n      if (node.children) result += extractPlainText(node.children, RuleType)\n    } else if (type === RuleType.image) {\n      if (node.alt) {\n        result += node.alt\n      }\n    }\n  }\n  return result\n}\n\n/**\n * Check if tag should be filtered per GFM tagfilter extension\n */\nexport function shouldFilterTag(tagName: string): boolean {\n  var lowerTag = tagName.toLowerCase()\n  return (\n    lowerTag === 'title' ||\n    lowerTag === 'textarea' ||\n    lowerTag === 'style' ||\n    lowerTag === 'xmp' ||\n    lowerTag === 'iframe' ||\n    lowerTag === 'noembed' ||\n    lowerTag === 'noframes' ||\n    lowerTag === 'script' ||\n    lowerTag === 'plaintext'\n  )\n}\n\n/**\n * Apply tagfilter to text content - escape dangerous tags\n */\nexport function applyTagFilterToText(text: string): string {\n  // Escape dangerous tags in raw HTML text\n  // Matches opening tags like <tag> or <tag attr=\"val\">\n  return text.replace(\n    /<(\\/?)(title|textarea|style|xmp|iframe|noembed|noframes|script|plaintext)(\\s|>|\\/)/gi,\n    function (match, slash, tagName, after) {\n      // Only escape the opening <\n      return '&lt;' + slash + tagName + after\n    }\n  )\n}\n\n","import { RuleType, type MarkdownToJSX } from './types'\nimport * as $ from './constants'\nimport * as util from './utils'\n\n// NOTE: All debug and tracking functions are automatically removed by build-plugins.ts\n\n// Global parseMetrics - accessible via global.parseMetrics from all files\ndeclare global {\n  var parseMetrics: {\n    blockParsers: {\n      [key: string]: {\n        attempts: number\n        hits: number\n        hitTimings: number[]\n      }\n    }\n    inlineParsers: {\n      [key: string]: {\n        attempts: number\n        hits: number\n        hitTimings: number[]\n      }\n    }\n    totalOperations: number\n    blockParseIterations: number\n    inlineParseIterations: number\n  } | null\n  var parseMetricsStartTimes: Map<string, number> | null\n}\n\nexport {};\n\nfunction warn(message: string): void {\n  console.warn(message)\n}\n\nfunction countConsecutiveChars(\n  source: string,\n  pos: number,\n  targetChar: string,\n  maxCount?: number\n): number {\n  var targetCode = charCode(targetChar)\n  var len = source.length\n  var max = maxCount ?? len - pos\n  var count = 0\n  while (\n    count < max &&\n    pos + count < len &&\n    charCode(source, pos + count) === targetCode\n  )\n    count++\n  return count\n}\n\n// Unified flanking check: dir=0 for left, dir=1 for right\nfunction checkFlanking(\n  source: string,\n  delimiterStart: number,\n  delimiterEnd: number,\n  bound: number,\n  dir: number\n): boolean {\n  if (dir === 0 ? delimiterEnd >= bound : delimiterStart <= bound) return false\n\n  const adjacentChar =\n    dir === 0 ? source[delimiterEnd] : source[delimiterStart - 1]\n  const oppositeChar =\n    dir === 0\n      ? delimiterStart > 0\n        ? source[delimiterStart - 1]\n        : null\n      : delimiterEnd < source.length\n        ? source[delimiterEnd]\n        : null\n\n  var adjacentCode = charCode(adjacentChar)\n\n  if (\n    adjacentCode < $.CHAR_ASCII_BOUNDARY\n      ? util.isASCIIWhitespace(adjacentCode)\n      : util.isUnicodeWhitespace(adjacentChar)\n  ) {\n    return false\n  }\n\n  var oppositeCode = oppositeChar ? charCode(oppositeChar) : null\n  var isOppositeWS =\n    oppositeChar === null ||\n    oppositeChar === '\\n' ||\n    oppositeChar === '\\r' ||\n    (oppositeCode !== null\n      ? oppositeCode < $.CHAR_ASCII_BOUNDARY\n        ? util.isASCIIWhitespace(oppositeCode)\n        : util.isUnicodeWhitespace(oppositeChar)\n      : true)\n\n  var isAdjacentPunct = isPunctuation(adjacentCode, adjacentChar)\n\n  if (!isAdjacentPunct) return true\n  if (isOppositeWS) return true\n\n  return oppositeChar\n    ? isPunctuation(charCode(oppositeChar), oppositeChar)\n    : false\n}\n\n// Per CommonMark spec: backslashes escape ASCII punctuation characters in link destinations\n// For non-punctuation characters, the backslash is preserved as a literal backslash\n// Per CommonMark spec: backslash unescaping and entity reference decoding for URLs and titles\n// Any ASCII punctuation character may be backslash-escaped\n// Entity references are recognized and decoded to Unicode\nfunction unescapeUrlOrTitle(str: string): string {\n  var result = '',\n    i = 0\n  while (i < str.length) {\n    if (str[i] === '\\\\' && i + 1 < str.length) {\n      var next = str[i + 1]\n      result += util.isUnicodePunctuation(charCode(next)) ? next : '\\\\' + next\n      i += 2\n    } else {\n      result += str[i++]\n    }\n  }\n  return util.decodeEntityReferences(result)\n}\n\nfunction skipToNextLine(source: string, lineEnd: number): number {\n  if (lineEnd >= source.length) return lineEnd\n  if (\n    source.charCodeAt(lineEnd) === $.CHAR_CR &&\n    lineEnd + 1 < source.length &&\n    source.charCodeAt(lineEnd + 1) === $.CHAR_NEWLINE\n  ) {\n    return lineEnd + 2\n  }\n  if (source.charCodeAt(lineEnd) === $.CHAR_NEWLINE) {\n    return lineEnd + 1\n  }\n  return lineEnd + 1\n}\n\nfunction getCharType(code: number, skipAutoLink: boolean): number {\n  if (code >= $.CHAR_ASCII_BOUNDARY) return 0\n  var type = util.inlineCharTypeTable[code]\n  if (\n    skipAutoLink &&\n    type === 1 &&\n    (code === $.CHAR_f || code === $.CHAR_H || code === $.CHAR_W)\n  ) {\n    return 0\n  }\n  return type\n}\n\nfunction tryMergeBlockquoteContinuation(\n  source: string,\n  currentPos: number,\n  lastItem: MarkdownToJSX.ASTNode[],\n  continuationContent: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): number | null {\n  if (\n    !lastItem.length ||\n    lastItem[lastItem.length - 1].type !== RuleType.blockQuote\n  )\n    return null\n  const checkPos = util.skipWhitespace(\n    continuationContent,\n    0,\n    continuationContent.length\n  )\n  if (\n    checkPos >= continuationContent.length ||\n    continuationContent[checkPos] !== '>'\n  )\n    return null\n  // We've already verified it starts with '>', so try blockquote directly\n  // (parseBlock might match fenced code blocks first due to indentation)\n  const cont = parseBlockQuote(source, currentPos, state, options)\n  if (!cont) return null\n  const lastBlockQuote = lastItem[\n    lastItem.length - 1\n  ] as MarkdownToJSX.BlockQuoteNode\n  const contBlockQuote = cont as MarkdownToJSX.BlockQuoteNode & {\n    endPos: number\n  }\n  if (contBlockQuote.children)\n    lastBlockQuote.children.push(...contBlockQuote.children)\n  return contBlockQuote.endPos\n}\n\nfunction createHeading(\n  level: number,\n  children: MarkdownToJSX.ASTNode[],\n  content: string,\n  slugify: (str: string) => string\n): MarkdownToJSX.HeadingNode {\n  return {\n    type: RuleType.heading,\n    level,\n    children,\n    id: slugify(content),\n  } as MarkdownToJSX.HeadingNode\n}\n\n// Static regex patterns for performance\nexport const UNESCAPE_R: RegExp = /\\\\(.)/g\nconst HEADING_TRAILING_HASHES_R = /\\s+#+\\s*$/\n// Unified regex for all list item patterns: ordered (digit + delimiter + content) or unordered (marker + content)\n// Groups: 1=ordered_num, 2=ordered_delim, 3=ordered_content, 4=ordered_empty_num, 5=ordered_empty_delim, 6=unordered_marker, 7=unordered_content, 8=unordered_empty_marker\nconst LIST_ITEM_R =\n  /^(?:(\\d{1,9})([.)])\\s+(.*)$|(\\d{1,9})([.)])\\s*$|([-*+])\\s+(.*)$|([-*+])\\s*$)/\n// List items with content (marker + whitespace + content or end of line) - for continuation matching\nconst ORDERED_LIST_ITEM_WITH_CONTENT_R = /^(\\d{1,9})([.)])(\\s+|$)/\nconst UNORDERED_LIST_ITEM_WITH_CONTENT_R = /^([*+\\-])(\\s+|$)/\nexport const HTML_BLOCK_ELEMENT_START_R: RegExp =\n  /^<([a-z][^ >/\\n\\r]*) ?([^>]*?)>/i\nexport const HTML_BLOCK_ELEMENT_START_R_ATTR: RegExp =\n  /^<([a-z][^ >/]*) ?(?:[^>/]+[^/]|)>/i\n\nvar charCode = function (c: string, pos: number = 0) {\n  return c.charCodeAt(pos)\n}\nvar isAlnum = function (c: string): boolean {\n  return util.isAlnumCode(charCode(c))\n}\nvar isWS = function (c: string) {\n  return util.isASCIIWhitespace(charCode(c))\n}\nvar isSpaceOrTab = function (c: string): boolean {\n  return c === ' ' || c === '\\t'\n}\nvar isAttrWhitespace = function (c: string): boolean {\n  return c === ' ' || c === '\\t' || c === '\\n' || c === '\\r'\n}\nvar isPunctuation = function (code: number, char: string): boolean {\n  return util.isUnicodePunctuation(code < $.CHAR_ASCII_BOUNDARY ? code : char)\n}\nvar isNameChar = function (c: string) {\n  var n = charCode(c)\n  return (\n    isAlnum(c) ||\n    n === $.CHAR_DASH ||\n    n === $.CHAR_UNDERSCORE ||\n    n === $.CHAR_COLON ||\n    n === $.CHAR_PERIOD\n  )\n}\n\n// HTML validation functions removed - parser only recognizes boundaries, not validates syntax\n// Per GFM spec: parser's job is to identify HTML boundaries and pass content opaquely\n\nfunction parseHTMLTagName(\n  source: string,\n  pos: number\n): { tagName: string; tagLower: string; nextPos: number } | null {\n  var sourceLen = source.length\n  if (pos >= sourceLen) return null\n  var firstCharCode = charCode(source[pos])\n  if (!isAlphaCode(firstCharCode)) return null\n  var tagNameStart = pos\n  var tagNameEnd = pos\n  while (tagNameEnd < sourceLen) {\n    var code = charCode(source[tagNameEnd])\n    if (\n      (code >= $.CHAR_a && code <= $.CHAR_z) ||\n      (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n      (code >= $.CHAR_DIGIT_0 && code <= $.CHAR_DIGIT_9) ||\n      code === $.CHAR_DASH\n    ) {\n      tagNameEnd++\n    } else {\n      var tagEndCode = charCode(source[tagNameEnd])\n      if (\n        tagEndCode === $.CHAR_SPACE ||\n        tagEndCode === $.CHAR_TAB ||\n        tagEndCode === $.CHAR_NEWLINE ||\n        tagEndCode === $.CHAR_CR ||\n        tagEndCode === $.CHAR_GT ||\n        tagEndCode === $.CHAR_SLASH\n      ) {\n        break\n      } else {\n        return null\n      }\n    }\n  }\n  if (tagNameEnd === tagNameStart) return null\n  var tagName = source.slice(tagNameStart, tagNameEnd)\n\n  // Validate tag name according to spec: only ASCII letters, digits, hyphens\n  for (var i = 0; i < tagName.length; i++) {\n    var code = charCode(tagName[i])\n    if (\n      !(\n        (code >= $.CHAR_a && code <= $.CHAR_z) ||\n        (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n        (code >= $.CHAR_DIGIT_0 && code <= $.CHAR_DIGIT_9) ||\n        code === $.CHAR_DASH\n      )\n    ) {\n      return null\n    }\n  }\n\n  return { tagName, tagLower: tagName.toLowerCase(), nextPos: tagNameEnd }\n}\n\n/** Unified HTML tag parser that handles opening, closing, and self-closing tags */\nexport function parseHTMLTag(\n  source: string,\n  pos: number\n): {\n  tagName: string\n  tagLower: string\n  attrs: string\n  endPos: number\n  isClosing: boolean\n  isSelfClosing: boolean\n  hasNewline: boolean\n  hasSpaceBeforeSlash: boolean\n  whitespaceBeforeAttrs: string\n} | null {\n  var token = scanRawHTML(source, pos)\n  if (!token || token.kind !== 'tag') return null\n\n  // Note: hasSpaceBeforeSlash is already validated in scanner (returns null if invalid)\n  return {\n    tagName: token.tagName || '',\n    tagLower: token.tagNameLower || '',\n    attrs: token.attrs || '',\n    endPos: token.endPos,\n    isClosing: token.isClosing || false,\n    isSelfClosing: token.isSelfClosing || false,\n    hasNewline: token.hasNewline,\n    hasSpaceBeforeSlash: false,\n    whitespaceBeforeAttrs: token.whitespaceBeforeAttrs || '',\n  }\n}\n\n/** Find matching closing tag position for inline HTML tags. Returns [contentEnd, closingTagEnd] or null */\nfunction findInlineClosingTag(\n  source: string,\n  startPos: number,\n  tagNameLower: string\n): [number, number] | null {\n  var depth = 1\n  var searchPos = startPos\n  while (depth > 0 && searchPos < source.length) {\n    var tagIdx = source.indexOf('<', searchPos)\n    if (tagIdx === -1) return null\n    var tagParseResult = parseHTMLTag(source, tagIdx)\n    if (!tagParseResult) {\n      searchPos = tagIdx + 1\n      continue\n    }\n    if (\n      tagParseResult.isClosing &&\n      tagParseResult.tagLower === tagNameLower &&\n      --depth === 0\n    )\n      return [tagIdx, tagParseResult.endPos]\n    if (\n      !tagParseResult.isClosing &&\n      !tagParseResult.isSelfClosing &&\n      tagParseResult.tagLower === tagNameLower\n    )\n      depth++\n    searchPos = tagParseResult.endPos\n  }\n  return null\n}\n\nexport const INTERPOLATION_R: RegExp = /^\\{.*\\}$/\nconst DOUBLE_NEWLINE_R = /\\n\\n/\nconst BLOCK_SYNTAX_R =\n  /^(\\s{0,3}#[#\\s]|\\s{0,3}[-*+]\\s|\\s{0,3}\\d+\\.\\s|\\s{0,3}>\\s|\\s{0,3}```)/m\nconst TYPE1_TAG_R = /<\\/?(?:pre|script|style|textarea)\\b/i\nexport const UPPERCASE_TAG_R: RegExp = /^<[A-Z]/\nconst TRAILING_NEWLINE_R = /\\n$/\nconst BLOCK_START_CHARS_SET = new Set([\n  '#',\n  '>',\n  '-',\n  '*',\n  '+',\n  '`',\n  '|',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n])\n\n/** Find the next occurrence of a character, ignoring escaped versions */\nfunction findUnescapedChar(\n  source: string,\n  startPos: number,\n  endPos: number,\n  targetChar: string\n): number {\n  let i = startPos\n  while (i < endPos) {\n    if (source[i] === '\\\\' && i + 1 < endPos) {\n      i += 2\n      continue\n    }\n    if (source[i] === targetChar) return i\n    i++\n  }\n  return -1\n}\n\ntype StyleTuple = [key: string, value: string]\n\nfunction addStyleToCollection(styles: StyleTuple[], buffer: string): void {\n  var colonIndex = buffer.indexOf(':')\n  if (colonIndex > 0) {\n    var value = buffer.slice(colonIndex + 1).trim()\n    var len = value.length\n    if (len >= 2) {\n      var first = value[0]\n      if ((first === '\"' || first === \"'\") && value[len - 1] === first) {\n        value = value.slice(1, -1)\n      }\n    }\n    styles.push([buffer.slice(0, colonIndex).trim(), value])\n  }\n}\n\nexport function parseStyleAttribute(styleString: string): StyleTuple[] {\n  var styles: StyleTuple[] = []\n  if (!styleString) return styles\n\n  var buffer = ''\n  var depth = 0\n  var quoteChar = ''\n\n  for (var i = 0; i < styleString.length; i++) {\n    var char = styleString[i]\n\n    if (char === '\"' || char === \"'\") {\n      if (!quoteChar) {\n        quoteChar = char\n        depth++\n      } else if (char === quoteChar) {\n        quoteChar = ''\n        depth--\n      }\n    } else if (char === '(' && util.endsWith(buffer, 'url')) {\n      depth++\n    } else if (char === ')' && depth > 0) {\n      depth--\n    } else if (char === ';' && depth === 0) {\n      addStyleToCollection(styles, buffer)\n      buffer = ''\n      continue\n    }\n\n    buffer += char\n  }\n\n  addStyleToCollection(styles, buffer)\n\n  return styles\n}\n\nfunction attributeValueToJSXPropValue(\n  tag: MarkdownToJSX.HTMLTags,\n  key: string,\n  value: string,\n  sanitizeUrlFn: (\n    value: string,\n    tag: string,\n    attribute: string\n  ) => string | null,\n  options: ParseOptions\n): any {\n  if (key === 'style') {\n    return parseStyleAttribute(value).reduce(\n      function (styles, [k, v]) {\n        const sanitized = sanitizeUrlFn(v, tag, k)\n        if (sanitized != null) {\n          styles[k.replace(/(-[a-z])/g, substr => substr[1].toUpperCase())] =\n            sanitized\n        }\n        return styles\n      },\n      {} as { [key: string]: any }\n    );\n  }\n\n  // Handle JSX expressions (braces) before sanitization\n  // This allows parsing of arrays/objects in JSX props\n  if (value.match(INTERPOLATION_R)) {\n    value = value.slice(1, value.length - 1)\n    value = value ? value.replace(UNESCAPE_R, '$1') : value\n\n    // Try to parse as JSON for arrays/objects (best effort)\n    // Keep as raw string for functions and complex expressions\n    if (value.length > 0) {\n      const firstChar = value[0]\n      // Check if it looks like an array or object literal\n      if (firstChar === '[' || firstChar === '{') {\n        try {\n          return JSON.parse(value)\n        } catch (e) {\n          // Not valid JSON, keep as string (e.g., functions, JSX expressions)\n          return value\n        }\n      }\n    }\n    // For other expressions (functions, variables, etc.), keep as string by default\n    // Only eval if explicitly opted-in (NOT recommended for user inputs)\n    if (value === 'true') return true\n    if (value === 'false') return false\n\n    // Attempt to eval unserializable expressions only if explicitly enabled\n    //  WARNING: This uses eval() and should only be used with trusted content\n    if (options.evalUnserializableExpressions) {\n      try {\n        // Try to evaluate as an expression (function, variable, etc.)\n        // eslint-disable-next-line no-eval\n        return eval(`(${value})`)\n      } catch (e) {\n        // If eval fails, return as string\n        return value\n      }\n    }\n\n    // Don't apply sanitization to JSX expressions\n    // Keep as string - can be handled via renderRule on a case-by-case basis\n    return value\n  }\n\n  if (util.ATTRIBUTES_TO_SANITIZE.indexOf(key) !== -1) {\n    return sanitizeUrlFn(\n      value ? value.replace(UNESCAPE_R, '$1') : value,\n      tag,\n      key\n    )\n  }\n\n  return value === 'true' ? true : value === 'false' ? false : value\n}\n\nfunction parseHTMLAttributes(\n  attrs: string,\n  tagName: string,\n  tagNameOriginal: string,\n  options: ParseOptions\n): { [key: string]: any } {\n  const result: { [key: string]: any } = {}\n  if (!attrs || !attrs.trim()) return result\n\n  const attrMatches: string[] = []\n  let i = 0\n  const len = attrs.length\n  while (i < len) {\n    while (i < len && isAttrWhitespace(attrs[i])) i++\n    if (i >= len) break\n    const nameStart = i\n    while (i < len && isNameChar(attrs[i])) i++\n    if (i === nameStart) {\n      i++\n      continue\n    }\n    const name = attrs.slice(nameStart, i)\n    while (i < len && isAttrWhitespace(attrs[i])) i++\n    if (i >= len || attrs[i] !== '=') {\n      attrMatches.push(name)\n      continue\n    }\n    i++\n    while (i < len && isAttrWhitespace(attrs[i])) i++\n    if (i >= len) {\n      attrMatches.push(name + '=')\n      break\n    }\n    const valueStart = i\n    const q = attrs[i]\n    if (q === '\"' || q === \"'\") {\n      i++\n      while (i < len) {\n        if (attrs[i] === q) {\n          if (i + 1 >= len) {\n            i++\n            break\n          }\n          const nextChar = attrs[i + 1]\n          if (isAttrWhitespace(nextChar) || nextChar === '/') {\n            i++\n            break\n          }\n        }\n        i++\n      }\n    } else if (q === '{') {\n      let depth = 1\n      i++\n      while (i < len && depth > 0) {\n        if (attrs[i] === '{') depth++\n        else if (attrs[i] === '}') {\n          depth--\n          if (depth === 0) {\n            i++\n            break\n          }\n        }\n        i++\n      }\n    } else {\n      while (i < len && !isAttrWhitespace(attrs[i])) i++\n    }\n    attrMatches.push(name + '=' + attrs.slice(valueStart, i))\n  }\n\n  if (!attrMatches?.length) return result\n  const tagNameLower = tagName.toLowerCase()\n  for (let i = 0; i < attrMatches.length; i++) {\n    const rawAttr = attrMatches[i],\n      delimiterIdx = rawAttr.indexOf('=')\n    if (delimiterIdx !== -1) {\n      const key = rawAttr.slice(0, delimiterIdx).trim(),\n        keyLower = key.toLowerCase()\n      if (keyLower === 'ref') continue\n      const rawValue = rawAttr.slice(delimiterIdx + 1).trim(),\n        value = ((str: string) => {\n          const first = str[0]\n          if (\n            (first === '\"' || first === \"'\") &&\n            str.length >= 2 &&\n            str[str.length - 1] === first\n          )\n            return str.slice(1, -1)\n          return str\n        })(rawValue)\n\n      if (\n        (keyLower === 'href' && tagNameLower === 'a') ||\n        (keyLower === 'src' && tagNameLower === 'img')\n      ) {\n        const safe = options.sanitizer(\n          value,\n          tagNameLower as MarkdownToJSX.HTMLTags,\n          keyLower\n        )\n        if (safe == null) {\n          warn(`Stripped unsafe ${keyLower} on <${tagNameOriginal}>`)\n          continue\n        }\n        result[key] = safe\n      } else {\n        const normalizedValue = attributeValueToJSXPropValue(\n          tagNameLower as MarkdownToJSX.HTMLTags,\n          keyLower,\n          value,\n          options.sanitizer,\n          options\n        )\n        result[key] = normalizedValue\n      }\n    } else if (rawAttr !== 'style')\n      result[rawAttr] = true\n  }\n  // Check for URI-encoded malicious content in the raw attributes string\n  // Only decode if % is present (performance optimization)\n  if (attrs.indexOf('%') !== -1) {\n    try {\n      if (util.SANITIZE_R.test(decodeURIComponent(attrs)))\n        for (var key in result) delete result[key]\n    } catch (e) {\n      // Invalid URI encoding (e.g., \"100%\") - skip the check\n      // Individual attributes were already sanitized above\n    }\n  } else if (util.SANITIZE_R.test(attrs)) {\n    for (var key in result) delete result[key]\n  }\n  return result\n}\n\nexport type ParseResult = (MarkdownToJSX.ASTNode & { endPos: number }) | null\n\n/** Options passed to parsers */\nexport type ParseOptions = Omit<MarkdownToJSX.Options, 'slugify'> & {\n  slugify: (input: string) => string\n}\n\nvar isBlockStartChar = function (c: string): boolean {\n  return BLOCK_START_CHARS_SET.has(c)\n}\n\ninterface BracketEntry {\n  type: 'link' | 'image'\n  pos: number\n  resultIdx: number\n  inAnchor: boolean\n}\n\n// Check if an invalid reference definition should be skipped per CommonMark Examples 208 and 210\nfunction shouldSkipInvalidReferenceDefinition(\n  input: string,\n  refCheckPos: number,\n  isAtDocumentStart: boolean\n): { shouldSkip: boolean; newPos: number } {\n  // Find closing ']' handling escapes\n  let bracketEnd = refCheckPos + 1\n  while (bracketEnd < input.length && input[bracketEnd] !== ']') {\n    if (input[bracketEnd] === '\\\\' && bracketEnd + 1 < input.length) {\n      bracketEnd += 2\n      continue\n    }\n    bracketEnd++\n  }\n  if (bracketEnd >= input.length) return { shouldSkip: false, newPos: 0 }\n\n  // Check if label starts/ends with newline (Example 208 pattern)\n  const labelStart = refCheckPos + 1\n  const labelEnd = bracketEnd\n  const labelStartsWithNewline =\n    labelStart < labelEnd &&\n    (input[labelStart] === '\\n' || input[labelStart] === '\\r')\n  const labelEndsWithNewline =\n    labelEnd > labelStart &&\n    (input[labelEnd - 1] === '\\n' || input[labelEnd - 1] === '\\r')\n\n  let afterBracket = bracketEnd + 1\n  // Skip whitespace after ']'\n  afterBracket = util.skipWhitespace(input, afterBracket)\n\n  // Check for colon\n  if (afterBracket >= input.length || input[afterBracket] !== ':') {\n    return { shouldSkip: false, newPos: 0 }\n  }\n\n  // Found colon - check for Example 208 pattern (label starts/ends with newline at document start)\n  if ((labelStartsWithNewline || labelEndsWithNewline) && isAtDocumentStart) {\n    // Invalid ref definition per Example 208 - skip to next line after URL\n    let skipPos = afterBracket + 1\n    skipPos = util.skipWhitespace(input, skipPos)\n    // Skip optional newline\n    if (skipPos < input.length && input[skipPos] === '\\n') {\n      skipPos = util.skipWhitespace(input, skipPos + 1)\n    }\n    // Find end of URL line (next newline)\n    while (skipPos < input.length && input[skipPos] !== '\\n') {\n      skipPos++\n    }\n    if (skipPos < input.length) {\n      skipPos++\n    }\n    return { shouldSkip: true, newPos: skipPos }\n  }\n\n  // Check for Example 210 pattern (trailing text after title)\n  return checkExample210Pattern(input, afterBracket)\n}\n\n// Helper for Example 210: trailing text after title\nfunction checkExample210Pattern(\n  input: string,\n  colonPos: number\n): { shouldSkip: boolean; newPos: number } {\n  let urlEnd = colonPos + 1\n  urlEnd = util.skipWhitespace(input, urlEnd)\n  // Skip optional newline\n  if (urlEnd < input.length && input[urlEnd] === '\\n') {\n    urlEnd = util.skipWhitespace(input, urlEnd + 1)\n  }\n  // Find end of URL (next newline)\n  while (urlEnd < input.length && input[urlEnd] !== '\\n') {\n    urlEnd++\n  }\n  if (urlEnd >= input.length) return { shouldSkip: false, newPos: 0 }\n\n  urlEnd++\n  // Check for title delimiter on next line\n  let titleLineStart = util.skipWhitespace(input, urlEnd)\n  if (\n    titleLineStart >= input.length ||\n    (input[titleLineStart] !== '\"' && input[titleLineStart] !== \"'\")\n  ) {\n    return { shouldSkip: false, newPos: 0 }\n  }\n\n  // Has title delimiter - check for trailing text (Example 210)\n  const titleChar = input[titleLineStart]\n  let titleEnd = titleLineStart + 1\n  while (\n    titleEnd < input.length &&\n    input[titleEnd] !== titleChar &&\n    input[titleEnd] !== '\\n'\n  ) {\n    if (input[titleEnd] === '\\\\' && titleEnd + 1 < input.length) {\n      titleEnd += 2\n      continue\n    }\n    titleEnd++\n  }\n  if (titleEnd >= input.length || input[titleEnd] !== titleChar) {\n    return { shouldSkip: false, newPos: 0 }\n  }\n\n  // Found closing quote - check for trailing text\n  let afterTitle = util.skipWhitespace(input, titleEnd + 1)\n  if (\n    afterTitle < input.length &&\n    input[afterTitle] !== '\\n' &&\n    input[afterTitle] !== '\\r'\n  ) {\n    // Trailing text found - invalid ref definition per Example 210\n    return { shouldSkip: true, newPos: urlEnd }\n  }\n\n  return { shouldSkip: false, newPos: 0 }\n}\n\n// Check if nodes contain a link (prevents nested links per CommonMark)\nfunction containsLink(nodes: MarkdownToJSX.ASTNode[]): boolean {\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i]\n    if (node.type === RuleType.link) return true\n    if (node.type === RuleType.textFormatted) {\n      var formattedNode = node as MarkdownToJSX.FormattedTextNode\n      if (formattedNode.children && containsLink(formattedNode.children))\n        return true\n    }\n  }\n  return false\n}\n\nfunction extractAllTextFromNodes(nodes: MarkdownToJSX.ASTNode[]): string {\n  var text = ''\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var node = nodes[i]\n    var type = node.type\n    if (type === RuleType.text) {\n      text += (node as MarkdownToJSX.TextNode).text\n    } else if (type === RuleType.image) {\n      var imgNode = node as MarkdownToJSX.ImageNode\n      if (imgNode.alt) text += imgNode.alt\n    } else if (type === RuleType.textFormatted) {\n      var formattedNode = node as MarkdownToJSX.FormattedTextNode\n      if (formattedNode.children) {\n        text += extractAllTextFromNodes(formattedNode.children)\n      }\n    } else if (type === RuleType.link) {\n      var linkNode = node as MarkdownToJSX.LinkNode\n      if (linkNode.children) {\n        text += extractAllTextFromNodes(linkNode.children)\n      }\n    }\n  }\n  return text\n}\n\nconst WHITESPACE_CHARS = new Set([' ', '\\t', '\\r', '\\n', '\\f', '\\v'])\n\n/**\n * Single pass, no recursion, eliminates parseLink/parseImage/parseRefLink/parseRefImage functions\n */\nfunction parseInlineSpan(\n  source: string,\n  start: number,\n  end: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  var result: MarkdownToJSX.ASTNode[] = []\n  var delimiterStack: DelimiterEntry[] = []\n  var bracketStack: BracketEntry[] = []\n\n  var pos = start\n  var textStart = start\n  var skipAutoLink = options.disableAutoLink || state.inAnchor\n  var hasAmpersand = false\n  var inAnchor = !!state.inAnchor\n  var disableParsingRawHTML = !!options.disableParsingRawHTML\n  var isStreaming = options.optimizeForStreaming\n\n  // Track incomplete syntax for streaming mode\n  var incompleteBacktickPos = -1\n  var incompleteHTMLPos = -1\n  var htmlElementIndices: number[] = []\n\n  // Helper: handle HTML tag parsing (angle brace autolinks, comments, tags, type 7 blocks)\n  var handleHTMLTag = function (\n    checkType7Block: boolean,\n    respectDisableAutoLink: boolean\n  ): boolean {\n    // In streaming mode, skip all HTML-related parsing when already inside HTML to avoid infinite recursion\n    if (isStreaming && state.inHTML) {\n      return false\n    }\n\n    if (!inAnchor && (!respectDisableAutoLink || !options.disableAutoLink)) {\n      var angleBraceResult = parseLinkOrImage(source, pos, state, options, '<')\n      if (angleBraceResult) {\n        flushText(pos)\n        result.push(angleBraceResult)\n        pos = angleBraceResult.endPos\n        textStart = pos\n        return true\n      }\n    }\n\n    // Skip HTML parsing if disableParsingRawHTML is enabled\n    if (disableParsingRawHTML) {\n      return false\n    }\n\n    var htmlResult = parseHTML(source, pos, state, options)\n    if (htmlResult) {\n      flushText(pos)\n      var htmlNodeIdx = result.length\n      result.push(htmlResult)\n      // Track HTML elements for streaming mode incomplete tag detection\n      if (htmlElementIndices) {\n        htmlElementIndices.push(htmlNodeIdx)\n      }\n      pos = htmlResult.endPos\n      textStart = pos\n      return true\n    }\n\n    // Track incomplete HTML for streaming mode\n    if (isStreaming && incompleteHTMLPos === -1) {\n      // Check if this looks like the start of an HTML tag\n      if (pos + 1 < end) {\n        var nextChar = charCode(source, pos + 1)\n        if (\n          (nextChar >= $.CHAR_A && nextChar <= $.CHAR_Z) ||\n          (nextChar >= $.CHAR_a && nextChar <= $.CHAR_z) ||\n          nextChar === $.CHAR_SLASH ||\n          nextChar === $.CHAR_EXCLAMATION\n        ) {\n          incompleteHTMLPos = pos\n        }\n      }\n    }\n\n    if (!checkType7Block) return false\n    var tagCheckResult = parseHTMLTag(source, pos)\n    if (!tagCheckResult) return false\n    var tagNameStart = pos + (tagCheckResult.isClosing ? 2 : 1)\n    if (tagNameStart >= source.length || isSpaceOrTab(source[tagNameStart]))\n      return false\n    var closeIdx = source.indexOf('>', pos + 1)\n    if (closeIdx !== -1) {\n      var contentStart = pos + 1\n      var contentLen = closeIdx - contentStart\n      if (contentLen >= 7) {\n        var isHttp = util.startsWith(source, 'http://', contentStart)\n        if (isHttp || util.startsWith(source, 'https://', contentStart)) {\n          for (var j = contentStart; j < closeIdx; j++) {\n            if (isSpaceOrTab(source[j])) return false\n          }\n        }\n      }\n    }\n    var tagFirstCharCode = charCode(source, tagNameStart)\n    if (\n      isAlphaCode(tagFirstCharCode) &&\n      tagNameStart + 1 < source.length &&\n      source[tagNameStart + 1] === ':'\n    )\n      return false\n    if (tagCheckResult.isClosing && tagCheckResult.attrs.trim().length)\n      return false\n\n    if (tagCheckResult.attrs.length) {\n      var inQuotes = false\n      var quoteChar = ''\n      for (var i = 0; i < tagCheckResult.attrs.length; i++) {\n        var ch = tagCheckResult.attrs[i]\n        if (inQuotes && ch === quoteChar) {\n          inQuotes = false\n        } else if (!inQuotes && (ch === '\"' || ch === \"'\")) {\n          inQuotes = true\n          quoteChar = ch\n        } else if (ch === '*' || ch === '#' || ch === '!') {\n          var checkAhead = i + 1\n          while (\n            checkAhead < tagCheckResult.attrs.length &&\n            tagCheckResult.attrs[checkAhead] !== '=' &&\n            tagCheckResult.attrs[checkAhead] !== ' ' &&\n            tagCheckResult.attrs[checkAhead] !== '\\t'\n          )\n            checkAhead++\n          if (\n            checkAhead < tagCheckResult.attrs.length &&\n            tagCheckResult.attrs[checkAhead] === '='\n          )\n            return false\n        }\n      }\n    }\n\n    // Valid tag with newline - type 7 block, preserve as raw HTML\n    // But still parse content into children\n    var rawText = source.slice(pos, tagCheckResult.endPos)\n    var tagName = tagCheckResult.tagName.toLowerCase()\n    var contentToParse = rawText\n    // Extract content if rawText includes opening tag\n    var tagEnd = contentToParse.indexOf('>')\n    if (tagEnd !== -1) {\n      contentToParse = contentToParse.slice(tagEnd + 1)\n      var closingTag = '</' + tagName + '>'\n      var closingIdx = contentToParse.indexOf(closingTag)\n      if (closingIdx !== -1) {\n        contentToParse = contentToParse.slice(0, closingIdx)\n      }\n    }\n    var children: MarkdownToJSX.ASTNode[] = []\n    if (contentToParse.trim() && options) {\n      var parseState: MarkdownToJSX.State = {\n        ...state,\n        inline: false,\n        inHTML: true,\n      }\n      var trimmed = contentToParse.trim()\n      if (\n        DOUBLE_NEWLINE_R.test(trimmed) ||\n        BLOCK_SYNTAX_R.test(trimmed) ||\n        HTML_BLOCK_ELEMENT_START_R.test(trimmed)\n      ) {\n        children = parseBlocksInHTML(trimmed, parseState, options)\n      } else if (trimmed) {\n        parseState.inline = true\n        children = parseInlineSpan(\n          trimmed,\n          0,\n          trimmed.length,\n          parseState,\n          options\n        )\n      }\n    }\n    // Parse attributes from the tag (#781 fix for multi-line attributes)\n    var rawAttrs = tagCheckResult.whitespaceBeforeAttrs + tagCheckResult.attrs\n    var parsedAttrs = parseHTMLAttributes(\n      rawAttrs,\n      tagName,\n      tagCheckResult.tagName,\n      options\n    )\n    var htmlBlockResult = {\n      type: RuleType.htmlBlock,\n      tag: tagCheckResult.tagName as MarkdownToJSX.HTMLTags,\n      attrs: parsedAttrs,\n      children: children,\n      rawText: rawText,\n      text: contentToParse, // @deprecated - cleaned up content without tags, use rawText for full raw HTML\n      verbatim: true,\n      endPos: tagCheckResult.endPos,\n    } as MarkdownToJSX.HTMLNode & { endPos: number }\n    flushText(pos)\n    result.push(htmlBlockResult)\n    pos = htmlBlockResult.endPos\n    textStart = pos\n    return true\n  }\n\n  var flushText = function (endPos: number) {\n    if (endPos > textStart) {\n      var text = source.slice(textStart, endPos)\n      result.push({\n        type: RuleType.text,\n        text: hasAmpersand ? util.decodeEntityReferences(text) : text,\n      } as MarkdownToJSX.TextNode)\n      textStart = endPos\n      hasAmpersand = false\n    }\n  }\n\n  while (pos < end) {\n    var code = charCode(source, pos)\n    var charType = getCharType(code, skipAutoLink)\n\n    if (charType === 0) {\n      if (code === $.CHAR_AMPERSAND) hasAmpersand = true\n      pos++\n      // Fast path for ASCII text - avoid repeated charCode calls and lookups\n      while (pos < end) {\n        code = charCode(source, pos)\n        if (code >= $.CHAR_ASCII_BOUNDARY) break\n        if (code === $.CHAR_AMPERSAND) hasAmpersand = true\n        var lookupCharType = util.inlineCharTypeTable[code]\n        if (lookupCharType !== 0) {\n          // Check for autolink exception\n          if (\n            skipAutoLink &&\n            lookupCharType === 1 &&\n            (code === $.CHAR_f || code === $.CHAR_H || code === $.CHAR_W)\n          ) {\n            pos++\n            continue\n          }\n          break\n        }\n        pos++\n      }\n      continue\n    }\n\n    // CODE SPANS (highest priority, no nesting)\n    if (code === $.CHAR_BACKTICK) {\n      var backtickStart = pos\n      var backtickCount = 0\n      while (pos + backtickCount < end) {\n        if (charCode(source, pos + backtickCount) !== $.CHAR_BACKTICK) break\n        backtickCount++\n      }\n\n      if (backtickCount > 0) {\n        var contentStart = pos + backtickCount\n        var contentEnd = -1\n        var i = contentStart\n        // Scan character by character for closing backticks - faster than indexOf\n        while (i < end) {\n          // Find next backtick\n          while (i < end && charCode(source, i) !== $.CHAR_BACKTICK) i++\n          if (i >= end) break\n\n          // Count consecutive backticks\n          var closingCount = 0\n          while (\n            i + closingCount < end &&\n            charCode(source, i + closingCount) === $.CHAR_BACKTICK\n          ) {\n            closingCount++\n          }\n          if (closingCount > backtickCount) closingCount = backtickCount\n          var j = i + closingCount\n\n          // Check if this is a valid closing sequence\n          if (\n            closingCount === backtickCount &&\n            (i <= contentStart ||\n              charCode(source, i - 1) !== $.CHAR_BACKTICK) &&\n            (j >= end || charCode(source, j) !== $.CHAR_BACKTICK)\n          ) {\n            contentEnd = i\n            i = j\n            break\n          }\n          i++\n        }\n\n        if (contentEnd !== -1) {\n          var rawContent = source.slice(contentStart, contentEnd)\n          var hasNewline = false\n          for (var k = 0; k < rawContent.length; k++) {\n            var nlCode = charCode(rawContent, k)\n            if (nlCode === $.CHAR_NEWLINE || nlCode === $.CHAR_CR) {\n              hasNewline = true\n              break\n            }\n          }\n          var content = rawContent\n          if (hasNewline) {\n            // Optimize newline replacement by avoiding regex\n            content = rawContent\n              .replace(/\\r\\n/g, ' ')\n              .replace(/\\r/g, ' ')\n              .replace(/\\n/g, ' ')\n          }\n          if (content.length > 0) {\n            var firstChar = charCode(content, 0)\n            var lastChar = charCode(content, content.length - 1)\n            if (firstChar === $.CHAR_SPACE && lastChar === $.CHAR_SPACE) {\n              for (var idx = 1; idx < content.length - 1; idx++) {\n                if (charCode(content, idx) !== $.CHAR_SPACE) {\n                  content = content.slice(1, content.length - 1)\n                  break\n                }\n              }\n            }\n          }\n\n          flushText(backtickStart)\n          result.push({\n            type: RuleType.codeInline,\n            text: content,\n          } as MarkdownToJSX.CodeInlineNode)\n          pos = i\n          textStart = pos\n          continue\n        }\n        // Track incomplete backticks for streaming mode\n        if (isStreaming && incompleteBacktickPos === -1) {\n          incompleteBacktickPos = backtickStart\n          // In streaming mode, stop processing at incomplete backtick\n          // Flush any text before the backtick and exit\n          flushText(backtickStart)\n          end = backtickStart\n          break\n        }\n        pos = contentStart\n        continue\n      }\n    }\n\n    // AUTOLINKS: BARE URLS AND EMAIL (check BEFORE escapes to preserve backslashes in URLs)\n    if (\n      !inAnchor &&\n      !skipAutoLink &&\n      (code === $.CHAR_f || code === $.CHAR_H || code === $.CHAR_W)\n    ) {\n      var autolinkType: 'h' | 'w' | 'f' | null = null\n      // Cache character codes to avoid repeated function calls\n      var c1 = pos + 1 < end ? charCode(source, pos + 1) : 0\n      var c2 = pos + 2 < end ? charCode(source, pos + 2) : 0\n      var c3 = pos + 3 < end ? charCode(source, pos + 3) : 0\n      var c4 = pos + 4 < end ? charCode(source, pos + 4) : 0\n      var c5 = pos + 5 < end ? charCode(source, pos + 5) : 0\n\n      if (\n        code === $.CHAR_H &&\n        c1 === $.CHAR_t &&\n        c2 === $.CHAR_t &&\n        c3 === $.CHAR_p\n      ) {\n        autolinkType = 'h'\n      } else if (\n        code === $.CHAR_W &&\n        c1 === $.CHAR_W &&\n        c2 === $.CHAR_W &&\n        c3 === $.CHAR_PERIOD\n      ) {\n        autolinkType = 'w'\n      } else if (\n        code === $.CHAR_f &&\n        c1 === $.CHAR_t &&\n        c2 === $.CHAR_p &&\n        c3 === $.CHAR_COLON &&\n        c4 === $.CHAR_SLASH &&\n        c5 === $.CHAR_SLASH\n      ) {\n        autolinkType = 'f'\n      }\n      if (autolinkType) {\n        var bareUrlResult = parseLinkOrImage(\n          source,\n          pos,\n          state,\n          options,\n          autolinkType\n        )\n        if (bareUrlResult) {\n          flushText(pos)\n          result.push(bareUrlResult)\n          pos = bareUrlResult.endPos\n          textStart = pos\n          continue\n        }\n      }\n    }\n\n    if (!inAnchor && !skipAutoLink && code === $.CHAR_AT) {\n      var emailResult = parseLinkOrImage(source, pos, state, options, '@')\n      if (emailResult && 'emailStart' in emailResult) {\n        var emailStart = (\n          emailResult as MarkdownToJSX.LinkNode & {\n            endPos: number\n            emailStart: number\n          }\n        ).emailStart\n        var emailEnd = emailResult.endPos\n        var removedIndices: number[] = []\n        for (var j = delimiterStack.length - 1; j >= 0; j--) {\n          var delim = delimiterStack[j]\n          if (delim.sourcePos >= emailStart && delim.sourcePos < emailEnd) {\n            if (delim.nodeIndex >= 0 && delim.nodeIndex < result.length) {\n              result.splice(delim.nodeIndex, 1)\n              removedIndices.push(delim.nodeIndex)\n            }\n            delimiterStack.splice(j, 1)\n          }\n        }\n        if (emailStart < textStart) {\n          for (var i = result.length - 1; i >= 0; i--) {\n            if (result[i].type === RuleType.text) {\n              result.splice(i, 1)\n              removedIndices.push(i)\n              break\n            }\n          }\n          textStart = emailStart\n        }\n        // Batch update delimiter indices after all removals (O(n+m) instead of O(n*m))\n        if (removedIndices.length) {\n          removedIndices.sort(function (a, b) {\n            return a - b\n          })\n          var removedIdx = 0\n          for (var m = 0; m < delimiterStack.length; m++) {\n            var delim = delimiterStack[m]\n            while (\n              removedIdx < removedIndices.length &&\n              removedIndices[removedIdx] < delim.nodeIndex\n            )\n              removedIdx++\n            delim.nodeIndex -= removedIdx\n          }\n        }\n        flushText(emailStart)\n        result.push(emailResult)\n        pos = emailEnd\n        textStart = pos\n        continue\n      }\n    }\n\n    // HTML TAGS AND AUTOLINKS (check BEFORE escapes to preserve backslashes in autolinks)\n    if (code === $.CHAR_LT) {\n      if (handleHTMLTag(true, false)) continue\n    }\n\n    // BACKSLASH ESCAPES\n    if (code === $.CHAR_BACKSLASH) {\n      if (pos + 1 < end && charCode(source, pos + 1) === $.CHAR_NEWLINE) {\n        var afterNewline = pos + 2\n        while (\n          afterNewline < end &&\n          charCode(source, afterNewline) === $.CHAR_SPACE\n        )\n          afterNewline++\n        if (afterNewline >= end) {\n          pos++\n          continue\n        }\n        flushText(pos)\n        result.push({ type: RuleType.breakLine } as MarkdownToJSX.BreakLineNode)\n        pos += 2\n        while (pos < end && charCode(source, pos) === $.CHAR_SPACE) pos++\n        textStart = pos\n        continue\n      }\n\n      var nextChar = pos + 1 < end ? source[pos + 1] : ''\n      if (\n        nextChar &&\n        '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'.indexOf(nextChar) !== -1\n      ) {\n        flushText(pos)\n        result.push({\n          type: RuleType.text,\n          text: nextChar === '&' ? '&\\u200B' : nextChar,\n        } as MarkdownToJSX.TextNode)\n        pos += 2\n        textStart = pos\n        continue\n      }\n    }\n\n    // LINKS AND IMAGES - OPENING BRACKET\n    if (code === $.CHAR_BRACKET_OPEN) {\n      if (!inAnchor) {\n        if (pos + 1 < end && source[pos + 1] === '^') {\n          var footnoteEndPos = pos + 2\n          while (footnoteEndPos < end && source[footnoteEndPos] !== ']')\n            footnoteEndPos++\n          if (footnoteEndPos < end) {\n            var identifier = source.slice(pos + 2, footnoteEndPos)\n            flushText(pos)\n            result.push({\n              type: RuleType.footnoteReference,\n              target: `#${options.slugify(identifier)}`,\n              text: identifier,\n            } as MarkdownToJSX.FootnoteReferenceNode)\n            pos = footnoteEndPos + 1\n            textStart = pos\n            continue\n          }\n        }\n\n        if (\n          state.inList &&\n          pos + 2 < end &&\n          charCode(source, pos + 2) === $.CHAR_BRACKET_CLOSE\n        ) {\n          var nextCode = charCode(source, pos + 1)\n          if (\n            nextCode === $.CHAR_SPACE ||\n            nextCode === $.CHAR_x ||\n            nextCode === $.CHAR_X\n          ) {\n            flushText(pos)\n            result.push({\n              type: RuleType.gfmTask,\n              completed: nextCode === $.CHAR_x || nextCode === $.CHAR_X,\n            } as MarkdownToJSX.GFMTaskNode)\n            pos += 3\n            textStart = pos\n            continue\n          }\n        }\n      }\n\n      var isImage = false\n      if (pos > start && source[pos - 1] === '!') {\n        var backslashCount = 0\n        for (\n          var checkPos = pos - 2;\n          checkPos >= start && source[checkPos] === '\\\\';\n          checkPos--\n        )\n          backslashCount++\n        if ((backslashCount & 1) === 0) {\n          isImage = true\n          if (textStart < pos - 1) flushText(pos - 1)\n          if (\n            result.length > 0 &&\n            result[result.length - 1].type === RuleType.text\n          ) {\n            var lastText = result[result.length - 1] as MarkdownToJSX.TextNode\n            if (lastText.text.endsWith('!')) {\n              lastText.text = lastText.text.slice(0, -1)\n              if (!lastText.text) result.pop()\n            }\n          }\n        }\n      }\n      if (!isImage) flushText(pos)\n      textStart = pos + 1\n      if (!inAnchor || isImage) {\n        bracketStack.push({\n          type: isImage ? 'image' : 'link',\n          pos: isImage ? pos - 1 : pos,\n          resultIdx: result.length,\n          inAnchor: inAnchor,\n        })\n      }\n\n      pos++\n      continue\n    }\n\n    // LINKS AND IMAGES - CLOSING BRACKET\n    if (code === $.CHAR_BRACKET_CLOSE && bracketStack.length > 0) {\n      var bracket = bracketStack[bracketStack.length - 1]\n      var linkTextStart = bracket.pos + (bracket.type === 'image' ? 2 : 1)\n      var linkTextEnd = pos\n      flushText(pos)\n      var afterBracket = pos + 1\n      var linkChildren = buildLinkChildren(result, bracket)\n      var hasNestedLink = bracket.type === 'link' && containsLink(linkChildren)\n      var foundRefBrackets = false\n\n      if (\n        !hasNestedLink &&\n        afterBracket < end &&\n        source[afterBracket] === '('\n      ) {\n        var urlResult = parseUrlAndTitle(source, afterBracket + 1, true)\n        if (urlResult) {\n          finalizeLinkOrImageNode(\n            result,\n            delimiterStack,\n            bracketStack,\n            bracket,\n            linkTextStart,\n            linkTextEnd,\n            options.sanitizer(\n              unescapeUrlOrTitle(urlResult.target),\n              'a',\n              'href'\n            ),\n            urlResult.title ? unescapeUrlOrTitle(urlResult.title) : undefined\n          )\n          pos = urlResult.endPos\n          textStart = pos\n          continue\n        }\n      }\n\n      var refs = state.refs || {}\n      util.hasKeys(refs);\n      var refLabel: string | null = null\n      var refEnd = pos\n      if (afterBracket < end && source[afterBracket] === '[') {\n        var refStart = afterBracket + 1\n        var i = refStart\n        while (i < end && source[i] !== ']') i++\n        if (i < end) {\n          refLabel = source.slice(refStart, i)\n          refEnd = i\n          foundRefBrackets = true\n        }\n      }\n      if (!foundRefBrackets || refLabel === '')\n        refLabel = source.slice(linkTextStart, linkTextEnd)\n      var normalizedRef = normalizeReferenceLabel(refLabel)\n      if (!hasNestedLink && refs && refs[normalizedRef]) {\n        var ref = refs[normalizedRef]\n        finalizeLinkOrImageNode(\n          result,\n          delimiterStack,\n          bracketStack,\n          bracket,\n          linkTextStart,\n          linkTextEnd,\n          ref.target,\n          ref.title\n        )\n        pos = refEnd + 1\n        textStart = pos\n        continue\n      }\n\n      var bracketResultIdx = bracket.resultIdx\n      bracketStack.pop()\n      result.length = bracketResultIdx\n\n      if (isStreaming) {\n        // Streaming mode: keep link children without brackets\n        result.push(...linkChildren)\n        // If there was a ( after ], this is an incomplete link - truncate here\n        if (afterBracket < end && source[afterBracket] === '(') {\n          // Don't process anything after the incomplete link syntax\n          return result\n        }\n      } else {\n        // Normal mode: insert brackets and content as text\n        if (bracket.type === 'image')\n          result.push({\n            type: RuleType.text,\n            text: '!',\n          } as MarkdownToJSX.TextNode)\n        result.push(\n          { type: RuleType.text, text: '[' } as MarkdownToJSX.TextNode,\n          ...linkChildren,\n          { type: RuleType.text, text: ']' } as MarkdownToJSX.TextNode\n        )\n      }\n\n      for (var k = 0; k < delimiterStack.length; k++) {\n        if (delimiterStack[k].nodeIndex >= bracketResultIdx)\n          delimiterStack[k].nodeIndex++\n      }\n      pos++\n      textStart = pos\n      continue\n    }\n\n    // ========================================\n    // EMPHASIS AND STRIKETHROUGH DELIMITERS (*, _, ~~, ==)\n    // ========================================\n    if (\n      code === $.CHAR_ASTERISK ||\n      code === $.CHAR_UNDERSCORE ||\n      code === $.CHAR_TILDE ||\n      code === $.CHAR_EQ\n    ) {\n      var delimChar = source[pos]\n      var delimStart = pos\n      var delimCount = countConsecutiveChars(source, pos, delimChar)\n\n      // GFM strikethrough (~~) and marked text (==) require exactly 2 delimiters\n      if ((delimChar === '~' || delimChar === '=') && delimCount !== 2) {\n        pos++\n        continue\n      }\n\n      var delimiterEnd = delimStart + delimCount\n      var leftFlanking = checkFlanking(source, delimStart, delimiterEnd, end, 0)\n      var rightFlanking = checkFlanking(\n        source,\n        delimStart,\n        delimiterEnd,\n        start,\n        1\n      )\n      var canOpen = leftFlanking\n      var canClose = rightFlanking\n      if (delimChar === '_' && leftFlanking && rightFlanking) {\n        if (delimStart > 0) {\n          var precedingChar = source[delimStart - 1]\n          var precedingCode = charCode(precedingChar)\n          canOpen = isPunctuation(precedingCode, precedingChar)\n        }\n        if (delimiterEnd < end) {\n          var followingChar = source[delimiterEnd]\n          var followingCode = charCode(followingChar)\n          canClose = isPunctuation(followingCode, followingChar)\n        }\n      }\n      flushText(delimStart)\n      delimiterStack.push({\n        nodeIndex: result.length,\n        type: delimChar as '*' | '_' | '~' | '=',\n        length: delimCount,\n        canOpen: canOpen,\n        canClose: canClose,\n        active: true,\n        sourcePos: delimStart,\n        inAnchor: inAnchor,\n      })\n      result.push({\n        type: RuleType.text,\n        text: source.slice(delimStart, delimStart + delimCount),\n      } as MarkdownToJSX.TextNode)\n\n      pos = delimStart + delimCount\n      textStart = pos\n      continue\n    }\n\n    // ========================================\n    // LINE BREAKS\n    // ========================================\n    if (code === $.CHAR_NEWLINE) {\n      var checkPos = pos - 1\n      var spaceCount = 0\n      while (\n        checkPos >= textStart &&\n        charCode(source, checkPos) === $.CHAR_SPACE\n      ) {\n        spaceCount++\n        checkPos--\n      }\n      if (spaceCount >= 2) {\n        var afterNewline = pos + 1\n        while (\n          afterNewline < end &&\n          charCode(source, afterNewline) === $.CHAR_SPACE\n        )\n          afterNewline++\n        if (afterNewline >= end) {\n          flushText(checkPos + 1)\n          pos = end\n          textStart = end\n          continue\n        }\n        flushText(checkPos + 1)\n        result.push({ type: RuleType.breakLine } as MarkdownToJSX.BreakLineNode)\n        pos++\n        while (pos < end && charCode(source, pos) === $.CHAR_SPACE) pos++\n        textStart = pos\n        continue\n      }\n\n      var prevCode = pos > textStart ? charCode(source, pos - 1) : 0\n      var nextCode = pos + 1 < end ? charCode(source, pos + 1) : 0\n      var flushPos =\n        pos > textStart &&\n        prevCode === $.CHAR_SPACE &&\n        nextCode === $.CHAR_SPACE\n          ? pos - 1\n          : pos\n      flushText(flushPos)\n      result.push({ type: RuleType.text, text: '\\n' } as MarkdownToJSX.TextNode)\n      textStart = pos + 1\n      if (\n        pos > start &&\n        prevCode === $.CHAR_SPACE &&\n        textStart < end &&\n        charCode(source, textStart) === $.CHAR_SPACE\n      )\n        textStart++\n      pos = textStart\n      continue\n    }\n\n    if (code === $.CHAR_AMPERSAND) hasAmpersand = true\n    pos++\n    while (pos < end) {\n      var code = charCode(source, pos)\n      if (code >= $.CHAR_ASCII_BOUNDARY) break\n      if (code === $.CHAR_AMPERSAND) hasAmpersand = true\n      var lookupCharType = util.inlineCharTypeTable[code]\n      if (lookupCharType === 0) {\n        pos++\n        continue\n      }\n      if (\n        lookupCharType === 1 &&\n        (code === $.CHAR_f || code === $.CHAR_H || code === $.CHAR_W) &&\n        skipAutoLink\n      ) {\n        pos++\n        continue\n      }\n      break\n    }\n  }\n\n  flushText(pos)\n\n  // Process emphasis using delimiter stack algorithm\n  if (delimiterStack.length) {\n    processEmphasis(result, delimiterStack, null)\n  }\n\n  // Streaming optimization: remove unclosed syntax markers while keeping content\n  if (isStreaming) {\n    var cutoffIdx = result.length\n\n    // Check for unclosed non-void HTML elements and remove them (reverse order)\n    for (var hi = htmlElementIndices.length - 1; hi >= 0; hi--) {\n      var htmlIdx = htmlElementIndices[hi]\n      if (\n        htmlIdx < result.length &&\n        result[htmlIdx].type === RuleType.htmlBlock\n      ) {\n        var htmlNode = result[htmlIdx] as MarkdownToJSX.HTMLNode\n        // Check if this is a non-void element with no children (likely unclosed)\n        if (\n          !util.isVoidElement(htmlNode.tag) &&\n          (!htmlNode.children || htmlNode.children.length === 0)\n        ) {\n          // Remove just the HTML element, keeping content after\n          result.splice(htmlIdx, 1)\n          // Adjust other tracking indices\n          if (htmlIdx < cutoffIdx) cutoffIdx--\n          for (var k = 0; k < delimiterStack.length; k++) {\n            if (delimiterStack[k].nodeIndex > htmlIdx) {\n              delimiterStack[k].nodeIndex--\n            }\n          }\n          for (var k = hi + 1; k < htmlElementIndices.length; k++) {\n            if (htmlElementIndices[k] > htmlIdx) {\n              htmlElementIndices[k]--\n            }\n          }\n        }\n      }\n    }\n\n    // Find earliest incomplete syntax position\n    if (incompleteBacktickPos !== -1 && incompleteBacktickPos < cutoffIdx) {\n      // Find the result node index at this source position\n      for (var ri = result.length - 1; ri >= 0; ri--) {\n        if (result[ri].type === RuleType.text) {\n          // Approximate - if this text node might contain the backticks, truncate here\n          cutoffIdx = ri\n          break\n        }\n      }\n    }\n\n    if (incompleteHTMLPos !== -1 && incompleteHTMLPos < cutoffIdx) {\n      // Find the result node index at this source position\n      for (var ri = result.length - 1; ri >= 0; ri--) {\n        if (result[ri].type === RuleType.text) {\n          // Approximate - if this text node might contain the HTML start, truncate here\n          cutoffIdx = ri\n          break\n        }\n      }\n    }\n\n    // Remove unmatched delimiter text nodes (reverse order to preserve indices)\n    for (var i = delimiterStack.length - 1; i >= 0; i--) {\n      if (delimiterStack[i].active && delimiterStack[i].nodeIndex < cutoffIdx) {\n        result.splice(delimiterStack[i].nodeIndex, 1)\n        // Adjust cutoff and other indices\n        if (delimiterStack[i].nodeIndex < cutoffIdx) cutoffIdx--\n        // Adjust indices for remaining delimiters\n        for (var j = 0; j < i; j++) {\n          if (delimiterStack[j].nodeIndex > delimiterStack[i].nodeIndex) {\n            delimiterStack[j].nodeIndex--\n          }\n        }\n      }\n    }\n\n    // Truncate at incomplete syntax if found\n    if (cutoffIdx < result.length) {\n      result.length = cutoffIdx\n    }\n\n    // Skip bracket insertion entirely - content is already in result\n    return result\n  }\n\n  // Insert bracket text nodes in forward order (more efficient than reverse splices)\n  if (bracketStack.length) {\n    bracketStack.sort(function (a, b) {\n      return a.resultIdx - b.resultIdx\n    })\n    for (var i = 0; i < bracketStack.length; i++) {\n      result.splice(bracketStack[i].resultIdx + i, 0, {\n        type: RuleType.text,\n        text: bracketStack[i].type === 'image' ? '![' : '[',\n      } as MarkdownToJSX.TextNode)\n    }\n  }\n\n  return result\n}\n\n// Helper: Process emphasis within link/image text and update delimiter stack\nfunction processEmphasisInLinkText(\n  result: MarkdownToJSX.ASTNode[],\n  delimiterStack: DelimiterEntry[],\n  bracket: BracketEntry,\n  linkTextStart: number,\n  linkTextEnd: number\n): void {\n  var hasDelims = false\n  for (var di = 0; di < delimiterStack.length; di++) {\n    if (\n      delimiterStack[di].sourcePos >= linkTextStart &&\n      delimiterStack[di].sourcePos < linkTextEnd\n    ) {\n      hasDelims = true\n      break\n    }\n  }\n  if (!hasDelims) return\n\n  var tempNodes = buildLinkChildren(result, bracket)\n  var tempDelims: DelimiterEntry[] = []\n  for (var di = 0; di < delimiterStack.length; di++) {\n    var delim = delimiterStack[di]\n    if (delim.sourcePos >= linkTextStart && delim.sourcePos < linkTextEnd) {\n      tempDelims.push({\n        nodeIndex: delim.nodeIndex - bracket.resultIdx,\n        type: delim.type,\n        length: delim.length,\n        canOpen: delim.canOpen,\n        canClose: delim.canClose,\n        active: delim.active,\n        sourcePos: delim.sourcePos,\n        inAnchor: delim.inAnchor,\n      })\n    }\n  }\n  processEmphasis(tempNodes, tempDelims, null)\n  result.length = bracket.resultIdx\n  for (var i = 0; i < tempNodes.length; i++) result.push(tempNodes[i])\n  var newDelimStack: DelimiterEntry[] = []\n  for (var di = 0; di < delimiterStack.length; di++) {\n    if (\n      delimiterStack[di].sourcePos < linkTextStart ||\n      delimiterStack[di].sourcePos >= linkTextEnd\n    ) {\n      newDelimStack.push(delimiterStack[di])\n    }\n  }\n  delimiterStack.length = 0\n  for (var i = 0; i < newDelimStack.length; i++)\n    delimiterStack.push(newDelimStack[i])\n}\n\n// Helper: Create link or image node from children and target/title\nfunction createLinkOrImageNode(\n  bracket: BracketEntry,\n  linkChildren: MarkdownToJSX.ASTNode[],\n  target: string | null,\n  title: string | undefined\n): MarkdownToJSX.ASTNode {\n  if (bracket.type === 'link') {\n    return {\n      type: RuleType.link,\n      target: target,\n      title: title,\n      children: linkChildren,\n    } as MarkdownToJSX.LinkNode\n  }\n  return {\n    type: RuleType.image,\n    target: target || '',\n    alt: extractAllTextFromNodes(linkChildren),\n    title: title,\n  } as MarkdownToJSX.ImageNode\n}\n\nfunction buildLinkChildren(\n  result: MarkdownToJSX.ASTNode[],\n  bracket: BracketEntry\n): MarkdownToJSX.ASTNode[] {\n  return result.slice(bracket.resultIdx)\n}\n\nfunction finalizeLinkOrImageNode(\n  result: MarkdownToJSX.ASTNode[],\n  delimiterStack: DelimiterEntry[],\n  bracketStack: BracketEntry[],\n  bracket: BracketEntry,\n  linkTextStart: number,\n  linkTextEnd: number,\n  target: string | null,\n  title: string | undefined\n): void {\n  processEmphasisInLinkText(\n    result,\n    delimiterStack,\n    bracket,\n    linkTextStart,\n    linkTextEnd\n  )\n  var linkChildren = buildLinkChildren(result, bracket)\n  bracketStack.pop()\n  result.length = bracket.resultIdx\n  result.push(createLinkOrImageNode(bracket, linkChildren, target, title))\n}\n\n/** Parse URL and optional title from parentheses: (url \"title\") */\n// Parse link destination (URL) - handles angle brackets and regular URLs\nfunction parseLinkDestination(\n  source: string,\n  start: number,\n  allowNestedParens: boolean\n): { target: string; endPos: number; hadSpace: boolean } | null {\n  let i = util.skipWhitespace(source, start)\n  const hasAngleBrackets = i < source.length && source[i] === '<'\n  if (hasAngleBrackets) i++\n  const actualUrlStart = i\n\n  // Handle empty angle brackets <>\n  if (hasAngleBrackets && i < source.length && source[i] === '>') {\n    return { target: '', endPos: i + 1, hadSpace: false }\n  }\n\n  let target: string\n  let urlEnd: number\n  var foundSpace = false\n\n  if (hasAngleBrackets) {\n    // For angle bracket URLs, parse until '>', allowing spaces and handling escapes\n    urlEnd = i\n    while (urlEnd < source.length && source[urlEnd] !== '>') {\n      const c = source[urlEnd]\n      if (c === '\\n' || c === '\\r' || c === '<') return null\n      if (c === '\\\\') {\n        urlEnd += 2\n        continue\n      }\n      urlEnd++\n    }\n    if (urlEnd >= source.length || source[urlEnd] !== '>') return null\n    urlEnd++\n    // Trim leading and trailing whitespace inside < >\n    let actualStart = actualUrlStart\n    while (actualStart < urlEnd - 1 && isSpaceOrTab(source[actualStart]))\n      actualStart++\n    let actualEnd = urlEnd - 1\n    while (actualEnd > actualStart && isSpaceOrTab(source[actualEnd - 1]))\n      actualEnd--\n    target = source.slice(actualStart, actualEnd)\n    i = urlEnd\n  } else {\n    // Non-angle bracket URL: break on whitespace, newline\n    let parenDepth = 0\n    urlEnd = i\n    while (urlEnd < source.length) {\n      const c = source[urlEnd]\n      if (c === ' ' || c === '\\t' || c === '\\n') {\n        foundSpace = true\n        break\n      }\n      if (!allowNestedParens && c === ')') break\n      if (allowNestedParens && c === '(') {\n        if (urlEnd > 0 && source[urlEnd - 1] === '\\\\') {\n          urlEnd++\n          continue\n        }\n        parenDepth++\n        urlEnd++\n        continue\n      }\n      if (allowNestedParens && c === ')') {\n        if (urlEnd > 0 && source[urlEnd - 1] === '\\\\') {\n          urlEnd++\n          continue\n        }\n        if (parenDepth === 0) break\n        parenDepth--\n        urlEnd++\n        continue\n      }\n      urlEnd++\n    }\n    target = source.slice(actualUrlStart, urlEnd)\n    i = urlEnd\n  }\n\n  return { target, endPos: i, hadSpace: foundSpace }\n}\n\n// Parse link title - handles quoted and parenthesized titles\nfunction parseLinkTitle(\n  source: string,\n  start: number,\n  hadSpaceInUrl: boolean,\n  hasAngleBrackets: boolean\n): { title: string | undefined; endPos: number } {\n  let i = start\n  // Skip whitespace after URL\n  let newlineCount = 0\n  while (i < source.length) {\n    const c = source[i]\n    if (isSpaceOrTab(c)) {\n      i++\n    } else if (c === '\\n') {\n      if (newlineCount >= 1) break\n      newlineCount++\n      i++\n    } else if (util.isUnicodeWhitespace(c)) {\n      break\n    } else {\n      break\n    }\n  }\n\n  // If URL contained spaces and there's no title delimiter, the link is invalid\n  if (hadSpaceInUrl && !hasAngleBrackets) {\n    if (\n      i >= source.length ||\n      (source[i] !== '\"' && source[i] !== \"'\" && source[i] !== '(')\n    ) {\n      return { title: undefined, endPos: i }\n    }\n  }\n  let title: string | undefined = undefined\n  if (i < source.length) {\n    const titleChar = source[i]\n    if (titleChar === '\"' || titleChar === \"'\") {\n      i++\n      const titleStart = i\n      while (i < source.length && source[i] !== titleChar) {\n        if (source[i] === '\\\\') i++\n        i++\n      }\n      if (i < source.length) {\n        title = source.slice(titleStart, i)\n        i++\n      }\n    } else if (titleChar === '(') {\n      i++\n      const titleStart = i\n      let parenDepth = 1\n      while (i < source.length && parenDepth > 0) {\n        if (source[i] === '\\\\' && i + 1 < source.length) i++\n        else if (source[i] === '(') parenDepth++\n        else if (source[i] === ')') parenDepth--\n        i++\n      }\n      if (parenDepth === 0) {\n        title = source.slice(titleStart, i - 1)\n      }\n    }\n  }\n\n  i = util.skipWhitespace(source, i)\n  return { title, endPos: i }\n}\n\nfunction parseUrlAndTitle(\n  source: string,\n  urlStart: number,\n  allowNestedParens: boolean\n): { target: string; title: string | undefined; endPos: number } | null {\n  const destResult = parseLinkDestination(source, urlStart, allowNestedParens)\n  if (!destResult) return null\n\n  let i = urlStart\n  i = util.skipWhitespace(source, i)\n  const hasAngleBrackets = i < source.length && source[i] === '<'\n\n  // Handle empty angle brackets <>\n  if (\n    hasAngleBrackets &&\n    destResult.target === '' &&\n    destResult.endPos === i + 2\n  ) {\n    const titleResult = parseLinkTitle(\n      source,\n      destResult.endPos,\n      false,\n      hasAngleBrackets\n    )\n    if (\n      titleResult.endPos >= source.length ||\n      source[titleResult.endPos] !== ')'\n    )\n      return null\n    return {\n      target: '',\n      title: titleResult.title,\n      endPos: titleResult.endPos + 1,\n    }\n  }\n\n  const titleResult = parseLinkTitle(\n    source,\n    destResult.endPos,\n    destResult.hadSpace,\n    hasAngleBrackets\n  )\n  if (titleResult.endPos >= source.length || source[titleResult.endPos] !== ')')\n    return null\n\n  return {\n    target: destResult.target,\n    title: titleResult.title,\n    endPos: titleResult.endPos + 1,\n  }\n}\n\nenum AutolinkMode {\n  URI,\n  EMAIL,\n  ANGLE,\n}\n\nfunction isAlphaCode(code: number): boolean {\n  return (\n    (code >= $.CHAR_A && code <= $.CHAR_Z) ||\n    (code >= $.CHAR_a && code <= $.CHAR_z)\n  )\n}\n\nfunction isValidUriScheme(content: string): boolean {\n  const colonPos = content.indexOf(':')\n  if (colonPos < 2 || colonPos > 32) return false\n\n  const firstCharCode = charCode(content)\n  if (!isAlphaCode(firstCharCode)) {\n    return false\n  }\n\n  // Check if all chars before colon are valid scheme chars\n  for (let j = 1; j < colonPos; j++) {\n    const c = content[j]\n    const cCode = charCode(c)\n    if (!isAlnum(c) && c !== '+' && c !== '.' && c !== '-') {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isValidAutolinkContext(\n  source: string,\n  start: number,\n  includeCR: boolean\n): boolean {\n  if (start === 0) return true\n  let validChars = includeCR ? ' \\t\\n\\r*_~(' : ' \\t\\n*_~('\n  return validChars.indexOf(source[start - 1]) !== -1\n}\n\nfunction sanitizeAndCreate(\n  target: string,\n  linkText: string,\n  endPos: number,\n  sanitizer: (url: string, tag: string, attr: string) => string | null,\n  emailStart?: number\n): ParseResult | null {\n  let safe = sanitizer(target, 'a', 'href')\n  if (!safe) return null\n  return {\n    type: RuleType.link,\n    target: safe,\n    children: [{ type: RuleType.text, text: linkText }],\n    endPos: endPos,\n    ...(emailStart !== undefined ? { emailStart } : {}),\n  } as MarkdownToJSX.LinkNode & { endPos: number; emailStart?: number }\n}\n\nfunction parseAutolink(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  mode: AutolinkMode\n): ParseResult | null {\n  if (\n    state.inAnchor ||\n    (mode !== AutolinkMode.ANGLE && options.disableAutoLink)\n  )\n    return null\n\n  if (mode === AutolinkMode.ANGLE) {\n    if (source[pos] !== '<') return null\n    let end = pos + 1\n    while (end < source.length && source[end] !== '>') {\n      const endCode = charCode(source, end)\n      if (\n        endCode === $.CHAR_SPACE ||\n        endCode === $.CHAR_TAB ||\n        endCode === $.CHAR_NEWLINE ||\n        endCode === $.CHAR_CR ||\n        endCode < $.CHAR_SPACE\n      )\n        return null\n      end++\n    }\n    if (end >= source.length || source[end] !== '>') return null\n    let content = source.slice(pos + 1, end)\n    if (!content.length) return null\n\n    let hasBackslash = content.indexOf('\\\\') !== -1\n    let hasValidUriScheme = isValidUriScheme(content)\n    let isHttp =\n      util.startsWith(content, 'http://') ||\n      util.startsWith(content, 'https://')\n    let isMailto = false\n    if (!hasValidUriScheme && !isHttp && content.length >= 7) {\n      const firstChar = content[0]\n      if (firstChar === 'm' || firstChar === 'M') {\n        const contentLower = content.toLowerCase()\n        if (util.startsWith(contentLower, 'mailto:')) {\n          isMailto = true\n          let colonPos = contentLower.indexOf(':')\n          let mailtoText = content.slice(colonPos + 1)\n          return sanitizeAndCreate(\n            'mailto:' + mailtoText,\n            content,\n            end + 1,\n            options.sanitizer\n          )\n        }\n      }\n    }\n    let isEmailLike =\n      !hasBackslash &&\n      content.indexOf('@') !== -1 &&\n      content.indexOf('//') === -1 &&\n      !hasValidUriScheme\n\n    if (!isHttp && !isMailto && !isEmailLike && !hasValidUriScheme) return null\n\n    let target = content,\n      linkText = content\n    if (!isMailto && !hasValidUriScheme && !isHttp && isEmailLike) {\n      target = 'mailto:' + content\n    }\n\n    return sanitizeAndCreate(target, linkText, end + 1, options.sanitizer)\n  }\n\n  if (mode === AutolinkMode.EMAIL) {\n    let emailStart = pos\n    while (\n      emailStart > 0 &&\n      (isAlnum(source[emailStart - 1]) ||\n        '.+-_'.indexOf(source[emailStart - 1]) !== -1)\n    )\n      emailStart--\n    if (emailStart >= pos || !isValidAutolinkContext(source, emailStart, true))\n      return null\n\n    let emailEnd = pos + 1\n    let hasDot = false\n    while (emailEnd < source.length) {\n      let c = source[emailEnd]\n      if (c === '.') {\n        hasDot = true\n        emailEnd++\n      } else if (isAlnum(c) || c === '-' || c === '_') emailEnd++\n      else break\n    }\n\n    if (!hasDot || emailEnd <= pos + 1) return null\n    while (emailEnd > pos + 1 && source[emailEnd - 1] === '.') emailEnd--\n    if (\n      emailEnd > pos + 1 &&\n      (source[emailEnd - 1] === '-' || source[emailEnd - 1] === '_')\n    )\n      return null\n    // Check if email contains at least one dot\n    // For large documents, prefer slice+includes to avoid scanning entire document\n    const emailLength = emailEnd - (pos + 1)\n    if (emailLength < 10000) {\n      if (\n        source.indexOf('.', pos + 1) >= emailEnd ||\n        source.indexOf('.', pos + 1) === -1\n      )\n        return null\n    } else {\n      if (source.slice(pos + 1, emailEnd).indexOf('.') === -1) return null\n    }\n\n    let email = source.slice(emailStart, emailEnd)\n    return sanitizeAndCreate(\n      'mailto:' + email,\n      email,\n      emailEnd,\n      options.sanitizer,\n      emailStart\n    )\n  }\n\n  let isHttp =\n    util.startsWith(source, 'http://', pos) ||\n    util.startsWith(source, 'https://', pos)\n  let isFtp = !isHttp && util.startsWith(source, 'ftp://', pos)\n  let isWww = !isHttp && !isFtp && util.startsWith(source, 'www.', pos)\n  if (\n    !(isHttp || isFtp || isWww) ||\n    !isValidAutolinkContext(source, pos, false)\n  )\n    return null\n\n  var urlEnd =\n    pos +\n    (isHttp ? (charCode(source, pos + 4) === $.CHAR_s ? 8 : 7) : isFtp ? 6 : 4)\n  var domainStart = urlEnd\n  // Inline scanDomain\n  while (urlEnd < source.length) {\n    const code = charCode(source, urlEnd)\n    if (\n      code === $.CHAR_SPACE ||\n      code === $.CHAR_TAB ||\n      code === $.CHAR_NEWLINE ||\n      code === $.CHAR_LT ||\n      code === $.CHAR_GT\n    )\n      break\n    urlEnd++\n  }\n  if (urlEnd <= domainStart) return null\n  // Inline trimTrailingPunct\n  let trimmed = urlEnd\n  while (trimmed > domainStart) {\n    let lastChar = source[trimmed - 1]\n    if (trimmed > domainStart + 1 && source[trimmed - 2] === '\\\\') break\n    if (\n      lastChar === '?' ||\n      lastChar === '!' ||\n      lastChar === '.' ||\n      lastChar === ',' ||\n      lastChar === ':' ||\n      lastChar === '*' ||\n      lastChar === '_' ||\n      lastChar === '~'\n    ) {\n      trimmed--\n    } else if (lastChar === ';') {\n      let ampPos = trimmed - 2\n      while (\n        ampPos >= domainStart &&\n        source[ampPos] !== '&' &&\n        source[ampPos] !== ' '\n      )\n        ampPos--\n      if (ampPos >= domainStart && source[ampPos] === '&') {\n        let entityName = source.slice(ampPos + 1, trimmed - 1)\n        if (\n          entityName.length >= 2 &&\n          entityName.length <= 10 &&\n          /^[a-zA-Z0-9]+$/.test(entityName) &&\n          (entityName === 'lt' ||\n            entityName === 'gt' ||\n            (entityName.length >= 3 &&\n              (util.startsWith(entityName, 'amp') ||\n                util.startsWith(entityName, 'apos') ||\n                util.startsWith(entityName, 'quot') ||\n                util.startsWith(entityName, 'nbsp') ||\n                /^[a-z]{3,10}$/.test(entityName))))\n        )\n          break\n        trimmed = ampPos\n        break\n      }\n      trimmed--\n    } else if (lastChar === ')') {\n      let openCount = 0,\n        closeCount = 0\n      for (let i = domainStart; i < trimmed; i++) {\n        if (source[i] === '(') openCount++\n        if (source[i] === ')') closeCount++\n      }\n      if (closeCount > openCount) trimmed--\n      else break\n    } else break\n  }\n  urlEnd = trimmed\n  if (urlEnd <= domainStart) return null\n\n  var domainEnd = domainStart\n  var lastDot = -1\n  var secondLastDot = -1\n  while (domainEnd < urlEnd) {\n    const domainCode = charCode(source, domainEnd)\n    if (\n      (domainCode >= $.CHAR_A && domainCode <= $.CHAR_Z) ||\n      (domainCode >= $.CHAR_a && domainCode <= $.CHAR_z) ||\n      (domainCode >= $.CHAR_DIGIT_0 && domainCode <= $.CHAR_DIGIT_9) ||\n      domainCode === $.CHAR_DASH ||\n      domainCode === $.CHAR_UNDERSCORE ||\n      domainCode === $.CHAR_PERIOD\n    ) {\n      if (domainCode === $.CHAR_PERIOD) {\n        secondLastDot = lastDot\n        lastDot = domainEnd\n      }\n      domainEnd++\n      continue\n    }\n    break\n  }\n  if (domainEnd === domainStart || lastDot === -1) return null\n  if (secondLastDot === -1) secondLastDot = domainStart - 1\n  for (let i = secondLastDot + 1; i < lastDot; i++) {\n    if (source[i] === '_') return null\n  }\n  for (let i = lastDot + 1; i < domainEnd; i++) {\n    if (source[i] === '_') return null\n  }\n\n  let linkText = source.slice(pos, urlEnd)\n  return sanitizeAndCreate(\n    isWww ? 'http://' + linkText : linkText,\n    linkText,\n    urlEnd,\n    options.sanitizer\n  )\n}\n\n// Unified link/image parser - handles all link/image types based on starting character\nfunction parseLinkOrImage(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  startChar: '[' | '!' | '<' | 'h' | 'f' | 'w' | '@'\n): ParseResult | null {\n  // Angle brace autolink: <url>\n  if (startChar === '<') {\n    return parseAutolink(\n      source,\n      pos,\n      state,\n      options,\n      AutolinkMode.ANGLE\n    ) as ParseResult\n  }\n\n  // Bare URL autolink: http://, https://, ftp://, www.\n  if (startChar === 'h' || startChar === 'f' || startChar === 'w') {\n    return parseAutolink(\n      source,\n      pos,\n      state,\n      options,\n      AutolinkMode.URI\n    ) as ParseResult\n  }\n\n  // Email autolink: @example.com\n  if (startChar === '@') {\n    return parseAutolink(\n      source,\n      pos,\n      state,\n      options,\n      AutolinkMode.EMAIL\n    ) as ParseResult | null\n  }\n\n  // Bracket-based links/images are handled inline in parseInlineSpan\n  // This function only handles autolinks\n  return null\n}\n\nfunction normalizeReferenceLabel(label: string): string {\n  var trimmed = label.trim()\n  var normalized = trimmed.replace(/[\\s\\t\\n\\r]+/g, ' ')\n  if (normalized.indexOf('\\u1E9E') !== -1) {\n    return normalized.replace(/\\u1E9E/g, 'ss').toLowerCase();\n  }\n  return normalized.toLowerCase()\n}\n\nfunction parseGFMTask(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State\n): ParseResult {\n  if (pos + 3 >= source.length || source[pos] !== '[') return null\n  const marker = source[pos + 1]\n  if (marker !== ' ' && marker !== 'x' && marker !== 'X') return null\n  if (source[pos + 2] !== ']') return null\n  return {\n    type: RuleType.gfmTask,\n    completed: marker.toLowerCase() === 'x',\n    endPos: pos + 3,\n  } as MarkdownToJSX.GFMTaskNode & { endPos: number }\n}\n\nfunction parseBlocksWithState(\n  content: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  config: { inline?: boolean; list?: boolean; inBlockQuote?: boolean }\n): MarkdownToJSX.ASTNode[] {\n  const originalInline = state.inline\n  const originalList = state.inList\n  const originalInBlockQuote = state.inBlockQuote\n  if (config.inline !== undefined) state.inline = config.inline\n  if (config.list !== undefined) state.inList = config.list\n  if (config.inBlockQuote !== undefined)\n    state.inBlockQuote = config.inBlockQuote\n  const blocks = parseBlocksInHTML(content, state, options)\n  state.inline = originalInline\n  state.inList = originalList\n  state.inBlockQuote = originalInBlockQuote\n  return blocks\n}\n\nfunction parseInlineWithState(\n  content: string,\n  start: number,\n  end: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  return parseWithInlineMode(state, true, () =>\n    parseInlineSpan(content, start, end, state, options)\n  )\n}\n\ntype BlockParserFn = (\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n) => ParseResult | null\n\nfunction parseBlock(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult | null {\n  var char = source[pos]\n  if (char === undefined) return null\n  var effectivePos = pos\n  var indentInfo: ReturnType<typeof calculateIndent> | null = null\n  var firstChar = char\n  var lineEnd: number | null = null\n\n  var charCodeVal = charCode(char)\n  var isIndentChar = charCodeVal === $.CHAR_SPACE || charCodeVal === $.CHAR_TAB\n  if (isIndentChar) {\n    lineEnd = util.findLineEnd(source, pos)\n    indentInfo = calculateIndent(source, pos, lineEnd)\n    effectivePos = pos + indentInfo.charCount\n    if (effectivePos >= source.length) return parseCodeBlock(source, pos, state)\n    firstChar = source[effectivePos]\n  }\n  var spaceEquivalent = indentInfo ? indentInfo.spaceEquivalent : 0\n  if (spaceEquivalent >= 4) {\n    if (isIndentChar) return parseCodeBlock(source, pos, state)\n    return null\n  }\n  var firstCharCode = charCode(firstChar)\n  if (firstCharCode === $.CHAR_GT) {\n    var blockQuoteResult = parseBlockQuote(source, pos, state, options)\n    if (blockQuoteResult) return blockQuoteResult\n  } else if (firstCharCode === $.CHAR_UNDERSCORE) {\n    return parseBreakThematic(source, pos, state, options)\n  } else if (\n    firstCharCode === $.CHAR_DASH ||\n    firstCharCode === $.CHAR_ASTERISK ||\n    firstCharCode === $.CHAR_PLUS\n  ) {\n    var thematicBreakResult = parseBreakThematic(source, pos, state, options)\n    if (thematicBreakResult) return thematicBreakResult\n    var listResult = parseList(source, pos, state, options)\n    if (listResult) return listResult\n  } else if (\n    firstCharCode >= $.CHAR_DIGIT_0 &&\n    firstCharCode <= $.CHAR_DIGIT_9\n  ) {\n    var listResult = parseList(source, pos, state, options)\n    if (listResult) return listResult\n  } else if (firstCharCode === $.CHAR_HASH) {\n    return parseHeading(source, effectivePos, state, options)\n  } else if (firstCharCode === $.CHAR_BRACKET_OPEN) {\n    return parseDefinition(\n      source,\n      effectivePos,\n      state,\n      options,\n      effectivePos + 1 < source.length &&\n        charCode(source, effectivePos + 1) === $.CHAR_CARET\n    )\n  } else if (firstCharCode === $.CHAR_LT && !options.disableParsingRawHTML) {\n    return parseHTML(source, effectivePos, state, options)\n  } else if (\n    firstCharCode === $.CHAR_BACKTICK ||\n    firstCharCode === $.CHAR_TILDE\n  ) {\n    if (!lineEnd) lineEnd = util.findLineEnd(source, pos)\n    if (!indentInfo) indentInfo = calculateIndent(source, pos, lineEnd)\n    if (indentInfo.spaceEquivalent <= 3)\n      return parseCodeFenced(source, effectivePos, state, options)\n  } else if (firstCharCode === $.CHAR_PIPE) {\n    return parseTable(source, pos, state, options)\n  }\n  if (isIndentChar) return parseCodeBlock(source, pos, state)\n  return null\n}\n\n/** Parse blocks inside HTML content */\nfunction parseBlocksInHTML(\n  input: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  const result: MarkdownToJSX.ASTNode[] = []\n  let pos = 0\n\n  while (pos < input.length) {\n    while (pos < input.length && input[pos] === '\\n') {\n      pos++\n    }\n\n    if (pos >= input.length) break\n\n    var char = input[pos]\n\n    // Fast path: check for setext heading in list context\n    // Per CommonMark: setext headings take precedence over thematic breaks\n    if (state.inList && result.length > 0) {\n      var lastBlock = result[result.length - 1]\n      if (lastBlock?.type === RuleType.paragraph) {\n        var paragraph = lastBlock as MarkdownToJSX.ParagraphNode\n        // Quick check for potential setext underline characters\n        var code = charCode(char)\n        if (\n          code === $.CHAR_DASH ||\n          code === $.CHAR_EQ ||\n          code === $.CHAR_SPACE ||\n          code === $.CHAR_TAB\n        ) {\n          var lineEnd = util.findLineEnd(input, pos)\n          var lineContent = input.slice(pos, lineEnd)\n\n          // Check indentation (up to 3 spaces allowed for setext headings)\n          var indentInfo = calculateIndent(input, pos, lineEnd)\n          if (indentInfo.spaceEquivalent < 4) {\n            var trimmed = lineContent.slice(indentInfo.charCount).trim()\n            // Use convertSetextHeadingInListItem helper to check and convert\n            if (convertSetextHeadingInListItem(result, trimmed, options)) {\n              pos =\n                lineEnd +\n                (lineEnd < input.length && input[lineEnd] === '\\n' ? 1 : 0)\n              continue\n            }\n          }\n        }\n      }\n    }\n\n    // Try parseBlock first (handles most block types)\n    var blockResult = parseBlock(input, pos, state, options)\n    if (blockResult) {\n      result.push(blockResult)\n      pos = blockResult.endPos\n      continue\n    }\n\n    // Try setext heading (not handled by parseBlock)\n    var setextResult = parseHeadingSetext(input, pos, state, options)\n    if (setextResult) {\n      result.push(setextResult)\n      pos = setextResult.endPos\n      continue\n    }\n\n    var remaining = input.slice(pos).trim()\n    if (remaining) {\n      // Per CommonMark spec example 293: Before parsing a paragraph, check if there's\n      // a blockquote ending with a paragraph in recent blocks that this should merge into\n      if (state.inBlockQuote && result.length > 0) {\n        // Find the deepest blockquote ending with a paragraph in recent blocks\n        // (may be nested inside list items)\n        function findBlockquoteWithParagraphEnd(\n          node: MarkdownToJSX.ASTNode\n        ): MarkdownToJSX.ParagraphNode | null {\n          if (node.type === RuleType.blockQuote) {\n            var blockQuote = node as MarkdownToJSX.BlockQuoteNode\n            if (blockQuote.children && blockQuote.children.length > 0) {\n              var lastChild =\n                blockQuote.children[blockQuote.children.length - 1]\n              if (lastChild.type === RuleType.paragraph) {\n                return lastChild as MarkdownToJSX.ParagraphNode\n              }\n            }\n          } else if (\n            node.type === RuleType.orderedList ||\n            node.type === RuleType.unorderedList\n          ) {\n            var list = node as\n              | MarkdownToJSX.OrderedListNode\n              | MarkdownToJSX.UnorderedListNode\n            if (list.items && list.items.length > 0) {\n              var lastItem = list.items[list.items.length - 1]\n              if (lastItem && lastItem.length > 0) {\n                var lastItemChild = lastItem[lastItem.length - 1]\n                var found = findBlockquoteWithParagraphEnd(lastItemChild)\n                if (found) return found\n              }\n            }\n          }\n          return null\n        }\n\n        // Check recent blocks (from end) for blockquote ending with paragraph\n        for (var i = result.length - 1; i >= 0; i--) {\n          var paragraph = findBlockquoteWithParagraphEnd(result[i])\n          if (paragraph) {\n            var parseResult = parseParagraph(input, pos, state, options)\n            if (parseResult) {\n              var newParagraph = parseResult as MarkdownToJSX.ParagraphNode\n              // Merge the new paragraph's children into the blockquote's paragraph\n              if (paragraph.children && newParagraph.children) {\n                paragraph.children.push(\n                  { type: RuleType.text, text: '\\n' } as MarkdownToJSX.TextNode,\n                  ...newParagraph.children\n                )\n              }\n              pos = parseResult.endPos\n              continue\n            }\n          }\n        }\n      }\n\n      var parseResult = parseParagraph(input, pos, state, options)\n      if (parseResult) {\n        result.push(parseResult)\n        pos = parseResult.endPos\n        continue\n      }\n    }\n\n    pos++\n  }\n\n  return result\n}\n\nfunction parseHeading(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline) return null\n\n  // Find line end to limit expensive indentation scan\n  const lineEnd = util.findLineEnd(source, pos)\n  const indentResult = calculateIndent(source, pos, lineEnd, 3)\n  if (indentResult.spaceEquivalent > 3 && !state.inList) return null\n  var i = pos + indentResult.charCount\n\n  if (i >= source.length || source[i] !== '#') return null\n\n  const level = countConsecutiveChars(source, i, '#', 6)\n  i += level\n\n  if (i >= source.length) return null\n  const afterHash = source[i]\n  if (afterHash === '\\n' || afterHash === '\\r') {\n    const lineEnd = util.findLineEnd(source, i)\n    return {\n      ...createHeading(level, [], '', options.slugify),\n      endPos: lineEnd + (lineEnd < source.length ? 1 : 0),\n    } as MarkdownToJSX.HeadingNode & { endPos: number }\n  }\n  if (afterHash !== ' ' && afterHash !== '\\t') return null\n\n  const contentStart = i\n  const contentEnd = util.findLineEnd(source, contentStart)\n  var content = source\n    .slice(contentStart, contentEnd)\n    .replace(HEADING_TRAILING_HASHES_R, '')\n    .trim()\n\n  const children = parseInlineWithState(\n    content,\n    0,\n    content.length,\n    state,\n    options\n  )\n\n  return {\n    ...createHeading(level, children, content, options.slugify),\n    endPos: contentEnd + (contentEnd < source.length ? 1 : 0),\n  } as MarkdownToJSX.HeadingNode & { endPos: number }\n}\n\nfunction parseHeadingSetext(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline || state.inBlockQuote || state.inList) return null\n\n  const firstLineEnd = util.findLineEnd(source, pos)\n  if (firstLineEnd >= source.length) return null\n\n  // Find underline pattern first, then validate backwards\n  let underlineLineStart = skipToNextLine(source, firstLineEnd),\n    underlineLineEnd = -1,\n    underlineChar: string | null = null\n\n  // Scan forward for underline (= or - with up to 3 spaces indentation)\n  for (\n    var linesScanned = 0;\n    underlineLineStart < source.length && linesScanned < 10;\n    linesScanned++\n  ) {\n    const lineEnd = util.findLineEnd(source, underlineLineStart)\n    if (lineEnd >= source.length) break\n\n    // Check if blank line (stops setext headings)\n    var i = underlineLineStart\n    while (\n      i < lineEnd &&\n      (charCode(source, i) === $.CHAR_SPACE ||\n        charCode(source, i) === $.CHAR_TAB ||\n        charCode(source, i) === $.CHAR_CR)\n    )\n      i++\n    if (i >= lineEnd) break\n\n    // Check indentation (up to 3 spaces) and first char\n    var indentCount = 0,\n      checkPos = underlineLineStart\n    while (\n      checkPos < lineEnd &&\n      indentCount < 3 &&\n      charCode(source, checkPos) === $.CHAR_SPACE\n    ) {\n      indentCount++\n      checkPos++\n    }\n\n    if (checkPos < lineEnd) {\n      const code = charCode(source, checkPos)\n      if (code === $.CHAR_EQ || code === $.CHAR_DASH) {\n        // Validate underline: only = or - with optional trailing spaces, no internal spaces\n        const char = source[checkPos]\n        var underlineCount = 0,\n          hasSeenWS = false,\n          p = checkPos\n        while (p < lineEnd) {\n          const c = charCode(source, p)\n          if (c === code) {\n            if (hasSeenWS) {\n              underlineCount = 0\n              break\n            }\n            underlineCount++\n          } else if (c === $.CHAR_SPACE || c === $.CHAR_TAB) {\n            hasSeenWS = true\n          } else {\n            underlineCount = 0\n            break\n          }\n          p++\n        }\n\n        if (underlineCount >= 1) {\n          underlineLineEnd = lineEnd\n          underlineChar = char\n          break\n        }\n      }\n    }\n\n    underlineLineStart = skipToNextLine(source, lineEnd)\n  }\n\n  if (!underlineChar) return null\n\n  // Quick validation: content cannot start with certain block characters\n  const firstCharCode = charCode(source, pos)\n  if (\n    firstCharCode === $.CHAR_HASH ||\n    firstCharCode === $.CHAR_GT ||\n    source[pos] === '|'\n  )\n    return null\n\n  // Collect content lines forward to underline\n  let contentEnd = pos\n  var currentPos = pos,\n    hasContent = false\n\n  while (currentPos < underlineLineStart) {\n    const lineEnd = util.findLineEnd(source, currentPos)\n    if (lineEnd >= underlineLineStart) break\n\n    // Check if line has non-whitespace content\n    var j = currentPos\n    while (\n      j < lineEnd &&\n      (charCode(source, j) === $.CHAR_SPACE ||\n        charCode(source, j) === $.CHAR_TAB ||\n        charCode(source, j) === $.CHAR_CR)\n    )\n      j++\n    if (j < lineEnd) {\n      // Line has content\n      hasContent = true\n      contentEnd = lineEnd\n    }\n\n    currentPos = skipToNextLine(source, lineEnd)\n  }\n\n  if (!hasContent) return null\n\n  // Extract and trim content\n  const rawContent = source.slice(pos, contentEnd)\n  var startTrim = 0,\n    endTrim = rawContent.length\n  while (\n    startTrim < endTrim &&\n    (rawContent.charCodeAt(startTrim) === $.CHAR_SPACE ||\n      rawContent.charCodeAt(startTrim) === $.CHAR_TAB ||\n      rawContent.charCodeAt(startTrim) === $.CHAR_CR ||\n      rawContent.charCodeAt(startTrim) === $.CHAR_NEWLINE)\n  )\n    startTrim++\n  while (\n    endTrim > startTrim &&\n    (rawContent.charCodeAt(endTrim - 1) === $.CHAR_SPACE ||\n      rawContent.charCodeAt(endTrim - 1) === $.CHAR_TAB ||\n      rawContent.charCodeAt(endTrim - 1) === $.CHAR_CR ||\n      rawContent.charCodeAt(endTrim - 1) === $.CHAR_NEWLINE)\n  )\n    endTrim--\n  const content = rawContent.slice(startTrim, endTrim)\n\n  if (!content) return null\n\n  const level = underlineChar === '=' ? 1 : 2\n  const children = parseInlineWithState(\n    content,\n    0,\n    content.length,\n    state,\n    options\n  )\n\n  return {\n    ...createHeading(level, children, content, options.slugify),\n    endPos: underlineLineEnd + (underlineLineEnd < source.length ? 1 : 0),\n  } as MarkdownToJSX.HeadingNode & { endPos: number }\n}\n\nfunction parseParagraph(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  // Note: We don't check isBlockStartChar here because this is called as a fallback\n  // after other block parsers have already tried and failed\n  if (state.inline) return null\n\n  if (options.optimizeForStreaming && source[pos] === '|') {\n    var checkLen = Math.min(500, source.length - pos)\n    var checkContent = source.substr(pos, checkLen)\n    var streamPipeCount = 0\n    var streamHasSeparator = false\n    for (var streamIdx = 0; streamIdx < checkContent.length; streamIdx++) {\n      if (checkContent[streamIdx] === '|') streamPipeCount++\n      if (checkContent[streamIdx] === '-' || checkContent[streamIdx] === ':') streamHasSeparator = true\n    }\n    if (streamPipeCount >= 3 && streamHasSeparator) {\n      var streamEndPos = util.findLineEnd(source, pos)\n      while (streamEndPos < source.length) {\n        var nextStart = skipToNextLine(source, streamEndPos)\n        if (nextStart >= source.length) break\n        var nextEnd = util.findLineEnd(source, nextStart)\n        var nextLine = source.slice(nextStart, nextEnd)\n        if (nextLine.indexOf('|') === -1 && nextLine.indexOf('-') === -1) break\n        streamEndPos = nextEnd\n        if (nextEnd >= source.length) break\n      }\n      return {\n        type: RuleType.paragraph,\n        children: [],\n        endPos: skipToNextLine(source, streamEndPos),\n      } as MarkdownToJSX.ParagraphNode & { endPos: number }\n    }\n  }\n\n  let endPos = pos\n  const sourceLen = source.length\n\n  while (endPos < sourceLen) {\n    let lineEnd = util.findLineEnd(source, endPos)\n    let isEmptyLine = true\n\n    for (let i = endPos; i < lineEnd; i++) {\n      const code = charCode(source, i)\n      if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB && code !== $.CHAR_CR) {\n        isEmptyLine = false\n        break\n      }\n    }\n\n    if (isEmptyLine) {\n      endPos = lineEnd\n      break\n    }\n\n    if (lineEnd >= sourceLen) {\n      endPos = sourceLen\n      break\n    }\n\n    const nextLineStart = skipToNextLine(source, lineEnd)\n    if (nextLineStart >= sourceLen) {\n      endPos = sourceLen\n      break\n    }\n\n    let nextLineEnd = util.findLineEnd(source, nextLineStart)\n    let nextLineIsEmpty = true\n    let nextLineFirstChar = ''\n\n    for (let i = nextLineStart; i < nextLineEnd; i++) {\n      const code = charCode(source, i)\n      if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB && code !== $.CHAR_CR) {\n        nextLineIsEmpty = false\n        if (nextLineFirstChar === '') nextLineFirstChar = source[i]\n        break\n      }\n    }\n\n    if (nextLineIsEmpty) {\n      endPos = lineEnd\n      break\n    }\n\n    // Check if next line starts with a block element\n    // BUT: per CommonMark, lines indented by exactly 4 spaces are paragraph continuation,\n    // not code blocks or other blocks, even if they start with block-starting characters.\n    let shouldBreak = false\n    const nextIndentInfo = calculateIndent(source, nextLineStart, nextLineEnd)\n    const isExact4SpaceIndent =\n      nextIndentInfo.spaceEquivalent === 4 && nextIndentInfo.charCount === 4\n\n    // Check for HTML blocks first (types 1-6 can interrupt paragraphs)\n    // Per CommonMark spec: HTML blocks of types 1-6 can interrupt paragraphs\n    if (\n      nextLineFirstChar === '<' &&\n      !isExact4SpaceIndent &&\n      !options.disableParsingRawHTML\n    ) {\n      const htmlCheckPos = nextLineStart\n      let htmlLineStart = htmlCheckPos\n      let htmlIndent = 0\n      while (htmlLineStart < nextLineEnd && htmlIndent < 3) {\n        const code = charCode(source, htmlLineStart)\n        if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n          htmlIndent++\n          htmlLineStart++\n        } else {\n          break\n        }\n      }\n      if (htmlLineStart < nextLineEnd && source[htmlLineStart] === '<') {\n        var htmlResult = parseHTML(\n          source,\n          htmlLineStart,\n          { ...state, inline: false },\n          options\n        )\n        if (htmlResult) {\n          shouldBreak =\n            !('canInterruptParagraph' in htmlResult) ||\n            (htmlResult.canInterruptParagraph as boolean)\n        }\n      }\n    }\n\n    // In list context, lines indented to the content start column are also continuation\n    // For now, treat 4-space indented lines as continuation regardless of context\n    if (isExact4SpaceIndent) {\n      // Line is indented exactly 4 spaces - this is paragraph continuation\n      // Per CommonMark spec: lines indented by exactly 4 spaces are paragraph continuation,\n      // not code blocks or other blocks, even if they start with block-starting characters.\n      // Don't break, continue paragraph across this line\n      shouldBreak = false\n    } else if (\n      !shouldBreak &&\n      nextLineFirstChar &&\n      isBlockStartChar(nextLineFirstChar)\n    ) {\n      // Reference definitions don't break paragraphs - skip them\n      if (nextLineFirstChar === '[') {\n        // Check if it's a reference definition (not a footnote)\n        const checkPos = nextLineStart\n        if (checkPos + 1 >= sourceLen || source[checkPos + 1] !== '^') {\n          // Could be a reference definition - don't break paragraph\n          shouldBreak = false\n        } else {\n          // Footnote definition - break paragraph\n          shouldBreak = true\n        }\n      } else if (nextLineFirstChar === '*' || nextLineFirstChar === '+') {\n        // Asterisk/plus is only a block start for lists (*/+ followed by space/tab) or thematic breaks (3+ alone)\n        // But thematic breaks can have up to 3 spaces indentation, so check for thematic break first\n        const thematicBreakResult = parseBreakThematic(\n          source,\n          nextLineStart,\n          state,\n          options\n        )\n        if (thematicBreakResult) {\n          shouldBreak = true\n        } else {\n          // Check if it's a list (followed by space/tab)\n          const secondChar =\n            nextLineStart + 1 < sourceLen ? source[nextLineStart + 1] : ''\n          if (secondChar && isSpaceOrTab(secondChar)) {\n            shouldBreak = true\n          } else {\n            // Not a list or thematic break - don't break paragraph\n            shouldBreak = false\n          }\n        }\n      } else {\n        // Use parseBlock to check if next line starts a block\n        // Special handling needed for setext headings and ordered lists\n        const blockResult = parseBlock(source, nextLineStart, state, options)\n\n        if (blockResult) {\n          // Check if it's a code block from 4+ space indentation (paragraph continuation)\n          if (blockResult.type === RuleType.codeBlock) {\n            const blockIndentInfo = calculateIndent(\n              source,\n              nextLineStart,\n              nextLineEnd\n            )\n            if (blockIndentInfo.spaceEquivalent >= 4) {\n              // 4+ space indentation is paragraph continuation, not a block start\n              shouldBreak = false\n            } else {\n              // Fenced code block - break paragraph\n              shouldBreak = true\n            }\n          } else if (\n            blockResult.type === RuleType.unorderedList ||\n            blockResult.type === RuleType.orderedList\n          ) {\n            // Lists can interrupt paragraphs, but ordered lists starting with numbers other than 1 cannot\n            if (blockResult.type === RuleType.orderedList) {\n              const orderedList = blockResult as MarkdownToJSX.OrderedListNode\n              // Only ordered lists starting with 1 can interrupt paragraphs\n              shouldBreak = orderedList.start === 1\n            } else {\n              shouldBreak = true\n            }\n          } else if (nextLineFirstChar === '-') {\n            // Dash could be setext heading underline if preceded by content\n            // Per CommonMark: setext headings take precedence over thematic breaks\n            if (endPos > pos) {\n              // We have content - break paragraph to let setext heading parser check\n              shouldBreak = true\n            } else {\n              // No content - use the block result (thematic break or list)\n              shouldBreak = true\n            }\n          } else if (blockResult.type === RuleType.ref) {\n            // Reference definitions don't break paragraphs\n            shouldBreak = false\n          } else {\n            // Other block types break paragraphs\n            shouldBreak = true\n          }\n        }\n      }\n    } else {\n      // Next line doesn't start with a block-starting character\n      // Per CommonMark: in paragraph context, lines indented by exactly 4 spaces\n      // are paragraph continuation, not code blocks. Only 4+ spaces at document\n      // start (not in paragraph) are code blocks.\n      // So we don't break on 4-space indentation in paragraph continuation.\n    }\n\n    if (shouldBreak) {\n      endPos = lineEnd\n      break\n    }\n\n    // Continue paragraph across single newline\n    endPos = skipToNextLine(source, lineEnd)\n  }\n\n  if (endPos <= pos) return null\n\n  // Per CommonMark: lines indented by exactly 4 spaces in paragraph context\n  // are continuation, not code blocks. We need to remove the 4-space indentation\n  // from continuation lines but preserve them as part of the paragraph.\n  var contentStart = pos\n  var contentEnd = endPos\n\n  while (contentStart < contentEnd) {\n    const code = charCode(source, contentStart)\n    if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n      contentStart++\n    } else {\n      break\n    }\n  }\n\n  // Fast path: if no newlines, use content directly (common case)\n  // Check if there's a newline between contentStart and contentEnd\n  // We can optimize by checking if contentEnd is beyond the first line\n  const firstLineEnd = util.findLineEnd(source, contentStart)\n  var hasNewline = contentEnd > firstLineEnd\n\n  var processedContent\n  if (!hasNewline) {\n    // Single line - no processing needed\n    processedContent = source.slice(contentStart, contentEnd)\n  } else {\n    // Multi-line: process 4-space indentation\n    var processedParts: string[] = []\n    var lineStart = contentStart\n    var lineIndex = 0\n\n    while (lineStart < contentEnd) {\n      var lineEnd = util.findLineEnd(source, lineStart)\n      if (lineEnd > contentEnd) lineEnd = contentEnd\n\n      if (lineIndex === 0) {\n        processedParts.push(source.slice(lineStart, lineEnd))\n      } else {\n        // Check for exactly 4 leading spaces\n        var spaceCount = 0\n        while (spaceCount < 4 && lineStart + spaceCount < lineEnd) {\n          if (charCode(source, lineStart + spaceCount) === $.CHAR_SPACE) {\n            spaceCount++\n          } else {\n            break\n          }\n        }\n        var start = spaceCount === 4 ? lineStart + 4 : lineStart\n        processedParts.push(source.slice(start, lineEnd))\n      }\n\n      if (lineEnd < contentEnd) {\n        const charAtEnd = charCode(source, lineEnd)\n        if (charAtEnd === $.CHAR_CR || charAtEnd === $.CHAR_NEWLINE) {\n          processedParts.push('\\n')\n          lineStart = skipToNextLine(source, lineEnd)\n        } else {\n          lineStart = contentEnd\n        }\n      } else {\n        lineStart = contentEnd\n      }\n      lineIndex++\n    }\n    processedContent = processedParts.join('')\n  }\n\n  var processedContentEnd = processedContent.length\n  while (processedContentEnd > 0) {\n    var c = processedContent.charCodeAt(processedContentEnd - 1)\n    if (c === $.CHAR_SPACE || c === $.CHAR_TAB) {\n      processedContentEnd--\n    } else {\n      break\n    }\n  }\n  if (processedContentEnd < processedContent.length) {\n    processedContent = processedContent.slice(0, processedContentEnd)\n  }\n\n  // Check if processed content has actual content\n  let hasProcessedContent = false\n  for (let i = 0; i < processedContent.length; i++) {\n    const code = processedContent.charCodeAt(i)\n    if (\n      code !== $.CHAR_SPACE &&\n      code !== $.CHAR_TAB &&\n      code !== $.CHAR_NEWLINE &&\n      code !== $.CHAR_CR\n    ) {\n      hasProcessedContent = true\n      break\n    }\n  }\n  if (!hasProcessedContent) return null\n\n  // Per CommonMark spec: Extract link reference definitions from paragraph content\n  // Reference definitions can appear at the end of paragraph content\n  // They should be extracted and stored, not parsed as inline content\n  // Scan backwards from endPos in source to find reference definitions\n  var extractedContent = processedContent\n  var extractedEndPos = endPos\n  // Find the last newline in the source before endPos (optimized: manual scan instead of lastIndexOf)\n  var lastNewlinePos = -1\n  var searchPos = endPos - 1\n  while (searchPos >= contentStart) {\n    if (charCode(source, searchPos) === $.CHAR_NEWLINE) {\n      lastNewlinePos = searchPos\n      break\n    }\n    searchPos--\n  }\n  if (lastNewlinePos >= 0) {\n    // Per CommonMark spec: \"A link reference definition cannot interrupt a paragraph.\"\n    // Only extract reference definitions if they're at the START of the paragraph (no content before them)\n    // Check if there's any non-whitespace content before the last newline\n    var hasContentBeforeNewline = false\n    for (var checkPos = contentStart; checkPos < lastNewlinePos; checkPos++) {\n      const code = charCode(source, checkPos)\n      if (\n        code !== $.CHAR_SPACE &&\n        code !== $.CHAR_TAB &&\n        code !== $.CHAR_NEWLINE &&\n        code !== $.CHAR_CR\n      ) {\n        hasContentBeforeNewline = true\n        break\n      }\n    }\n\n    // Only extract reference definition if there's no content before the newline\n    // (i.e., it's at the start of the paragraph)\n    if (!hasContentBeforeNewline) {\n      // Check if the content after the last newline is a reference definition\n      var refDefStartPos = lastNewlinePos + 1\n      // Skip any leading whitespace\n      while (refDefStartPos < source.length) {\n        const code = charCode(source, refDefStartPos)\n        if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n          refDefStartPos++\n        } else {\n          break\n        }\n      }\n      // Check indentation - reference definitions can't be indented 4+ spaces\n      var refDefIndent = refDefStartPos - (lastNewlinePos + 1)\n      if (\n        refDefIndent < 4 &&\n        refDefStartPos < source.length &&\n        source[refDefStartPos] === '['\n      ) {\n        var refDefState = { ...state, inline: false }\n        var refDefResult = parseDefinition(\n          source,\n          refDefStartPos,\n          refDefState,\n          options,\n          false\n        )\n        if (refDefResult) {\n          // Reference definition was successfully parsed - exclude it from paragraph content\n          // Find the corresponding position in processedContent\n          // Count newlines from contentStart to lastNewlinePos\n          var newlineCount = 0\n          var searchPos = contentStart\n          while (searchPos <= lastNewlinePos) {\n            const nlPos = source.indexOf('\\n', searchPos)\n            if (nlPos === -1 || nlPos > lastNewlinePos) break\n            newlineCount++\n            searchPos = nlPos + 1\n          }\n          // Find the corresponding position in processedContent\n          var newlinePosInProcessed = 0\n          var newlinesFound = 0\n          searchPos = 0\n          while (searchPos < processedContent.length) {\n            const nlPos = processedContent.indexOf('\\n', searchPos)\n            if (nlPos === -1) break\n            newlinesFound++\n            if (newlinesFound === newlineCount) {\n              newlinePosInProcessed = nlPos + 1\n              break\n            }\n            searchPos = nlPos + 1\n          }\n          if (newlinePosInProcessed > 0) {\n            extractedContent = processedContent.slice(\n              0,\n              newlinePosInProcessed - 1\n            )\n          }\n          extractedEndPos = refDefResult.endPos\n          // Update state.refs from the parsed reference\n          state.refs = refDefState.refs\n        }\n      }\n    }\n  }\n\n  // Parse as inline (newlines are preserved by default)\n  const children = parseInlineWithState(\n    extractedContent,\n    0,\n    extractedContent.length,\n    state,\n    options\n  )\n\n  var result: MarkdownToJSX.ParagraphNode & {\n    endPos: number\n    removedClosingTags?: MarkdownToJSX.ASTNode[]\n  } = {\n    type: RuleType.paragraph,\n    children,\n    endPos: extractedEndPos,\n  }\n\n  // Per CommonMark spec Example 148: when paragraphs contain multiple closing tags at the end,\n  // only the first closing tag should be kept in the paragraph, the rest should be removed\n  // This handles cases where closing tags are part of HTML block structures\n  // Heuristic: if there are 3+ consecutive closing tags, remove all but the first one\n  // Example 148: <p><em>world</em>.</pre></p> should keep </pre> but remove </td>, </tr>, </table> (4 tags)\n  // Example 623: <p></a></foo ></p> should keep both </a> and </foo > (2 tags, not removed)\n  if (children.length > 0) {\n    // Find closing tags at the end of paragraph children (ignoring whitespace-only text nodes)\n    // Keep the first closing tag but remove the rest\n    var closingTagIndices: number[] = []\n    for (var i = children.length - 1; i >= 0; i--) {\n      var child = children[i]\n      if (\n        child.type === RuleType.htmlSelfClosing &&\n        child.isClosingTag === true\n      ) {\n        closingTagIndices.push(i)\n      } else if (child.type === RuleType.text) {\n        var textNode = child as MarkdownToJSX.TextNode\n        // Skip whitespace-only text nodes when looking for consecutive closing tags\n        if (textNode.text && textNode.text.trim().length > 0) {\n          break\n        }\n      } else {\n        // Stop at first non-closing-tag, non-whitespace node\n        break\n      }\n    }\n    // If we found 3+ consecutive closing tags at the end, remove all but the first one\n    // Store the removed closing tags on the paragraph node so html() can render them separately\n    // Heuristic: 3+ tags indicates HTML block structure (like </pre></td></tr></table>)\n    // 2 tags might be standalone (like </a></foo >) - keep both\n    if (closingTagIndices.length >= 3) {\n      // Keep only the first closing tag (earliest in array), remove the rest\n      var firstClosingTagIdx = closingTagIndices[closingTagIndices.length - 1]\n      var removedClosingTags = children.slice(firstClosingTagIdx + 1)\n      children.splice(firstClosingTagIdx + 1)\n      result.removedClosingTags = removedClosingTags\n    }\n  }\n\n  return result\n}\n\nfunction parseFrontmatter(source: string, pos: number): ParseResult {\n  if (pos !== 0) return null\n  const bounds = util.parseFrontmatterBounds(source)\n  if (!bounds?.hasValidYaml) return null\n  let sliceEnd = bounds.endPos - 1\n  if (sliceEnd > 0 && source[sliceEnd - 1] === '\\r') sliceEnd--\n  let text = util.normalizeInput(source.slice(0, sliceEnd))\n  return {\n    type: RuleType.frontmatter,\n    text,\n    endPos: bounds.endPos,\n  } as MarkdownToJSX.FrontmatterNode & { endPos: number }\n}\n\nfunction parseBreakThematic(\n  source: string,\n  pos: number,\n  state?: MarkdownToJSX.State,\n  options?: ParseOptions\n): ParseResult {\n  // Find the end of the line\n  const lineEnd = util.findLineEnd(source, pos)\n\n  // Per CommonMark: up to 3 spaces of indentation allowed\n  // Count indentation, checking if it exceeds 3 spaces\n  // OPTIMIZATION: Work directly on source string to avoid slice allocation\n  const indentResult = calculateIndent(source, pos, lineEnd, 3)\n  if (indentResult.spaceEquivalent > 3) return null\n  var checkPos = pos + indentResult.charCount\n\n  // Now check for thematic break character (-, *, or _)\n  if (checkPos >= lineEnd) return null\n  const startChar = source[checkPos]\n  if (startChar !== '-' && startChar !== '*' && startChar !== '_') return null\n\n  // OPTIMIZATION: Fast path - count matching characters before full validation\n  // This eliminates 96% of failed attempts (102 attempts -> ~4 attempts)\n  // Thematic break requires 3+ matching chars per CommonMark spec\n  var charCount = 0\n  var scanPos = checkPos\n  while (scanPos < lineEnd) {\n    var char = source[scanPos]\n    if (char === startChar) {\n      charCount++\n    } else if (char !== ' ' && char !== '\\t') {\n      // Non-matching non-whitespace character - not a thematic break\n      return null\n    }\n    scanPos++\n  }\n\n  if (charCount < 3) {\n    return null // Need at least 3 matching characters per CommonMark spec\n  }\n\n  return {\n    type: RuleType.breakThematic,\n    endPos: skipToNextLine(source, lineEnd),\n  } as MarkdownToJSX.BreakThematicNode & { endPos: number }\n}\n\n/** Calculate the space-equivalent indentation at a position (tabs = 4 spaces) */\nexport function calculateIndent(\n  source: string,\n  pos: number,\n  maxPos: number,\n  maxSpaces?: number\n): { spaceEquivalent: number; charCount: number } {\n  let spaceEquivalent = 0\n  let charCount = 0\n  let i = pos\n  while (i < maxPos) {\n    var iCode = charCode(source, i)\n    if (iCode !== $.CHAR_SPACE && iCode !== $.CHAR_TAB) break\n    if (maxSpaces !== undefined && spaceEquivalent >= maxSpaces) break\n    if (iCode === $.CHAR_TAB) {\n      spaceEquivalent += 4 - (spaceEquivalent % 4)\n    } else {\n      spaceEquivalent += 1\n    }\n    charCount++\n    i++\n  }\n  return { spaceEquivalent, charCount }\n}\n\nfunction extractCodeBlockLineContent(\n  source: string,\n  lineStart: number,\n  lineEnd: number,\n  startColumn: number\n): string {\n  let indentChars = 0\n  let indentSpaceEquivalent = 0\n  let currentColumn = startColumn\n  for (let i = lineStart; i < lineEnd && indentSpaceEquivalent < 4; i++) {\n    var iCode = charCode(source, i)\n    if (iCode === $.CHAR_TAB) {\n      const spaces = 4 - (currentColumn % 4)\n      indentSpaceEquivalent += spaces\n      indentChars++\n      currentColumn += spaces\n      if (indentSpaceEquivalent >= 4) break\n    } else if (iCode === $.CHAR_SPACE) {\n      indentSpaceEquivalent++\n      indentChars++\n      currentColumn++\n      if (indentSpaceEquivalent >= 4) break\n    } else {\n      break\n    }\n  }\n\n  let content = source.slice(lineStart + indentChars, lineEnd)\n  var tabCount = 0\n  for (var tc = lineStart; tc < lineEnd; tc++) {\n    if (source[tc] === '\\t') tabCount++\n    if (tabCount >= 2) break\n  }\n  if (tabCount >= 2 && util.startsWith(content, '\\t') && startColumn > 0) {\n    content = '  ' + content.slice(1)\n  }\n  return content\n}\n\nfunction parseCodeBlock(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State\n): ParseResult {\n  // Limit indentation scan to current line\n  const lineEndForIndent = util.findLineEnd(source, pos)\n  const indentInfo = calculateIndent(source, pos, lineEndForIndent)\n  if (indentInfo.spaceEquivalent < 4) return null\n\n  const initialIndent = indentInfo.spaceEquivalent\n  const lineEnd = util.findLineEnd(source, pos + indentInfo.charCount)\n  const lineStart = pos\n\n  let column = 0\n  var i = lineStart - 1\n  while (i >= 0 && source[i] !== '\\n' && source[i] !== '\\r') {\n    i--\n  }\n  i++\n  while (i < lineStart) {\n    if (source[i] === '\\t') {\n      column = column + 4 - (column % 4)\n    } else {\n      column++\n    }\n    i++\n  }\n\n  let firstLineContent = extractCodeBlockLineContent(\n    source,\n    lineStart,\n    lineEnd,\n    column\n  )\n  const contentStart = skipToNextLine(source, lineEnd)\n  if (contentStart >= source.length) {\n    if (!firstLineContent.trim()) return null\n    return {\n      type: RuleType.codeBlock,\n      text: firstLineContent,\n      endPos: contentStart,\n    } as MarkdownToJSX.CodeBlockNode & { endPos: number }\n  }\n\n  var parts: string[] = []\n  parts.push(firstLineContent)\n  let endPos = contentStart\n\n  while (endPos < source.length) {\n    const nextLineEnd = util.findLineEnd(source, endPos)\n    if (isBlankLineCheck(source, endPos, nextLineEnd)) {\n      const nextLinePos = nextLineEnd + 1\n      if (nextLinePos < source.length) {\n        const nextLineEnd = util.findLineEnd(source, nextLinePos)\n        const nextIndentInfo = calculateIndent(source, nextLinePos, nextLineEnd)\n        const nextChar = source[nextLinePos + nextIndentInfo.charCount]\n        if (\n          nextChar &&\n          nextChar !== '\\n' &&\n          (nextIndentInfo.spaceEquivalent < 4 ||\n            (nextChar === '>' &&\n              nextIndentInfo.spaceEquivalent < initialIndent))\n        ) {\n          break\n        }\n      }\n      parts.push('\\n')\n    } else {\n      const currentIndentInfo = calculateIndent(source, endPos, nextLineEnd)\n      if (currentIndentInfo.spaceEquivalent < 4) {\n        break\n      }\n\n      let lineContent = extractCodeBlockLineContent(\n        source,\n        endPos,\n        nextLineEnd,\n        0\n      )\n      parts.push('\\n')\n      parts.push(lineContent)\n    }\n\n    endPos = skipToNextLine(source, nextLineEnd)\n  }\n\n  let content = parts.join('')\n  content = content.replace(TRAILING_NEWLINE_R, '')\n  if (!content.trim()) return null\n\n  return {\n    type: RuleType.codeBlock,\n    text: content,\n    endPos,\n  } as MarkdownToJSX.CodeBlockNode & { endPos: number }\n}\n\nexport function parseCodeFenced(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  const fenceChar = source[pos]\n  if (fenceChar !== '`' && fenceChar !== '~') return null\n\n  // Fast check: must have at least 3 consecutive fence chars\n  const fenceLength = countConsecutiveChars(source, pos, fenceChar)\n  if (fenceLength < 3) return null\n\n  // Find line start for indentation calculation\n  let lineStart = pos\n  while (lineStart > 0 && charCode(source, lineStart - 1) !== $.CHAR_NEWLINE)\n    lineStart--\n\n  // Calculate indentation (caller already verified <= 3, but we need exact value)\n  const indentInfo = calculateIndent(source, lineStart, pos)\n  let openingIndent = indentInfo.spaceEquivalent\n  let contentIndentToRemove = openingIndent\n\n  // Handle 4-space indentation special case (simplified)\n  if (openingIndent === 4 && indentInfo.charCount === 4) {\n    // All 4 chars before pos are spaces/tabs, so this is indented code block\n    openingIndent = 0\n    contentIndentToRemove = 4\n  }\n\n  // Should not happen since caller checks indent <= 3, but keep for safety\n  if (openingIndent >= 4) return null\n\n  let i = util.skipWhitespace(source, pos + fenceLength)\n  const lineEnd = util.findLineEnd(source, i)\n  let langAndAttrs = source.slice(i, lineEnd).trim()\n\n  if (fenceChar === '`' && langAndAttrs.indexOf('`') !== -1) return null\n\n  langAndAttrs = langAndAttrs.replace(UNESCAPE_R, '$1')\n  const langSpaceIdx = langAndAttrs.indexOf(' ')\n  const lang =\n    langSpaceIdx > 0 ? langAndAttrs.slice(0, langSpaceIdx) : langAndAttrs\n  const attrsString =\n    langSpaceIdx > 0 ? langAndAttrs.slice(langSpaceIdx + 1).trim() : ''\n  const attrs =\n    attrsString && /=\\s*[\"']/.test(attrsString)\n      ? parseHTMLAttributes(attrsString, 'code', 'code', options)\n      : undefined\n\n  let contentStart = skipToNextLine(source, lineEnd)\n  let endPos = contentStart\n  // Track whether we found an explicit closing fence or an implicit close\n  // (when encountering a new opening fence with info string)\n  let foundExplicitClose = false\n\n  while (endPos < source.length) {\n    let lineEndPos = util.findLineEnd(source, endPos)\n\n    let fenceStart = endPos\n    let indentCount = 0\n    while (fenceStart < lineEndPos) {\n      const code = charCode(source, fenceStart)\n      if (code === $.CHAR_SPACE) {\n        indentCount++\n        fenceStart++\n        if (indentCount >= 4) break\n      } else if (code === $.CHAR_TAB) {\n        indentCount += 4 - (indentCount % 4)\n        fenceStart++\n        if (indentCount >= 4) break\n      } else {\n        break\n      }\n    }\n\n    if (indentCount < 4) {\n      let closeLen = countConsecutiveChars(\n        source,\n        fenceStart,\n        fenceChar,\n        lineEndPos - fenceStart\n      )\n      if (closeLen >= fenceLength) {\n        let afterFence = fenceStart + closeLen\n        while (afterFence < lineEndPos) {\n          const code = charCode(source, afterFence)\n          if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n            afterFence++\n          } else {\n            break\n          }\n        }\n        if (afterFence === lineEndPos) {\n          // Valid closing fence (only whitespace after fence chars)\n          foundExplicitClose = true\n          break\n        }\n        // Check if this looks like an opening fence with an info string\n        // Per issue: a fence with a language (e.g., ```python) should be treated\n        // as a new opening fence, implicitly closing the current code block\n        // This happens BEFORE this line (we don't include this line in content)\n        // Only treat as new opening if info string immediately follows fence (no space)\n        // This ensures ``` aaa (with space) is not treated as new opening per CommonMark\n        if (closeLen >= 3 && afterFence < lineEndPos) {\n          // Check if there's whitespace immediately after the fence chars\n          let posAfterFence = fenceStart + closeLen\n          let hasWhitespaceAfterFence =\n            posAfterFence < lineEndPos &&\n            (charCode(source, posAfterFence) === $.CHAR_SPACE ||\n              charCode(source, posAfterFence) === $.CHAR_TAB)\n\n          // Only treat as new opening if NO space between fence and info string\n          if (!hasWhitespaceAfterFence) {\n            // There's non-whitespace immediately after the fence - looks like ```python\n            // Info strings cannot contain backticks for backtick fences\n            let isValidInfoString = true\n            if (fenceChar === '`') {\n              // Check if there's a backtick in the info string\n              let lineContent = source.slice(posAfterFence, lineEndPos)\n              if (lineContent.indexOf('`') !== -1) {\n                isValidInfoString = false\n              }\n            }\n            if (isValidInfoString) {\n              // This is a new opening fence - current code block ends before this line\n              // endPos is already at the start of this line, so content won't include it\n              // foundExplicitClose stays false - we don't skip past this line\n              break\n            }\n          }\n        }\n      }\n    } else if (\n      contentIndentToRemove === 4 &&\n      openingIndent === 0 &&\n      indentCount === 4\n    ) {\n      let closeLen = countConsecutiveChars(\n        source,\n        fenceStart,\n        fenceChar,\n        lineEndPos - fenceStart\n      )\n      if (\n        closeLen >= fenceLength &&\n        isBlankLineCheck(source, fenceStart + closeLen, lineEndPos)\n      ) {\n        foundExplicitClose = true\n        break\n      }\n    }\n\n    endPos = skipToNextLine(source, lineEndPos)\n  }\n\n  let contentEnd =\n    endPos > contentStart && source[endPos - 1] === '\\n' ? endPos - 1 : endPos\n  if (contentEnd > contentStart && source[contentEnd - 1] === '\\r') {\n    contentEnd--\n  }\n  let rawContent = util.normalizeInput(source.slice(contentStart, contentEnd))\n  if (contentIndentToRemove) {\n    rawContent = removeExtraIndentFromCodeBlock(\n      rawContent,\n      contentIndentToRemove\n    )\n  }\n\n  // If we found an explicit closing fence, skip past it\n  // If we found an implicit close (new opening fence), endPos should stay at the start\n  // of that line so the next parse can handle the new code block\n  let finalEndPos =\n    foundExplicitClose && endPos < source.length\n      ? skipToNextLine(source, util.findLineEnd(source, endPos))\n      : endPos\n\n  return {\n    type: RuleType.codeBlock,\n    text: rawContent,\n    lang: lang,\n    attrs: attrs,\n    endPos: finalEndPos,\n  } as MarkdownToJSX.CodeBlockNode & { endPos: number }\n}\n\nfunction parseBlockQuoteChildren(\n  content: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  // Fast check: if content is empty or only whitespace, return early\n  for (var i = 0; i < content.length; i++) {\n    if (!isWS(content[i])) {\n      // Parse all blocks using parseBlocksWithState (which uses parseBlock via parseBlocksInHTML)\n      const blockChildren = parseBlocksWithState(content, state, options, {\n        inline: false,\n        inBlockQuote: true,\n      })\n      // Remove endPos property efficiently without creating intermediate objects\n      for (var j = 0; j < blockChildren.length; j++) {\n        const node = blockChildren[j] as MarkdownToJSX.ASTNode & {\n          endPos?: number\n        }\n        if ('endPos' in node) {\n          delete node.endPos\n        }\n      }\n      return blockChildren\n    }\n  }\n  return []\n}\n\nfunction parseBlockQuote(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline) return null\n\n  let checkPos = pos\n  while (\n    checkPos < source.length &&\n    (source[checkPos] === ' ' || source[checkPos] === '\\t')\n  ) {\n    checkPos++\n  }\n  if (checkPos >= source.length || source[checkPos] !== '>') return null\n\n  // Find the end of the blockquote and process content in single pass\n  let endPos = pos\n  var processedParts: string[] = []\n  var alertType: string | undefined = undefined\n  var hasContent = false\n  var firstLineStart = -1\n\n  // Track if we're currently in a code block (indented or fenced) that requires > prefix\n  var inCodeBlock = false\n  var codeBlockType: 'indented' | 'fenced' | null = null\n  var fencedFenceChar: string | null = null\n  var fencedFenceLength = 0\n  var previousLineWasEmpty = false\n\n  while (endPos < source.length) {\n    const lineEnd = util.findLineEnd(source, endPos)\n\n    // Check if this line starts a blockquote\n    let lineStart = endPos\n    // Skip leading whitespace\n    while (\n      lineStart < lineEnd &&\n      (source[lineStart] === ' ' || source[lineStart] === '\\t')\n    ) {\n      lineStart++\n    }\n\n    // If line starts with '>', it's part of the blockquote\n    if (lineStart < lineEnd && source[lineStart] === '>') {\n      let contentStart = lineStart + 1\n      if (contentStart < lineEnd && source[contentStart] === ' ') contentStart++\n\n      // Inline code block detection (was detectCodeBlockInBlockQuote)\n      const indentInfo = calculateIndent(source, contentStart, lineEnd)\n      const isIndented = indentInfo.spaceEquivalent >= 4\n      let isFenced = false\n      let fenceChar: string | null = null\n      let fenceLen = 0\n      if (contentStart < lineEnd) {\n        const firstChar = source[contentStart]\n        if (firstChar === '`' || firstChar === '~') {\n          let len = 0\n          let i = contentStart\n          while (i < lineEnd && source[i] === firstChar && len < 20) {\n            len++\n            i++\n          }\n          if (len >= 3) {\n            isFenced = true\n            fenceChar = firstChar\n            fenceLen = len\n          }\n        }\n      }\n\n      // Update code block state\n      if (\n        inCodeBlock &&\n        codeBlockType === 'fenced' &&\n        fenceChar === fencedFenceChar &&\n        fenceLen >= fencedFenceLength\n      ) {\n        inCodeBlock = false\n        codeBlockType = null\n        fencedFenceChar = null\n        fencedFenceLength = 0\n      } else if (isIndented || isFenced) {\n        inCodeBlock = true\n        codeBlockType = isIndented ? 'indented' : 'fenced'\n        fencedFenceChar = fenceChar\n        fencedFenceLength = fenceLen\n      }\n\n      // Inline blank line check (was isBlankLineCheck)\n      var isBlankLine = !isIndented && !isFenced\n      if (isBlankLine) {\n        for (var i = contentStart; i < lineEnd; i++) {\n          if (!isWS(source[i])) {\n            isBlankLine = false\n            break\n          }\n        }\n      }\n      previousLineWasEmpty = isBlankLine\n\n      // Track first line for alert extraction\n      if (firstLineStart === -1 && !isBlankLine) {\n        firstLineStart = processedParts.length\n      }\n      if (!isBlankLine) hasContent = true\n\n      // Process line content: remove > marker and optional space, handle tabs\n      const afterMarkerStart = lineStart + 1\n\n      // Check if first char after > is a tab (needs special handling)\n      if (afterMarkerStart < lineEnd && source[afterMarkerStart] === '\\t') {\n        // Expand tabs to spaces\n        processedParts.push('  ') // First tab after > becomes 2 spaces\n        let col = 4\n        for (let k = afterMarkerStart + 1; k < lineEnd; k++) {\n          const char = source[k]\n          var code = charCode(char)\n          if (code === $.CHAR_TAB) {\n            const spaces = 4 - (col % 4)\n            // Use fixed strings for common cases\n            if (spaces === 1) processedParts.push(' ')\n            else if (spaces === 2) processedParts.push('  ')\n            else if (spaces === 3) processedParts.push('   ')\n            else processedParts.push(' '.repeat(spaces))\n            col += spaces\n          } else {\n            processedParts.push(char)\n            col++\n          }\n        }\n        if (lineEnd < source.length) processedParts.push('\\n')\n      } else {\n        // Fast path: no tab immediately after > (common case)\n        let processedContentStart = afterMarkerStart\n        if (\n          processedContentStart < lineEnd &&\n          source[processedContentStart] === ' '\n        ) {\n          processedContentStart++\n        }\n        processedParts.push(source.slice(processedContentStart, lineEnd))\n        if (lineEnd < source.length) processedParts.push('\\n')\n      }\n    } else {\n      // Check for lazy continuation line (line without > that continues blockquote)\n      // Inline blank line check\n      var isEmptyLine = true\n      for (var i = endPos; i < lineEnd; i++) {\n        if (!isWS(source[i])) {\n          isEmptyLine = false\n          break\n        }\n      }\n\n      // Stop blockquote if: empty line, or in code block (code blocks require > prefix)\n      if (isEmptyLine || inCodeBlock) {\n        break\n      }\n\n      const lazyIndentInfo = calculateIndent(source, endPos, lineEnd)\n      if (lazyIndentInfo.spaceEquivalent === 0) {\n        // Check if this line starts a block (excluding reference definitions which don't break blockquotes)\n        const blockResult = parseBlock(source, endPos, state, options)\n        if (\n          blockResult &&\n          blockResult.type !== RuleType.ref &&\n          blockResult.type !== RuleType.codeBlock\n        ) {\n          break\n        }\n        if (previousLineWasEmpty) {\n          break\n        }\n      }\n      processedParts.push(source.slice(endPos, lineEnd))\n      if (lineEnd < source.length) processedParts.push('\\n')\n    }\n\n    endPos = skipToNextLine(source, lineEnd)\n  }\n\n  // Empty blockquotes are valid (e.g., \">\\n\" or \">\\n>  \\n> \\n\")\n  // Only reject if we didn't process any lines at all\n  if (endPos === pos) return null\n\n  // Remove trailing newline if present (avoid endsWith check by tracking)\n  if (\n    processedParts.length > 0 &&\n    processedParts[processedParts.length - 1] === '\\n'\n  ) {\n    processedParts.pop()\n  }\n\n  let processedContent = processedParts.join('')\n\n  // Extract alert type (check start of content for [!...]\\n pattern)\n  if (\n    processedContent.length >= 4 &&\n    processedContent.charCodeAt(0) === $.CHAR_BRACKET_OPEN &&\n    processedContent.charCodeAt(1) === $.CHAR_EXCLAMATION\n  ) {\n    const alertEnd = processedContent.indexOf(']\\n', 2)\n    if (alertEnd > 2) {\n      alertType = processedContent.slice(2, alertEnd)\n      processedContent = processedContent.slice(alertEnd + 2)\n    }\n  }\n\n  const children = parseBlockQuoteChildren(processedContent, state, options)\n\n  const result: MarkdownToJSX.BlockQuoteNode & { endPos: number } = {\n    type: RuleType.blockQuote,\n    children,\n    endPos,\n  }\n  if (alertType) {\n    result.alert = alertType\n  }\n  return result\n}\n\n/** Remove extra indentation from code block text when used in list items */\nfunction removeExtraIndentFromCodeBlock(\n  codeBlockText: string,\n  extraIndent: number\n): string {\n  return codeBlockText\n    .split('\\n')\n    .map(function (line) {\n      if (line.length === 0) return line\n      let toRemove = extraIndent\n      let removed = 0\n      let i = 0\n      let currentColumn = 0\n      while (i < line.length && removed < toRemove) {\n        if (line[i] === ' ') {\n          removed++\n          currentColumn++\n          i++\n        } else if (line[i] === '\\t') {\n          const spacesFromTab = 4 - (currentColumn % 4)\n          if (removed + spacesFromTab <= toRemove) {\n            removed += spacesFromTab\n            currentColumn += spacesFromTab\n            i++\n          } else {\n            const remainingToRemove = toRemove - removed\n            const spacesToKeep = Math.max(0, spacesFromTab - remainingToRemove)\n            return ' '.repeat(spacesToKeep) + line.slice(i + 1)\n          }\n        } else {\n          break\n        }\n      }\n      return line.slice(i)\n    })\n    .join('\\n')\n}\n\nfunction appendListContinuation(\n  continuationContent: string,\n  lastItem: MarkdownToJSX.ASTNode[],\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  addNewline: boolean = true\n): void {\n  const sourceToParse = (addNewline ? '\\n' : '') + continuationContent\n  const continuationInline = parseInlineWithState(\n    sourceToParse,\n    0,\n    sourceToParse.length,\n    state,\n    options\n  )\n  if (\n    lastItem.length > 0 &&\n    lastItem[lastItem.length - 1].type === RuleType.paragraph\n  ) {\n    ;(\n      lastItem[lastItem.length - 1] as MarkdownToJSX.ParagraphNode\n    ).children.push(...continuationInline)\n  } else {\n    lastItem.push(...continuationInline)\n  }\n}\n\n// Helper: Check if list item contains block-level content\nfunction listItemHasBlockContent(item: MarkdownToJSX.ASTNode[]): boolean {\n  return item.some(function (node) {\n    return (\n      node.type === RuleType.codeBlock ||\n      node.type === RuleType.paragraph ||\n      node.type === RuleType.blockQuote ||\n      node.type === RuleType.orderedList ||\n      node.type === RuleType.unorderedList ||\n      node.type === RuleType.heading\n    )\n  })\n}\n\n// Helper: Check if line matches any list item pattern\nfunction isLineListItem(line: string): boolean {\n  return !!line.match(LIST_ITEM_R)\n}\n\n// Helper: Find deepest nested list parent in item hierarchy\nfunction findNestedListParent(\n  item: MarkdownToJSX.ASTNode[]\n): MarkdownToJSX.ASTNode[] {\n  if (item.length === 0) return item\n  var lastBlock = item[item.length - 1]\n  if (\n    (lastBlock.type === RuleType.orderedList ||\n      lastBlock.type === RuleType.unorderedList) &&\n    (\n      lastBlock as\n        | MarkdownToJSX.OrderedListNode\n        | MarkdownToJSX.UnorderedListNode\n    ).items?.length > 0\n  ) {\n    return findNestedListParent(\n      (\n        lastBlock as\n          | MarkdownToJSX.OrderedListNode\n          | MarkdownToJSX.UnorderedListNode\n      ).items.slice(-1)[0]\n    )\n  }\n  return item\n}\n\n// Helper: Skip link reference definition if present\nfunction skipLinkReferenceDefinition(\n  source: string,\n  linePos: number,\n  lineEnd: number,\n  indentInfo: ReturnType<typeof calculateIndent>,\n  lineWithoutIndent: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): number | null {\n  if (!util.startsWith(lineWithoutIndent, '[')) return null\n  var refCheckState = { inline: false, list: false, refs: state.refs || {} }\n  var refResult = parseDefinition(\n    source,\n    linePos + indentInfo.charCount,\n    refCheckState,\n    options,\n    false\n  )\n  return refResult ? refResult.endPos : null\n}\n\n// Helper: Check if we should break list due to empty item after blank line\nfunction shouldBreakForEmptyItem(\n  items: MarkdownToJSX.ASTNode[][],\n  isEmptyItem: boolean,\n  prevLineWasBlank: boolean,\n  firstItemContent: string\n): boolean {\n  if (items.length !== 1 || !prevLineWasBlank) return false\n  const lastItem = items[0] // Since items.length === 1, this is the only item\n  if (lastItem.length !== 0) return false\n  if (isEmptyItem) return true\n  if (!isEmptyItem && firstItemContent.trim() === '') return true\n  return false\n}\n\n// Helper: Calculate content start column for a list item\n// Helper: Calculate marker end position from match\nfunction calculateMarkerEnd(match: RegExpMatchArray, ordered: boolean): number {\n  var markerStart = match.index || 0\n  return ordered\n    ? markerStart + match[1].length + match[2].length + 1\n    : markerStart + match[1].length + 1\n}\n\nfunction calculateListItemContentColumn(\n  source: string,\n  contentStartInSource: number,\n  lineEnd: number,\n  baseIndent: number,\n  markerEndInLine: number\n): { contentStartColumn: number; contentStartPos: number } {\n  var spacesAfterMarker = 0\n  var col = baseIndent + markerEndInLine\n  var contentCheckPos = contentStartInSource\n  while (contentCheckPos < lineEnd && spacesAfterMarker < 4) {\n    var code = charCode(source, contentCheckPos)\n    if (code === $.CHAR_SPACE) {\n      spacesAfterMarker++\n      col++\n    } else if (code === $.CHAR_TAB) {\n      var spaces = 4 - (col % 4)\n      if (spacesAfterMarker + spaces > 4) break\n      spacesAfterMarker += spaces\n      col += spaces\n    } else {\n      break\n    }\n    contentCheckPos++\n  }\n  return { contentStartColumn: col, contentStartPos: contentCheckPos }\n}\n\nfunction matchListItem(\n  lineWithoutIndent: string\n): { match: RegExpMatchArray; ordered: boolean; listItemRegex: RegExp } | null {\n  var match = lineWithoutIndent.match(LIST_ITEM_R)\n  if (!match) return null\n\n  // Groups: 1=ordered_num, 2=ordered_delim, 3=ordered_content, 4=ordered_empty_num, 5=ordered_empty_delim, 6=unordered_marker, 7=unordered_content, 8=unordered_empty_marker\n  if (match[1]) {\n    // Ordered with content: (\\d{1,9})([.)])\\s+(.*)\n    return {\n      match: [lineWithoutIndent, match[1], match[2], match[3]],\n      ordered: true,\n      listItemRegex: ORDERED_LIST_ITEM_WITH_CONTENT_R,\n    }\n  }\n  if (match[4]) {\n    // Ordered empty: (\\d{1,9})([.)])\\s*\n    return {\n      match: [lineWithoutIndent, match[4], match[5], ''],\n      ordered: true,\n      listItemRegex: ORDERED_LIST_ITEM_WITH_CONTENT_R,\n    }\n  }\n  if (match[6]) {\n    // Unordered with content: ([-*+])\\s+(.*)\n    return {\n      match: [lineWithoutIndent, match[6], match[7]],\n      ordered: false,\n      listItemRegex: UNORDERED_LIST_ITEM_WITH_CONTENT_R,\n    }\n  }\n  if (match[8]) {\n    // Unordered empty: ([-*+])\\s*\n    return {\n      match: [lineWithoutIndent, match[8], ''],\n      ordered: false,\n      listItemRegex: UNORDERED_LIST_ITEM_WITH_CONTENT_R,\n    }\n  }\n  return null\n}\n\n// Helper: Check if a line is a matching list item for the current list\nfunction isMatchingListItem(\n  lineWithoutIndent: string,\n  indentInfo: ReturnType<typeof calculateIndent>,\n  ordered: boolean,\n  marker: string | undefined,\n  delimiter: string | undefined,\n  baseIndent: number,\n  listItemRegex: RegExp\n): boolean {\n  if (indentInfo.spaceEquivalent !== baseIndent) return false\n  var match = lineWithoutIndent.match(listItemRegex)\n  if (match) {\n    return ordered ? match[2] === delimiter : match[1] === marker\n  }\n  var emptyMatch = lineWithoutIndent.match(LIST_ITEM_R)\n  if (!emptyMatch) return false\n  if (ordered) {\n    return emptyMatch[4] && emptyMatch[5] === delimiter\n  } else {\n    return emptyMatch[8] === marker\n  }\n}\n\n// Helper: Handle fenced code blocks that span multiple lines in list items\nfunction expandMultilineFencedCodeBlock(\n  source: string,\n  itemContent: string,\n  startPos: number,\n  markerWidth: number\n): { content: string; endPos: number } {\n  var content = itemContent\n  var pos = startPos\n  var fenceChar = itemContent[0]\n  while (pos < source.length) {\n    var lineEnd = util.findLineEnd(source, pos)\n    var line = source.slice(pos, lineEnd)\n    var processedLine = util.startsWith(line, ' '.repeat(markerWidth))\n      ? line.slice(markerWidth)\n      : line\n    if (\n      util.startsWith(processedLine.trim(), fenceChar) &&\n      countConsecutiveChars(processedLine.trim(), 0, fenceChar) >= 3\n    ) {\n      return { content: content, endPos: skipToNextLine(source, lineEnd) }\n    }\n    content += '\\n' + processedLine\n    pos = skipToNextLine(source, lineEnd)\n  }\n  return { content: content, endPos: pos }\n}\n\n// Helper function to add a new list item with all standard processing\nfunction addListItem(\n  source: string,\n  items: MarkdownToJSX.ASTNode[][],\n  itemContentStartColumns: number[],\n  itemContent: string,\n  startPos: number,\n  nextLineEnd: number,\n  nextIndent: number,\n  nextIndentChars: number,\n  nextMatch: RegExpMatchArray,\n  ordered: boolean,\n  hasBlankLines: boolean,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): { newCurrentPos: number; itemHasBlankLine: boolean } {\n  // Derive marker/delimiter/regex (cheap to recompute vs passing 3 extra params)\n  var marker = ordered ? undefined : nextMatch[1]\n  var delimiter = ordered ? nextMatch[2] : undefined\n  var listItemRegex = ordered\n    ? ORDERED_LIST_ITEM_WITH_CONTENT_R\n    : UNORDERED_LIST_ITEM_WITH_CONTENT_R\n\n  // Check if item has blank lines\n  var itemHasBlankLine = hasBlankLines\n  if (!hasBlankLines) {\n    var startCheckPos = skipToNextLine(source, nextLineEnd)\n    var checkItemPos = startCheckPos\n    while (checkItemPos < source.length) {\n      var checkLineEnd = util.findLineEnd(source, checkItemPos)\n      var checkLine = source.slice(checkItemPos, checkLineEnd)\n      var checkIndentInfo = calculateIndent(source, checkItemPos, checkLineEnd)\n      var checkIndent = checkIndentInfo.spaceEquivalent\n      if (isBlankLineCheck(source, checkItemPos, checkLineEnd)) {\n        var afterBlank = skipToNextLine(source, checkLineEnd)\n        if (afterBlank < source.length) {\n          var afterBlankLineEnd = util.findLineEnd(source, afterBlank)\n          var afterBlankIndentInfo = calculateIndent(\n            source,\n            afterBlank,\n            afterBlankLineEnd\n          )\n          var afterBlankIndent = afterBlankIndentInfo.spaceEquivalent\n          var thisItemMarkerEnd = calculateMarkerEnd(nextMatch, ordered)\n          var thisItemContentStartInSource =\n            startPos + nextIndentChars + thisItemMarkerEnd\n          var thisItemResult = calculateListItemContentColumn(\n            source,\n            thisItemContentStartInSource,\n            nextLineEnd,\n            nextIndent,\n            thisItemMarkerEnd\n          )\n          var thisItemContentStartColumn = thisItemResult.contentStartColumn\n          if (afterBlankIndent + 1 > thisItemContentStartColumn) {\n            itemHasBlankLine = true\n            break\n          }\n        }\n        break\n      } else if (checkIndent <= nextIndent) {\n        var checkLineWithoutIndent = checkLine.slice(checkIndentInfo.charCount)\n        var checkMatch = checkLineWithoutIndent.match(listItemRegex)\n        if (\n          checkMatch &&\n          (ordered ? checkMatch[2] === delimiter : checkMatch[1] === marker)\n        ) {\n          break\n        }\n      }\n      checkItemPos = skipToNextLine(source, checkLineEnd)\n    }\n  }\n\n  // Calculate content start column\n  var thisItemMarkerEnd = calculateMarkerEnd(nextMatch, ordered)\n  var thisItemContentStartInSource =\n    startPos + nextIndentChars + thisItemMarkerEnd\n  var thisItemResult = calculateListItemContentColumn(\n    source,\n    thisItemContentStartInSource,\n    nextLineEnd,\n    nextIndent,\n    thisItemMarkerEnd\n  )\n  var thisItemContentStartColumn = thisItemResult.contentStartColumn\n\n  // Handle fenced code blocks\n  var actualItemContent = itemContent\n  var newCurrentPos = skipToNextLine(source, nextLineEnd)\n  if (\n    util.startsWith(itemContent, '```') ||\n    util.startsWith(itemContent, '~~~')\n  ) {\n    var markerWidth = ordered\n      ? nextMatch[1].length + nextMatch[2].length + 1\n      : nextMatch[1].length + 1\n    var expandedResult = expandMultilineFencedCodeBlock(\n      source,\n      itemContent,\n      newCurrentPos,\n      markerWidth\n    )\n    actualItemContent = expandedResult.content\n    newCurrentPos = expandedResult.endPos\n  }\n\n  // Build and add item with GFM task support\n  items.push(\n    buildListItemContent(actualItemContent, itemHasBlankLine, state, options)\n  )\n  itemContentStartColumns.push(thisItemContentStartColumn)\n\n  return { newCurrentPos, itemHasBlankLine }\n}\n\n// Helper function to process list item continuation lines\nfunction checkHTMLTagInterruptsList(\n  source: string,\n  pos: number,\n  indentChars: number,\n  baseIndent: number,\n  indent: number,\n  options: ParseOptions\n): boolean {\n  if (indent > baseIndent || options.disableParsingRawHTML) return false\n  const lineStartPos = pos + indentChars\n  if (lineStartPos >= source.length || source[lineStartPos] !== '<')\n    return false\n  return isValidHTMLTagStart(source, lineStartPos)\n}\n\n// Lightweight check for HTML tag validity without full parsing\nfunction isValidHTMLTagStart(source: string, pos: number): boolean {\n  if (pos >= source.length || source[pos] !== '<') return false\n  const len = source.length\n  let i = pos + 1\n\n  // Handle closing tags\n  if (i < len && source[i] === '/') {\n    i++\n  }\n\n  // Must have at least one character for tag name\n  if (i >= len) return false\n\n  // First character of tag name must be letter\n  const firstChar = charCode(source, i)\n  if (!isAlphaCode(firstChar)) return false\n  i++\n\n  // Rest of tag name can be letters, digits, hyphens, underscores\n  // Use early return to avoid nested conditionals\n  while (i < len) {\n    const ch = source[i]\n    const code = charCode(source, i)\n\n    // Break conditions (valid tag name terminators)\n    if (\n      ch === '>' ||\n      ch === ' ' ||\n      ch === '\\t' ||\n      ch === '\\n' ||\n      ch === '\\r' ||\n      ch === '/'\n    ) {\n      break\n    }\n\n    // Valid tag name characters - continue\n    if (\n      ch === '-' ||\n      ch === '_' ||\n      isAlphaCode(code) ||\n      (code >= 48 && code <= 57)\n    ) {\n      i++\n    } else {\n      return false // Invalid character in tag name\n    }\n  }\n\n  // Find the end of the tag - use state machine approach to reduce branching\n  let state = 0 // 0: normal, 1: in double quotes, 2: in single quotes\n  while (i < len) {\n    const ch = source[i]\n    const code = charCode(source, i)\n\n    // State machine for quote handling\n    if (state === 1) {\n      // in double quotes\n      if (ch === '\"') state = 0\n      i++\n    } else if (state === 2) {\n      // in single quotes\n      if (ch === \"'\") state = 0\n      i++\n    } else if (ch === '\"') {\n      state = 1\n      i++\n    } else if (ch === \"'\") {\n      state = 2\n      i++\n    } else if (ch === '>') {\n      return true // Found valid closing >\n    } else if (ch === '/' && i + 1 < len && source[i + 1] === '>') {\n      return true // Found valid self-closing />\n    } else if (code === 10 || code === 13) {\n      // \\n or \\r\n      return false // No multiline tags in this context\n    } else {\n      i++\n    }\n  }\n\n  return false // No closing > found\n}\n\nfunction processContinuation(\n  source: string,\n  item: MarkdownToJSX.ASTNode[],\n  contentStartColumn: number,\n  startPos: number,\n  baseIndent: number,\n  ordered: boolean,\n  marker: string | undefined,\n  delimiter: string | undefined,\n  listItemRegex: RegExp,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  allowLinkRefs?: boolean\n): number {\n  let pos = startPos\n  let prevLineWasBlank = false\n  while (pos < source.length) {\n    const lineEnd = util.findLineEnd(source, pos)\n    const indentInfo = calculateIndent(source, pos, lineEnd)\n    const indent = indentInfo.spaceEquivalent\n\n    if (isBlankLineCheck(source, pos, lineEnd)) {\n      prevLineWasBlank = true\n      pos = skipToNextLine(source, lineEnd)\n      continue\n    }\n\n    const lineWithoutIndent = source.slice(pos + indentInfo.charCount, lineEnd)\n\n    if (\n      indent <= baseIndent &&\n      isMatchingListItem(\n        lineWithoutIndent,\n        indentInfo,\n        ordered,\n        marker,\n        delimiter,\n        baseIndent,\n        listItemRegex\n      )\n    ) {\n      break\n    }\n\n    if (indent >= contentStartColumn) {\n      // Check for link reference definitions (only for first item)\n      if (allowLinkRefs && prevLineWasBlank) {\n        const refEndPos = skipLinkReferenceDefinition(\n          source,\n          pos,\n          lineEnd,\n          indentInfo,\n          lineWithoutIndent,\n          state,\n          options\n        )\n        if (refEndPos) {\n          pos = refEndPos\n          prevLineWasBlank = false\n          continue\n        }\n      }\n\n      const result = processListContinuationLine(\n        source,\n        pos,\n        lineEnd,\n        indentInfo,\n        contentStartColumn - 1,\n        contentStartColumn,\n        item,\n        prevLineWasBlank,\n        state,\n        options,\n        undefined,\n        baseIndent\n      )\n      if (result.processed) {\n        pos = result.newPos\n        prevLineWasBlank = result.wasBlank\n        continue\n      }\n    } else {\n      break\n    }\n  }\n  return pos\n}\n\n// Helper: Parse content with paragraph wrapping for tight/loose lists\nfunction parseContentWithParagraphHandling(\n  content: string,\n  wrapInParagraph: boolean,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  const blocks = parseBlocksWithState(content, state, options, {\n    inline: false,\n    list: true,\n  })\n  if (blocks.length > 0) {\n    // Unwrap single paragraph for tight lists\n    return !wrapInParagraph &&\n      blocks.length === 1 &&\n      blocks[0].type === RuleType.paragraph\n      ? (blocks[0] as MarkdownToJSX.ParagraphNode).children\n      : blocks\n  }\n  // Fallback to inline parsing\n  const inline = parseWithInlineMode(state, true, () =>\n    parseInlineSpan(content, 0, content.length, state, options)\n  )\n  return wrapInParagraph && inline.length > 0\n    ? [\n        {\n          type: RuleType.paragraph,\n          children: inline,\n        } as MarkdownToJSX.ParagraphNode,\n      ]\n    : inline\n}\n\nfunction buildListItemContent(\n  itemContent: string,\n  itemHasBlankLine: boolean,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  const task = parseGFMTask(itemContent, 0, state)\n  const hasTask =\n    task &&\n    (task.endPos >= itemContent.length || itemContent[task.endPos] === ' ')\n  if (!hasTask) {\n    return parseContentWithParagraphHandling(\n      itemContent,\n      itemHasBlankLine,\n      state,\n      options\n    )\n  }\n  const afterTask =\n    task.endPos < itemContent.length ? task.endPos + 1 : task.endPos\n  const restContent = itemContent.slice(afterTask)\n  const restNodes = parseContentWithParagraphHandling(\n    restContent,\n    itemHasBlankLine,\n    state,\n    options\n  )\n  const nodes: MarkdownToJSX.ASTNode[] = [task]\n  if (task.endPos < itemContent.length) {\n    nodes.push({ type: RuleType.text, text: ' ' } as MarkdownToJSX.TextNode)\n  }\n  nodes.push(...restNodes)\n  return nodes\n}\n\nfunction checkUnicodeWhitespaceAfterMarker(\n  match: RegExpMatchArray,\n  marker: string\n): boolean {\n  if (!match[0]) return false\n  const markerInMatch = match[0].indexOf(marker)\n  if (markerInMatch === -1) return false\n  const afterMarkerInMatch = markerInMatch + marker.length\n  if (afterMarkerInMatch >= match[0].length) return false\n  const afterMarkerChar = match[0][afterMarkerInMatch]\n  return afterMarkerChar ? charCode(afterMarkerChar) === $.CHAR_NBSP : false\n}\n\nfunction convertSetextHeadingInListItem(\n  lastItem: MarkdownToJSX.ASTNode[],\n  underlineLine: string,\n  options: ParseOptions\n): boolean {\n  if (lastItem.length === 0) return false\n  const lastBlock = lastItem[lastItem.length - 1]\n  const trimmed = underlineLine.trim()\n  if (\n    (!util.startsWith(trimmed, '=') && !util.startsWith(trimmed, '-')) ||\n    trimmed.length < 1 ||\n    !/^[=-]+[ \\t]*$/.test(trimmed)\n  ) {\n    return false\n  }\n\n  let headingChildren: MarkdownToJSX.ASTNode[] = []\n  let headingContent = ''\n  if (lastBlock.type === RuleType.paragraph) {\n    const paragraph = lastBlock as MarkdownToJSX.ParagraphNode\n    headingChildren = paragraph.children\n    headingContent = paragraph.children\n      .map(child =>\n        child.type === RuleType.text\n          ? (child as MarkdownToJSX.TextNode).text\n          : ''\n      )\n      .join('')\n      .trim()\n  } else if (lastBlock.type === RuleType.text) {\n    const textNodes: MarkdownToJSX.TextNode[] = []\n    let i = lastItem.length - 1\n    while (i >= 0 && lastItem[i].type === RuleType.text) {\n      textNodes.unshift(lastItem[i] as MarkdownToJSX.TextNode)\n      i--\n    }\n    if (textNodes.length > 0) {\n      headingChildren = textNodes\n      headingContent = textNodes\n        .map(node => (node as MarkdownToJSX.TextNode).text)\n        .join('')\n        .trim()\n    }\n  }\n\n  if (!headingContent) return false\n\n  const underlineChar = trimmed[0]\n  const level = underlineChar === '=' ? 1 : 2\n  if (lastBlock.type === RuleType.paragraph) {\n    lastItem.pop()\n  } else if (lastBlock.type === RuleType.text) {\n    while (\n      lastItem.length > 0 &&\n      lastItem[lastItem.length - 1].type === RuleType.text\n    ) {\n      lastItem.pop()\n    }\n  }\n  lastItem.push(\n    createHeading(level, headingChildren, headingContent, options.slugify)\n  )\n  return true\n}\n\nfunction processListContinuationLine(\n  source: string,\n  currentPos: number,\n  nextLineEnd: number,\n  nextIndentInfo: ReturnType<typeof calculateIndent>,\n  continuationColumn: number,\n  contentStartColumn: number,\n  lastItem: MarkdownToJSX.ASTNode[],\n  prevLineWasBlank: boolean,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  unwrapParagraphs?: boolean,\n  baseIndent?: number\n): { processed: boolean; newPos: number; wasBlank: boolean } {\n  const nextIndent = nextIndentInfo.spaceEquivalent\n  const continuationContent = source.slice(\n    currentPos + nextIndentInfo.charCount,\n    nextLineEnd\n  )\n\n  if (nextIndent >= continuationColumn + 4) {\n    const blockResult = parseCodeBlock(source, currentPos, state)\n    if (blockResult) {\n      const codeBlockNode = blockResult as MarkdownToJSX.CodeBlockNode & {\n        endPos: number\n      }\n      const adjustedText = removeExtraIndentFromCodeBlock(\n        codeBlockNode.text || '',\n        contentStartColumn\n      )\n      lastItem.push({\n        ...codeBlockNode,\n        text: adjustedText,\n      } as MarkdownToJSX.CodeBlockNode)\n      return {\n        processed: true,\n        newPos: codeBlockNode.endPos,\n        wasBlank: false,\n      }\n    }\n  }\n\n  const indentRelativeToContentFenced = nextIndent - (contentStartColumn - 1)\n  if (\n    nextIndent + 1 >= contentStartColumn &&\n    indentRelativeToContentFenced <= 3\n  ) {\n    const continuationStart = currentPos + nextIndentInfo.charCount\n    if (continuationStart < nextLineEnd) {\n      const firstCharAfterIndent = source[continuationStart]\n      if (firstCharAfterIndent === '`' || firstCharAfterIndent === '~') {\n        const fencedResult = parseCodeFenced(\n          source,\n          continuationStart,\n          state,\n          options\n        )\n        if (fencedResult) {\n          const codeBlockNode = fencedResult as MarkdownToJSX.CodeBlockNode & {\n            endPos: number\n          }\n          const adjustedText = removeExtraIndentFromCodeBlock(\n            codeBlockNode.text || '',\n            contentStartColumn - 1\n          )\n          lastItem.push({\n            ...codeBlockNode,\n            text: adjustedText,\n            endPos: codeBlockNode.endPos,\n          } as MarkdownToJSX.CodeBlockNode & { endPos: number })\n          return {\n            processed: true,\n            newPos: codeBlockNode.endPos,\n            wasBlank: false,\n          }\n        }\n      }\n      // Try parsing as table when line starts with |\n      if (firstCharAfterIndent === '|') {\n        const tableResult = parseTable(\n          source,\n          continuationStart,\n          state,\n          options\n        )\n        if (tableResult) {\n          const tableNode = tableResult as MarkdownToJSX.TableNode & {\n            endPos: number\n          }\n          lastItem.push(tableNode)\n          return {\n            processed: true,\n            newPos: tableNode.endPos,\n            wasBlank: false,\n          }\n        }\n      }\n    }\n  }\n\n  if (\n    continuationContent.length > 0 &&\n    (continuationContent[0] === '-' ||\n      continuationContent[0] === '*' ||\n      continuationContent[0] === '+' ||\n      (continuationContent[0] >= '0' && continuationContent[0] <= '9'))\n  ) {\n    const listMarkerRegex = /^([-*+]|\\d{1,9}[.)])\\s+/\n    if (listMarkerRegex.test(continuationContent)) {\n      const inline = parseInlineWithState(\n        continuationContent,\n        0,\n        continuationContent.length,\n        state,\n        options\n      )\n      lastItem.push({ type: RuleType.text, text: '\\n' }, ...inline)\n      return {\n        processed: true,\n        newPos: skipToNextLine(source, nextLineEnd),\n        wasBlank: false,\n      }\n    }\n  }\n\n  const mergedPos = tryMergeBlockquoteContinuation(\n    source,\n    currentPos,\n    lastItem,\n    continuationContent,\n    state,\n    options\n  )\n  if (mergedPos !== null) {\n    return { processed: true, newPos: mergedPos, wasBlank: false }\n  }\n\n  const continuationBlocks = parseBlocksWithState(\n    continuationContent,\n    state,\n    options,\n    { inline: false, list: true }\n  )\n  if (continuationBlocks.length > 0) {\n    if (unwrapParagraphs && continuationBlocks[0].type === RuleType.paragraph) {\n      const continuationParagraph =\n        continuationBlocks[0] as MarkdownToJSX.ParagraphNode\n      lastItem.push(\n        { type: RuleType.text, text: '\\n' } as MarkdownToJSX.TextNode,\n        ...continuationParagraph.children\n      )\n      if (continuationBlocks.length > 1) {\n        lastItem.push(...continuationBlocks.slice(1))\n      }\n    } else if (\n      !prevLineWasBlank &&\n      continuationBlocks[0].type === RuleType.paragraph &&\n      lastItem.length > 0\n    ) {\n      const lastBlock = lastItem[lastItem.length - 1]\n      const continuationParagraph =\n        continuationBlocks[0] as MarkdownToJSX.ParagraphNode\n      if (lastBlock.type === RuleType.paragraph) {\n        ;(lastBlock as MarkdownToJSX.ParagraphNode).children.push(\n          { type: RuleType.text, text: '\\n' } as MarkdownToJSX.TextNode,\n          ...continuationParagraph.children\n        )\n      } else if (lastBlock.type === RuleType.heading) {\n        lastItem.push(...continuationParagraph.children)\n      } else if (!listItemHasBlockContent(lastItem)) {\n        lastItem.push(\n          { type: RuleType.text, text: ' ' } as MarkdownToJSX.TextNode,\n          ...continuationParagraph.children\n        )\n      } else {\n        lastItem.push(...continuationBlocks)\n      }\n      if (continuationBlocks.length > 1) {\n        lastItem.push(...continuationBlocks.slice(1))\n      }\n    } else {\n      lastItem.push(...continuationBlocks)\n    }\n    return {\n      processed: true,\n      newPos: skipToNextLine(source, nextLineEnd),\n      wasBlank: false,\n    }\n  }\n\n  if (prevLineWasBlank) {\n    const inline = parseWithInlineMode(state, true, () =>\n      parseInlineSpan(\n        continuationContent,\n        0,\n        continuationContent.length,\n        state,\n        options\n      )\n    )\n    lastItem.push({\n      type: RuleType.paragraph,\n      children: inline,\n    } as MarkdownToJSX.ParagraphNode)\n  } else {\n    appendListContinuation(continuationContent, lastItem, state, options)\n  }\n  return {\n    processed: true,\n    newPos: skipToNextLine(source, nextLineEnd),\n    wasBlank: false,\n  }\n}\n\nfunction parseList(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline) return null\n\n  // Set inList state for proper GFM task tracking during inline parsing\n  var originalInList = state.inList\n  state.inList = true\n\n  // Lists must start at the beginning of a line (block boundary)\n  if (pos > 0) {\n    var prevCharCode = charCode(source, pos - 1)\n    if (prevCharCode !== $.CHAR_NEWLINE && prevCharCode !== $.CHAR_CR) {\n      state.inList = originalInList\n      return null\n    }\n  }\n\n  var lineEnd = util.findLineEnd(source, pos)\n  var indentInfo = calculateIndent(source, pos, lineEnd)\n  // Early fail: headings/lists cannot be indented more than 3 spaces unless in list context\n  if (indentInfo.spaceEquivalent > 3 && !state.inList) {\n    state.inList = originalInList\n    return null\n  }\n  var line = source.slice(pos, lineEnd)\n  var indent = indentInfo.charCount\n  var lineWithoutIndent = line.slice(indent)\n\n  // Detect list type: ordered (digit marker) vs unordered (-/*/+ marker)\n  var matchResult = matchListItem(lineWithoutIndent)\n  if (!matchResult) {\n    state.inList = originalInList\n    return null\n  }\n  var match = matchResult.match\n  var ordered = matchResult.ordered\n  var listItemRegex = matchResult.listItemRegex\n\n  var baseIndent = indentInfo.spaceEquivalent\n  // Extract list-specific properties: start number and delimiter for ordered, marker for unordered\n  var start = ordered ? parseInt(match[1], 10) : undefined\n  var delimiter = ordered ? match[2] : undefined // '.' or ')' for ordered lists\n  var marker = ordered ? undefined : match[1] // '-', '*', or '+' for unordered lists\n\n  // Check if this is an empty list item (no content after marker)\n  var isEmptyItem = ordered ? match[3] === '' : match[2] === ''\n\n  // Helper: Check if we're at a block boundary (document start or after blank line)\n  function isAtBlockBoundary(\n    checkPos: number,\n    requireBlankLine: boolean\n  ): boolean {\n    if (checkPos === 0) return true\n    var prevCode = charCode(source, checkPos - 1)\n    if (prevCode !== $.CHAR_NEWLINE) return false\n    if (!requireBlankLine) return true\n    var backPos = checkPos - 2\n    while (backPos >= 0) {\n      var code = charCode(source, backPos)\n      if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB) break\n      backPos--\n    }\n    return backPos < 0 || charCode(source, backPos) === $.CHAR_NEWLINE\n  }\n\n  // Per CommonMark: empty list items cannot interrupt paragraphs (need blank line)\n  if (isEmptyItem && !isAtBlockBoundary(pos, true)) {\n    state.inList = originalInList\n    return null\n  }\n\n  // Per CommonMark: only ordered lists starting with 1 can interrupt paragraphs\n  if (ordered && start !== 1 && !isAtBlockBoundary(pos, false)) {\n    return null\n  }\n\n  // For unordered lists, check that the whitespace after marker is regular space/tab, not Unicode whitespace\n  if (!ordered && checkUnicodeWhitespaceAfterMarker(match, marker)) {\n    return null\n  }\n\n  // Calculate the content start column: where the first non-whitespace character\n  // after the marker delimiter actually appears in the source\n  // This is needed to determine continuation indentation\n  var markerStartInLine = match.index || 0\n  // isEmptyItem is already set above - check if it needs updating based on spacesAfterMarkerCount\n  // Empty item is different from item with whitespace but no content\n  // We'll calculate spacesAfterMarkerCount later and update isEmptyItem if needed\n  var markerEndInLine = ordered\n    ? markerStartInLine + match[1].length + match[2].length + 1 // number + delimiter + required space\n    : isEmptyItem\n      ? markerStartInLine + match[1].length // marker only (no space)\n      : markerStartInLine + match[1].length + 1 // marker + required space\n  // Find the actual position after marker delimiter in the source\n  var contentStartInSource = pos + indent + markerEndInLine\n  // Count spaces/tabs before first non-whitespace in the content\n  // Per CommonMark spec: marker must be followed by 1  N  4 spaces\n  var contentColumnResult = calculateListItemContentColumn(\n    source,\n    contentStartInSource,\n    lineEnd,\n    baseIndent,\n    markerEndInLine\n  )\n  var contentStartColumn = contentColumnResult.contentStartColumn\n  // minimumContentStartColumn is the minimum column where content can start (for continuation checks)\n  // This is the column after marker+space, regardless of how much whitespace follows\n  // For empty items, it's right after the marker\n  var markerBaseColumn = baseIndent + markerStartInLine + match[1].length\n  var minimumContentStartColumn = ordered\n    ? markerBaseColumn + match[2].length + 1 // number + delimiter + space\n    : isEmptyItem\n      ? markerBaseColumn // marker only (no space)\n      : markerBaseColumn + 1 // marker + space\n\n  var items: MarkdownToJSX.ASTNode[][] = []\n  // Track contentStartColumn for each item (for nested list detection)\n  var itemContentStartColumns: number[] = []\n\n  // Helper: Check if a marker column is nested enough to belong to the last item\n  function isMarkerNested(\n    markerColumn: number,\n    lastItemContentColumn: number,\n    hasBlockContent: boolean\n  ): boolean {\n    return hasBlockContent\n      ? markerColumn >= lastItemContentColumn\n      : markerColumn > lastItemContentColumn\n  }\n\n  // Helper: Get last item\n  function getLastItem(): MarkdownToJSX.ASTNode[] {\n    return items[items.length - 1]\n  }\n\n  // Helper: Get last item's content start column\n  function getLastItemContentColumn(): number {\n    return (\n      itemContentStartColumns[itemContentStartColumns.length - 1] ??\n      contentStartColumn\n    )\n  }\n\n  function tryParseNestedList(\n    pos: number,\n    lastItem: MarkdownToJSX.ASTNode[]\n  ): ParseResult | null {\n    const parentItem = findNestedListParent(lastItem)\n    const originalList = state.inList\n    state.inList = true\n    const result = parseList(source, pos, state, options)\n    state.inList = originalList\n    if (result) {\n      parentItem.push(result)\n      return result\n    }\n    return null\n  }\n\n  var currentPos = skipToNextLine(source, lineEnd)\n\n  // Check if this is a loose list (has blank lines)\n  var checkPos = currentPos\n  var hasBlankLines = false\n\n  while (checkPos < source.length) {\n    var nextLineEnd = util.findLineEnd(source, checkPos)\n    var nextLine = source.slice(checkPos, nextLineEnd)\n    if (nextLine.trim() === '') {\n      // look ahead to next non-empty line\n      var look = skipToNextLine(source, nextLineEnd)\n      while (look < source.length) {\n        var code = charCode(source, look)\n        if (code === $.CHAR_NEWLINE) {\n          // keep skipping\n        } else if (!WHITESPACE_CHARS.has(source[look])) {\n          break\n        }\n        look++\n      }\n      var lookEnd = util.findLineEnd(source, look)\n      var lookLine = source.slice(look, lookEnd)\n      var lookIndentInfo = calculateIndent(source, look, lookEnd)\n      var lookLineWithoutIndent = lookLine.slice(lookIndentInfo.charCount)\n      if (\n        isMatchingListItem(\n          lookLineWithoutIndent,\n          lookIndentInfo,\n          ordered,\n          marker,\n          delimiter,\n          baseIndent,\n          listItemRegex\n        )\n      ) {\n        hasBlankLines = true\n      } else {\n        // Per CommonMark: link reference definitions can interrupt lists\n        // If blank line is followed by a link reference definition, check if there's a list item after it\n        var refEndPos = skipLinkReferenceDefinition(\n          source,\n          look,\n          lookEnd,\n          lookIndentInfo,\n          lookLineWithoutIndent,\n          state,\n          options\n        )\n        if (refEndPos) {\n          var afterRefPos = refEndPos\n          while (\n            afterRefPos < source.length &&\n            charCode(source, afterRefPos) === $.CHAR_NEWLINE\n          ) {\n            afterRefPos++\n          }\n          if (afterRefPos < source.length) {\n            var afterRefLineEnd = util.findLineEnd(source, afterRefPos)\n            var afterRefLine = source.slice(afterRefPos, afterRefLineEnd)\n            var afterRefIndentInfo = calculateIndent(\n              source,\n              afterRefPos,\n              afterRefLineEnd\n            )\n            var afterRefLineWithoutIndent = afterRefLine.slice(\n              afterRefIndentInfo.charCount\n            )\n            if (\n              isMatchingListItem(\n                afterRefLineWithoutIndent,\n                afterRefIndentInfo,\n                ordered,\n                marker,\n                delimiter,\n                baseIndent,\n                listItemRegex\n              )\n            ) {\n              hasBlankLines = true\n            }\n          }\n        }\n      }\n      break\n    }\n    var nextIndentInfo = calculateIndent(source, checkPos, nextLineEnd)\n    var nextLineWithoutIndent = nextLine.slice(nextIndentInfo.charCount)\n    var nextMatchResult = matchListItem(nextLineWithoutIndent)\n    if (!nextMatchResult) break\n    var nextMatch = nextMatchResult.match\n    if (ordered) {\n      if (nextMatch[2] !== delimiter) break\n    } else {\n      if (nextMatch[1] !== marker) break\n    }\n    checkPos = skipToNextLine(source, nextLineEnd)\n  }\n\n  // Parse the first item\n  var firstItemContent = ordered ? match[3] : match[2]\n  // Trim leading whitespace from content (regex now captures optional whitespace)\n  firstItemContent = firstItemContent.trimStart()\n\n  // Per CommonMark spec: tabs after list marker need special handling\n  // For `-\\t\\tfoo`: `-` at column 0, first tab at column 1 = 3 spaces (one for marker delimiter),\n  // second tab at column 4 = 4 spaces, total 6 spaces, so code block with 2 spaces remaining\n  // The regex `\\s+` consumes the tabs, so match[2]/match[3] is just `foo`\n  // We need to check the original source to detect tabs after the marker\n  var markerStartPos = pos + indent + (match.index || 0)\n  var markerEndPos = ordered\n    ? markerStartPos + match[1].length + match[2].length // number + delimiter\n    : markerStartPos + match[1].length // marker\n\n  // Check for spaces after marker (for code blocks with 5+ spaces)\n  // Per CommonMark: if there are 4+ spaces after the marker (including required space),\n  // the first line is an indented code block\n  var contentStartPos = markerEndPos\n  // Skip the required space/tab after marker\n  while (contentStartPos < source.length) {\n    var code = charCode(source, contentStartPos)\n    if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB) break\n    contentStartPos++\n  }\n  // Count spaces after marker (including the required one)\n  var spacesAfterMarkerCount = 0\n  var spacesCheckPos = markerEndPos\n  while (spacesCheckPos < lineEnd) {\n    var code = charCode(source, spacesCheckPos)\n    if (code === $.CHAR_TAB) {\n      spacesAfterMarkerCount += 4 - (spacesAfterMarkerCount % 4)\n    } else if (code === $.CHAR_SPACE) {\n      spacesAfterMarkerCount++\n    } else {\n      break\n    }\n    spacesCheckPos++\n  }\n\n  var tabsProcessed = false\n  if (\n    markerEndPos < source.length &&\n    charCode(source, markerEndPos) === $.CHAR_TAB\n  ) {\n    // First tab after marker was consumed by `\\s+`\n    // Tab at column 1 = 3 spaces (1 for delimiter, 2 for content)\n    // Check if there's a second tab\n    var tabCount = 1\n    var tabCheckPos = markerEndPos + 1\n    while (\n      tabCheckPos < source.length &&\n      charCode(source, tabCheckPos) === $.CHAR_TAB\n    ) {\n      tabCount++\n      tabCheckPos++\n    }\n\n    if (tabCount >= 2) {\n      // We have 2+ tabs after marker: first gives 2 spaces, second at column 4 = 4 spaces\n      // Total: 6 spaces, then remove 4 for code block = 2 spaces\n      firstItemContent = '      ' + firstItemContent\n      tabsProcessed = true\n    }\n  }\n  // Update isEmptyItem now that we know spacesAfterMarkerCount\n  // Empty item is one with no whitespace after marker (spacesAfterMarkerCount === 0)\n  // For unordered lists, also check that match[2] is empty (no content captured)\n  if (!ordered) {\n    isEmptyItem = isEmptyItem && spacesAfterMarkerCount === 0\n  }\n  // RULE_2_CODE_START: if 4+ spaces after marker, first line is indented code block\n  // Skip if tabs were already processed (they already account for code block indentation)\n  if (spacesAfterMarkerCount >= 4 && !tabsProcessed) {\n    // Preserve the leading spaces for code blocks\n    const preservedSpaces = ' '.repeat(spacesAfterMarkerCount - 1)\n    firstItemContent = preservedSpaces + firstItemContent.trimStart()\n  }\n\n  // RULE_3_BLANK_START: check if item starts with blank line\n  // If firstItemContent is empty (just whitespace), this is RULE_3_BLANK_START\n  var startsWithBlankLine = firstItemContent.trim() === ''\n  if (startsWithBlankLine) {\n    // For RULE_3_BLANK_START, content starts after blank line(s)\n    // Continuation lines need to be indented by W + 1 spaces minimum\n    // W is the width of the marker (1 for '-', 2 for '10.', etc.)\n    // So minimum continuation indent is markerWidth + 1\n  }\n\n  // Check if there will be blank lines within the first item (after currentPos)\n  // by looking ahead to see if we'll encounter a blank line before the next item or end\n  let firstItemHasBlankLine = hasBlankLines\n  if (!hasBlankLines && currentPos < source.length) {\n    var firstCheckPos = currentPos\n    while (firstCheckPos < source.length) {\n      var firstNextLineEnd = util.findLineEnd(source, firstCheckPos)\n      var firstNextLine = source.slice(firstCheckPos, firstNextLineEnd)\n      if (isBlankLineCheck(source, firstCheckPos, firstNextLineEnd)) {\n        // Found blank line - check if continuation belongs to nested list or first item\n        var afterBlank = skipToNextLine(source, firstNextLineEnd)\n        // Skip consecutive blank lines\n        while (afterBlank < source.length) {\n          var blankLineEnd = util.findLineEnd(source, afterBlank)\n          if (isBlankLineCheck(source, afterBlank, blankLineEnd)) {\n            afterBlank = skipToNextLine(source, blankLineEnd)\n          } else {\n            break\n          }\n        }\n\n        if (afterBlank < source.length) {\n          var afterIndentInfo = calculateIndent(\n            source,\n            afterBlank,\n            source.length\n          )\n          var afterIndent = afterIndentInfo.spaceEquivalent\n          if (afterIndent >= baseIndent) {\n            var afterLine = source.slice(\n              afterBlank,\n              util.findLineEnd(source, afterBlank)\n            )\n            var afterMatch = afterLine\n              .slice(afterIndentInfo.charCount)\n              .match(listItemRegex)\n            var afterIsNewItem =\n              afterMatch &&\n              (ordered ? afterMatch[2] === delimiter : afterMatch[1] === marker)\n\n            // Find nested item before blank line and calculate its content column\n            var nestedItemContentColumn = null\n            for (\n              var nestedCheckPos = currentPos;\n              nestedCheckPos < firstCheckPos;\n              nestedCheckPos = util.findLineEnd(source, nestedCheckPos) + 1\n            ) {\n              var nestedCheckLineEnd = util.findLineEnd(source, nestedCheckPos)\n              var nestedCheckIndentInfo = calculateIndent(\n                source,\n                nestedCheckPos,\n                nestedCheckLineEnd\n              )\n              var nestedCheckMatch = source\n                .slice(nestedCheckPos, nestedCheckLineEnd)\n                .slice(nestedCheckIndentInfo.charCount)\n                .match(listItemRegex)\n              var isNestedItem =\n                nestedCheckMatch &&\n                nestedCheckIndentInfo.spaceEquivalent > baseIndent &&\n                nestedCheckIndentInfo.spaceEquivalent >= contentStartColumn &&\n                (ordered\n                  ? nestedCheckMatch[2] === delimiter\n                  : nestedCheckMatch[1] === marker)\n\n              if (isNestedItem) {\n                // Calculate nested item's content column (same pattern as contentStartColumn)\n                var nestedMarkerStart =\n                  nestedCheckIndentInfo.spaceEquivalent + 1\n                var nestedMarkerEnd = ordered\n                  ? nestedMarkerStart +\n                    nestedCheckMatch[1].length +\n                    nestedCheckMatch[2].length +\n                    1\n                  : nestedMarkerStart + nestedCheckMatch[1].length + 1\n                var nestedContentStartInSource =\n                  nestedCheckPos +\n                  nestedCheckIndentInfo.charCount +\n                  nestedCheckMatch[0].length\n                var nestedResult = calculateListItemContentColumn(\n                  source,\n                  nestedContentStartInSource,\n                  nestedCheckLineEnd,\n                  nestedMarkerStart,\n                  nestedMarkerEnd - nestedMarkerStart\n                )\n                nestedItemContentColumn = nestedResult.contentStartColumn\n                break\n              }\n            }\n\n            var continuationCheckColumn =\n              spacesAfterMarkerCount >= 5\n                ? minimumContentStartColumn\n                : contentStartColumn\n            if (\n              !afterIsNewItem &&\n              afterIndent >= continuationCheckColumn &&\n              (nestedItemContentColumn === null ||\n                afterIndent + 1 < nestedItemContentColumn)\n            ) {\n              firstItemHasBlankLine = true\n            }\n          }\n        }\n        break\n      }\n      // Check if this line is a new list item (at same or greater indentation)\n      var firstLineIndentInfo = calculateIndent(\n        source,\n        firstCheckPos,\n        firstNextLineEnd\n      )\n      var firstIndent = firstLineIndentInfo.spaceEquivalent\n      var firstLineWithoutIndent = firstNextLine.slice(\n        firstLineIndentInfo.charCount\n      )\n      var firstLineMatch = firstLineWithoutIndent.match(listItemRegex)\n      var firstIsNewItem =\n        firstLineMatch &&\n        (ordered\n          ? firstLineMatch[2] === delimiter\n          : firstLineMatch[1] === marker)\n      // If it's a new item at baseIndent, it's the next item at same level - stop looking\n      // For nested items, continue looking for blank lines after the nested list\n      if (firstIsNewItem) {\n        if (firstIndent <= baseIndent) {\n          // Same level or higher - stop looking\n          break\n        }\n        // Nested list - continue looking (don't break)\n      }\n      firstCheckPos = skipToNextLine(source, firstNextLineEnd)\n    }\n  }\n\n  // Handle fenced code blocks that span multiple lines\n  // Note: We use manual expansion here rather than parseCodeFenced because\n  // we need to return a content string (with fence lines) that will be parsed later,\n  // not an AST node. parseCodeFenced returns an AST node, which doesn't fit this use case.\n  var actualFirstItemContent = firstItemContent\n  if (\n    util.startsWith(firstItemContent, '```') ||\n    util.startsWith(firstItemContent, '~~~')\n  ) {\n    var markerWidth = ordered\n      ? match[1].length + match[2].length + 1\n      : match[1].length + 1\n    var expandedResult = expandMultilineFencedCodeBlock(\n      source,\n      firstItemContent,\n      currentPos,\n      markerWidth\n    )\n    actualFirstItemContent = expandedResult.content\n    currentPos = expandedResult.endPos\n  }\n\n  // For tight lists with whitespace-only first line, combine with continuation to avoid multiple blocks\n  var hasWhitespaceButNoContent =\n    !isEmptyItem &&\n    firstItemContent.trim() === '' &&\n    spacesAfterMarkerCount > 0 &&\n    spacesAfterMarkerCount < 5\n  // For ALL tight lists (no blank lines), concatenate simple text continuation lines BEFORE\n  // building the item content. This is necessary to preserve hard line breaks (two trailing\n  // spaces before newline) that would otherwise be lost when first line and continuation are\n  // parsed separately. The broader condition (not just whitespace-only first lines) is safe\n  // because we stop collecting text when we hit NEW block elements (not continuations of the\n  // same block element), which ensures block-level structures are still parsed correctly.\n  if (!firstItemHasBlankLine) {\n    // Detect if the first line starts a blockquote (to allow continuation lines)\n    var firstLineFirstChar =\n      actualFirstItemContent.length > 0 ? actualFirstItemContent[0] : ''\n    var firstLineStartsBlockQuote = firstLineFirstChar === '>'\n\n    var pos = currentPos\n    while (pos < source.length) {\n      var lineEnd = util.findLineEnd(source, pos)\n      var line = source.slice(pos, lineEnd)\n      if (line.trim() === '') break\n      var indentInfo = calculateIndent(source, pos, lineEnd)\n      if (indentInfo.spaceEquivalent < minimumContentStartColumn) break\n      var lineWithoutIndent = line.slice(indentInfo.charCount)\n      if (\n        indentInfo.spaceEquivalent <= baseIndent &&\n        isMatchingListItem(\n          lineWithoutIndent,\n          indentInfo,\n          ordered,\n          marker,\n          delimiter,\n          baseIndent,\n          listItemRegex\n        )\n      ) {\n        break\n      }\n      // Check for nested list items\n      if (\n        isLineListItem(lineWithoutIndent) &&\n        indentInfo.spaceEquivalent > baseIndent\n      ) {\n        break\n      }\n      // Check for block elements - stop collecting text if we hit a NEW block element\n      // (not a continuation of the same block element started on the first line)\n      var firstChar = lineWithoutIndent.length > 0 ? lineWithoutIndent[0] : ''\n      // Allow blockquote continuation if first line started a blockquote\n      var isBlockQuoteContinuation =\n        firstChar === '>' && firstLineStartsBlockQuote\n      if (\n        (firstChar === '>' && !isBlockQuoteContinuation) ||\n        firstChar === '#' ||\n        util.startsWith(lineWithoutIndent, '```') ||\n        util.startsWith(lineWithoutIndent, '~~~')\n      ) {\n        break\n      }\n      actualFirstItemContent += '\\n' + lineWithoutIndent\n      currentPos = pos = skipToNextLine(source, lineEnd)\n    }\n  }\n\n  // Build first item with GFM task support\n  items.push(\n    buildListItemContent(\n      actualFirstItemContent,\n      firstItemHasBlankLine,\n      state,\n      options\n    )\n  )\n  itemContentStartColumns.push(contentStartColumn)\n\n  // Process continuation lines for the first item\n  // For tight lists (no blank lines), also process continuation if it's indented enough\n  const shouldProcessContinuation =\n    firstItemHasBlankLine &&\n    (spacesAfterMarkerCount >= 5 || hasWhitespaceButNoContent)\n  if (shouldProcessContinuation) {\n    const lastItem = getLastItem()\n    currentPos = processContinuation(\n      source,\n      lastItem,\n      minimumContentStartColumn,\n      currentPos,\n      baseIndent,\n      ordered,\n      marker,\n      delimiter,\n      listItemRegex,\n      state,\n      options,\n      true\n    )\n  } else if (!firstItemHasBlankLine) {\n    // For tight lists (no blank lines), process continuation lines\n    const continuationColumn = minimumContentStartColumn - 1\n    while (currentPos < source.length) {\n      const nextLineEnd = util.findLineEnd(source, currentPos)\n      const nextLine = source.slice(currentPos, nextLineEnd)\n      const nextIndentInfo = calculateIndent(source, currentPos, nextLineEnd)\n      const nextIndent = nextIndentInfo.spaceEquivalent\n      const nextLineWithoutIndent = nextLine.slice(nextIndentInfo.charCount)\n\n      if (\n        nextLine.trim() === '' ||\n        (nextIndent <= baseIndent &&\n          isMatchingListItem(\n            nextLineWithoutIndent,\n            nextIndentInfo,\n            ordered,\n            marker,\n            delimiter,\n            baseIndent,\n            listItemRegex\n          )) ||\n        (isLineListItem(nextLineWithoutIndent) && nextIndent > baseIndent) ||\n        nextIndent < continuationColumn\n      ) {\n        break\n      }\n\n      const lastItem = getLastItem()\n      const result = processListContinuationLine(\n        source,\n        currentPos,\n        nextLineEnd,\n        nextIndentInfo,\n        continuationColumn,\n        contentStartColumn,\n        lastItem,\n        false,\n        state,\n        options,\n        true,\n        baseIndent\n      )\n      if (result.processed) {\n        currentPos = result.newPos\n      } else {\n        break\n      }\n    }\n  }\n\n  // Continue parsing subsequent list items\n  var prevLineWasBlank = false\n  while (currentPos < source.length) {\n    const nextLineEnd = util.findLineEnd(source, currentPos)\n\n    const nextLine = source.slice(currentPos, nextLineEnd)\n    const nextIndentInfo = calculateIndent(source, currentPos, nextLineEnd)\n    const nextIndentChars = nextIndentInfo.charCount\n    const nextIndent = nextIndentInfo.spaceEquivalent\n\n    if (nextLine.trim() === '') {\n      // Blank line - mark as loose list and continue\n      hasBlankLines = true\n      prevLineWasBlank = true\n      currentPos = skipToNextLine(source, nextLineEnd)\n    } else if (nextIndent < baseIndent) {\n      const nextLineWithoutIndent = nextLine.slice(nextIndentChars)\n      if (\n        nextLineWithoutIndent.startsWith('<') &&\n        checkHTMLTagInterruptsList(\n          source,\n          currentPos,\n          nextIndentChars,\n          baseIndent,\n          nextIndent,\n          options\n        )\n      ) {\n        break\n      }\n\n      // Less indented - check if this is a lazy continuation line\n      // Per CommonMark: lazy continuation lines can have all indentation deleted\n      // They are still part of the list item if they are paragraph continuation text\n      const trimmed = nextLineWithoutIndent.trim()\n      if (\n        trimmed.length > 0 &&\n        items.length > 0 &&\n        !isBlockStartChar(trimmed[0]) &&\n        !isMatchingListItem(\n          nextLineWithoutIndent,\n          nextIndentInfo,\n          ordered,\n          marker,\n          delimiter,\n          baseIndent,\n          listItemRegex\n        )\n      ) {\n        const lastItem = getLastItem()\n        if (lastItem.length > 0) {\n          const lastBlock = lastItem[lastItem.length - 1]\n          if (\n            !prevLineWasBlank &&\n            (lastBlock.type === RuleType.paragraph ||\n              lastBlock.type === RuleType.text)\n          ) {\n            // This is a lazy continuation line - continue the paragraph\n            // Per CommonMark: lazy continuation only applies when there's no blank line\n            appendListContinuation(\n              nextLineWithoutIndent,\n              lastItem,\n              state,\n              options\n            )\n            prevLineWasBlank = false\n            currentPos = skipToNextLine(source, nextLineEnd)\n            continue\n          }\n        }\n      }\n      // Not a lazy continuation - end of list\n      break\n    } else {\n      const nextLineWithoutIndent = nextLine.slice(nextIndentChars)\n\n      // Check for setext heading BEFORE thematic break\n      // If last item ends with text/paragraph and this line is setext underline, convert to heading\n      // Per CommonMark: setext underline must be indented enough to be continuation\n      // BUT: don't check if this line is a list item marker (would be continuation of wrong item)\n      if (items.length > 0) {\n        const lastItemContentStartColumn =\n          itemContentStartColumns[items.length - 1] || contentStartColumn\n        if (\n          nextIndent + 1 >= lastItemContentStartColumn &&\n          !isMatchingListItem(\n            nextLineWithoutIndent,\n            nextIndentInfo,\n            ordered,\n            marker,\n            delimiter,\n            baseIndent,\n            listItemRegex\n          )\n        ) {\n          const lastItem = getLastItem()\n          if (\n            lastItem.length > 0 &&\n            convertSetextHeadingInListItem(\n              lastItem,\n              nextLineWithoutIndent,\n              options\n            )\n          ) {\n            currentPos = skipToNextLine(source, nextLineEnd)\n            continue\n          }\n        }\n      }\n\n      // Check if this line is a thematic break (per CommonMark, thematic breaks end lists)\n      const thematicBreakResult = parseBreakThematic(\n        source,\n        currentPos,\n        state,\n        options\n      )\n      if (thematicBreakResult) {\n        // Thematic break ends the list\n        break\n      }\n\n      // Per CommonMark spec: link reference definitions interrupt list continuation\n      // Check if this is a link reference definition after a blank line\n      if (prevLineWasBlank) {\n        const refEndPos = skipLinkReferenceDefinition(\n          source,\n          currentPos,\n          nextLineEnd,\n          nextIndentInfo,\n          nextLineWithoutIndent,\n          state,\n          options\n        )\n        if (refEndPos) {\n          // Skip link reference definition and continue parsing list (don't break)\n          currentPos = refEndPos\n          prevLineWasBlank = false\n          continue\n        }\n      }\n\n      // If line is at base indentation and not a list item, check for lazy continuation first\n      if (nextIndent <= baseIndent) {\n        if (\n          nextLineWithoutIndent.startsWith('<') &&\n          checkHTMLTagInterruptsList(\n            source,\n            currentPos,\n            nextIndentChars,\n            baseIndent,\n            nextIndent,\n            options\n          )\n        ) {\n          break\n        }\n\n        if (\n          !isMatchingListItem(\n            nextLineWithoutIndent,\n            nextIndentInfo,\n            ordered,\n            marker,\n            delimiter,\n            baseIndent,\n            listItemRegex\n          )\n        ) {\n          // Check for lazy continuation when nextIndent === baseIndent\n          // Per CommonMark: lazy continuation lines can have all indentation deleted\n          // BUT: only if there was no blank line before (lazy continuation requires no blank line)\n          // AND: only if it's truly paragraph continuation text (not a block start)\n          if (nextIndent === baseIndent && !prevLineWasBlank) {\n            const trimmed = nextLineWithoutIndent.trim()\n            if (trimmed.length > 0 && !isBlockStartChar(trimmed[0])) {\n              // Check if this line would start a block (like HTML comment, thematic break, etc.)\n              // If so, it should break the list, not continue it\n              const blockResult = parseBlock(source, currentPos, state, options)\n              if (blockResult && blockResult.type !== RuleType.paragraph) {\n                break\n              }\n              const lastItem = getLastItem()\n              if (lastItem.length > 0 && !listItemHasBlockContent(lastItem)) {\n                // Continuation line at base indentation - add newline for proper spacing\n                appendListContinuation(\n                  nextLineWithoutIndent,\n                  lastItem,\n                  state,\n                  options,\n                  true\n                )\n                prevLineWasBlank = false\n                currentPos = skipToNextLine(source, nextLineEnd)\n                continue\n              }\n            }\n          }\n          break\n        }\n      }\n\n      // Check for empty items with blank lines\n      if (\n        shouldBreakForEmptyItem(\n          items,\n          isEmptyItem,\n          prevLineWasBlank,\n          firstItemContent\n        )\n      )\n        break\n\n      const nextMatchResult = matchListItem(nextLineWithoutIndent)\n      const nextMatch = nextMatchResult ? nextMatchResult.match : null\n      const isSameType =\n        nextMatch &&\n        (ordered ? nextMatch[2] === delimiter : nextMatch[1] === marker)\n      // Per CommonMark: list markers may be indented by up to 3 spaces\n      // If marker is too indented (> 3 spaces), it's not a valid list item\n      // If there's a blank line before such a marker, end the list (e.g., Example 313)\n      if (isSameType && nextIndent > 3 && prevLineWasBlank) {\n        break\n      }\n      // Skip list item processing and fall through to continuation check\n      if (isSameType && nextIndent <= baseIndent + 3) {\n        if (nextIndent >= 4 && prevLineWasBlank) break\n        if (nextIndent === baseIndent) {\n          // Item at same level - parse as new item\n          let itemContent = ordered ? nextMatch[3] : nextMatch[2]\n          itemContent = itemContent.trimStart()\n\n          const result = addListItem(\n            source,\n            items,\n            itemContentStartColumns,\n            itemContent,\n            currentPos,\n            nextLineEnd,\n            nextIndent,\n            nextIndentChars,\n            nextMatch,\n            ordered,\n            hasBlankLines,\n            state,\n            options\n          )\n          currentPos = result.newCurrentPos\n          prevLineWasBlank = false\n\n          // For empty items, process continuation immediately\n          if (itemContent.trim() === '') {\n            const newItem = items[items.length - 1]\n            const thisItemContentStartColumn = getLastItemContentColumn()\n            currentPos = processContinuation(\n              source,\n              newItem,\n              thisItemContentStartColumn,\n              currentPos,\n              baseIndent,\n              ordered,\n              marker,\n              delimiter,\n              listItemRegex,\n              state,\n              options\n            )\n          }\n\n          continue\n        }\n        if (nextIndent > baseIndent) {\n          // Per CommonMark spec: items are only nested if indented enough to belong to previous item\n          // If there was a blank line before this item, it's at the same level (not nested)\n          if (prevLineWasBlank) {\n            // Blank line before item means it's a new item at same level, not nested\n            let itemContent = ordered ? nextMatch[3] : nextMatch[2]\n            // Trim leading whitespace from content (regex now captures optional whitespace)\n            itemContent = itemContent.trimStart()\n            const result = addListItem(\n              source,\n              items,\n              itemContentStartColumns,\n              itemContent,\n              currentPos,\n              nextLineEnd,\n              nextIndent,\n              nextIndentChars,\n              nextMatch,\n              ordered,\n              hasBlankLines,\n              state,\n              options\n            )\n            currentPos = result.newCurrentPos\n            prevLineWasBlank = false\n            continue\n          }\n          // Check if this item's marker position is indented enough to be continuation of previous item\n          // We need to calculate the previous item's contentStartColumn, not use the first item's\n          const lastItem = getLastItem()\n          const markerColumn = nextIndent + 1\n          const isNested = isMarkerNested(\n            markerColumn,\n            getLastItemContentColumn(),\n            listItemHasBlockContent(lastItem)\n          )\n\n          if (isNested) {\n            const nestedResult = tryParseNestedList(currentPos, lastItem)\n            if (nestedResult) {\n              currentPos = nestedResult.endPos\n              prevLineWasBlank = false\n              continue\n            }\n          }\n          // Item is not indented enough to be nested - check if it's same type for same level\n          if (!isNested && isSameType) {\n            // This item has more indentation than baseIndent but not enough to be nested\n            // It's still at the same level - parse it as a new item\n            let itemContent = ordered ? nextMatch[3] : nextMatch[2]\n            // Trim leading whitespace from content\n            itemContent = itemContent.trimStart()\n            if (!hasBlankLines) {\n              // Check if this item has blank lines within it\n              let checkItemPos = skipToNextLine(source, nextLineEnd)\n              while (checkItemPos < source.length) {\n                const checkLineEnd = util.findLineEnd(source, checkItemPos)\n                const checkLine = source.slice(checkItemPos, checkLineEnd)\n                const checkIndentInfo = calculateIndent(\n                  source,\n                  checkItemPos,\n                  checkLineEnd\n                )\n                const checkIndent = checkIndentInfo.spaceEquivalent\n\n                if (checkLine.trim() === '') {\n                  const afterBlank = skipToNextLine(source, checkLineEnd)\n                  if (afterBlank < source.length) {\n                    const afterBlankIndentInfo = calculateIndent(\n                      source,\n                      afterBlank,\n                      source.length\n                    )\n                    const afterBlankIndent =\n                      afterBlankIndentInfo.spaceEquivalent\n                    // Calculate contentStartColumn for this item\n                    const thisItemMarkerStart = nextIndent\n                    const thisItemContentStart =\n                      thisItemMarkerStart +\n                      (ordered\n                        ? nextMatch[1].length + nextMatch[2].length + 1\n                        : nextMatch[1].length + 1)\n                    if (afterBlankIndent + 1 > thisItemContentStart) {\n                      break\n                    }\n                  }\n                  break\n                } else if (checkIndent <= baseIndent) {\n                  // Check if this is the next list item at baseIndent or less\n                  const checkLineWithoutIndent = checkLine.slice(\n                    checkIndentInfo.charCount\n                  )\n                  const checkMatch = checkLineWithoutIndent.match(listItemRegex)\n                  const isNextItem =\n                    checkMatch &&\n                    (ordered\n                      ? checkMatch[2] === delimiter\n                      : checkMatch[1] === marker)\n                  if (isNextItem && checkIndent <= baseIndent) {\n                    break\n                  }\n                }\n                checkItemPos = skipToNextLine(source, checkLineEnd)\n              }\n            }\n            const result = addListItem(\n              source,\n              items,\n              itemContentStartColumns,\n              itemContent,\n              currentPos,\n              nextLineEnd,\n              nextIndent,\n              nextIndentChars,\n              nextMatch,\n              ordered,\n              hasBlankLines,\n              state,\n              options\n            )\n            currentPos = result.newCurrentPos\n            prevLineWasBlank = false\n            continue\n          } else if (!isNested && !isSameType) {\n            // Different marker type at same level - end this list\n            break\n          }\n          // Fall through to continuation check if isNested but parseList failed\n          // Check if this is continuation content\n          // Per CommonMark: continuation needs to be indented to at least the content start column\n          // nextIndent is space count (0-indexed), contentStartColumn is column number (1-indexed)\n          // When list item has block content, exact indentation (==) continues; otherwise use >\n          // For continuation checks, use minimumContentStartColumn (column after marker+space)\n          // instead of contentStartColumn (which can be higher for code blocks)\n          {\n            const lastItem = getLastItem()\n            // Check if last item is empty (no content)\n            const lastItemIsEmpty = lastItem.length === 0\n            // Check for empty items with blank lines\n            if (\n              lastItemIsEmpty &&\n              shouldBreakForEmptyItem(\n                items,\n                isEmptyItem,\n                prevLineWasBlank,\n                firstItemContent\n              )\n            )\n              break\n\n            const hasBlockContent = lastItem.some(\n              node =>\n                node.type === RuleType.codeBlock ||\n                node.type === RuleType.paragraph ||\n                node.type === RuleType.blockQuote ||\n                node.type === RuleType.orderedList ||\n                node.type === RuleType.unorderedList ||\n                node.type === RuleType.heading\n            )\n            // For empty items, use minimumContentStartColumn (marker + space) instead of contentStartColumn\n            // which can be higher when there's extra whitespace but no content\n            const continuationColumn =\n              lastItemIsEmpty && items.length === 1\n                ? minimumContentStartColumn\n                : contentStartColumn\n            const continuationCheck = hasBlockContent\n              ? nextIndent >= continuationColumn\n              : nextIndent > continuationColumn\n            if (continuationCheck) {\n              const result = processListContinuationLine(\n                source,\n                currentPos,\n                nextLineEnd,\n                nextIndentInfo,\n                continuationColumn,\n                contentStartColumn,\n                getLastItem(),\n                prevLineWasBlank,\n                state,\n                options,\n                undefined,\n                baseIndent\n              )\n              if (result.processed) {\n                prevLineWasBlank = result.wasBlank\n                currentPos = result.newPos\n                continue\n              }\n            } else {\n              break\n            }\n          }\n        } else if (nextIndent === baseIndent) {\n          // Check for Unicode whitespace after marker in unordered lists\n          if (\n            !ordered &&\n            nextMatch &&\n            checkUnicodeWhitespaceAfterMarker(nextMatch, nextMatch[1])\n          ) {\n            break\n          }\n          let itemContent = ordered ? nextMatch[3] : nextMatch[2]\n          // Trim leading whitespace from content (regex now captures optional whitespace)\n          itemContent = itemContent.trimStart()\n          // Per CommonMark: A list is loose if items are separated by blank lines,\n          // OR if an item directly contains two block-level elements with a blank line between them.\n          // If list is loose (hasBlankLines = true), ALL items are wrapped.\n          // Otherwise, an item is wrapped only if it has blank lines within it.\n          // A blank line before this item means the PREVIOUS item was separated from this one,\n          // making the list loose. For this item, we check if it has continuation after blank lines.\n          // But if the list is already loose (hasBlankLines), wrap this item too.\n          const result = addListItem(\n            source,\n            items,\n            itemContentStartColumns,\n            itemContent,\n            currentPos,\n            nextLineEnd,\n            baseIndent,\n            nextIndentChars,\n            nextMatch,\n            ordered,\n            hasBlankLines,\n            state,\n            options\n          )\n          currentPos = result.newCurrentPos\n          prevLineWasBlank = false\n        }\n      } else if (nextIndent > baseIndent) {\n        // Check if this is a list item - if so, check if it should be nested or separate\n        // Per CommonMark: list item markers can only be indented 0-3 spaces relative to baseIndent\n        // However, nested lists can have more indentation if they're indented relative to content start\n        // So we need to try parsing as nested list first, then check for paragraph continuation\n        const lastItem = getLastItem()\n        const isListItemResult = isLineListItem(nextLineWithoutIndent)\n        if (isListItemResult) {\n          // Check if marker would be properly nested (relative to content start column)\n          // This handles nested lists that may have > 3 spaces indent from baseIndent\n          const markerColumn = nextIndent + 1\n          const isNested = isMarkerNested(\n            markerColumn,\n            getLastItemContentColumn(),\n            listItemHasBlockContent(lastItem)\n          )\n\n          if (isNested) {\n            // Properly nested - try parsing as nested list\n            const nestedResult = tryParseNestedList(currentPos, lastItem)\n            if (nestedResult) {\n              currentPos = nestedResult.endPos\n              prevLineWasBlank = false\n              continue\n            }\n          }\n\n          // Not properly nested - check if marker indent is valid (0-3 spaces relative to baseIndent)\n          // Per CommonMark: list item markers can only be indented 0-3 spaces relative to baseIndent\n          const markerIndentRelative = nextIndent - baseIndent\n          if (markerIndentRelative > 3) {\n            // Too much indentation (> 3 spaces from baseIndent) and not nested - not a valid list item marker\n            // Check if it should be treated as paragraph continuation (if last item ends with paragraph)\n            const lastBlock =\n              lastItem.length > 0 ? lastItem[lastItem.length - 1] : null\n            if (\n              lastBlock &&\n              (lastBlock.type === RuleType.paragraph ||\n                lastBlock.type === RuleType.text)\n            ) {\n              // This is paragraph continuation text, not a code block or nested list\n              appendListContinuation(\n                nextLineWithoutIndent,\n                lastItem,\n                state,\n                options\n              )\n              prevLineWasBlank = false\n              currentPos = skipToNextLine(source, nextLineEnd)\n              continue\n            }\n            // Not paragraph continuation - fall through to code block check\n          } else {\n            // Valid marker indent (0-3 spaces) but not nested - this should be a separate list\n            break\n          }\n        } else {\n          // Not a list item - try parsing as nested list (for other block types)\n          const nestedResult = tryParseNestedList(currentPos, lastItem)\n          if (nestedResult) {\n            currentPos = nestedResult.endPos\n            prevLineWasBlank = false\n            continue\n          }\n        }\n        // Check if this is continuation content\n        // Per CommonMark: continuation needs to be indented to at least the content start column\n        // nextIndent is space count (0-indexed), contentStartColumn is column number (1-indexed)\n        // When list item has block content, exact indentation (==) continues; otherwise use >\n        // For continuation checks, use minimumContentStartColumn (column after marker+space)\n        // instead of contentStartColumn (which can be higher for code blocks)\n        const continuationColumn = contentStartColumn\n        const continuationCheck = listItemHasBlockContent(lastItem)\n          ? nextIndent >= continuationColumn - 1\n          : nextIndent > continuationColumn - 1\n        if (continuationCheck) {\n          const result = processListContinuationLine(\n            source,\n            currentPos,\n            nextLineEnd,\n            nextIndentInfo,\n            continuationColumn - 1,\n            contentStartColumn,\n            getLastItem(),\n            prevLineWasBlank,\n            state,\n            options,\n            undefined,\n            baseIndent\n          )\n          if (result.processed) {\n            prevLineWasBlank = result.wasBlank\n            currentPos = result.newPos\n            continue\n          }\n        } else {\n          break\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  // For loose lists, ensure all items have paragraph wrappers\n  // The first item may have been created before we detected that the list is loose\n  if (\n    hasBlankLines &&\n    items.length > 1 &&\n    items[0].length > 0 &&\n    items[0][0].type !== RuleType.paragraph\n  ) {\n    // Check if list is truly loose (another item has paragraph wrapper)\n    for (var j = 1; j < items.length; j++) {\n      if (items[j].length > 0 && items[j][0].type === RuleType.paragraph) {\n        // First item is all inline content - wrap it for loose lists\n        var isBlock = false\n        for (var i = 0; i < items[0].length; i++) {\n          var t = items[0][i].type\n          if (\n            t === RuleType.codeBlock ||\n            t === RuleType.heading ||\n            t === RuleType.blockQuote ||\n            t === RuleType.orderedList ||\n            t === RuleType.unorderedList ||\n            t === RuleType.htmlBlock ||\n            t === RuleType.breakThematic\n          ) {\n            isBlock = true\n            break\n          }\n        }\n        if (!isBlock) {\n          items[0] = [\n            {\n              type: RuleType.paragraph,\n              children: items[0],\n            } as MarkdownToJSX.ParagraphNode,\n          ]\n        }\n        break\n      }\n    }\n  }\n\n  const listNode = ordered\n    ? ({\n        type: RuleType.orderedList,\n        items,\n        ordered: true,\n        start,\n      } as MarkdownToJSX.OrderedListNode)\n    : ({\n        type: RuleType.unorderedList,\n        items,\n        ordered: false,\n      } as MarkdownToJSX.UnorderedListNode)\n\n  // Restore original inList state\n  state.inList = originalInList\n\n  return {\n    ...listNode,\n    endPos: currentPos,\n  } as (MarkdownToJSX.OrderedListNode | MarkdownToJSX.UnorderedListNode) & {\n    endPos: number\n  }\n}\n\nfunction parseTable(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  if (state.inline) return null\n\n  const lines: string[] = []\n  let currentPos = pos\n\n  while (currentPos < source.length) {\n    const lineEnd = util.findLineEnd(source, currentPos)\n    if (isBlankLineCheck(source, currentPos, lineEnd)) break\n\n    const line = source.slice(currentPos, lineEnd).trim()\n    const isTableLine =\n      line.indexOf('|') !== -1 ||\n      (lines.length >= 3 && line && !isBlockStartChar(line[0]))\n\n    if (!isTableLine) break\n    lines.push(line)\n    currentPos = skipToNextLine(source, lineEnd)\n  }\n\n  if (lines.length < 2) return null\n\n  // Unwrap pipes and split cells\n  const unwrap = (line: string) =>\n    line[0] === '|' && line[line.length - 1] === '|' ? line.slice(1, -1) : line\n\n  const splitCells = (line: string) => {\n    const cells: string[] = []\n    let current = ''\n    let inCode = false\n\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i]\n      if (ch === '\\\\' && i + 1 < line.length && line[i + 1] === '|') {\n        current += '|'\n        i++\n      } else if (ch === '`') {\n        inCode = !inCode\n        current += ch\n      } else if (ch === '|' && !inCode) {\n        cells.push(current.trim())\n        current = ''\n      } else {\n        current += ch\n      }\n    }\n    cells.push(current.trim())\n    return cells\n  }\n\n  const headerCells = splitCells(unwrap(lines[0]))\n  if (!headerCells.length) return null\n\n  const separatorCells = splitCells(unwrap(lines[1]))\n  if (\n    separatorCells.length !== headerCells.length ||\n    separatorCells.some(cell => !/^:?-+:?$/.test(cell))\n  ) {\n    return null\n  }\n\n  const alignments = separatorCells.map(cell => {\n    const start = cell[0] === ':'\n    const end = cell[cell.length - 1] === ':'\n    return start && end ? 'center' : start ? 'left' : end ? 'right' : null\n  })\n\n  if (options.optimizeForStreaming && lines.length === 2) {\n    return null\n  }\n\n  const parseRow = (cells: string[]) =>\n    parseWithInlineMode(state, true, () =>\n      cells.map(cell => parseInlineSpan(cell, 0, cell.length, state, options))\n    )\n\n  const header = parseRow(headerCells)\n\n  const body = lines.slice(2).map(line => {\n    const cells =\n      line.indexOf('|') !== -1 ? splitCells(unwrap(line)) : [line.trim()]\n\n    // Normalize cell count\n    const count = headerCells.length\n    while (cells.length < count) cells.push('')\n    cells.length = count\n\n    return parseRow(cells)\n  })\n\n  return {\n    type: RuleType.table,\n    header,\n    cells: body,\n    align: alignments,\n    endPos: currentPos,\n  } as MarkdownToJSX.TableNode & { endPos: number }\n}\n\n// Type 6 block-level tags - only the most common ones that matter in practice\n// Unknown tags default to type 7 (inline/non-interrupting) for safety\n// This is a pragmatic subset of the CommonMark spec's full list\nvar TYPE6_TAGS = [\n  'div',\n  'p',\n  'section',\n  'article',\n  'aside',\n  'nav',\n  'header',\n  'footer',\n  'main',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'blockquote',\n  'ul',\n  'ol',\n  'li',\n  'dl',\n  'dt',\n  'dd',\n  'table',\n  'thead',\n  'tbody',\n  'tfoot',\n  'tr',\n  'td',\n  'th',\n  'form',\n  'fieldset',\n  'hr',\n  'pre',\n  'details',\n  'summary',\n  'figure',\n  'figcaption',\n]\n\n// Type 1 block tags for fast lookup\nconst TYPE1_TAGS_SET = new Set(['pre', 'script', 'style', 'textarea'])\n\nfunction isType6Tag(tagName: string): boolean {\n  return TYPE6_TAGS.indexOf(tagName.toLowerCase()) !== -1\n}\n\nexport function isType1Block(tagLower: string): boolean {\n  return TYPE1_TAGS_SET.has(tagLower)\n}\n\nfunction isBlankLineCheck(\n  source: string,\n  lineStart: number,\n  lineEnd: number\n): boolean {\n  for (var i = lineStart; i < lineEnd; i++) {\n    const code = charCode(source, i)\n    if (code !== $.CHAR_SPACE && code !== $.CHAR_TAB && code !== $.CHAR_CR)\n      return false\n  }\n  return true\n}\n\nfunction parseWithInlineMode<T>(\n  state: MarkdownToJSX.State,\n  inlineMode: boolean,\n  parseFn: () => T\n): T {\n  const originalInline = state.inline\n  state.inline = inlineMode\n  try {\n    return parseFn()\n  } finally {\n    state.inline = originalInline\n  }\n}\n\nfunction findNextBlankLine(\n  source: string,\n  startPos: number,\n  sourceLen: number\n): number {\n  var pos = startPos\n  while (pos < sourceLen) {\n    var nextLineEnd = util.findLineEnd(source, pos)\n    if (isBlankLineCheck(source, pos, nextLineEnd)) return pos\n    pos = skipToNextLine(source, nextLineEnd)\n  }\n  return sourceLen\n}\n\nfunction createHTMLCommentResult(\n  text: string,\n  endPos: number,\n  options?: { raw?: boolean; endsWithGreaterThan?: boolean }\n): MarkdownToJSX.HTMLCommentNode & {\n  endPos: number\n  raw?: boolean\n  endsWithGreaterThan?: boolean\n} {\n  return {\n    type: RuleType.htmlComment,\n    text: util.normalizeInput(text),\n    endPos,\n    ...options,\n  } as MarkdownToJSX.HTMLCommentNode & {\n    endPos: number\n    raw?: boolean\n    endsWithGreaterThan?: boolean\n  }\n}\n\nfunction createVerbatimHTMLBlock(\n  tagName: string,\n  text: string,\n  endPos: number,\n  attrs?: { [key: string]: any },\n  rawAttrs?: string,\n  isClosingTag?: boolean,\n  canInterruptParagraph?: boolean,\n  options?: ParseOptions,\n  state?: MarkdownToJSX.State\n): MarkdownToJSX.HTMLNode & {\n  endPos: number\n  isClosingTag?: boolean\n  canInterruptParagraph?: boolean\n} {\n  var normalizedText = util.normalizeInput(text)\n  // Detect empty unclosed HTML tags when forceBlock or optimizeForStreaming is used to avoid infinite recursion\n  // For empty unclosed tags like <var>, the text field contains the opening tag itself\n  // When forceBlock/optimizeForStreaming is used, this would cause recursion if the tag is parsed again\n  var finalText = normalizedText\n  if (\n    options &&\n    (options.forceBlock || options.optimizeForStreaming) &&\n    text &&\n    !isClosingTag\n  ) {\n    var openingTagPattern = new RegExp(\n      '^<' + tagName.toLowerCase() + '(\\\\s[^>]*)?>$',\n      'i'\n    )\n    if (openingTagPattern.test(text.trim())) {\n      // Empty unclosed tag detected - render as empty element to avoid recursion\n      finalText = ''\n    }\n  }\n\n  // Always parse content into children, even for verbatim blocks\n  // Extract content from text (may include opening tag)\n  var contentToParse = finalText\n  var tagLower = tagName.toLowerCase()\n\n  // If text starts with opening tag, extract just the content\n  var openingTagPattern2 = new RegExp('^<' + tagLower + '[\\\\s>]', 'i')\n  if (openingTagPattern2.test(contentToParse)) {\n    // Find the end of opening tag\n    var tagEnd = contentToParse.indexOf('>')\n    if (tagEnd !== -1) {\n      contentToParse = contentToParse.slice(tagEnd + 1)\n      // Remove closing tag if present\n      var closingTag = '</' + tagLower + '>'\n      var closingIdx = contentToParse.indexOf(closingTag)\n      if (closingIdx !== -1) {\n        contentToParse = contentToParse.slice(0, closingIdx)\n      }\n    }\n  } else {\n    // Text might just be content, but check for closing tag\n    var closingTag2 = '</' + tagLower + '>'\n    var closingIdx2 = contentToParse.indexOf(closingTag2)\n    if (closingIdx2 !== -1) {\n      contentToParse = contentToParse.slice(0, closingIdx2)\n    }\n  }\n\n  // Parse content into children\n  var children: MarkdownToJSX.ASTNode[] = []\n\n  // In streaming mode, skip all child parsing to avoid infinite recursion with unclosed tags\n  // The content will be rendered as plain text inside the HTML block\n  if (contentToParse && options && !options.optimizeForStreaming) {\n    var parseState: MarkdownToJSX.State = state || {\n      inline: false,\n      inHTML: true,\n      inAnchor: false,\n    }\n\n    // Determine if content should be parsed as blocks or inline\n    var trimmed = contentToParse.trim()\n    var hasDoubleNewline = DOUBLE_NEWLINE_R.test(trimmed)\n    var hasBlockSyntax = BLOCK_SYNTAX_R.test(trimmed)\n    var hasHTMLTags = HTML_BLOCK_ELEMENT_START_R.test(trimmed)\n\n    if (hasDoubleNewline || hasBlockSyntax || hasHTMLTags) {\n      // Parse as blocks\n      var blockState = {\n        ...parseState,\n        inline: false,\n        inHTML: true,\n        inAnchor: parseState.inAnchor || tagLower === 'a',\n      }\n      children = parseBlocksInHTML(trimmed, blockState, options)\n    } else if (trimmed) {\n      // Parse as inline\n      var inlineState = {\n        ...parseState,\n        inline: true,\n        inHTML: true,\n        inAnchor: parseState.inAnchor || tagLower === 'a',\n      }\n      children = parseInlineSpan(\n        trimmed,\n        0,\n        trimmed.length,\n        inlineState,\n        options\n      )\n    }\n  }\n\n  return {\n    type: RuleType.htmlBlock,\n    tag: tagName as MarkdownToJSX.HTMLTags,\n    attrs: attrs || {},\n    rawAttrs: rawAttrs,\n    children: children,\n    rawText: finalText,\n    text: contentToParse, // @deprecated - cleaned up content without tags, use rawText for full raw HTML\n    verbatim: true,\n    isClosingTag: isClosingTag,\n    canInterruptParagraph: canInterruptParagraph,\n    endPos: endPos,\n  } as MarkdownToJSX.HTMLNode & {\n    endPos: number\n    isClosingTag?: boolean\n    canInterruptParagraph?: boolean\n  }\n}\n\n/**\n * Check if content contains block-worthy elements that should be parsed\n * (explicit block syntax or blank lines not inside type 1 HTML blocks)\n */\nfunction hasBlockContent(content: string): boolean {\n  const hasExplicitBlockSyntax = BLOCK_SYNTAX_R.test(content)\n  const hasBlankLines = DOUBLE_NEWLINE_R.test(content)\n  const hasType1Tags = TYPE1_TAG_R.test(content)\n  return hasExplicitBlockSyntax || (hasBlankLines && !hasType1Tags)\n}\n\nfunction processHTMLBlock(\n  tagNameOriginal: string,\n  tagName: string,\n  attrs: string,\n  content: string,\n  fullMatch: string,\n  endPos: number,\n  source: string,\n  state: MarkdownToJSX.State,\n  parentInAnchor: boolean,\n  options: ParseOptions\n): MarkdownToJSX.HTMLNode & { endPos: number } {\n  // Apply block-level paragraph wrapping heuristics\n  if (!state.inHTML && !state.inline && !util.endsWith(fullMatch, '\\n')) {\n    let checkPos = endPos\n    const sourceLen = source.length\n\n    while (checkPos < sourceLen) {\n      const lineEnd = util.findLineEnd(source, checkPos)\n      if (isBlankLineCheck(source, checkPos, lineEnd)) break\n\n      const line = source.slice(checkPos, lineEnd).trim()\n      if (line.length > 0 && isBlockStartChar(line[0])) {\n        const htmlResult = parseHTML(source, checkPos, state, options)\n        if (htmlResult) {\n          checkPos = htmlResult.endPos\n          continue\n        }\n        const selfClosingMatch = parseHTMLTag(source, checkPos)\n        if (selfClosingMatch) {\n          checkPos = selfClosingMatch.endPos\n          continue\n        }\n        return null\n      }\n      checkPos = skipToNextLine(source, lineEnd)\n    }\n  }\n\n  const lowerTag = tagName\n  const isType1BlockTag = isType1Block(lowerTag)\n\n  // Per CommonMark spec: Type 6 blocks that end at blank lines should have verbatim content\n  // Check if this is a type 6 block (block-level, not type 1, not void)\n  var isType6Block = !isType1BlockTag && !util.isVoidElement(tagName)\n\n  // Always extract raw attributes from fullMatch if available (for consistency)\n  // Per CommonMark spec Example 153: newlines and spaces between attributes should be removed\n  // (not converted to spaces) when rendering. Extract raw attributes so html() can handle this.\n  var rawOpeningTag: string | undefined = undefined\n  // Extract raw attributes from opening tag slice if fullMatch is available\n  if (fullMatch) {\n    // Find the closing > of the opening tag\n    var openingTagEnd = fullMatch.indexOf('>')\n    if (openingTagEnd !== -1) {\n      var openingTagSlice = fullMatch.slice(0, openingTagEnd + 1)\n      // Check if opening tag has newlines (for rawOpeningTag preservation)\n      if (openingTagSlice.indexOf('\\n') !== -1) {\n        rawOpeningTag = openingTagSlice\n      }\n      // Always extract raw attributes from the opening tag slice for consistency\n      // Find the tag name end (after <div or <div/) - first whitespace or >\n      var tagNameEnd = openingTagEnd\n      for (var i = 1; i < openingTagEnd; i++) {\n        var ch = openingTagSlice[i]\n        if (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '>') {\n          tagNameEnd = i\n          break\n        }\n      }\n      // Extract attributes from after tag name to before >\n      // Preserve leading whitespace for CommonMark compliance (Examples 615-616)\n      attrs = openingTagSlice.slice(tagNameEnd, openingTagEnd)\n    }\n  }\n\n  // Parse attributes, but always preserve raw attributes for consistency\n  // Per CommonMark spec Example 153: newlines and spaces between attributes should be removed\n  // (not converted to spaces) when rendering. Store raw attributes so html() can handle this.\n  // Trim leading whitespace for parsing, but preserve full attrs (with whitespace) for rawAttrs\n  var attrsTrimmed = attrs.replace(/^[\\s\\n\\r\\t]+/, '')\n  var parsedAttributes = parseHTMLAttributes(\n    attrsTrimmed,\n    tagName,\n    tagNameOriginal,\n    options\n  )\n  var attributes: Record<string, any> = {\n    ...parsedAttributes,\n  }\n\n  // For type 6 blocks, check if content ends with blank line or if there's no closing tag\n  // Both cases mean content should be verbatim\n  var endedAtBlankLine = false\n  var hasClosingTagWithBlockSyntax = false\n  if (isType6Block && content.length > 0) {\n    // Check if there's a closing tag in the content - if so, extract content before it\n    var closingTagPattern = '</' + lowerTag\n    var closingTagIdx = content.indexOf(closingTagPattern)\n    if (closingTagIdx >= 0) {\n      var afterTag = closingTagIdx + closingTagPattern.length\n      while (\n        afterTag < content.length &&\n        (content[afterTag] === ' ' || content[afterTag] === '\\t')\n      )\n        afterTag++\n      if (afterTag < content.length && content[afterTag] === '>') {\n        var contentBeforeClosingTag = content.slice(0, closingTagIdx)\n        if (hasBlockContent(contentBeforeClosingTag)) {\n          content = contentBeforeClosingTag\n          hasClosingTagWithBlockSyntax = true\n        } else {\n          endedAtBlankLine = true\n        }\n      }\n    }\n\n    // If we didn't find a proper closing tag with block syntax, check if content ends with blank lines\n    if (!hasClosingTagWithBlockSyntax) {\n      // Check if content ends with blank line pattern (newline, optional whitespace, newline)\n      var checkPos = content.length - 1\n      // Skip trailing newline\n      if (content[checkPos] === '\\n') {\n        checkPos--\n        // Skip whitespace\n        while (\n          checkPos >= 0 &&\n          (content[checkPos] === ' ' ||\n            content[checkPos] === '\\t' ||\n            content[checkPos] === '\\r')\n        ) {\n          checkPos--\n        }\n        // If there's another newline before this, we have a blank line ending\n        if (checkPos >= 0 && content[checkPos] === '\\n') {\n          endedAtBlankLine = true\n        }\n      }\n    }\n  }\n\n  // Determine if this block should have verbatim rendering hint\n  // Type 1 blocks and Type 6 blocks ending with blank lines should be verbatim\n  var shouldTreatAsVerbatim =\n    isType1BlockTag ||\n    (isType6Block && endedAtBlankLine && !hasBlockContent(content))\n\n  var normalizedContent = util.normalizeInput(content)\n  // Store original content for text field before we modify it for parsing\n  var contentForText = normalizedContent\n  if (shouldTreatAsVerbatim) {\n    if (normalizedContent.length > 0 && normalizedContent[0] === '\\n') {\n      normalizedContent = normalizedContent.slice(1)\n      contentForText = normalizedContent\n    }\n    if (\n      normalizedContent.length > 0 &&\n      normalizedContent[normalizedContent.length - 1] === '\\n'\n    ) {\n      normalizedContent = normalizedContent.slice(0, -1)\n      contentForText = normalizedContent\n    }\n    // Remove closing tag from content before parsing (it should only be in text field)\n    // But keep it in contentForText for the text field\n    var closingTagPattern = '</' + lowerTag + '>'\n    var closingTagIdx = normalizedContent.indexOf(closingTagPattern)\n    if (closingTagIdx !== -1) {\n      normalizedContent = normalizedContent.slice(0, closingTagIdx)\n      // contentForText keeps the closing tag\n    }\n  }\n\n  const leftTrimMatch = normalizedContent.match(/^([ \\t]*)/)\n  const leftTrimAmount = leftTrimMatch ? leftTrimMatch[1] : ''\n  const trimmer = new RegExp(\n    `^${leftTrimAmount.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}`,\n    'gm'\n  )\n  const trimmed = normalizedContent.replace(trimmer, '')\n\n  const hasDoubleNewline = DOUBLE_NEWLINE_R.test(trimmed)\n  const hasNonParagraphBlockSyntax = BLOCK_SYNTAX_R.test(trimmed)\n  const isParagraphTag = lowerTag === 'p'\n  // Check if content contains HTML tags - if so, parse as blocks for proper nesting\n  const hasHTMLTags = HTML_BLOCK_ELEMENT_START_R.test(trimmed)\n  const hasBlockSyntax = isParagraphTag\n    ? hasDoubleNewline\n    : hasDoubleNewline ||\n      hasNonParagraphBlockSyntax ||\n      (state.inHTML && hasHTMLTags)\n\n  // ALWAYS parse content into children, regardless of verbatim flag\n  // Recursion is prevented by state.inHTML guard at parseHTML entry\n  let children: MarkdownToJSX.ASTNode[] = []\n  if (trimmed) {\n    // Parse as blocks when content contains HTML tags to ensure nested HTML is parsed correctly\n    if (hasBlockSyntax || hasHTMLTags) {\n      const blockState = {\n        ...state,\n        inline: false,\n        inHTML: true,\n        inAnchor: state.inAnchor || lowerTag === 'a',\n      }\n      children = parseBlocksInHTML(trimmed, blockState, options)\n    } else {\n      const childState = {\n        ...state,\n        inline: true,\n        inHTML: options.optimizeForStreaming ? true : state.inHTML,\n        inAnchor: parentInAnchor || state.inAnchor || lowerTag === 'a',\n      }\n      children = parseInlineSpan(\n        trimmed,\n        0,\n        trimmed.length,\n        childState,\n        options\n      )\n    }\n  }\n\n  // Store raw text for verbatim blocks (for CommonMark compliance in default renderer)\n  var finalText: string | undefined = undefined\n  if (shouldTreatAsVerbatim) {\n    if (rawOpeningTag !== undefined) {\n      // Type 1 block with newlines in opening tag - preserve raw opening tag + content\n      // Store the full raw HTML (opening tag + content) in text field\n      // The closing tag will be added by html()\n      finalText = rawOpeningTag + contentForText\n    } else {\n      finalText = contentForText\n    }\n  }\n\n  return {\n    type: RuleType.htmlBlock,\n    tag: (shouldTreatAsVerbatim\n      ? tagName\n      : tagNameOriginal) as MarkdownToJSX.HTMLTags,\n    attrs: attributes,\n    rawAttrs: attrs,\n    children: children,\n    rawText: finalText,\n    text: trimmed, // @deprecated - cleaned up content without tags, use rawText for full raw HTML\n    verbatim: shouldTreatAsVerbatim,\n    canInterruptParagraph: true, // type 1-6 blocks can interrupt paragraphs\n    endPos: endPos,\n  } as MarkdownToJSX.HTMLNode & {\n    endPos: number\n    canInterruptParagraph?: boolean\n  }\n}\n\nfunction parseHTML(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): ParseResult {\n  // Must start with '<'\n  if (source[pos] !== '<') return null\n\n  // In streaming mode, skip all HTML parsing when already inside HTML to avoid infinite recursion\n  if (options.optimizeForStreaming && state.inHTML) {\n    return null\n  }\n\n  // Track attempt after cheap disqualifications but before expensive parsing work\n  if (!state.inline) {}\n\n  // Check for processing instructions, declarations, and comments first (before unified parser)\n  if (pos + 1 < source.length) {\n    if (source[pos + 1] === '?') {\n      var piToken = scanRawHTML(source, pos)\n      if (piToken && piToken.kind === 'pi') {\n        return createHTMLCommentResult(piToken.text || '', piToken.endPos, {\n          raw: true,\n        })\n      }\n    } else if (source[pos + 1] === '!') {\n      // Check for HTML comments (<!-- ... -->)\n      if (pos + 3 < source.length && source.slice(pos, pos + 4) === '<!--') {\n        if (state.inline) {} else {}\n        var token = scanRawHTML(source, pos)\n        if (token && token.kind === 'comment') {\n          // Extract text content (strip <!-- and -->)\n          var text = token.text || ''\n          var endsWithGreaterThan = false\n          if (text === '<!-->') {\n            text = ''\n            endsWithGreaterThan = true\n          } else if (text === '<!--->') {\n            text = '-'\n            endsWithGreaterThan = true\n          } else if (text.startsWith('<!--') && text.endsWith('-->')) {\n            text = text.slice(4, -3)\n          }\n          // Track hit for inline mode (block mode hit tracking happens in parseMarkdown)\n          if (state.inline) {}\n          return createHTMLCommentResult(text, token.endPos, {\n            endsWithGreaterThan,\n          })\n        }\n      }\n      var declToken = scanRawHTML(source, pos)\n      if (\n        declToken &&\n        (declToken.kind === 'declaration' || declToken.kind === 'cdata')\n      ) {\n        return createHTMLCommentResult(declToken.text || '', declToken.endPos, {\n          raw: true,\n        })\n      }\n    }\n  }\n\n  // Check for space/newline after < (invalid HTML - should be escaped)\n  if (pos + 1 < source.length) {\n    const nextChar = source[pos + 1]\n    if (\n      nextChar === ' ' ||\n      nextChar === '\\n' ||\n      nextChar === '\\t' ||\n      nextChar === '\\r'\n    ) {\n      return null\n    }\n  }\n\n  // Check if this looks like an autolink before parsing as HTML\n  var closeIdx = source.indexOf('>', pos + 1)\n  if (closeIdx !== -1) {\n    var contentBetween = source.slice(pos + 1, closeIdx)\n    // Check for spaces - if found, might be failed autolink\n    var hasSpace =\n      contentBetween.indexOf(' ') !== -1 || contentBetween.indexOf('\\t') !== -1\n\n    // Check for HTTP(S) URLs - these should be autolinks, not HTML tags\n    if (\n      !hasSpace &&\n      (util.startsWith(contentBetween, 'http://') ||\n        util.startsWith(contentBetween, 'https://'))\n    ) {\n      return null // This is an autolink, not an HTML tag\n    }\n\n    // Check for URI schemes (scheme:pattern) - no spaces\n    if (!hasSpace && isValidUriScheme(contentBetween)) {\n      return null // This is an autolink (URI scheme), not an HTML tag\n    }\n  }\n\n  // Use unified parser\n  var tagResult = parseHTMLTag(source, pos)\n\n  // If parseHTMLTag returns null, it might be an incomplete tag\n  // Handle incomplete/partial tags inline (previously handled by matchHTMLBlock)\n  if (!tagResult && !state.inline) {\n    // Check if we have < followed by a valid tag name (even without closing >)\n    var sourceLen = source.length\n    var firstLineEnd = util.findLineEnd(source, pos)\n    var lineStart = pos\n    // Skip up to 3 spaces of indentation (per spec)\n    var indent = 0\n    while (\n      lineStart < firstLineEnd &&\n      indent < 3 &&\n      (source[lineStart] === ' ' || source[lineStart] === '\\t')\n    ) {\n      indent++\n      lineStart++\n    }\n    if (lineStart >= firstLineEnd || source[lineStart] !== '<') return null\n\n    // Try to parse tag name even if tag is incomplete\n    // Only handle incomplete tags for block-level tags (type 6)\n    // Non-block-level tags that parseHTMLTag can't parse are invalid, not incomplete\n    if (lineStart + 1 < firstLineEnd) {\n      var tagNameResult = parseHTMLTagName(source, lineStart + 1)\n      if (tagNameResult) {\n        var tagName = tagNameResult.tagName\n        var isType6 = isType6Tag(tagName)\n        // Only handle incomplete tags for block-level tags\n        if (!isType6) {\n          return null // Non-block-level tags that parseHTMLTag can't parse are invalid\n        }\n        // Find where the tag would end (end of line or before invalid char)\n        var partialTagEnd = tagNameResult.nextPos\n        var hasNewlineInTag = false\n        var inQuotesPartial = false\n        var quoteCharPartial = ''\n        var checkEnd = firstLineEnd\n        var foundClosingAngle = false\n        // Check across multiple lines to find the end of the tag\n        // Optimized: use indexOf to quickly find boundary characters\n        while (checkEnd < sourceLen && !foundClosingAngle) {\n          var advancedInInnerLoop = false\n          while (partialTagEnd < checkEnd) {\n            var c = source[partialTagEnd]\n            if (inQuotesPartial) {\n              if (c === quoteCharPartial) {\n                inQuotesPartial = false\n                quoteCharPartial = ''\n              }\n              if (c === '\\n' || c === '\\r') {\n                hasNewlineInTag = true\n              }\n              partialTagEnd++\n              advancedInInnerLoop = true\n            } else if (c === '\"' || c === \"'\") {\n              inQuotesPartial = true\n              quoteCharPartial = c\n              partialTagEnd++\n              advancedInInnerLoop = true\n            } else if (c === '\\n' || c === '\\r') {\n              hasNewlineInTag = true\n              partialTagEnd++\n              advancedInInnerLoop = true\n              var nextLineEnd = util.findLineEnd(source, partialTagEnd)\n              if (nextLineEnd === partialTagEnd) break\n              checkEnd = nextLineEnd\n            } else if (c === '>') {\n              partialTagEnd++\n              foundClosingAngle = true\n              break\n            } else {\n              partialTagEnd++\n              advancedInInnerLoop = true\n            }\n          }\n          if (foundClosingAngle) break\n          if (!advancedInInnerLoop && partialTagEnd >= checkEnd) {\n            var nextCheckEnd = util.findLineEnd(source, checkEnd + 1)\n            if (nextCheckEnd <= checkEnd) break\n            checkEnd = nextCheckEnd\n          } else if (partialTagEnd >= checkEnd && checkEnd < sourceLen) {\n            var nextCheckEnd = util.findLineEnd(source, checkEnd + 1)\n            if (nextCheckEnd <= checkEnd) break\n            checkEnd = nextCheckEnd\n          } else {\n            break\n          }\n        }\n        // Only handle as incomplete tag if it has a newline (extends beyond first line)\n        // OR if it extends to end of first line without closing >\n        // If tag completes on first line with closing >, parseHTMLTag should have handled it\n        if (!hasNewlineInTag && foundClosingAngle) {\n          return null // Tag completes on first line but parseHTMLTag returned null - invalid, not incomplete\n        }\n        // Tag has newline - treat as incomplete and extend to end of first line if needed\n        if (partialTagEnd >= firstLineEnd && firstLineEnd < sourceLen) {\n          partialTagEnd = firstLineEnd\n        }\n        // Determine block type and find blank line\n        var blockType: 'type6' | 'type7' = isType6 ? 'type6' : 'type7'\n        var tagEnd = partialTagEnd\n        var blockEnd = findNextBlankLine(\n          source,\n          skipToNextLine(source, firstLineEnd),\n          sourceLen\n        )\n        var blockContent = source.slice(tagEnd, blockEnd)\n        var isClosingTag = pos + 1 < source.length && source[pos + 1] === '/'\n\n        // For type 7 blocks with incomplete tags, preserve raw HTML\n        if (blockType === 'type7' && blockContent.trim() === '') {\n          var rawTagHTML = source.slice(pos, blockEnd)\n          var tagLineEnd = util.findLineEnd(rawTagHTML, 0)\n          if (tagLineEnd < rawTagHTML.length) tagLineEnd++\n          var rawTag = rawTagHTML.slice(0, tagLineEnd)\n          return createVerbatimHTMLBlock(\n            tagName,\n            rawTag,\n            blockEnd,\n            {},\n            undefined,\n            isClosingTag,\n            false, // type 7 blocks cannot interrupt paragraphs\n            options,\n            state\n          )\n        }\n\n        // For type 6/7 blocks with incomplete tags and content, preserve full raw HTML\n        var fullRawHTML = source.slice(pos, blockEnd)\n        return createVerbatimHTMLBlock(\n          tagName,\n          fullRawHTML,\n          blockEnd,\n          {},\n          undefined,\n          isClosingTag,\n          blockType === 'type6', // type 6 can interrupt, type 7 cannot\n          options,\n          state\n        )\n      }\n    }\n    return null\n  }\n\n  if (!tagResult) return null\n\n  // Per CommonMark spec: reject HTML tags that look like failed autolinks\n  // Check if the content between < and > looks like a failed autolink\n  // (HTTP(S) URLs with spaces are failed autolinks - checked above)\n  if (closeIdx !== -1) {\n    var contentBetweenCheck = source.slice(pos + 1, closeIdx)\n    // If it starts with http:// or https:// but has spaces, it's a failed autolink\n    if (\n      (util.startsWith(contentBetweenCheck, 'http://') ||\n        util.startsWith(contentBetweenCheck, 'https://')) &&\n      (contentBetweenCheck.indexOf(' ') !== -1 ||\n        contentBetweenCheck.indexOf('\\t') !== -1)\n    ) {\n      return null // Failed autolink - reject as HTML tag\n    }\n  }\n\n  // If a tag name has a colon at position 1 (e.g., \"m:abc\"), it's trying to be an autolink\n  // but the scheme is only 1 character (invalid). These should be escaped, not parsed as HTML.\n  // Examples: <m:abc>, <x:foo> should be escaped as &lt;m:abc&gt;, &lt;x:foo&gt;\n  var tagNameStart = pos + (tagResult.isClosing ? 2 : 1)\n  if (tagNameStart < source.length) {\n    var tagNameFirstChar = source[tagNameStart]\n    var tagNameFirstCharCode = charCode(tagNameFirstChar)\n    // Check if it starts with a letter\n    if (\n      (tagNameFirstCharCode >= 97 && tagNameFirstCharCode <= 122) ||\n      (tagNameFirstCharCode >= 65 && tagNameFirstCharCode <= 90)\n    ) {\n      // Check if second character is a colon (making it a 1-char scheme, which is invalid)\n      if (\n        tagNameStart + 1 < source.length &&\n        source[tagNameStart + 1] === ':'\n      ) {\n        // This looks like a failed autolink attempt - reject as HTML tag\n        return null\n      }\n    }\n  }\n\n  // Handle closing tags\n  if (tagResult.isClosing) {\n    // Per CommonMark: closing tags cannot have attributes\n    // If attrs is not empty (after trimming whitespace), it's invalid HTML - escape it\n    var attrsTrimmed = tagResult.attrs.trim()\n    if (attrsTrimmed.length > 0) {\n      // Invalid closing tag with attributes - return null to allow escaping\n      return null\n    }\n\n    // Per CommonMark spec: closing tags are type 7 HTML blocks\n    // Parse as block if: (1) on its own line, or (2) followed by a block-level HTML tag\n    // Per Example 148: </td></tr></table> should be block-level\n    // Per Example 623: </a></foo > should be inline (wrapped in paragraph)\n    if (!state.inline) {\n      var sourceLen = source.length\n      var firstLineEnd = util.findLineEnd(source, pos)\n      var tagEnd = tagResult.endPos\n\n      // Check if tag is on its own line or followed by a block-level HTML tag\n      var afterTag = tagEnd\n      while (\n        afterTag < firstLineEnd &&\n        (source[afterTag] === ' ' ||\n          source[afterTag] === '\\t' ||\n          source[afterTag] === '\\r')\n      ) {\n        afterTag++\n      }\n\n      var shouldParseAsBlock =\n        afterTag >= firstLineEnd ||\n        (source[afterTag] === '<' &&\n          (function () {\n            var nextTag = parseHTMLTag(source, afterTag)\n            return nextTag && isType6Tag(nextTag.tagLower)\n          })())\n\n      if (shouldParseAsBlock) {\n        var blockEnd = findNextBlankLine(\n          source,\n          skipToNextLine(source, firstLineEnd),\n          sourceLen\n        )\n        var blockContent = source.slice(tagEnd, blockEnd)\n        if (blockContent.length > 0) {\n          if (blockContent[0] === '\\r' && blockContent[1] === '\\n') {\n            blockContent = blockContent.slice(2)\n          } else if (blockContent[0] === '\\n' || blockContent[0] === '\\r') {\n            blockContent = blockContent.slice(1)\n          }\n        }\n\n        // Cache lowercase tag name to avoid repeated toLowerCase() calls\n        const tagLower = tagResult.tagLower || tagResult.tagName.toLowerCase()\n        return createVerbatimHTMLBlock(\n          tagResult.tagName,\n          blockContent,\n          blockEnd,\n          parseHTMLAttributes(\n            tagResult.whitespaceBeforeAttrs + tagResult.attrs,\n            tagLower,\n            tagResult.tagName,\n            options\n          ),\n          tagResult.whitespaceBeforeAttrs + tagResult.attrs,\n          true,\n          false,\n          options,\n          state\n        )\n      }\n    }\n\n    // Fallback: for inline context or if block parsing didn't match, parse as self-closing\n    // Per CommonMark spec Example 623: closing tags should preserve raw HTML to maintain spacing (e.g., </foo >)\n    // Always preserve rawText for closing tags (both inline and block level) so they can be rendered correctly\n    var rawText = source.slice(pos, tagResult.endPos)\n    const result: MarkdownToJSX.HTMLSelfClosingNode & {\n      endPos: number\n      isClosingTag?: boolean\n      rawText?: string\n    } = {\n      type: RuleType.htmlSelfClosing,\n      tag: tagResult.tagName,\n      attrs: {},\n      endPos: tagResult.endPos,\n      isClosingTag: true,\n      rawText: rawText,\n    }\n    return result\n  }\n\n  // Now use unified parser result\n  // tagResult already contains parsed tag info\n\n  // IMPORTANT: All validation must happen BEFORE block parsing check\n  // This ensures invalid tags are rejected even if they would match as blocks\n\n  // Validate tag name: cannot start with space or newline after <\n  // Per CommonMark spec Example 621: < a> and <\\nfoo> are invalid\n  var tagNameStart = pos + (tagResult.isClosing ? 2 : 1)\n  if (tagNameStart < source.length) {\n    var firstChar = source[tagNameStart]\n    if (\n      firstChar === ' ' ||\n      firstChar === '\\t' ||\n      firstChar === '\\n' ||\n      firstChar === '\\r'\n    ) {\n      // Tag name starts with whitespace - invalid HTML\n      return null\n    }\n  }\n\n  // Attributes are passed through opaquely - no validation\n\n  var tagNameLower = tagResult.tagLower\n  var isVoid = util.isVoidElement(tagResult.tagName)\n\n  // Check if this is a JSX component (starts with uppercase letter)\n  // JSX components should be parsed as block-level HTML even with newlines\n  const isJSXComponent =\n    tagResult.tagName.length > 0 &&\n    tagResult.tagName[0] >= 'A' &&\n    tagResult.tagName[0] <= 'Z'\n\n  // Self-closing tags: has /> or is void (except anchor tags which need special handling)\n  // Per CommonMark spec: self-closing tags with newlines are type 7 blocks\n  // Type 7 blocks don't interrupt paragraphs, so they should be parsed as inline HTML\n  // IMPORTANT: Validation already happened above, so if we get here the tag is valid\n  // EXCEPTION: JSX components (uppercase tags) should always be parsed as block-level HTML\n  if (tagResult.isSelfClosing || (isVoid && tagNameLower !== 'a')) {\n    // If tag has newline, it's a type 7 block - don't interrupt paragraphs\n    // Return null to allow paragraph wrapping - parseInlineSpan will parse as raw HTML\n    // But only if validation passed (which already happened above)\n    // EXCEPTION: JSX components should be parsed as block-level HTML even with newlines\n    if (tagResult.hasNewline && !isJSXComponent) {\n      return null\n    }\n\n    // If we're not in HTML block context and not inline, parse as inline HTML\n    // This allows them to be wrapped in paragraphs per type 7 block rules\n    // Return null to allow paragraph wrapping - parseInlineSpan will parse them as raw HTML\n    // EXCEPTION: JSX components should be parsed as block-level HTML even when not in HTML block context\n    if (!state.inHTML && !state.inline && !isJSXComponent) {\n      return null\n    }\n\n    var attrsTrimmedSelfClose = tagResult.attrs.replace(/\\/\\s*$/, '')\n    var selfCloseAttrs = parseHTMLAttributes(\n      attrsTrimmedSelfClose,\n      tagNameLower,\n      tagResult.tagName,\n      options\n    )\n    // For inline context, preserve raw HTML to maintain spacing\n    var rawText = state.inline ? source.slice(pos, tagResult.endPos) : undefined\n    const result: MarkdownToJSX.HTMLSelfClosingNode & {\n      endPos: number\n      rawText?: string\n    } = {\n      type: RuleType.htmlSelfClosing,\n      tag: tagResult.tagName,\n      attrs: selfCloseAttrs,\n      endPos: tagResult.endPos,\n    }\n    if (rawText !== undefined) {\n      result.rawText = rawText\n    }\n    return result\n  }\n\n  // For inline context, parse as simple opening tag (no closing tag search)\n  // IMPORTANT: Validation must happen before this check to reject invalid tags\n  // Note: parseHTMLTag only returns a result if tag has closing >, so tag is complete\n  // Multiline attributes are supported - newlines in tags are valid HTML\n  if (state.inline) {\n    // Validation already happened above, so if we get here the tag is valid\n    var attrsTrimmedInline = tagResult.attrs.replace(/\\/\\s*$/, '')\n    // Preserve whitespace before attributes for CommonMark compliance\n    var rawAttrsWithWhitespace =\n      tagResult.whitespaceBeforeAttrs + attrsTrimmedInline\n    var parsedInlineAttrs = parseHTMLAttributes(\n      attrsTrimmedInline,\n      tagNameLower,\n      tagResult.tagName,\n      options\n    )\n    var inlineAttrs: Record<string, any> = {\n      ...parsedInlineAttrs,\n    }\n\n    // For non-void inline tags, find matching closing tag and parse content\n    var inlineEndPos = tagResult.endPos\n    var children: MarkdownToJSX.ASTNode[] = []\n    if (!util.isVoidElement(tagResult.tagName)) {\n      var closingResult = findInlineClosingTag(\n        source,\n        tagResult.endPos,\n        tagNameLower\n      )\n      if (closingResult !== null) {\n        var content = source.slice(tagResult.endPos, closingResult[0])\n        // Recursion is prevented by state.inHTML guard at parseHTML entry\n        if (content) {\n          if (\n            (state.inHTML && HTML_BLOCK_ELEMENT_START_R.test(content)) ||\n            hasBlockContent(content)\n          ) {\n            children = parseBlocksInHTML(\n              content,\n              {\n                ...state,\n                inline: false,\n                inHTML: true,\n                inAnchor: state.inAnchor || tagNameLower === 'a',\n              },\n              options\n            )\n          } else {\n            children = parseInlineSpan(\n              content,\n              0,\n              content.length,\n              {\n                ...state,\n                inline: true,\n                inHTML: options.optimizeForStreaming ? true : state.inHTML,\n                inAnchor: state.inAnchor || tagNameLower === 'a',\n              },\n              options\n            )\n          }\n        }\n        inlineEndPos = closingResult[1]\n      }\n    }\n    return {\n      type: RuleType.htmlBlock,\n      tag: tagResult.tagName as MarkdownToJSX.HTMLTags,\n      attrs: inlineAttrs,\n      rawAttrs: rawAttrsWithWhitespace,\n      children: children,\n      verbatim: false,\n      endPos: inlineEndPos,\n    } as MarkdownToJSX.HTMLNode & { endPos: number }\n  }\n\n  // For inline context, don't try block parsing - simple opening tags should be parsed inline\n  // Block parsing is only for tags that need closing tags or are block-level\n  if (!state.inline) {\n    // Determine block type inline (previously handled by matchHTMLBlock)\n    var sourceLen = source.length\n    var firstLineEnd = util.findLineEnd(source, pos)\n    var tagLower = tagResult.tagLower\n    var isType1BlockVar = isType1Block(tagLower)\n    var isType6Block = !isType1BlockVar && isType6Tag(tagResult.tagName)\n    var tagHasClosingAngle = false\n    var checkPos = pos\n    while (checkPos < tagResult.endPos) {\n      if (source[checkPos] === '>') {\n        tagHasClosingAngle = true\n        break\n      }\n      checkPos++\n    }\n    // Check if tag is followed by end of line (with optional whitespace)\n    var afterTag = tagResult.endPos\n    while (\n      afterTag < firstLineEnd &&\n      (source[afterTag] === ' ' || source[afterTag] === '\\t')\n    ) {\n      afterTag++\n    }\n    // Check if tag is complete on line\n    // For type 6 blocks, they can have content on same line\n    // For other tags, they must be followed by newline or end of line\n    var isCompleteOnLine =\n      afterTag >= firstLineEnd ||\n      source[afterTag] === '\\n' ||\n      source[afterTag] === '\\r' ||\n      (isType6Block && afterTag < firstLineEnd) ||\n      !tagHasClosingAngle\n\n    // Type 1 blocks (pre, script, style, textarea) need matching closing tags\n    // Handle type 1 blocks even if they have newlines in the opening tag\n    if (isType1BlockVar && tagHasClosingAngle && !tagResult.isClosing) {\n      // Type 1: find matching closing tag\n      var type1TagName = tagResult.tagName\n      var type1TagEnd = tagResult.endPos\n      var type1Attrs = tagResult.attrs\n      var type1ContentPos = type1TagEnd\n      if (source[type1ContentPos] === '\\n') type1ContentPos++\n      var type1ContentStart = type1ContentPos\n      var type1ContentEnd = type1ContentPos\n      var type1Depth = 1\n      var type1OpenTagLen = tagLower.length + 1\n      while (type1Depth > 0) {\n        var type1Idx = source.indexOf('<', type1ContentPos)\n        if (type1Idx === -1) {\n          type1ContentEnd = sourceLen\n          type1ContentPos = sourceLen\n          break\n        }\n        var type1OpenIdx = -1\n        var type1CloseIdx = -1\n        if (source[type1Idx + 1] === '/') {\n          type1CloseIdx = type1Idx\n        } else if (\n          type1Idx + type1OpenTagLen + 1 <= sourceLen &&\n          (source[type1Idx + 1] === tagLower[0] ||\n            source[type1Idx + 1] === type1TagName[0])\n        ) {\n          var type1TagCandidate = source.substring(\n            type1Idx + 1,\n            type1Idx + type1OpenTagLen\n          )\n          if (\n            type1TagCandidate.toLowerCase() === tagLower &&\n            (source[type1Idx + type1OpenTagLen] === ' ' ||\n              source[type1Idx + type1OpenTagLen] === '>')\n          ) {\n            type1OpenIdx = type1Idx\n          }\n        }\n        if (type1OpenIdx === -1 && type1CloseIdx === -1) {\n          type1ContentPos = type1Idx + 1\n          continue\n        }\n        if (\n          type1OpenIdx !== -1 &&\n          (type1CloseIdx === -1 || type1OpenIdx < type1CloseIdx)\n        ) {\n          type1ContentPos = type1OpenIdx + type1OpenTagLen + 1\n          type1Depth++\n        } else {\n          var type1P = type1CloseIdx + 2\n          while (type1P < sourceLen) {\n            var type1C = source[type1P]\n            if (\n              type1C !== ' ' &&\n              type1C !== '\\t' &&\n              type1C !== '\\n' &&\n              type1C !== '\\r'\n            )\n              break\n            type1P++\n          }\n          if (type1P + tagLower.length > sourceLen) break\n          var type1CloseTagCandidate = source.substring(\n            type1P,\n            type1P + tagLower.length\n          )\n          if (type1CloseTagCandidate.toLowerCase() !== tagLower) {\n            type1ContentPos = type1P\n            continue\n          }\n          type1P += tagLower.length\n          while (type1P < sourceLen) {\n            var type1C2 = source[type1P]\n            if (\n              type1C2 !== ' ' &&\n              type1C2 !== '\\t' &&\n              type1C2 !== '\\n' &&\n              type1C2 !== '\\r'\n            )\n              break\n            type1P++\n          }\n          if (type1P >= sourceLen || source[type1P] !== '>') {\n            type1ContentPos = type1P\n            continue\n          }\n          var type1ClosingTagEnd = type1P + 1\n          var type1LineEndAfterClose = util.findLineEnd(\n            source,\n            type1ClosingTagEnd\n          )\n          type1ContentEnd = type1LineEndAfterClose\n          type1ContentPos = type1LineEndAfterClose + 1\n          type1Depth--\n        }\n      }\n      var type1TrailingNl = 0\n      while (\n        type1ContentPos + type1TrailingNl < sourceLen &&\n        source[type1ContentPos + type1TrailingNl] === '\\n'\n      )\n        type1TrailingNl++\n      var type1FullMatch = source.slice(pos, type1ContentPos + type1TrailingNl)\n      var type1Content = source.slice(type1ContentStart, type1ContentEnd)\n      var type1EndPos = type1ContentPos + type1TrailingNl\n      return processHTMLBlock(\n        tagResult.tagName,\n        tagResult.tagName,\n        type1Attrs,\n        type1Content,\n        type1FullMatch,\n        type1EndPos,\n        source,\n        state,\n        false,\n        options\n      )\n    }\n\n    // Type 6/7 blocks end at blank lines\n    if (isCompleteOnLine || !tagHasClosingAngle) {\n      // Determine if type 6 or type 7\n      var blockType: 'type6' | 'type7' = isType6Block ? 'type6' : 'type7'\n      var tagEnd = tagResult.endPos\n      var blockEnd = findNextBlankLine(\n        source,\n        skipToNextLine(source, firstLineEnd),\n        sourceLen\n      )\n\n      // For type 6 blocks, check if there's a closing tag before the blank line\n      // If found AND the next content is another HTML tag, stop at the closing tag\n      // This ensures proper nesting of sibling elements (e.g., <dt></dt><dd></dd>)\n      if (blockType === 'type6' && !tagResult.isClosing) {\n        // For JSX components, preserve case; for HTML, use lowercase\n        const tagNameForClosing = isJSXComponent\n          ? tagResult.tagName\n          : tagResult.tagLower || tagResult.tagName.toLowerCase()\n        var closingTagPattern = '</' + tagNameForClosing\n        var openingTagPattern = '<' + tagNameForClosing\n\n        // Find the matching closing tag by tracking nesting depth\n        var searchPos = tagEnd\n        var depth = 1 // We already have one opening tag (depth starts at 1)\n        var closingIdx = -1\n        while (searchPos < blockEnd && depth > 0) {\n          var nextOpenIdx = source.indexOf(openingTagPattern, searchPos)\n          var nextCloseIdx = source.indexOf(closingTagPattern, searchPos)\n\n          // Validate and find next valid opening tag (followed by whitespace or >)\n          // Note: We don't accept / because that indicates a self-closing tag\n          while (nextOpenIdx !== -1 && nextOpenIdx < blockEnd) {\n            var afterOpenPos = nextOpenIdx + openingTagPattern.length\n            if (afterOpenPos >= sourceLen) {\n              nextOpenIdx = -1\n              break\n            }\n            var charAfterOpen = source[afterOpenPos]\n            if (\n              charAfterOpen === ' ' ||\n              charAfterOpen === '\\t' ||\n              charAfterOpen === '\\n' ||\n              charAfterOpen === '\\r' ||\n              charAfterOpen === '>'\n            ) {\n              break // Valid opening tag found\n            }\n            // Not valid (could be self-closing like <div/> or partial match), search for next\n            nextOpenIdx = source.indexOf(openingTagPattern, afterOpenPos)\n          }\n\n          if (nextOpenIdx === -1 || nextOpenIdx >= blockEnd) {\n            nextOpenIdx = blockEnd\n          }\n          if (nextCloseIdx === -1 || nextCloseIdx >= blockEnd) {\n            nextCloseIdx = blockEnd\n          }\n\n          if (nextOpenIdx < nextCloseIdx) {\n            // Found an opening tag first - increase depth\n            depth++\n            searchPos = nextOpenIdx + openingTagPattern.length\n          } else if (nextCloseIdx < blockEnd) {\n            // Found a closing tag first - decrease depth\n            depth--\n            if (depth === 0) {\n              closingIdx = nextCloseIdx\n              break\n            }\n            searchPos = nextCloseIdx + closingTagPattern.length\n          } else {\n            break // No more tags found\n          }\n        }\n\n        if (closingIdx !== -1 && closingIdx < blockEnd) {\n          // Found the matching closing tag before the blank line\n          // Check if it's valid\n          var afterClosingTag = closingIdx + closingTagPattern.length\n          while (\n            afterClosingTag < sourceLen &&\n            (source[afterClosingTag] === ' ' ||\n              source[afterClosingTag] === '\\t')\n          ) {\n            afterClosingTag++\n          }\n          if (afterClosingTag < sourceLen && source[afterClosingTag] === '>') {\n            // Valid closing tag found before blank line\n            // Check if the content immediately after the closing tag (after newline) starts with another HTML tag\n            var closingTagEndPos = afterClosingTag + 1\n            var nextContentPos = closingTagEndPos\n            // Skip to next line\n            while (\n              nextContentPos < sourceLen &&\n              source[nextContentPos] !== '\\n'\n            ) {\n              nextContentPos++\n            }\n            if (nextContentPos < sourceLen) {\n              nextContentPos++ // Skip the newline\n            }\n            // Skip leading whitespace on next line\n            while (\n              nextContentPos < sourceLen &&\n              (source[nextContentPos] === ' ' ||\n                source[nextContentPos] === '\\t')\n            ) {\n              nextContentPos++\n            }\n            // Check if next content is another HTML tag (that is NOT a closing tag for our current tag)\n            if (\n              nextContentPos < sourceLen &&\n              source[nextContentPos] === '<' &&\n              !util.startsWith(source.slice(nextContentPos), closingTagPattern)\n            ) {\n              var nextTag = parseHTMLTag(source, nextContentPos)\n              if (nextTag) {\n                // Next content is a different HTML tag - stop at our closing tag\n                blockEnd = closingTagEndPos\n              }\n            }\n            // Otherwise, continue to blank line as per CommonMark\n          }\n        } else {\n          // No matching closing tag found before blank line\n          // Check if there's a closing tag after the blank line\n          closingIdx = source.indexOf(closingTagPattern, tagEnd)\n          if (closingIdx !== -1) {\n            // Closing tag found but after blank line\n            // Check if there's block content that would warrant extending to the closing tag\n            var extendedContent = source.slice(tagEnd, closingIdx)\n            var shouldExtend =\n              isJSXComponent || hasBlockContent(extendedContent)\n            if (shouldExtend) {\n              // Extend block to include closing tag\n              var afterClosingTag2 = closingIdx + closingTagPattern.length\n              while (\n                afterClosingTag2 < sourceLen &&\n                (source[afterClosingTag2] === ' ' ||\n                  source[afterClosingTag2] === '\\t')\n              ) {\n                afterClosingTag2++\n              }\n              if (\n                afterClosingTag2 < sourceLen &&\n                source[afterClosingTag2] === '>'\n              ) {\n                var closingLineEnd = util.findLineEnd(\n                  source,\n                  afterClosingTag2 + 1\n                )\n                blockEnd = closingLineEnd\n              }\n            }\n          }\n        }\n      }\n\n      var blockContent = source.slice(tagEnd, blockEnd)\n      var blockAttrs = tagResult.whitespaceBeforeAttrs + tagResult.attrs\n      var isClosingTag = tagResult.isClosing\n\n      // Handle type 6/7 blocks\n      // For type 7 blocks with empty content (standalone tags), determine if they should be block or inline\n      // Per CommonMark: Type 7 blocks cannot interrupt paragraphs, but if they're on their own line they're blocks\n      // However, if the tag contains newlines in attributes (without hasNewline flag because they're in quotes),\n      // it should be treated as inline and wrapped in a paragraph\n\n      // Helper to parse type 7 block attributes\n      const parseType7Attrs = () => {\n        const tagLower = tagResult.tagLower || tagResult.tagName.toLowerCase()\n        const rawAttrs = tagResult.whitespaceBeforeAttrs + tagResult.attrs\n        return {\n          parsed: parseHTMLAttributes(\n            rawAttrs,\n            tagLower,\n            tagResult.tagName,\n            options\n          ),\n          raw: rawAttrs,\n        }\n      }\n\n      if (blockType === 'type7' && blockContent.trim() === '') {\n        // Check if the tag itself contains a newline (inside the tag, not after it)\n        var rawTagText = source.slice(pos, tagResult.endPos)\n        var tagContainsNewline = rawTagText.indexOf('\\n') !== -1\n\n        if (tagContainsNewline) {\n          // Tag has newline inside it (in attribute) - should be wrapped in paragraph\n          return null\n        }\n\n        // Tag is on its own line, treat as block\n        var tagEndInSource = tagResult.endPos\n        var tagLineEnd = util.findLineEnd(source, tagEndInSource)\n        if (tagLineEnd < source.length) tagLineEnd++\n        var rawTag = source.slice(pos, tagLineEnd)\n        // Parse attributes for single-line type 7 blocks\n        const type7Attrs = parseType7Attrs()\n        return createVerbatimHTMLBlock(\n          tagResult.tagName,\n          rawTag,\n          blockEnd,\n          type7Attrs.parsed,\n          type7Attrs.raw,\n          isClosingTag,\n          false, // type 7 blocks cannot interrupt paragraphs\n          options,\n          state\n        )\n      }\n\n      // For type 7 blocks with multi-line or incomplete opening tags, preserve raw HTML\n      var openingTagHasNewline = tagResult.hasNewline\n      var openingTagIsIncomplete = !tagHasClosingAngle\n      if (\n        (openingTagHasNewline || openingTagIsIncomplete) &&\n        blockType === 'type7'\n      ) {\n        var openingTagEnd = tagResult.endPos\n        var rawOpeningTag = source.slice(pos, openingTagEnd)\n        var rawContent = blockContent\n        var fullRawHTML = rawOpeningTag + rawContent\n        // Parse attributes even for multi-line tags (#781)\n        const multilineAttrs = parseType7Attrs()\n        return createVerbatimHTMLBlock(\n          tagResult.tagName,\n          fullRawHTML,\n          blockEnd,\n          multilineAttrs.parsed,\n          multilineAttrs.raw,\n          isClosingTag,\n          false, // type 7 blocks cannot interrupt paragraphs\n          options,\n          state\n        )\n      }\n\n      // Parse attributes, but always preserve raw attributes for consistency\n      // Cache lowercase tag name to avoid repeated toLowerCase() calls\n      const tagLower = tagResult.tagLower || tagResult.tagName.toLowerCase()\n      var parsedBlockAttributes = parseHTMLAttributes(\n        blockAttrs,\n        tagLower,\n        tagResult.tagName,\n        options\n      )\n      var blockAttributes: Record<string, any> = {\n        ...parsedBlockAttributes,\n      }\n\n      // For type 6 blocks with block syntax, parse through processHTMLBlock\n      if (blockType === 'type6') {\n        var contentForBlockCheck = blockContent\n        var closingTagIdx = blockContent.indexOf('</' + tagLower)\n        if (closingTagIdx >= 0) {\n          var afterTag = closingTagIdx + 2 + tagResult.tagName.length\n          while (\n            afterTag < blockContent.length &&\n            (blockContent[afterTag] === ' ' || blockContent[afterTag] === '\\t')\n          )\n            afterTag++\n          if (\n            afterTag < blockContent.length &&\n            blockContent[afterTag] === '>'\n          ) {\n            contentForBlockCheck = blockContent.slice(0, closingTagIdx)\n          }\n        }\n\n        if (hasBlockContent(contentForBlockCheck)) {\n          return processHTMLBlock(\n            tagResult.tagName,\n            tagResult.tagName,\n            blockAttrs,\n            contentForBlockCheck,\n            source.slice(pos, tagResult.endPos),\n            blockEnd,\n            source,\n            state,\n            false,\n            options\n          )\n        }\n      }\n\n      var verbatimContent = blockContent\n      if (verbatimContent.length > 0) {\n        if (verbatimContent[0] === '\\r' && verbatimContent[1] === '\\n') {\n          verbatimContent = verbatimContent.slice(2)\n        } else if (verbatimContent[0] === '\\n' || verbatimContent[0] === '\\r') {\n          verbatimContent = verbatimContent.slice(1)\n        }\n      }\n      // Per CommonMark spec: remove common leading whitespace from all lines\n      var lines = verbatimContent.split('\\n')\n      var minIndent = Infinity\n      for (var lineIdx = 0; lineIdx < lines.length; lineIdx++) {\n        var line = lines[lineIdx]\n        if (line.trim().length === 0) continue\n        var indent = 0\n        while (\n          indent < line.length &&\n          (line[indent] === ' ' || line[indent] === '\\t')\n        ) {\n          indent++\n        }\n        if (indent < minIndent) minIndent = indent\n      }\n      if (minIndent > 0 && minIndent < Infinity) {\n        var dedentedLines: string[] = []\n        for (var lineIdx2 = 0; lineIdx2 < lines.length; lineIdx2++) {\n          var line2 = lines[lineIdx2]\n          if (line2.trim().length === 0) {\n            dedentedLines.push(line2)\n          } else {\n            dedentedLines.push(line2.slice(minIndent))\n          }\n        }\n        verbatimContent = dedentedLines.join('\\n')\n      }\n\n      return createVerbatimHTMLBlock(\n        tagResult.tagName,\n        verbatimContent,\n        blockEnd,\n        blockAttributes,\n        blockAttrs,\n        isClosingTag,\n        blockType === 'type6' ? true : false, // type 6 can interrupt, type 7 cannot\n        options,\n        state\n      )\n    }\n  }\n\n  // If we're in inline context and didn't match simple tag parsing, return null\n  // This allows the tag to be escaped or handled by other parsers\n  if (state.inline) {\n    return null\n  }\n\n  // Fallback: Try void element without /> (manual parsing)\n  // Only try this if self-closing didn't match\n  var tagNameResult = parseHTMLTagName(source, pos + 1)\n  if (!tagNameResult) return null\n\n  var tagName = tagNameResult.tagName\n  if (!util.isVoidElement(tagName)) {\n    return null\n  }\n\n  // Use tagLower from parseHTMLTagName result to avoid repeated toLowerCase() calls\n  const tagLowerVoid = tagNameResult.tagLower\n\n  var i = tagNameResult.nextPos\n  var len = source.length\n  while (i < len && isSpaceOrTab(source[i])) i++\n  var attrsStart = i\n\n  while (i < len && source[i] !== '>') i++\n  if (i >= len) return null\n\n  const attrs = source.slice(attrsStart, i).trim()\n  const afterAngle = i + 1\n\n  let checkIdx = afterAngle\n  while (checkIdx < len && isSpaceOrTab(source[checkIdx])) checkIdx++\n  const closeTagPattern = '</' + tagLowerVoid + '>'\n  const foundIdx = source.toLowerCase().indexOf(closeTagPattern, checkIdx)\n  if (foundIdx !== -1) {\n    const between = source.slice(checkIdx, foundIdx).trim()\n    if (between) {\n      return null\n    }\n  }\n\n  i++\n  const endPos = i\n  while (i < len && isSpaceOrTab(source[i])) i++\n  if (i < len && source[i] === '\\n') i++\n\n  const fallbackAttributes = parseHTMLAttributes(\n    attrs,\n    tagName,\n    tagName,\n    options\n  )\n\n  return {\n    type: RuleType.htmlSelfClosing,\n    tag: tagName,\n    attrs: fallbackAttributes,\n    endPos,\n  } as MarkdownToJSX.HTMLSelfClosingNode & { endPos: number }\n}\n\n// ============================================================================\n// HTML Token Interface and Unified Scanner\n// Ultra-compact unified scanner for all HTML constructs\n// ============================================================================\n\nexport interface HTMLToken {\n  kind: 'tag' | 'comment' | 'pi' | 'declaration' | 'cdata'\n  tagNameLower?: string\n  tagName?: string\n  isClosing?: boolean\n  isSelfClosing?: boolean\n  hasNewline: boolean\n  type6Candidate?: boolean\n  type7Candidate?: boolean\n  endPos: number\n  attrs?: string\n  whitespaceBeforeAttrs?: string\n  text?: string\n  raw?: boolean\n}\n\n/**\n * Scan tag-like constructs: </tag, <tag\n */\nfunction scanTagLike(source: string, pos: number): HTMLToken | null {\n  if (source[pos] !== '<') return null\n\n  var sourceLen = source.length\n\n  // Check for closing tag (</tag>)\n  var isClosing = false\n  var tagStart = pos + 1\n  if (pos + 1 < sourceLen && source[pos + 1] === '/') {\n    isClosing = true\n    tagStart = pos + 2\n  }\n\n  // Parse tag name\n  var tagNameResult = parseHTMLTagName(source, tagStart)\n  if (!tagNameResult) return null\n\n  var tagName = tagNameResult.tagName\n  var tagLower = tagNameResult.tagLower\n  var attrsStart = tagNameResult.nextPos\n\n  // Fast path: tags without attributes or whitespace\n  if (attrsStart < sourceLen) {\n    var immediateChar = source[attrsStart]\n    if (immediateChar === '>' || immediateChar === '/') {\n      var endPos = immediateChar === '>' ? attrsStart + 1 : attrsStart + 2\n      if (\n        immediateChar === '/' &&\n        (attrsStart + 1 >= sourceLen || source[attrsStart + 1] !== '>')\n      ) {\n        return null\n      }\n      var isSelfClosingFast = immediateChar === '/'\n      var type6CandidateFast = isType6Tag(tagName)\n      var type7CandidateFast = !isType1Block(tagLower) && !type6CandidateFast\n      return {\n        kind: 'tag',\n        tagNameLower: tagLower,\n        tagName: tagName,\n        isClosing: isClosing,\n        isSelfClosing: isSelfClosingFast,\n        hasNewline: false,\n        type6Candidate: type6CandidateFast,\n        type7Candidate: type7CandidateFast,\n        endPos: endPos,\n        attrs: '',\n        whitespaceBeforeAttrs: '',\n      }\n    }\n  }\n\n  // Capture whitespace after tag name (including newlines per CommonMark spec)\n  var whitespaceStart = attrsStart\n  var hasNewline = false\n  while (attrsStart < sourceLen) {\n    var ch = source[attrsStart]\n    var code = charCode(source, attrsStart)\n    if (ch === ' ' || ch === '\\t') {\n      // Space or tab - continue\n    } else if (code === 10 || code === 13) {\n      // \\n or \\r\n      hasNewline = true\n    } else {\n      break // Not whitespace\n    }\n    attrsStart++\n  }\n  var whitespaceBeforeAttrs = source.slice(whitespaceStart, attrsStart)\n\n  // Parse attributes until we find > - minimal validation only for boundary detection\n  var tagEnd = attrsStart\n  var inQuotes = false\n  var quoteChar = ''\n  var braceDepth = 0\n  var hasSlash = false\n  var hasSpaceBeforeSlash = false\n\n  // State machine for attribute parsing: 0=normal, 1=inDoubleQuotes, 2=inSingleQuotes\n  var parseState = 0\n  while (tagEnd < sourceLen) {\n    var char = source[tagEnd]\n    var code = charCode(source, tagEnd)\n\n    // Handle quotes state machine\n    if (parseState === 1) {\n      // in double quotes\n      if (char === '\"') {\n        // Check for consecutive quotes (invalid HTML)\n        if (tagEnd + 1 < sourceLen && source[tagEnd + 1] === '\"') {\n          return null\n        }\n        parseState = 0\n      }\n      tagEnd++\n    } else if (parseState === 2) {\n      // in single quotes\n      if (char === \"'\") {\n        parseState = 0\n      }\n      tagEnd++\n    } else if (char === '\"') {\n      parseState = 1\n      tagEnd++\n    } else if (char === \"'\") {\n      parseState = 2\n      tagEnd++\n    } else if (char === '{' || (char === '}' && braceDepth > 0)) {\n      // Track JSX expression brace depth\n      braceDepth += char === '{' ? 1 : -1\n      tagEnd++\n    } else if (char === '>' && braceDepth === 0) {\n      // Found closing > - check for self-closing / and space before >\n      if (tagEnd > attrsStart) {\n        var checkBack = tagEnd - 1\n        while (checkBack >= attrsStart) {\n          var backChar = source[checkBack]\n          if (backChar !== ' ' && backChar !== '\\t') break\n          checkBack--\n        }\n        if (checkBack >= attrsStart && source[checkBack] === '/') {\n          hasSlash = true\n          hasSpaceBeforeSlash = checkBack < tagEnd - 1\n        }\n      }\n      tagEnd++\n      break\n    } else {\n      // Check for invalid attribute name characters (*, #, !)\n      if (char === '*' || char === '#' || char === '!') {\n        var checkAhead = tagEnd + 1\n        while (checkAhead < sourceLen) {\n          var aheadChar = source[checkAhead]\n          if (\n            aheadChar === '=' ||\n            aheadChar === ' ' ||\n            aheadChar === '\\t' ||\n            aheadChar === '\\n' ||\n            aheadChar === '\\r' ||\n            aheadChar === '>'\n          ) {\n            break\n          }\n          checkAhead++\n        }\n        if (checkAhead < sourceLen && source[checkAhead] === '=') {\n          return null // Invalid char in attribute name\n        }\n      }\n      // Track newlines\n      if (code === 10 || code === 13) {\n        // \\n or \\r\n        hasNewline = true\n      }\n      tagEnd++\n    }\n  }\n\n  // Must have found >\n  if (tagEnd > sourceLen || source[tagEnd - 1] !== '>') {\n    return null\n  }\n\n  // Reject tags with unclosed quotes\n  if (parseState === 1 || parseState === 2) {\n    return null\n  }\n\n  // Reject tags with unclosed JSX expressions\n  if (braceDepth > 0) {\n    return null\n  }\n\n  // Reject tags with space between / and > (invalid HTML structure)\n  if (hasSpaceBeforeSlash) {\n    return null\n  }\n\n  var attrsEnd = tagEnd - 1\n  if (hasSlash) {\n    // For self-closing tags, exclude the / from attrs\n    attrsEnd--\n  }\n  var attrs = source.slice(attrsStart, attrsEnd)\n  var isSelfClosing = hasSlash\n\n  // Minimal validation: reject missing space after quoted attribute value\n  var lastQuotePos = -1\n  var inQuotesCheck = false\n  var quoteCharCheck = ''\n  var afterEquals = false\n  for (var i = 0; i < attrs.length; i++) {\n    var ch = attrs[i]\n    if (inQuotesCheck) {\n      if (ch === quoteCharCheck) {\n        inQuotesCheck = false\n        lastQuotePos = i\n        quoteCharCheck = ''\n        afterEquals = false\n      }\n    } else if (ch === '\"' || ch === \"'\") {\n      inQuotesCheck = true\n      quoteCharCheck = ch\n      afterEquals = false\n    } else if (ch === '=') {\n      afterEquals = true\n    } else if (lastQuotePos !== -1 && i === lastQuotePos + 1) {\n      // Immediately after closing quote\n      var code = ch.charCodeAt(0)\n      if (isAlphaCode(code)) {\n        // Letter immediately after quote - missing space, reject\n        return null\n      }\n    } else if (\n      afterEquals &&\n      !inQuotesCheck &&\n      (ch === '*' || ch === '#' || ch === '!')\n    ) {\n      // Invalid char in unquoted attribute value - reject\n      return null\n    } else if (isSpaceOrTab(ch)) {\n      afterEquals = false\n    }\n  }\n\n  // Determine type 6/7 candidates\n  var type6Candidate = isType6Tag(tagName)\n  var type7Candidate = !isType1Block(tagLower) && !type6Candidate\n\n  return {\n    kind: 'tag',\n    tagNameLower: tagLower,\n    tagName: tagName,\n    isClosing: isClosing,\n    isSelfClosing: isSelfClosing,\n    hasNewline: hasNewline,\n    type6Candidate: type6Candidate,\n    type7Candidate: type7Candidate,\n    endPos: tagEnd,\n    attrs: attrs,\n    whitespaceBeforeAttrs: whitespaceBeforeAttrs,\n  }\n}\n\n// ============================================================================\n// Unified HTML Scanner\n// Ultra-compact unified scanner for all HTML constructs\n// ============================================================================\n\n/**\n * Unified HTML scanner - handles tags, comments, PIs, declarations, CDATA\n * Ultra-compact implementation tuned for minification\n */\nfunction scanRawHTML(s: string, p: number): HTMLToken | null {\n  if (p >= s.length || s[p] !== '<') return null\n  var l = s.length\n  if (p + 1 >= l) return null\n  var c = s[p + 1]\n  if (c === '!') {\n    if (p + 4 <= l && s.slice(p, p + 4) === '<!--') {\n      // Comment: scan for -->\n      var endPos = p + 4\n      if (endPos < l && s[endPos] === '>') {\n        return {\n          kind: 'comment',\n          hasNewline: false,\n          endPos: endPos + 1,\n          text: s.slice(p, endPos + 1),\n          raw: true,\n        }\n      }\n      if (endPos + 1 < l && s[endPos] === '-' && s[endPos + 1] === '>') {\n        return {\n          kind: 'comment',\n          hasNewline: false,\n          endPos: endPos + 2,\n          text: s.slice(p, endPos + 2),\n          raw: true,\n        }\n      }\n      while (endPos + 2 < l) {\n        if (s.slice(endPos, endPos + 3) === '-->') {\n          return {\n            kind: 'comment',\n            hasNewline: false,\n            endPos: endPos + 3,\n            text: s.slice(p, endPos + 3),\n            raw: true,\n          }\n        }\n        endPos++\n      }\n      return null\n    }\n    if (p + 9 <= l && s.slice(p, p + 9) === '<![CDATA[') {\n      // CDATA: scan for ]]>\n      var endPos = p + 9\n      while (endPos + 2 < l) {\n        if (s.slice(endPos, endPos + 3) === ']]>') {\n          return {\n            kind: 'cdata',\n            hasNewline: false,\n            endPos: endPos + 3,\n            text: s.slice(p, endPos + 3),\n            raw: true,\n          }\n        }\n        endPos++\n      }\n      return null\n    }\n    if (p + 2 < l && isAlphaCode(s.charCodeAt(p + 2))) {\n      // Declaration: scan for >\n      var endPos = p + 2\n      while (endPos < l && s[endPos] !== '>') endPos++\n      if (endPos >= l) return null\n      return {\n        kind: 'declaration',\n        hasNewline: false,\n        endPos: endPos + 1,\n        text: s.slice(p, endPos + 1),\n        raw: true,\n      }\n    }\n    return null\n  }\n  if (c === '?') {\n    // Processing instruction: scan for ?>\n    var endPos = p + 2\n    while (endPos + 1 < l) {\n      if (s.slice(endPos, endPos + 2) === '?>') {\n        return {\n          kind: 'pi',\n          hasNewline: false,\n          endPos: endPos + 2,\n          text: s.slice(p, endPos + 2),\n          raw: true,\n        }\n      }\n      endPos++\n    }\n    return null\n  }\n  return scanTagLike(s, p)\n}\n\ninterface DefinitionParseResult {\n  endPos: number\n  target: string\n  title?: string\n}\n\nfunction isBlockStartAt(s: string, p: number): boolean {\n  if (p >= s.length) return false\n  var c = s[p]\n  return (\n    c === '=' ||\n    c === '-' ||\n    c === '_' ||\n    c === '*' ||\n    c === '#' ||\n    c === '>' ||\n    c === '`' ||\n    c === '~' ||\n    c === '[' ||\n    (c >= '0' && c <= '9')\n  )\n}\n\nfunction isTitleDelimiter(s: string, p: number): boolean {\n  if (p >= s.length) return false\n  var c = s[p]\n  return c === '\"' || c === \"'\" || c === '('\n}\n\nfunction parseQuotedTitle(\n  s: string,\n  p: number,\n  closeChar: string\n): { value: string; endPos: number } | null {\n  var len = s.length\n  if (p >= len || s[p] !== closeChar) return null\n  p++\n  var start = p\n  var lastWasNewline = false\n  while (p < len && s[p] !== closeChar) {\n    var c = s.charCodeAt(p)\n    if (c === $.CHAR_NEWLINE) {\n      if (lastWasNewline) return null\n      lastWasNewline = true\n      p++\n    } else if (c === $.CHAR_CR) {\n      if (p + 1 < len && s.charCodeAt(p + 1) === $.CHAR_NEWLINE) {\n        if (lastWasNewline) return null\n        lastWasNewline = true\n        p += 2\n      } else {\n        lastWasNewline = false\n        p++\n      }\n    } else {\n      lastWasNewline = false\n      if (c === $.CHAR_BACKSLASH && p + 1 < len) p++\n      p++\n    }\n  }\n  if (p >= len) return null\n  return { value: s.slice(start, p), endPos: p + 1 }\n}\n\nfunction parseParenTitle(\n  s: string,\n  p: number\n): { value: string; endPos: number } | null {\n  var len = s.length\n  if (p >= len || s[p] !== '(') return null\n  p++\n  var start = p\n  var depth = 1\n  var lastWasNewline = false\n  while (p < len && depth > 0) {\n    var c = s.charCodeAt(p)\n    if (c === $.CHAR_NEWLINE) {\n      if (lastWasNewline) return null\n      lastWasNewline = true\n      p++\n    } else if (c === $.CHAR_CR) {\n      if (p + 1 < len && s.charCodeAt(p + 1) === $.CHAR_NEWLINE) {\n        if (lastWasNewline) return null\n        lastWasNewline = true\n        p += 2\n      } else {\n        lastWasNewline = false\n        p++\n      }\n    } else {\n      lastWasNewline = false\n      if (c === $.CHAR_BACKSLASH && p + 1 < len) {\n        p++\n      } else if (c === $.CHAR_PAREN_OPEN) {\n        depth++\n      } else if (c === $.CHAR_PAREN_CLOSE) {\n        depth--\n      }\n      p++\n    }\n  }\n  if (depth !== 0) return null\n  return { value: s.slice(start, p - 1), endPos: p }\n}\n\nfunction scanFootnoteEnd(s: string, p: number): number {\n  var len = s.length\n  var pos = p\n  while (pos < len) {\n    var isLineStart = pos === 0 || s[pos - 1] === '\\n'\n    var c = s.charCodeAt(pos)\n    if (c === $.CHAR_NEWLINE && pos > p) {\n      var nextPos = pos + 1\n      if (nextPos < len && s.charCodeAt(nextPos) === $.CHAR_CR) nextPos++\n      if (nextPos < len && s.charCodeAt(nextPos) === $.CHAR_NEWLINE) {\n        var afterBlank = nextPos + 1\n        while (\n          afterBlank < len &&\n          (s[afterBlank] === ' ' || s[afterBlank] === '\\t')\n        ) {\n          afterBlank++\n        }\n        var blankLineLen = afterBlank - (pos + 1)\n        if (s.charCodeAt(pos + 1) === $.CHAR_CR) blankLineLen--\n        if (\n          afterBlank < len &&\n          s.charCodeAt(afterBlank) !== $.CHAR_NEWLINE &&\n          s.charCodeAt(afterBlank) !== $.CHAR_CR &&\n          blankLineLen < 4\n        ) {\n          return pos\n        }\n      }\n    }\n    if (isLineStart && util.startsWith(s, '[^', pos)) {\n      var checkPos = pos + 2\n      while (checkPos < len && s[checkPos] !== ']') {\n        checkPos++\n      }\n      if (\n        checkPos < len &&\n        s[checkPos] === ']' &&\n        checkPos + 1 < len &&\n        s[checkPos + 1] === ':'\n      ) {\n        return pos\n      }\n    }\n    pos++\n  }\n  return len\n}\n\nfunction parseRefContent(\n  source: string,\n  pos: number,\n  urlNewlineCount: number\n): DefinitionParseResult | null {\n  const len = source.length\n  let i = pos\n\n  // Parse URL (can be in angle brackets or plain, can span multiple lines)\n  // At this point, i should be at the start of the destination (after any whitespace/newline)\n  // Per CommonMark spec: destination can be on the same line or following lines\n  const hasAngleBrackets = i < len && source[i] === '<'\n  if (hasAngleBrackets) i++\n\n  const urlStart = i\n  let urlEnd = urlStart\n\n  // Per CommonMark spec Example 199: empty destination after colon (just whitespace/newline)\n  // is invalid - should be parsed as paragraph, not reference definition\n  // Also check if we hit a blank line (two consecutive newlines) - destination ends there\n  if (urlStart >= len) {\n    // No destination found - invalid (except for empty <>)\n    if (!hasAngleBrackets) return null\n    // For angle brackets, empty destination is valid\n    urlEnd = urlStart\n  } else if (\n    urlNewlineCount > 0 &&\n    urlStart < len &&\n    source[urlStart] === '\\n'\n  ) {\n    // We had a newline after colon, skipped whitespace, but found another newline\n    // This means blank line after colon - empty destination, invalid\n    return null\n  } else {\n    // Find end of URL - can span multiple lines\n    // Per CommonMark spec: destination ends when we encounter:\n    // 1. Closing > for angle-bracketed URLs\n    // 2. Whitespace followed by title delimiter (\", ', or () on same or next line\n    // 3. End of input or two consecutive newlines (blank line)\n    while (urlEnd < len) {\n      if (hasAngleBrackets && source[urlEnd] === '>') {\n        break\n      }\n\n      if (source[urlEnd] === '\\n') {\n        // Check if next line continues the URL or starts a title\n        const nextLineStart = urlEnd + 1\n        if (nextLineStart >= len) break\n\n        // Check for blank line (two consecutive newlines)\n        if (nextLineStart < len && source[nextLineStart] === '\\n') {\n          // Blank line - URL ends here\n          break\n        }\n\n        // Skip whitespace on next line\n        let checkPos = nextLineStart\n        while (\n          checkPos < len &&\n          (source[checkPos] === ' ' || source[checkPos] === '\\t')\n        ) {\n          checkPos++\n        }\n\n        // If next line starts with title delimiter, URL ends here\n        if (checkPos < len && isTitleDelimiter(source, checkPos)) {\n          break\n        }\n\n        // Per CommonMark spec: reference definitions are block-level constructs\n        // If next line starts with '[', it's a new reference definition, so current one ends here\n        // Stop at the newline (don't include it in the URL)\n        if (checkPos < len && source[checkPos] === '[') {\n          break\n        }\n\n        // Check if next line looks like a block-level construct or content that would terminate the ref definition\n        // Per CommonMark spec: \"No further character may occur\" after title/URL\n        // URLs can span multiple lines, but continuation lines should still look like URLs\n        if (checkPos < len) {\n          const nextChar = source[checkPos]\n          if (isBlockStartAt(source, checkPos)) {\n            break\n          }\n          // Stop if next line starts with a letter (could be content, not URL continuation)\n          // URLs typically start with /, http, https, <, or are indented\n          // But allow if it looks like a URL scheme (letter followed by :)\n          if (nextChar >= 'a' && nextChar <= 'z') {\n            // Check if it's a URL scheme (e.g., \"http:\", \"ftp:\")\n            let schemeEnd = checkPos + 1\n            while (\n              schemeEnd < len &&\n              schemeEnd < checkPos + 32 &&\n              ((source[schemeEnd] >= 'a' && source[schemeEnd] <= 'z') ||\n                (source[schemeEnd] >= 'A' && source[schemeEnd] <= 'Z') ||\n                (source[schemeEnd] >= '0' && source[schemeEnd] <= '9') ||\n                source[schemeEnd] === '+' ||\n                source[schemeEnd] === '.' ||\n                source[schemeEnd] === '-')\n            ) {\n              schemeEnd++\n            }\n            // If followed by ':', it's a URL scheme - allow continuation\n            if (schemeEnd < len && source[schemeEnd] === ':') {\n              // URL scheme - allow continuation\n            } else {\n              // Not a URL scheme - stop here (likely content)\n              break\n            }\n          }\n        }\n\n        // Otherwise, continue URL on next line (skip the newline and leading whitespace)\n        urlEnd = checkPos\n        continue\n      }\n\n      if (\n        !hasAngleBrackets &&\n        (source[urlEnd] === ' ' || source[urlEnd] === '\\t')\n      ) {\n        // Check if this whitespace is followed by a title delimiter\n        let checkPos = urlEnd + 1\n        while (\n          checkPos < len &&\n          (source[checkPos] === ' ' || source[checkPos] === '\\t')\n        ) {\n          checkPos++\n        }\n\n        // Check if next char starts a title\n        if (checkPos < len && isTitleDelimiter(source, checkPos)) {\n          break\n        }\n\n        // Check if next line starts a title\n        if (checkPos < len && source[checkPos] === '\\n') {\n          const nextLineStart = checkPos + 1\n          if (nextLineStart < len && source[nextLineStart] === '\\n') {\n            // Blank line - URL ends here\n            break\n          }\n          let nextLineCheck = nextLineStart\n          while (\n            nextLineCheck < len &&\n            (source[nextLineCheck] === ' ' || source[nextLineCheck] === '\\t')\n          ) {\n            nextLineCheck++\n          }\n          if (nextLineCheck < len && isTitleDelimiter(source, nextLineCheck)) {\n            break\n          }\n        }\n\n        // No title delimiter found - URL continues (or ends if no title)\n        // Continue parsing to find title or end\n      }\n\n      urlEnd++\n    }\n  }\n\n  if (hasAngleBrackets && (urlEnd >= len || source[urlEnd] !== '>')) {\n    return null // No closing >\n  }\n\n  // Extract target and normalize whitespace\n  // Per CommonMark spec: destination can span multiple lines\n  // Leading/trailing whitespace on each line should be trimmed, but internal whitespace preserved\n  // Also, we need to preserve newlines between continuation lines\n  let target = source.slice(urlStart, urlEnd)\n\n  // Normalize whitespace: trim leading/trailing whitespace from each line\n  // but preserve newlines and internal whitespace\n  // Per CommonMark spec: leading/trailing whitespace is trimmed from destination\n  let targetLines: string[] = []\n  let targetLineStart = 0\n  for (let i = 0; i <= target.length; i++) {\n    if (i === target.length || target[i] === '\\n') {\n      let line = target.slice(targetLineStart, i)\n      // Trim leading/trailing whitespace from this line\n      line = line.trim()\n      if (line.length > 0 || targetLines.length === 0) {\n        // Only add non-empty lines, or the first line even if empty (for angle brackets)\n        targetLines.push(line)\n        if (i < target.length) {\n          targetLines.push('\\n')\n        }\n      } else if (i < target.length) {\n        // Empty continuation line - preserve as newline\n        targetLines.push('\\n')\n      }\n      targetLineStart = i + 1\n    }\n  }\n\n  target = targetLines.join('')\n\n  // Trim leading/trailing whitespace from the entire target\n  target = target.trim()\n\n  i = hasAngleBrackets ? urlEnd + 1 : urlEnd\n\n  // Check if we stopped URL parsing because next line starts with a block construct\n  // (indicating the ref definition ends here)\n  // Per Example 215: ref definitions end before setext headings\n  // A setext heading has content on one line, then = or - on the next line\n  // We need to look ahead to detect this pattern\n  var stoppedAtBlock = false\n  if (i < len && source[i] === '\\n') {\n    var nextLineStart = i + 1\n    var checkPos = nextLineStart\n    while (\n      checkPos < len &&\n      (source[checkPos] === ' ' || source[checkPos] === '\\t')\n    ) {\n      checkPos++\n    }\n    if (checkPos < len) {\n      const nextChar = source[checkPos]\n      if (isBlockStartAt(source, checkPos)) {\n        stoppedAtBlock = true\n      }\n      // Per Example 215: check if this looks like a setext heading\n      // Pattern: content line, then line starting with = or -\n      // If next line has content (not starting with block char), check if line after that starts with = or -\n      if (!stoppedAtBlock && nextChar !== '=' && nextChar !== '-') {\n        // Next line might be content - check if line after that starts with = or -\n        var firstLineEnd = util.findLineEnd(source, checkPos)\n        if (firstLineEnd < len) {\n          var secondLineStart = skipToNextLine(source, firstLineEnd)\n          var secondCheckPos = secondLineStart\n          while (\n            secondCheckPos < len &&\n            (source[secondCheckPos] === ' ' || source[secondCheckPos] === '\\t')\n          ) {\n            secondCheckPos++\n          }\n          if (secondCheckPos < len) {\n            var secondChar = source[secondCheckPos]\n            if (secondChar === '=' || secondChar === '-') {\n              // This is a setext heading pattern - ref definition should end before content line\n              stoppedAtBlock = true\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Per CommonMark spec: title delimiter must be separated by whitespace from destination\n  // Check if we see a title delimiter immediately after destination (no whitespace)\n  // This makes it invalid as a reference definition\n  if (!stoppedAtBlock && i < len && isTitleDelimiter(source, i)) {\n    // Title delimiter immediately after destination without whitespace - invalid\n    return null\n  }\n\n  // Skip whitespace between destination and title (including optional newline)\n  // Per CommonMark spec: title must be separated from destination by spaces/tabs\n  // The title can be on the same line or a following line\n  // Per CommonMark spec: Unicode whitespace (like non-breaking space) does NOT work for separation\n  // However, if we stopped because next line starts with a block construct, don't skip past the newline\n  let titleNewlineCount = 0\n  while (i < len && !stoppedAtBlock) {\n    const c = source[i]\n    if (c === '\\n') {\n      titleNewlineCount++\n      if (titleNewlineCount > 1) break // Only one optional newline allowed before title\n      i++\n      // After newline, skip leading whitespace on next line (only ASCII space/tab)\n      var whitespaceStart = i\n      i = util.skipWhitespace(source, i)\n      // If we hit Unicode whitespace, stop\n      if (\n        i < len &&\n        util.isUnicodeWhitespace(source[i]) &&\n        source[i] !== '\\n'\n      ) {\n        i = whitespaceStart - 1\n        break\n      }\n      // Check if next line starts with a block construct (ref definition ends here)\n      // Per Example 215: setext headings (= or -) also terminate ref definitions\n      if (i < len) {\n        const nextChar = source[i]\n        if (isBlockStartAt(source, i)) {\n          stoppedAtBlock = true\n          i = whitespaceStart - 1 // Back up to the newline\n          break\n        }\n        // Also check if this looks like a setext heading (need to look ahead to see if there's\n        // a line that starts with = or - after some content)\n        // For now, just checking = or - is sufficient as they're already in the block check above\n      }\n    } else if (c === ' ' || c === '\\t') {\n      i++\n    } else if (util.isUnicodeWhitespace(c)) {\n      // Unicode whitespace does NOT work for separation - stop here\n      break\n    } else {\n      break\n    }\n  }\n\n  // Parse optional title (can span multiple lines, but cannot contain blank lines)\n  let title: string | undefined = undefined\n  if (i < len) {\n    const titleChar = source[i]\n    var titleResult =\n      titleChar === '('\n        ? parseParenTitle(source, i)\n        : titleChar === '\"' || titleChar === \"'\"\n          ? parseQuotedTitle(source, i, titleChar)\n          : null\n    if (\n      titleResult === null &&\n      (titleChar === '\"' || titleChar === \"'\" || titleChar === '(')\n    ) {\n      return null\n    }\n    if (titleResult) {\n      title = titleResult.value\n      i = titleResult.endPos\n      var afterTitlePos = i\n      while (\n        afterTitlePos < len &&\n        (source[afterTitlePos] === ' ' || source[afterTitlePos] === '\\t')\n      ) {\n        afterTitlePos++\n      }\n      if (\n        afterTitlePos < len &&\n        source[afterTitlePos] !== '\\n' &&\n        source[afterTitlePos] !== '\\r'\n      ) {\n        return null\n      }\n      i = afterTitlePos\n    }\n  }\n\n  // Skip trailing whitespace\n  i = util.skipWhitespace(source, i)\n\n  // Must end at newline or end of input\n  // Per CommonMark spec: no further character may occur after title\n  // Per Example 210: if there's text after the title on the same line, it's invalid\n  // The title parsing already handles this - if title is found, i points to after the closing delimiter\n  // We just need to ensure there's no non-whitespace before the newline\n  if (i < len && source[i] !== '\\n') {\n    // Check if there's non-whitespace before the newline\n    var checkEndPos = i\n    while (checkEndPos < len && source[checkEndPos] !== '\\n') {\n      if (source[checkEndPos] !== ' ' && source[checkEndPos] !== '\\t') {\n        // Found non-whitespace after title - invalid reference definition\n        return null\n      }\n      checkEndPos++\n    }\n  }\n\n  // Also check: if no title was found, make sure we're at end of line or there's trailing text\n  // Per Example 210: `[foo]: /url\\n\"title\" ok` - the \"title\" ok is trailing text, should invalidate\n  if (title === undefined && i < len && source[i] !== '\\n') {\n    // No title found, but there's content after destination - check if it's just whitespace\n    var checkTrailingPos = i\n    while (checkTrailingPos < len && source[checkTrailingPos] !== '\\n') {\n      if (\n        source[checkTrailingPos] !== ' ' &&\n        source[checkTrailingPos] !== '\\t'\n      ) {\n        // Found non-whitespace after destination - invalid reference definition\n        return null\n      }\n      checkTrailingPos++\n    }\n  }\n\n  return {\n    endPos: i < len && source[i] === '\\n' ? i + 1 : i,\n    target: target,\n    title: title,\n  }\n}\n\nfunction parseFootnoteContent(\n  source: string,\n  pos: number\n): DefinitionParseResult | null {\n  // pos is already after the colon and whitespace\n  let contentStart = pos\n  let contentEnd = scanFootnoteEnd(source, pos)\n  let stoppedAtBlankLine =\n    contentEnd < source.length &&\n    source[contentEnd] === '\\n' &&\n    source[contentEnd + 1] === '\\n'\n\n  // Extract the footnote content (from after ']:' to before next footnote or end)\n  let extractEnd = contentEnd\n\n  // pos is already after the colon and whitespace, so we can use it directly\n  let contentStartPos = pos\n\n  // Process lines directly without splitting to avoid intermediate array allocation\n  var processedParts: string[] = []\n  let lineStart = contentStartPos\n  let lineIndex = 0\n  let prevWasBlank = false\n\n  while (lineStart < extractEnd) {\n    // Find line end - use findLineEnd to properly handle CRLF\n    let lineEnd = util.findLineEnd(source, lineStart)\n    if (lineEnd > extractEnd) lineEnd = extractEnd\n\n    // Extract and process line\n    if (lineIndex === 0) {\n      // First line - trim trailing whitespace only\n      let trimmedEnd = lineEnd\n      while (\n        trimmedEnd > lineStart &&\n        (source[trimmedEnd - 1] === ' ' || source[trimmedEnd - 1] === '\\t')\n      ) {\n        trimmedEnd--\n      }\n      // Build first line\n      let firstLineStr = source.slice(lineStart, trimmedEnd)\n      processedParts.push(firstLineStr)\n      // Check if first line is blank\n      prevWasBlank = firstLineStr.length === 0\n    } else {\n      // Check indentation on current line\n      let leadingSpaceCount = 0\n      let checkPos = lineStart\n      while (\n        checkPos < lineEnd &&\n        checkPos < lineStart + 4 &&\n        source[checkPos] === ' '\n      ) {\n        leadingSpaceCount++\n        checkPos++\n      }\n\n      // Check if current line is blank\n      let lineHasContent = false\n      for (let k = lineStart; k < lineEnd; k++) {\n        if (source[k] !== ' ' && source[k] !== '\\t' && source[k] !== '\\r') {\n          lineHasContent = true\n          break\n        }\n      }\n      let currentIsBlank = !lineHasContent\n\n      // Process continuation line based on indentation rules\n      if (leadingSpaceCount >= 4 && prevWasBlank) {\n        // 4+ spaces after a blank line - this is a paragraph, preserve indentation\n        processedParts.push(source.slice(lineStart, lineEnd))\n      } else if (leadingSpaceCount === 4 && !prevWasBlank) {\n        // Exactly 4 spaces without blank line - remove (markdown continuation indentation)\n        processedParts.push(source.slice(lineStart + 4, lineEnd))\n      } else {\n        // Otherwise preserve (less than 4 spaces or more than 4 spaces without blank line)\n        processedParts.push(source.slice(lineStart, lineEnd))\n      }\n\n      // Update prevWasBlank for next iteration\n      prevWasBlank = currentIsBlank\n    }\n\n    // Move to next line\n    if (lineEnd < extractEnd) {\n      const charAtEnd = charCode(source, lineEnd)\n      if (charAtEnd === $.CHAR_CR || charAtEnd === $.CHAR_NEWLINE) {\n        processedParts.push('\\n')\n        lineStart = skipToNextLine(source, lineEnd)\n      } else {\n        lineStart = extractEnd\n      }\n    } else {\n      lineStart = extractEnd\n    }\n    lineIndex++\n  }\n\n  let footnoteContent = processedParts.join('')\n\n  // Trim trailing whitespace/newlines but preserve internal structure\n  // If we stopped at a blank line, remove the trailing newline from the last line\n  if (stoppedAtBlankLine) {\n    // Remove trailing newline if present (but preserve newlines between lines)\n    footnoteContent = footnoteContent.replace(/\\n$/, '')\n  }\n  var contentLen = footnoteContent.length\n  while (contentLen > 0) {\n    var lastChar = footnoteContent[contentLen - 1]\n    if (lastChar === '\\n' || lastChar === ' ') {\n      contentLen--\n    } else {\n      break\n    }\n  }\n  if (contentLen < footnoteContent.length) {\n    footnoteContent = footnoteContent.slice(0, contentLen)\n  }\n\n  return {\n    endPos: contentEnd,\n    target: footnoteContent,\n    title: undefined,\n  }\n}\n\nexport function parseDefinition(\n  source: string,\n  pos: number,\n  state: MarkdownToJSX.State,\n  options: ParseOptions,\n  isFootnote: boolean\n): ParseResult | null {\n  if (source[pos] !== '[') return null\n  var hasCaret = pos + 1 < source.length && source[pos + 1] === '^'\n  if (isFootnote ? !hasCaret : hasCaret) return null\n\n  var lineStart = pos\n  while (lineStart > 0 && source[lineStart - 1] !== '\\n') lineStart--\n  if (\n    calculateIndent(source, lineStart, pos).spaceEquivalent >= 4 ||\n    state.inline\n  )\n    return null\n\n  var labelStart = pos + (isFootnote ? 2 : 1)\n  var len = source.length\n  var refEnd = findUnescapedChar(source, labelStart, len, ']')\n  if (refEnd === -1) return null\n  var ref = source.slice(labelStart, refEnd)\n  if (ref.length > 999) return null\n\n  var hasNonWhitespace = false,\n    hasUnescapedBracket = false,\n    labelHasNewlines = false\n  for (var j = 0; j < ref.length; j++) {\n    var c = ref[j]\n    if (c === '\\\\' && j + 1 < ref.length) {\n      j++\n      continue\n    }\n    var cCode = charCode(c)\n    if (cCode === $.CHAR_BRACKET_OPEN || cCode === $.CHAR_BRACKET_CLOSE) {\n      hasUnescapedBracket = true\n    } else if (cCode === $.CHAR_NEWLINE || cCode === $.CHAR_CR) {\n      labelHasNewlines = true\n    } else if (cCode !== $.CHAR_SPACE && cCode !== $.CHAR_TAB) {\n      hasNonWhitespace = true\n    }\n  }\n  if (!hasNonWhitespace || hasUnescapedBracket) return null\n\n  var i = refEnd + 1\n  if (labelHasNewlines) {\n    var labelStartCode = charCode(source, labelStart)\n    var refEndPrevCode = charCode(source, refEnd - 1)\n    if (\n      labelStartCode === $.CHAR_NEWLINE ||\n      labelStartCode === $.CHAR_CR ||\n      refEndPrevCode === $.CHAR_NEWLINE ||\n      refEndPrevCode === $.CHAR_CR ||\n      i >= len ||\n      source[i] !== ':'\n    )\n      return null\n  } else {\n    if (i >= len || source[i] !== ':') {\n      i = util.skipWhitespace(source, i)\n      if (i < len && charCode(source, i) === $.CHAR_NEWLINE)\n        i = util.skipWhitespace(source, i + 1)\n      if (i >= len || source[i] !== ':') return null\n    }\n  }\n  i++\n\n  var urlNewlineCount = 0\n  while (i < len) {\n    var iCode = charCode(source, i)\n    if (iCode === $.CHAR_NEWLINE) {\n      if (++urlNewlineCount > 1) break\n      i = util.skipWhitespace(source, i + 1)\n    } else if (iCode === $.CHAR_SPACE || iCode === $.CHAR_TAB) {\n      i++\n    } else {\n      break\n    }\n  }\n\n  const contentResult = isFootnote\n    ? parseFootnoteContent(source, i)\n    : parseRefContent(source, i, urlNewlineCount)\n  if (!contentResult) return null\n\n  const normalizedRef = normalizeReferenceLabel(ref)\n  const refs = state.refs || {}\n  const storageKey = isFootnote ? `^${normalizedRef}` : normalizedRef\n  if (!refs[storageKey]) {\n    refs[storageKey] = {\n      target: unescapeUrlOrTitle(contentResult.target.trim()),\n      title: contentResult.title\n        ? unescapeUrlOrTitle(contentResult.title)\n        : undefined,\n    }\n    state.refs = refs\n  }\n\n  return {\n    type: isFootnote ? RuleType.footnote : RuleType.ref,\n    endPos: contentResult.endPos,\n  } as (MarkdownToJSX.ReferenceNode | MarkdownToJSX.FootnoteNode) & {\n    endPos: number\n  }\n}\n\n// Delimiter stack entry for CommonMark spec delimiter stack algorithm\ninterface DelimiterEntry {\n  nodeIndex: number // Index in result array where this delimiter text node is\n  type: '*' | '_' | '~' | '='\n  length: number // Number of delimiters in the run\n  canOpen: boolean // Whether this delimiter can open emphasis\n  canClose: boolean // Whether this delimiter can close emphasis\n  active: boolean // Whether this delimiter is active\n  sourcePos: number // Source position where this delimiter starts (for overlap detection)\n  inAnchor: boolean // Whether this delimiter was collected inside a link (should not match with delimiters outside)\n}\n\n// Process emphasis using delimiter stack algorithm per CommonMark spec\nfunction processEmphasis(\n  nodes: MarkdownToJSX.ASTNode[],\n  delimiterStack: DelimiterEntry[],\n  stackBottom: number | null\n): void {\n  // openers_bottom for each delimiter type, indexed by numeric key: typeCode * 6 + (length % 3) * 2 + (canOpen ? 1 : 0)\n  // Type codes: '*' = 0, '_' = 1, '~' = 2, '=' = 3\n  var openersBottom: number[] = []\n\n  var currentPosition = stackBottom === null ? 0 : stackBottom + 1\n\n  while (currentPosition < delimiterStack.length) {\n    var closer = delimiterStack[currentPosition]\n    if (\n      !closer ||\n      (closer.type !== '*' &&\n        closer.type !== '_' &&\n        closer.type !== '~' &&\n        closer.type !== '=')\n    ) {\n      currentPosition++\n      continue\n    }\n\n    if (!closer.canClose || !closer.active) {\n      currentPosition++\n      continue\n    }\n\n    // Convert type to numeric code: '*' = 0, '_' = 1, '~' = 2, '=' = 3\n    var typeCode =\n      closer.type === '*'\n        ? 0\n        : closer.type === '_'\n          ? 1\n          : closer.type === '~'\n            ? 2\n            : 3\n    var openersBottomKey =\n      typeCode * 6 + (closer.length % 3) * 2 + (closer.canOpen ? 1 : 0)\n    var openersBottomIndex =\n      openersBottom[openersBottomKey] !== undefined\n        ? openersBottom[openersBottomKey]\n        : stackBottom === null\n          ? -1\n          : stackBottom\n\n    var openerIndex = -1\n    var closerType = closer.type\n    var closerInAnchor = closer.inAnchor\n    var closerCanOpen = closer.canOpen\n    var closerLength = closer.length\n    var closerLengthMod3 = closerLength % 3\n\n    for (var i = currentPosition - 1; i > openersBottomIndex; i--) {\n      var candidate = delimiterStack[i]\n      if (\n        !candidate ||\n        !candidate.active ||\n        candidate.type !== closerType ||\n        !candidate.canOpen ||\n        candidate.inAnchor !== closerInAnchor\n      )\n        continue\n      var openerLength = candidate.length\n      if (\n        (!closerCanOpen && !candidate.canClose) ||\n        closerLengthMod3 === 0 ||\n        (openerLength + closerLength) % 3 !== 0\n      ) {\n        openerIndex = i\n        break\n      }\n    }\n\n    if (openerIndex >= 0) {\n      var opener = delimiterStack[openerIndex]\n      var openerLength = opener.length\n\n      // Determine if emphasis or strong emphasis (both must have length >= 2 for strong)\n      var isStrong = openerLength >= 2 && closerLength >= 2\n      var delimitersToRemove = isStrong ? 2 : 1\n      if (\n        delimitersToRemove > openerLength ||\n        delimitersToRemove > closerLength\n      ) {\n        currentPosition++\n        continue\n      }\n\n      var openerNodeIndex = opener.nodeIndex\n      var closerNodeIndex = closer.nodeIndex\n      var contentStartIndex = openerNodeIndex + 1\n      var contentEndIndex = closerNodeIndex\n      var contentNodes = nodes.slice(contentStartIndex, contentEndIndex)\n\n      // Remove content nodes from nodes array (they'll be in the emphasis node)\n      if (contentNodes.length > 0) {\n        var nodesRemoved = contentEndIndex - contentStartIndex\n        nodes.splice(contentStartIndex, nodesRemoved)\n        for (var k = 0; k < delimiterStack.length; k++) {\n          if (delimiterStack[k].nodeIndex > contentStartIndex)\n            delimiterStack[k].nodeIndex -= nodesRemoved\n        }\n        if (closerNodeIndex > contentStartIndex) closerNodeIndex -= nodesRemoved\n      }\n\n      var emphasisTag =\n        opener.type === '~'\n          ? 'del'\n          : opener.type === '='\n            ? 'mark'\n            : isStrong\n              ? 'strong'\n              : 'em'\n      var emphasisNode: MarkdownToJSX.FormattedTextNode = {\n        type: RuleType.textFormatted,\n        tag: emphasisTag,\n        children: contentNodes,\n      }\n\n      var openerNode = nodes[openerNodeIndex] as MarkdownToJSX.TextNode\n      if (!openerNode || !openerNode.text) {\n        opener.active = closer.active = false\n        continue\n      }\n\n      // Remove delimiters from opener text node\n      var openerRemoved = openerNode.text.length <= delimitersToRemove\n      if (openerRemoved) {\n        nodes.splice(openerNodeIndex, 1)\n        for (var k = 0; k < delimiterStack.length; k++) {\n          if (delimiterStack[k].nodeIndex > openerNodeIndex)\n            delimiterStack[k].nodeIndex--\n        }\n        if (closerNodeIndex > openerNodeIndex) closerNodeIndex--\n      } else {\n        openerNode.text = openerNode.text.slice(delimitersToRemove)\n      }\n\n      var closerNode = nodes[closerNodeIndex] as MarkdownToJSX.TextNode\n      if (!closerNode || !closerNode.text) {\n        opener.active = closer.active = false\n        continue\n      }\n      var closerRemoved = closerNode.text.length <= delimitersToRemove\n      if (closerRemoved) {\n        nodes.splice(closerNodeIndex, 1)\n        for (var k = 0; k < delimiterStack.length; k++) {\n          if (delimiterStack[k].nodeIndex > closerNodeIndex)\n            delimiterStack[k].nodeIndex--\n        }\n      } else {\n        closerNode.text = closerNode.text.slice(delimitersToRemove)\n      }\n\n      // Insert emphasis node after opener (or at the position where opener was)\n      var insertIndex = openerRemoved\n        ? openerNodeIndex < closerNodeIndex\n          ? closerNodeIndex - 1\n          : openerNodeIndex\n        : openerNodeIndex + 1\n      if (insertIndex < 0 || insertIndex > nodes.length)\n        insertIndex = insertIndex < 0 ? 0 : nodes.length\n      nodes.splice(insertIndex, 0, emphasisNode)\n\n      // Update node indices in delimiter stack after insertion\n      for (var k = 0; k < delimiterStack.length; k++) {\n        if (delimiterStack[k].nodeIndex >= insertIndex) {\n          delimiterStack[k].nodeIndex++\n        }\n      }\n\n      // Remove delimiters between opener and closer from stack\n      for (var k = openerIndex + 1; k < currentPosition; k++) {\n        delimiterStack[k].active = false\n      }\n\n      // Update opener and closer in stack\n      if (openerRemoved) {\n        opener.active = false\n      } else {\n        opener.length -= delimitersToRemove\n        if (opener.length === 0) opener.active = false\n      }\n\n      if (closerRemoved) {\n        closer.active = false\n        currentPosition++\n      } else {\n        closer.length -= delimitersToRemove\n        if (closer.length === 0) {\n          closer.active = false\n          currentPosition++\n        }\n      }\n    } else {\n      // No opener found\n      openersBottom[openersBottomKey] = currentPosition - 1\n      if (!closer.canOpen) {\n        closer.active = false\n      }\n      currentPosition++\n    }\n  }\n\n  // Remove inactive delimiters from stack (O(n) shift algorithm instead of O(n) splice)\n  var writeIndex = 0\n  for (var i = 0; i < delimiterStack.length; i++) {\n    if (delimiterStack[i].active) {\n      delimiterStack[writeIndex++] = delimiterStack[i]\n    }\n  }\n  delimiterStack.length = writeIndex\n}\n\nexport function parseMarkdown(\n  input: string,\n  state: MarkdownToJSX.State,\n  options: ParseOptions\n): MarkdownToJSX.ASTNode[] {\n  var result: MarkdownToJSX.ASTNode[] = []\n  var pos = 0\n  var REF_CHECK_UNSET = -3\n  var cachedRefCheckPos = REF_CHECK_UNSET\n\n  // If inline mode, just parse the entire input as inline content\n  if (state.inline)\n    return parseInlineSpan(input, 0, input.length, state, options)\n\n  // Block parsing mode\n\n  // Check for frontmatter at the beginning (skip if doesn't start with ---)\n  if (pos === 0 && input.startsWith('---')) {\n    var frontmatterResult = parseFrontmatter(input, pos)\n    if (frontmatterResult) {\n      result.push(frontmatterResult)\n      pos = frontmatterResult.endPos\n    }\n  }\n\n  while (pos < input.length) {\n    // Skip leading newlines (but preserve whitespace for indented code blocks)\n    while (pos < input.length && input[pos] === '\\n') {\n      pos++\n    }\n\n    if (pos >= input.length) break\n    cachedRefCheckPos = REF_CHECK_UNSET\n\n    const char = input[pos]\n\n    // Try parseBlock first (handles indentation and tries all block parsers)\n    // Note: Individual parsers called by parseBlock track their own attempts\n    const parseResult = parseBlock(input, pos, state, options)\n    if (parseResult) {\n      const t = parseResult.type\n      if (t === RuleType.codeBlock) {\n        var isFenced = char === '`' || char === '~'\n        if (!isFenced && (char === ' ' || char === '\\t')) {\n          const lineEnd = util.findLineEnd(input, pos)\n          const indentInfo = calculateIndent(input, pos, lineEnd)\n          isFenced =\n            indentInfo.spaceEquivalent <= 3 &&\n            pos + indentInfo.charCount < input.length &&\n            (input[pos + indentInfo.charCount] === '`' ||\n              input[pos + indentInfo.charCount] === '~')\n        }\n      } else if (t === RuleType.breakThematic) {} else if (t === RuleType.blockQuote) {} else if (t === RuleType.heading) {} else if (t === RuleType.orderedList || t === RuleType.unorderedList) {} else if (t === RuleType.table) {} else if (t === RuleType.htmlComment) {} else if (t === RuleType.htmlBlock) {} else if (t === RuleType.ref) {}\n\n      // Special handling for HTML comments with trailing content\n      if (parseResult.type === RuleType.htmlComment) {\n        result.push(parseResult)\n        const htmlCheckPos = pos\n        pos = parseResult.endPos\n\n        // Per CommonMark spec Example 177: HTML comment blocks end at --> on the same line\n        // If there's content after --> on the same line, it should be treated as literal text\n        const commentLineEnd = util.findLineEnd(input, htmlCheckPos)\n        if (pos < commentLineEnd) {\n          const textContent = input.slice(pos, commentLineEnd)\n          if (textContent.trim().length > 0) {\n            result.push({\n              type: RuleType.text,\n              text: textContent,\n            } as MarkdownToJSX.TextNode)\n          }\n          pos = commentLineEnd\n          if (pos < input.length && input[pos] === '\\n') {\n            pos++\n          }\n        }\n        continue\n      }\n      // Special handling for HTML self-closing closing tags\n      if (\n        parseResult.type === RuleType.htmlBlock ||\n        parseResult.type === RuleType.htmlSelfClosing\n      ) {\n        const isSelfClosingClosingTag =\n          parseResult.type === RuleType.htmlSelfClosing &&\n          parseResult.isClosingTag === true\n        if (isSelfClosingClosingTag && !state.inline && !state.inHTML) {\n          // Don't match, fall through to other parsers\n        } else {\n          result.push(parseResult)\n          pos = parseResult.endPos\n          continue\n        }\n      } else {\n        result.push(parseResult)\n        pos = parseResult.endPos\n        continue\n      }\n    }\n\n    // Reference definition - check BEFORE setext heading to prevent conflicts\n    // Reference definitions take precedence over setext headings (e.g., [foo]: /url\\n===)\n    let refCheckPos =\n      cachedRefCheckPos !== REF_CHECK_UNSET ? cachedRefCheckPos : pos\n    if (cachedRefCheckPos === REF_CHECK_UNSET) {\n      if (isSpaceOrTab(char)) {\n        const lineEnd = util.findLineEnd(input, pos)\n        const indentInfo = calculateIndent(input, pos, lineEnd)\n        const checkPos = pos + indentInfo.charCount\n        if (\n          indentInfo.spaceEquivalent <= 3 &&\n          checkPos < input.length &&\n          input[checkPos] === '['\n        ) {\n          refCheckPos = checkPos\n        } else {\n          refCheckPos = -1\n        }\n      } else if (char === '[') {\n        refCheckPos = pos\n      } else {\n        refCheckPos = -1\n      }\n      cachedRefCheckPos = refCheckPos\n    }\n\n    if (\n      refCheckPos >= 0 &&\n      refCheckPos + 1 < input.length &&\n      input[refCheckPos + 1] === '^'\n    ) {\n      refCheckPos = -1\n    }\n\n    if (refCheckPos >= 0) {\n      const parseResult = parseDefinition(\n        input,\n        refCheckPos,\n        state,\n        options,\n        false\n      )\n      if (parseResult) {\n        result.push(parseResult)\n        pos = parseResult.endPos\n        continue\n      }\n      // parseDefinition returned null - check if this is an invalid reference definition that should be skipped\n      // Per CommonMark Examples 208 and 210: certain invalid reference definitions should be skipped entirely\n      const skipResult = shouldSkipInvalidReferenceDefinition(\n        input,\n        refCheckPos,\n        pos === 0\n      )\n      if (skipResult.shouldSkip) {\n        pos = skipResult.newPos\n        continue\n      }\n    }\n\n    // Heading (Setext style) - check after reference definitions\n    const setextResult = parseHeadingSetext(input, pos, state, options)\n    if (setextResult) {\n      result.push(setextResult)\n      pos = setextResult.endPos\n      continue\n    }\n\n    // Footnote definition (skip leading whitespace)\n    let footnoteCheckPos = pos\n    if (isSpaceOrTab(input[footnoteCheckPos])) {\n      const lineEnd = util.findLineEnd(input, pos)\n      const indentInfo = calculateIndent(input, pos, lineEnd)\n      footnoteCheckPos = pos + indentInfo.charCount\n    }\n    if (\n      footnoteCheckPos < input.length &&\n      input[footnoteCheckPos] === '[' &&\n      footnoteCheckPos + 1 < input.length &&\n      input[footnoteCheckPos + 1] === '^'\n    ) {\n      const footnoteResult = parseDefinition(\n        input,\n        footnoteCheckPos,\n        state,\n        options,\n        true\n      )\n      if (footnoteResult) {\n        pos = footnoteResult.endPos\n        continue\n      }\n    }\n\n    const paragraphResult = parseParagraph(input, pos, state, options)\n    if (paragraphResult) {\n      result.push(paragraphResult)\n      pos = paragraphResult.endPos\n      continue\n    }\n\n    pos++\n  }\n\n  // Note: Memory snapshot \"After block parsing\" is taken in compiler function\n  // after parseMarkdown returns, not here\n\n  // Footnotes footer is appended during rendering phase (not in AST)\n  // Footnotes are stored in refs with '^' prefix and extracted during rendering\n\n  // Collect all refs from state.refs (populated during parsing) and create a reference collection node\n  // Reference nodes stay in their original positions, but we prepend a collection node\n  // Include footnotes (keys starting with '^') so the renderer can handle them\n  const allRefs = state.refs || {}\n  const collectedRefs: {\n    [key: string]: { target: string; title: string | undefined }\n  } = {}\n  for (const key in allRefs) {\n    collectedRefs[key] = allRefs[key]\n  }\n\n  // Prepend reference collection node if we have any refs\n  if (util.hasKeys(collectedRefs)) {\n    const refCollectionNode: MarkdownToJSX.ReferenceCollectionNode = {\n      type: RuleType.refCollection,\n      refs: collectedRefs,\n    }\n    return [refCollectionNode, ...result]\n  }\n\n  return result\n}\n\n/**\n * Collect reference definitions from markdown input and populate the refs object.\n * This function scans the markdown for reference-style link and image definitions.\n *\n * @param input - The markdown string to scan\n * @param refs - Object to populate with reference definitions\n * @param options - Parser options\n */\nexport function collectReferenceDefinitions(\n  input: string,\n  refs: { [key: string]: { target: string; title: string | undefined } },\n  options: ParseOptions\n): void {\n  var pos = 0\n  var canStartRef = true\n  const len = input.length\n\n  while (pos < len) {\n    var newlines = 0\n    // Count consecutive newlines more efficiently\n    while (pos < len && charCode(input, pos) === $.CHAR_NEWLINE) {\n      newlines++\n      pos++\n    }\n    if (pos >= len) break\n    if (newlines > 0) canStartRef = true\n\n    // Skip fenced code\n    const currentCharCode = charCode(input, pos)\n    if (\n      currentCharCode === $.CHAR_BACKTICK ||\n      currentCharCode === $.CHAR_TILDE\n    ) {\n      var fence = parseCodeFenced(input, pos, { inline: false }, options)\n      if (fence) {\n        pos = fence.endPos\n        canStartRef = true\n        continue\n      }\n    }\n\n    // Try parse ref (up to 3 space indent)\n    var refPos = pos\n    var indent = 0\n    while (refPos < len && indent < 4) {\n      const code = charCode(input, refPos)\n      if (code === $.CHAR_SPACE) {\n        indent++\n        refPos++\n      } else if (code === $.CHAR_TAB) {\n        indent += 4 - (indent % 4)\n        refPos++\n      } else {\n        break\n      }\n    }\n\n    if (\n      indent < 4 &&\n      refPos < len &&\n      charCode(input, refPos) === $.CHAR_BRACKET_OPEN &&\n      canStartRef\n    ) {\n      if (refPos + 1 < len && charCode(input, refPos + 1) === $.CHAR_CARET) {\n        canStartRef = false\n        var lineEnd = util.findLineEnd(input, pos)\n        pos = lineEnd >= len ? len : skipToNextLine(input, lineEnd)\n        continue\n      } else {\n        var result = parseDefinition(\n          input,\n          refPos,\n          { inline: false, refs },\n          options,\n          false\n        )\n        if (result) {\n          pos = result.endPos\n          canStartRef = true\n          continue\n        }\n        // parseDefinition returned null - check if colon exists (invalid ref attempt) vs paragraph content\n        var lineEnd = util.findLineEnd(input, pos)\n        var colonPos = input.indexOf(':', refPos + 1)\n        if (colonPos === -1 || colonPos >= lineEnd) {\n          var indentInfo = calculateIndent(input, pos, lineEnd)\n          if (\n            !isBlankLineCheck(input, pos, lineEnd) &&\n            currentCharCode !== $.CHAR_HASH &&\n            currentCharCode !== $.CHAR_GT &&\n            currentCharCode !== $.CHAR_DASH &&\n            currentCharCode !== $.CHAR_EQ &&\n            indentInfo.spaceEquivalent < 4\n          ) {\n            canStartRef = false\n          }\n        }\n        pos = lineEnd >= len ? len : skipToNextLine(input, lineEnd)\n        continue\n      }\n    }\n\n    // Scan blockquotes for nested refs\n    if (currentCharCode === $.CHAR_GT && canStartRef) {\n      var bqEnd = pos\n      var bqLines = []\n      while (bqEnd < len) {\n        var lineEnd = util.findLineEnd(input, bqEnd)\n        var quotePos = bqEnd\n        while (quotePos < lineEnd) {\n          const code = charCode(input, quotePos)\n          if (code === $.CHAR_SPACE || code === $.CHAR_TAB) {\n            quotePos++\n          } else {\n            break\n          }\n        }\n        if (quotePos >= lineEnd || charCode(input, quotePos) !== $.CHAR_GT)\n          break\n\n        var contentStart = quotePos + 1\n        if (\n          contentStart < lineEnd &&\n          (charCode(input, contentStart) === $.CHAR_SPACE ||\n            charCode(input, contentStart) === $.CHAR_TAB)\n        )\n          contentStart++\n        bqLines.push(input.slice(contentStart, lineEnd))\n        bqEnd = skipToNextLine(input, lineEnd)\n      }\n      if (bqLines.length) {\n        collectReferenceDefinitions(bqLines.join('\\n'), refs, options)\n        pos = bqEnd\n        canStartRef = true\n        continue\n      }\n    }\n\n    var lineEnd = util.findLineEnd(input, pos)\n    if (lineEnd >= len) {\n      pos = len\n    } else {\n      var isCurrentLineBlank = isBlankLineCheck(input, pos, lineEnd)\n      var indentInfo = calculateIndent(input, pos, lineEnd)\n      pos = skipToNextLine(input, lineEnd)\n      canStartRef =\n        currentCharCode === $.CHAR_HASH ||\n        currentCharCode === $.CHAR_GT ||\n        currentCharCode === $.CHAR_DASH ||\n        currentCharCode === $.CHAR_EQ ||\n        isCurrentLineBlank ||\n        indentInfo.spaceEquivalent >= 4\n    }\n  }\n}\n\n/**\n * Given a markdown string, return an abstract syntax tree (AST) of the markdown.\n *\n * The first node in the AST is a reference collection node. This node contains all the\n * reference definitions found in the markdown. These reference definitions are used to\n * resolve reference links and images in the markdown.\n *\n * @lang zh  Markdown  Markdown  (AST)\n *\n * AST  Markdown  Markdown \n * @lang hi  Markdown    , Markdown     (AST)  \n *\n * AST          Markdown             Markdown              \n *\n * @param source - The markdown string to parse.\n * @lang zh @param source -  Markdown \n * @lang hi @param source -     Markdown \n * @param options - The options for the parser.\n * @lang zh @param options - \n * @lang hi @param options -    \n * @returns The AST of the markdown.\n * @lang zh @returns Markdown  AST\n * @lang hi @returns Markdown  AST\n */\nexport function parser(\n  source: string,\n  options?: MarkdownToJSX.Options\n): MarkdownToJSX.ASTNode[] {\n  // Strip BOM (U+FEFF) at document start per CommonMark spec\n  if (source.charCodeAt(0) === 0xfeff) {\n    source = source.slice(1)\n  }\n\n  // Normalize input: replace null bytes with U+FFFD per CommonMark spec\n  source = util.normalizeInput(source)\n\n  // Default state\n  const defaultState: MarkdownToJSX.State = { inline: false, refs: {} }\n  const finalState = { ...defaultState }\n\n  // Normalize options - convert MarkdownToJSX.Options to ParseOptions\n  const finalOptions: ParseOptions = {\n    ...options,\n    slugify: options?.slugify\n      ? (input: string) => options.slugify(input, util.slugify)\n      : util.slugify,\n    sanitizer: options?.sanitizer || util.sanitizer,\n    tagfilter: options?.tagfilter !== false,\n  }\n\n  // Collect reference definitions if not in inline mode\n  if (!finalState.inline) {\n    collectReferenceDefinitions(source, finalState.refs || {}, finalOptions)\n  }\n\n  // Parse markdown\n  const astNodes = parseMarkdown(source, finalState, finalOptions)\n\n  return astNodes\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 20184, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/readonly-url-search-params.ts"],"sourcesContent":["/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n"],"names":["ReadonlyURLSearchParams","ReadonlyURLSearchParamsError","Error","constructor","URLSearchParams","append","delete","set","sort"],"mappings":"AAAA;;;;CAIC,GAED,cAAc;;;+BAaDA,2BAAAA;;;eAAAA;;;AAZb,MAAMC,qCAAqCC;IACzCC,aAAc;QACZ,KAAK,CACH;IAEJ;AACF;AAMO,MAAMH,gCAAgCI;IAC3C,wKAAwK,GACxKC,SAAS;QACP,MAAM,IAAIJ;IACZ;IACA,wKAAwK,GACxKK,SAAS;QACP,MAAM,IAAIL;IACZ;IACA,wKAAwK,GACxKM,MAAM;QACJ,MAAM,IAAIN;IACZ;IACA,wKAAwK,GACxKO,OAAO;QACL,MAAM,IAAIP;IACZ;AACF","ignoreList":[0]}},
    {"offset": {"line": 20227, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/redirect-status-code.ts"],"sourcesContent":["export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n"],"names":["RedirectStatusCode"],"mappings":";;;+BAAYA,sBAAAA;;;eAAAA;;;AAAL,IAAKA,qBAAAA,WAAAA,GAAAA,SAAAA,kBAAAA;;;;WAAAA","ignoreList":[0]}},
    {"offset": {"line": 20253, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/redirect-error.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n"],"names":["REDIRECT_ERROR_CODE","RedirectType","isRedirectError","error","digest","split","errorCode","type","destination","slice","join","status","at","statusCode","Number","isNaN","RedirectStatusCode"],"mappings":";;;;;;;;;;;;;;;IAEaA,mBAAmB,EAAA;eAAnBA;;IAEDC,YAAY,EAAA;eAAZA;;IAgBIC,eAAe,EAAA;eAAfA;;;oCApBmB;AAE5B,MAAMF,sBAAsB;AAE5B,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;WAAAA;;AAgBL,SAASC,gBAAgBC,KAAc;IAC5C,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IAEA,MAAMA,SAASD,MAAMC,MAAM,CAACC,KAAK,CAAC;IAClC,MAAM,CAACC,WAAWC,KAAK,GAAGH;IAC1B,MAAMI,cAAcJ,OAAOK,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;IAC7C,MAAMC,SAASP,OAAOQ,EAAE,CAAC,CAAC;IAE1B,MAAMC,aAAaC,OAAOH;IAE1B,OACEL,cAAcN,uBACbO,CAAAA,SAAS,aAAaA,SAAS,MAAK,KACrC,OAAOC,gBAAgB,YACvB,CAACO,MAAMF,eACPA,cAAcG,oBAAAA,kBAAkB;AAEpC","ignoreList":[0]}},
    {"offset": {"line": 20307, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/redirect.ts"],"sourcesContent":["import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n"],"names":["getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","window","require","undefined","url","type","statusCode","RedirectStatusCode","TemporaryRedirect","error","Error","REDIRECT_ERROR_CODE","digest","getStore","isAction","RedirectType","push","replace","PermanentRedirect","isRedirectError","split","slice","join","Number","at"],"mappings":";;;;;;;;;;;;;;;;;;IAegBA,gBAAgB,EAAA;eAAhBA;;IA6EAC,8BAA8B,EAAA;eAA9BA;;IARAC,wBAAwB,EAAA;eAAxBA;;IARAC,uBAAuB,EAAA;eAAvBA;;IAhBAC,iBAAiB,EAAA;eAAjBA;;IAvBAC,QAAQ,EAAA;eAARA;;;oCArCmB;+BAM5B;AAEP,MAAMC,qBACJ,OAAOC,WAAW,qBAEZC,QAAQ,2KACRF,kBAAkB,GACpBG;AAEC,SAAST,iBACdU,GAAW,EACXC,IAAkB,EAClBC,aAAiCC,oBAAAA,kBAAkB,CAACC,iBAAiB;IAErE,MAAMC,QAAQ,OAAA,cAA8B,CAA9B,IAAIC,MAAMC,eAAAA,mBAAmB,GAA7B,qBAAA;eAAA;oBAAA;sBAAA;IAA6B;IAC3CF,MAAMG,MAAM,GAAG,GAAGD,eAAAA,mBAAmB,CAAC,CAAC,EAAEN,KAAK,CAAC,EAAED,IAAI,CAAC,EAAEE,WAAW,CAAC,CAAC;IACrE,OAAOG;AACT;AAcO,SAASV,SACd,2BAA2B,GAC3BK,GAAW,EACXC,IAAmB;IAEnBA,SAASL,oBAAoBa,YAAYC,WACrCC,eAAAA,YAAY,CAACC,IAAI,GACjBD,eAAAA,YAAY,CAACE,OAAO;IAExB,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACC,iBAAiB;AACxE;AAaO,SAASV,kBACd,2BAA2B,GAC3BM,GAAW,EACXC,OAAqBU,eAAAA,YAAY,CAACE,OAAO;IAEzC,MAAMvB,iBAAiBU,KAAKC,MAAME,oBAAAA,kBAAkB,CAACW,iBAAiB;AACxE;AAUO,SAASrB,wBAAwBY,KAAc;IACpD,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ,OAAO;IAEpC,wEAAwE;IACxE,kBAAkB;IAClB,OAAOA,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKC,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC;AACnD;AAEO,SAAS1B,yBAAyBa,KAAoB;IAC3D,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOD,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;AACtC;AAEO,SAASzB,+BAA+Bc,KAAoB;IACjE,IAAI,CAACU,CAAAA,GAAAA,eAAAA,eAAe,EAACV,QAAQ;QAC3B,MAAM,OAAA,cAAiC,CAAjC,IAAIC,MAAM,yBAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAgC;IACxC;IAEA,OAAOa,OAAOd,MAAMG,MAAM,CAACQ,KAAK,CAAC,KAAKI,EAAE,CAAC,CAAC;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 20400, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n"],"names":["HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","error","digest","prefix","httpStatus","split","has","Number","status"],"mappings":";;;;;;;;;;;;;;;;;IAAaA,qBAAqB,EAAA;eAArBA;;IAQAC,8BAA8B,EAAA;eAA9BA;;IAuCGC,kCAAkC,EAAA;eAAlCA;;IAPAC,2BAA2B,EAAA;eAA3BA;;IAnBAC,yBAAyB,EAAA;eAAzBA;;;AArBT,MAAMJ,wBAAwB;IACnCK,WAAW;IACXC,WAAW;IACXC,cAAc;AAChB;AAEA,MAAMC,gBAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACX;AAErC,MAAMC,iCAAiC;AAavC,SAASG,0BACdQ,KAAc;IAEd,IACE,OAAOA,UAAU,YACjBA,UAAU,QACV,CAAE,CAAA,YAAYA,KAAI,KAClB,OAAOA,MAAMC,MAAM,KAAK,UACxB;QACA,OAAO;IACT;IACA,MAAM,CAACC,QAAQC,WAAW,GAAGH,MAAMC,MAAM,CAACG,KAAK,CAAC;IAEhD,OACEF,WAAWb,kCACXO,cAAcS,GAAG,CAACC,OAAOH;AAE7B;AAEO,SAASZ,4BACdS,KAA8B;IAE9B,MAAMG,aAAaH,MAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE;IAC7C,OAAOE,OAAOH;AAChB;AAEO,SAASb,mCACdiB,MAAc;IAEd,OAAQA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE;IACJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 20474, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/not-found.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n"],"names":["notFound","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","error","Error","digest"],"mappings":";;;+BAsBgBA,YAAAA;;;eAAAA;;;oCAnBT;AAEP;;;;;;;;;;;;;CAaC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,MAAMG,QAAQ,OAAA,cAAiB,CAAjB,IAAIC,MAAMH,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BE,MAAkCE,MAAM,GAAGJ;IAE7C,MAAME;AACR","ignoreList":[0]}},
    {"offset": {"line": 20518, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/forbidden.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["forbidden","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":";;;+BAqBgBA,aAAAA;;;eAAAA;;;oCAlBT;AAEP,6BAA6B;AAC7B;;;;;;;;;;;CAWC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,IAAI,CAACG,QAAQC,GAAG,CAACC,uBAAqC,YAAF;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 20568, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/unauthorized.ts"],"sourcesContent":["import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n"],"names":["unauthorized","DIGEST","HTTP_ERROR_FALLBACK_ERROR_CODE","process","env","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","Error","error","digest"],"mappings":";;;+BAsBgBA,gBAAAA;;;eAAAA;;;oCAnBT;AAEP,gCAAgC;AAChC;;;;;;;;;;;;CAYC,GAED,MAAMC,SAAS,GAAGC,oBAAAA,8BAA8B,CAAC,IAAI,CAAC;AAE/C,SAASF;IACd,IAAI,CAACG,QAAQC,GAAG,CAACC,uBAAqC,YAAF;QAClD,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,+GAA+G,CAAC,GAD7G,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF;IAEA,MAAMC,QAAQ,OAAA,cAAiB,CAAjB,IAAID,MAAML,SAAV,qBAAA;eAAA;oBAAA;sBAAA;IAAgB;IAC5BM,MAAkCC,MAAM,GAAGP;IAC7C,MAAMM;AACR","ignoreList":[0]}},
    {"offset": {"line": 20619, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/dynamic-rendering-utils.ts"],"sourcesContent":["import type { NonStaticRenderStage } from './app-render/staged-rendering'\nimport type { RequestStore } from './app-render/work-unit-async-storage.external'\n\nexport function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(\n  underlying: T,\n  requestStore: RequestStore,\n  stage: NonStaticRenderStage\n): Promise<T> {\n  if (requestStore.stagedRendering) {\n    // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n    return requestStore.stagedRendering.delayUntilStage(\n      stage,\n      undefined,\n      underlying\n    )\n  }\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n"],"names":["isHangingPromiseRejectionError","makeDevtoolsIOAwarePromise","makeHangingPromise","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","route","expression","abortListenersBySignal","WeakMap","signal","aborted","Promise","reject","hangingPromise","_","boundRejection","bind","currentListeners","get","push","listeners","set","addEventListener","i","length","once","catch","ignoreReject","underlying","requestStore","stage","stagedRendering","delayUntilStage","undefined","resolve","setTimeout"],"mappings":";;;;;;;;;;;;;;;IAGgBA,8BAA8B,EAAA;eAA9BA;;IA2EAC,0BAA0B,EAAA;eAA1BA;;IAxCAC,kBAAkB,EAAA;eAAlBA;;;AAnCT,SAASF,+BACdG,GAAY;IAEZ,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAIC,MAAM,KAAKC;AACxB;AAEA,MAAMA,4BAA4B;AAElC,MAAMC,qCAAqCC;IAGzCC,YACkBC,KAAa,EACbC,UAAkB,CAClC;QACA,KAAK,CACH,CAAC,qBAAqB,EAAEA,WAAW,qGAAqG,EAAEA,WAAW,8KAA8K,EAAED,MAAM,EAAE,CAAC,GAAA,IAAA,CAJhUA,KAAAA,GAAAA,OAAAA,IAAAA,CACAC,UAAAA,GAAAA,YAAAA,IAAAA,CAJFN,MAAAA,GAASC;IASzB;AACF;AAGA,MAAMM,yBAAyB,IAAIC;AAS5B,SAASV,mBACdW,MAAmB,EACnBJ,KAAa,EACbC,UAAkB;IAElB,IAAIG,OAAOC,OAAO,EAAE;QAClB,OAAOC,QAAQC,MAAM,CAAC,IAAIV,6BAA6BG,OAAOC;IAChE,OAAO;QACL,MAAMO,iBAAiB,IAAIF,QAAW,CAACG,GAAGF;YACxC,MAAMG,iBAAiBH,OAAOI,IAAI,CAChC,MACA,IAAId,6BAA6BG,OAAOC;YAE1C,IAAIW,mBAAmBV,uBAAuBW,GAAG,CAACT;YAClD,IAAIQ,kBAAkB;gBACpBA,iBAAiBE,IAAI,CAACJ;YACxB,OAAO;gBACL,MAAMK,YAAY;oBAACL;iBAAe;gBAClCR,uBAAuBc,GAAG,CAACZ,QAAQW;gBACnCX,OAAOa,gBAAgB,CACrB,SACA;oBACE,IAAK,IAAIC,IAAI,GAAGA,IAAIH,UAAUI,MAAM,EAAED,IAAK;wBACzCH,SAAS,CAACG,EAAE;oBACd;gBACF,GACA;oBAAEE,MAAM;gBAAK;YAEjB;QACF;QACA,2GAA2G;QAC3G,6GAA6G;QAC7G,yFAAyF;QACzFZ,eAAea,KAAK,CAACC;QACrB,OAAOd;IACT;AACF;AAEA,SAASc,gBAAgB;AAElB,SAAS9B,2BACd+B,UAAa,EACbC,YAA0B,EAC1BC,KAA2B;IAE3B,IAAID,aAAaE,eAAe,EAAE;QAChC,iFAAiF;QACjF,OAAOF,aAAaE,eAAe,CAACC,eAAe,CACjDF,OACAG,WACAL;IAEJ;IACA,kEAAkE;IAClE,2EAA2E;IAC3E,OAAO,IAAIjB,QAAW,CAACuB;QACrB,sFAAsF;QACtFC,WAAW;YACTD,QAAQN;QACV,GAAG;IACL;AACF","ignoreList":[0]}},
    {"offset": {"line": 20706, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/lib/router-utils/is-postpone.ts"],"sourcesContent":["const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone')\n\nexport function isPostpone(error: any): boolean {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    error.$$typeof === REACT_POSTPONE_TYPE\n  )\n}\n"],"names":["isPostpone","REACT_POSTPONE_TYPE","Symbol","for","error","$$typeof"],"mappings":";;;+BAEgBA,cAAAA;;;eAAAA;;;AAFhB,MAAMC,sBAA8BC,OAAOC,GAAG,CAAC;AAExC,SAASH,WAAWI,KAAU;IACnC,OACE,OAAOA,UAAU,YACjBA,UAAU,QACVA,MAAMC,QAAQ,KAAKJ;AAEvB","ignoreList":[0]}},
    {"offset": {"line": 20723, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts"],"sourcesContent":["// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n"],"names":["BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","Error","constructor","reason","digest","err"],"mappings":"AAAA,+GAA+G;;;;;;;;;;;;;;;IAIlGA,iBAAiB,EAAA;eAAjBA;;IASGC,mBAAmB,EAAA;eAAnBA;;;AAZhB,MAAMC,iBAAiB;AAGhB,MAAMF,0BAA0BG;IAGrCC,YAA4BC,MAAc,CAAE;QAC1C,KAAK,CAAC,CAAC,mCAAmC,EAAEA,QAAQ,GAAA,IAAA,CAD1BA,MAAAA,GAAAA,QAAAA,IAAAA,CAFZC,MAAAA,GAASJ;IAIzB;AACF;AAGO,SAASD,oBAAoBM,GAAY;IAC9C,IAAI,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,CAAE,CAAA,YAAYA,GAAE,GAAI;QACjE,OAAO;IACT;IAEA,OAAOA,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0]}},
    {"offset": {"line": 20761, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/is-next-router-error.ts"],"sourcesContent":["import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n"],"names":["isNextRouterError","error","isRedirectError","isHTTPAccessFallbackError"],"mappings":";;;+BAWgBA,qBAAAA;;;eAAAA;;;oCART;+BAC6C;AAO7C,SAASA,kBACdC,KAAc;IAEd,OAAOC,CAAAA,GAAAA,eAAAA,eAAe,EAACD,UAAUE,CAAAA,GAAAA,oBAAAA,yBAAyB,EAACF;AAC7D","ignoreList":[0]}},
    {"offset": {"line": 20786, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/hooks-server-context.ts"],"sourcesContent":["const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n"],"names":["DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","Error","constructor","description","digest","err"],"mappings":";;;;;;;;;;;;;;IAEaA,kBAAkB,EAAA;eAAlBA;;IAQGC,oBAAoB,EAAA;eAApBA;;;AAVhB,MAAMC,qBAAqB;AAEpB,MAAMF,2BAA2BG;IAGtCC,YAA4BC,WAAmB,CAAE;QAC/C,KAAK,CAAC,CAAC,sBAAsB,EAAEA,aAAa,GAAA,IAAA,CADlBA,WAAAA,GAAAA,aAAAA,IAAAA,CAF5BC,MAAAA,GAAoCJ;IAIpC;AACF;AAEO,SAASD,qBAAqBM,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAE,KAChB,OAAOA,IAAID,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOC,IAAID,MAAM,KAAKJ;AACxB","ignoreList":[0]}},
    {"offset": {"line": 20830, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/static-generation-bailout.ts"],"sourcesContent":["const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n"],"names":["StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","Error","code","error"],"mappings":";;;;;;;;;;;;;;IAEaA,qBAAqB,EAAA;eAArBA;;IAIGC,uBAAuB,EAAA;eAAvBA;;;AANhB,MAAMC,0BAA0B;AAEzB,MAAMF,8BAA8BG;;QAApC,KAAA,IAAA,OAAA,IAAA,CACWC,IAAAA,GAAOF;;AACzB;AAEO,SAASD,wBACdI,KAAc;IAEd,IAAI,OAAOA,UAAU,YAAYA,UAAU,QAAQ,CAAE,CAAA,UAAUA,KAAI,GAAI;QACrE,OAAO;IACT;IAEA,OAAOA,MAAMD,IAAI,KAAKF;AACxB","ignoreList":[0]}},
    {"offset": {"line": 20874, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/lib/framework/boundary-constants.tsx"],"sourcesContent":["export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n"],"names":["METADATA_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME"],"mappings":";;;;;;;;;;;;;;;;IAAaA,sBAAsB,EAAA;eAAtBA;;IAEAC,oBAAoB,EAAA;eAApBA;;IACAC,yBAAyB,EAAA;eAAzBA;;IAFAC,sBAAsB,EAAA;eAAtBA;;;AADN,MAAMH,yBAAyB;AAC/B,MAAMG,yBAAyB;AAC/B,MAAMF,uBAAuB;AAC7B,MAAMC,4BAA4B","ignoreList":[0]}},
    {"offset": {"line": 20911, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/lib/scheduler.ts"],"sourcesContent":["export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n"],"names":["atLeastOneTask","scheduleImmediate","scheduleOnNextTick","waitAtLeastOneReactRenderTask","cb","Promise","resolve","then","process","env","NEXT_RUNTIME","setTimeout","nextTick","setImmediate","r"],"mappings":";;;;;;;;;;;;;;;;IA4CgBA,cAAc,EAAA;eAAdA;;IAbHC,iBAAiB,EAAA;eAAjBA;;IAtBAC,kBAAkB,EAAA;eAAlBA;;IAgDGC,6BAA6B,EAAA;eAA7BA;;;AAhDT,MAAMD,qBAAqB,CAACE;IACjC,6EAA6E;IAC7E,4EAA4E;IAC5E,uCAAuC;IACvC,EAAE;IACF,kLAAkL;IAClL,EAAE;IACFC,QAAQC,OAAO,GAAGC,IAAI,CAAC;QACrB,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;aAElC;YACLF,QAAQI,QAAQ,CAACR;QACnB;IACF;AACF;AAQO,MAAMH,oBAAoB,CAACG;IAChC,IAAII,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;SAElC;QACLG,aAAaT;IACf;AACF;AAOO,SAASJ;IACd,OAAO,IAAIK,QAAc,CAACC,UAAYL,kBAAkBK;AAC1D;AAWO,SAASH;IACd,IAAIK,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;SAElC;QACL,OAAO,IAAIL,QAAQ,CAACS,IAAMD,aAAaC;IACzC;AACF","ignoreList":[0]}},
    {"offset": {"line": 20976, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/server/app-render/dynamic-rendering.ts"],"sourcesContent":["/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  dynamicMetadata: null | Error\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    dynamicMetadata: null,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nexport function useDynamicSearchParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore) {\n    // We assume pages router context and just return\n    return\n  }\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(expression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-client': {\n      React.use(\n        makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      )\n      break\n    }\n    case 'prerender-legacy':\n    case 'prerender-ppr': {\n      if (workStore.forceStatic) {\n        return\n      }\n      throw new BailoutToCSRError(expression)\n    }\n    case 'prerender':\n    case 'prerender-runtime':\n      throw new InvariantError(\n        `\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'cache':\n    case 'unstable-cache':\n    case 'private-cache':\n      throw new InvariantError(\n        `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'request':\n      return\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message =\n      `Route \"${workStore.route}\": Uncached data was accessed outside of ` +\n      '<Suspense>. This delays the entire page from rendering, resulting in a ' +\n      'slow user experience. Learn more: ' +\n      'https://nextjs.org/docs/messages/blocking-route'\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nexport function trackDynamicHoleInRuntimeShell(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed inside \\`generateMetadata\\`. Except for this instance, the page would have been entirely prerenderable which may have been the intended behavior. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicMetadata = error\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed inside \\`generateViewport\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": Uncached data or \\`connection()\\` was accessed outside of \\`<Suspense>\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nexport function trackDynamicHoleInStaticShell(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed inside \\`generateMetadata\\` or you have file-based metadata such as icons that depend on dynamic params segments. Except for this instance, the page would have been entirely prerenderable which may have been the intended behavior. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicMetadata = error\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed inside \\`generateViewport\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": Runtime data such as \\`cookies()\\`, \\`headers()\\`, \\`params\\`, or \\`searchParams\\` was accessed outside of \\`<Suspense>\\`. This delays the entire page from rendering, resulting in a slow user experience. Learn more: https://nextjs.org/docs/messages/blocking-route`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  // TODO go back to owner stack here if available. This is temporarily using componentStack to get the right\n  //\n  error.stack = error.name + ': ' + message + (ownerStack || componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    logDisallowedDynamicError(\n      workStore,\n      serverDynamic.syncDynamicErrorWithStack\n    )\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function getStaticShellDisallowedDynamicReasons(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState\n): Array<Error> {\n  if (dynamicValidation.hasSuspenseAboveBody) {\n    // This route has opted into allowing fully dynamic rendering\n    // by including a Suspense boundary above the body. In this case\n    // a lack of a shell is not considered disallowed so we simply return\n    return []\n  }\n\n  if (prelude !== PreludeState.Full) {\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      return dynamicErrors\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      return [\n        new InvariantError(\n          `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason.`\n        ),\n      ]\n    }\n  } else {\n    // We have a prelude but we might still have dynamic metadata without any other dynamic access\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.dynamicErrors.length === 0 &&\n      dynamicValidation.dynamicMetadata\n    ) {\n      return [dynamicValidation.dynamicMetadata]\n    }\n  }\n  // We had a non-empty prelude and there are no dynamic holes\n  return []\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n"],"names":["Postpone","PreludeState","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createRenderInBrowserAbortSignal","delayUntilRuntimeStage","formatDynamicAPIAccesses","getFirstDynamicReason","getStaticShellDisallowedDynamicReasons","isDynamicPostpone","isPrerenderInterruptedError","logDisallowedDynamicError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackDynamicHoleInRuntimeShell","trackDynamicHoleInStaticShell","useDynamicRouteParams","useDynamicSearchParams","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","hasSuspenseAboveBody","hasDynamicMetadata","dynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","trackingState","expression","store","workUnitStore","type","forceDynamic","forceStatic","dynamicShouldError","StaticGenBailoutError","route","dynamicTracking","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack","process","env","NODE_ENV","usedDynamic","prerenderStore","abortOnSynchronousDynamicDataAccess","reason","error","createPrerenderInterruptedError","controller","abort","push","Error","undefined","errorWithStack","prerenderSignal","signal","aborted","workUnitAsyncStorage","getStore","assertPostpone","createPostponeReason","message","isDynamicPostponeReason","includes","NEXT_PRERENDER_INTERRUPTED","digest","length","serverDynamic","clientDynamic","filter","access","map","split","slice","line","join","AbortController","BailoutToCSRError","cacheSignal","inputReady","then","runtimeStagePromise","getRuntimeStagePromise","scheduleOnNextTick","workStore","workAsyncStorage","fallbackParams","fallbackRouteParams","size","use","makeHangingPromise","renderSignal","InvariantError","throwForMissingRequestStore","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","ROOT_LAYOUT_BOUNDARY_NAME","hasMetadataRegex","METADATA_BOUNDARY_NAME","hasViewportRegex","VIEWPORT_BOUNDARY_NAME","hasOutletRegex","OUTLET_BOUNDARY_NAME","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","ownerStack","captureOwnerStack","name","console","dev","hasReadableErrorStacks","prelude","i","result"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 21805, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/unstable-rethrow.server.ts"],"sourcesContent":["import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n"],"names":["unstable_rethrow","error","isNextRouterError","isBailoutToCSRError","isDynamicServerError","isDynamicPostpone","isPostpone","isHangingPromiseRejectionError","isPrerenderInterruptedError","Error","cause"],"mappings":";;;+BAUgBA,oBAAAA;;;eAAAA;;;uCAV+B;4BACpB;8BACS;mCACF;kCAI3B;oCAC8B;AAE9B,SAASA,iBAAiBC,KAAc;IAC7C,IACEC,CAAAA,GAAAA,mBAAAA,iBAAiB,EAACD,UAClBE,CAAAA,GAAAA,cAAAA,mBAAmB,EAACF,UACpBG,CAAAA,GAAAA,oBAAAA,oBAAoB,EAACH,UACrBI,CAAAA,GAAAA,kBAAAA,iBAAiB,EAACJ,UAClBK,CAAAA,GAAAA,YAAAA,UAAU,EAACL,UACXM,CAAAA,GAAAA,uBAAAA,8BAA8B,EAACN,UAC/BO,CAAAA,GAAAA,kBAAAA,2BAA2B,EAACP,QAC5B;QACA,MAAMA;IACR;IAEA,IAAIA,iBAAiBQ,SAAS,WAAWR,OAAO;QAC9CD,iBAAiBC,MAAMS,KAAK;IAC9B;AACF","ignoreList":[0]}},
    {"offset": {"line": 21839, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/unstable-rethrow.ts"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n"],"names":["unstable_rethrow","window","require"],"mappings":"AAAA;;;;;;CAMC;;;+BACYA,oBAAAA;;;eAAAA;;;AAAN,MAAMA,mBACX,OAAOC,WAAW,qBAEZC,QAAQ,wHACRF,gBAAgB,GAEhBE,QAAQ,8BACRF,gBAAgB","ignoreList":[0]}},
    {"offset": {"line": 21866, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/client/components/navigation.react-server.ts"],"sourcesContent":["import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n"],"names":["ReadonlyURLSearchParams","RedirectType","forbidden","notFound","permanentRedirect","redirect","unauthorized","unstable_isUnrecognizedActionError","unstable_rethrow","Error"],"mappings":";;;;;;;;;;;;;;;;;;;;;IAcSA,uBAAuB,EAAA;eAAvBA,yBAAAA,uBAAuB;;IALvBC,YAAY,EAAA;eAAZA,eAAAA,YAAY;;IAEZC,SAAS,EAAA;eAATA,WAAAA,SAAS;;IADTC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAFEC,iBAAiB,EAAA;eAAjBA,UAAAA,iBAAiB;;IAA3BC,QAAQ,EAAA;eAARA,UAAAA,QAAQ;;IAIRC,YAAY,EAAA;eAAZA,cAAAA,YAAY;;IAVLC,kCAAkC,EAAA;eAAlCA;;IAWPC,gBAAgB,EAAA;eAAhBA,iBAAAA,gBAAgB;;;yCAbe;0BAQI;+BACf;0BACJ;2BACC;8BACG;iCACI;AAX1B,SAASD;IACd,MAAM,OAAA,cAEL,CAFK,IAAIE,MACR,yEADI,qBAAA;eAAA;oBAAA;sBAAA;IAEN;AACF","ignoreList":[0]}},
    {"offset": {"line": 21940, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/src/api/navigation.react-server.ts"],"sourcesContent":["export * from '../client/components/navigation.react-server'\n"],"names":[],"mappings":";AAAA,cAAc,+CAA8C","ignoreList":[0]}},
    {"offset": {"line": 21947, "column": 0}, "map": {"version":3,"sources":["file:///C:/code/AnDDoanf/anddoanf/node_modules/next/src/build/templates/app-page.ts"],"sourcesContent":["import type { LoaderTree } from '../../server/lib/app-dir-module'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport {\n  AppPageRouteModule,\n  type AppPageRouteHandlerContext,\n} from '../../server/route-modules/app-page/module.compiled' with { 'turbopack-transition': 'next-ssr' }\n\nimport { RouteKind } from '../../server/route-kind' with { 'turbopack-transition': 'next-server-utility' }\n\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { getTracer, SpanKind, type Span } from '../../server/lib/trace/tracer'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { interopDefault } from '../../server/app-render/interop-default'\nimport { stripFlightHeaders } from '../../server/app-render/strip-flight-headers'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\nimport {\n  getFallbackRouteParams,\n  createOpaqueFallbackRouteParams,\n  type OpaqueFallbackRouteParams,\n} from '../../server/request/fallback-params'\nimport { setManifestsSingleton } from '../../server/app-render/manifests-singleton'\nimport {\n  isHtmlBotRequest,\n  shouldServeStreamingMetadata,\n} from '../../server/lib/streaming-metadata'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { getIsPossibleServerAction } from '../../server/lib/server-action-request-meta'\nimport {\n  RSC_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../client/components/app-router-headers'\nimport { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\nimport {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\nimport { FallbackMode, parseFallbackField } from '../../lib/fallback'\nimport RenderResult from '../../server/render-result'\nimport {\n  CACHE_ONE_YEAR,\n  HTML_CONTENT_TYPE_HEADER,\n  NEXT_CACHE_TAGS_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../../lib/constants'\nimport type { CacheControl } from '../../server/lib/cache-control'\nimport { ENCODED_TAGS } from '../../server/stream-utils/encoded-tags'\nimport { sendRenderResult } from '../../server/send-payload'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport { parseMaxPostponedStateSize } from '../../shared/lib/size-limit'\n\n// These are injected by the loader afterwards.\n\n/**\n * The tree created in next-app-loader that holds component segments and modules\n * and I've updated it.\n */\ndeclare const tree: LoaderTree\n\n// We inject the tree and pages here so that we can use them in the route\n// module.\n// INJECT:tree\n\nimport GlobalError from 'VAR_MODULE_GLOBAL_ERROR' with { 'turbopack-transition': 'next-server-utility' }\n\nexport { GlobalError }\n\n// These are injected by the loader afterwards.\ndeclare const __next_app_require__: (id: string | number) => unknown\ndeclare const __next_app_load_chunk__: (id: string | number) => Promise<unknown>\n\n// INJECT:__next_app_require__\n// INJECT:__next_app_load_chunk__\n\nexport const __next_app__ = {\n  require: __next_app_require__,\n  loadChunk: __next_app_load_chunk__,\n}\n\nimport * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { isInterceptionRouteAppPath } from '../../shared/lib/router/utils/interception-routes'\n\nexport * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n  definition: {\n    kind: RouteKind.APP_PAGE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n    appPaths: [],\n  },\n  userland: {\n    loaderTree: tree,\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  const isMinimalMode = Boolean(\n    process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n  )\n\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    query,\n    params,\n    pageIsDynamic,\n    buildManifest,\n    nextFontManifest,\n    reactLoadableManifest,\n    serverActionsManifest,\n    clientReferenceManifest,\n    subresourceIntegrityManifest,\n    prerenderManifest,\n    isDraftMode,\n    resolvedPathname,\n    revalidateOnlyGenerated,\n    routerServerContext,\n    nextConfig,\n    parsedUrl,\n    interceptionRoutePatterns,\n    deploymentId,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let { isOnDemandRevalidate } = prepareResult\n\n  // We use the resolvedPathname instead of the parsedUrl.pathname because it\n  // is not rewritten as resolvedPathname is. This will ensure that the correct\n  // prerender info is used instead of using the original pathname as the\n  // source. If however PPR is enabled and cacheComponents is disabled, we\n  // treat the pathname as dynamic. Currently, there's a bug in the PPR\n  // implementation that incorrectly leaves %%drp placeholders in the output of\n  // parallel routes. This is addressed with cacheComponents.\n  const prerenderInfo =\n    nextConfig.experimental.ppr &&\n    !nextConfig.cacheComponents &&\n    isInterceptionRouteAppPath(resolvedPathname)\n      ? null\n      : routeModule.match(resolvedPathname, prerenderManifest)\n\n  const isPrerendered = !!prerenderManifest.routes[resolvedPathname]\n\n  const userAgent = req.headers['user-agent'] || ''\n  const botType = getBotType(userAgent)\n  const isHtmlBot = isHtmlBotRequest(req)\n\n  /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */\n  const isPrefetchRSCRequest =\n    getRequestMeta(req, 'isPrefetchRSCRequest') ??\n    req.headers[NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\n\n  // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n\n  const isRSCRequest =\n    getRequestMeta(req, 'isRSCRequest') ?? Boolean(req.headers[RSC_HEADER])\n\n  const isPossibleServerAction = getIsPossibleServerAction(req)\n\n  /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */\n  const couldSupportPPR: boolean = checkIsAppPPREnabled(\n    nextConfig.experimental.ppr\n  )\n\n  if (\n    !getRequestMeta(req, 'postponed') &&\n    couldSupportPPR &&\n    req.headers[NEXT_RESUME_HEADER] === '1' &&\n    req.method === 'POST'\n  ) {\n    // Decode the postponed state from the request body, it will come as\n    // an array of buffers, so collect them and then concat them to form\n    // the string.\n\n    const body: Array<Buffer> = []\n    for await (const chunk of req) {\n      body.push(chunk)\n    }\n    const postponed = Buffer.concat(body).toString('utf8')\n\n    addRequestMeta(req, 'postponed', postponed)\n  }\n\n  // When enabled, this will allow the use of the `?__nextppronly` query to\n  // enable debugging of the static shell.\n  const hasDebugStaticShellQuery =\n    process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &&\n    typeof query.__nextppronly !== 'undefined' &&\n    couldSupportPPR\n\n  // When enabled, this will allow the use of the `?__nextppronly` query\n  // to enable debugging of the fallback shell.\n  const hasDebugFallbackShellQuery =\n    hasDebugStaticShellQuery && query.__nextppronly === 'fallback'\n\n  // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n  // prerender manifest and this is an app page.\n  const isRoutePPREnabled: boolean =\n    couldSupportPPR &&\n    ((\n      prerenderManifest.routes[normalizedSrcPage] ??\n      prerenderManifest.dynamicRoutes[normalizedSrcPage]\n    )?.renderingMode === 'PARTIALLY_STATIC' ||\n      // Ideally we'd want to check the appConfig to see if this page has PPR\n      // enabled or not, but that would require plumbing the appConfig through\n      // to the server during development. We assume that the page supports it\n      // but only during development.\n      (hasDebugStaticShellQuery &&\n        (routeModule.isDev === true ||\n          routerServerContext?.experimentalTestProxy === true)))\n\n  const isDebugStaticShell: boolean =\n    hasDebugStaticShellQuery && isRoutePPREnabled\n\n  // We should enable debugging dynamic accesses when the static shell\n  // debugging has been enabled and we're also in development mode.\n  const isDebugDynamicAccesses =\n    isDebugStaticShell && routeModule.isDev === true\n\n  const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n\n  // If we're in minimal mode, then try to get the postponed information from\n  // the request metadata. If available, use it for resuming the postponed\n  // render.\n  const minimalPostponed = isRoutePPREnabled\n    ? getRequestMeta(req, 'postponed')\n    : undefined\n\n  // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n  // we can use this fact to only generate the flight data for the request\n  // because we can't cache the HTML (as it's also dynamic).\n  let isDynamicRSCRequest =\n    isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n\n  // During a PPR revalidation, the RSC request is not dynamic if we do not have the postponed data.\n  // We only attach the postponed data during a resume. If there's no postponed data, then it must be a revalidation.\n  // This is to ensure that we don't bypass the cache during a revalidation.\n  if (isMinimalMode) {\n    isDynamicRSCRequest = isDynamicRSCRequest && !!minimalPostponed\n  }\n\n  // Need to read this before it's stripped by stripFlightHeaders. We don't\n  // need to transfer it to the request meta because it's only read\n  // within this function; the static segment data should have already been\n  // generated, so we will always either return a static response or a 404.\n  const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest')\n\n  // TODO: investigate existing bug with shouldServeStreamingMetadata always\n  // being true for a revalidate due to modifying the base-server this.renderOpts\n  // when fixing this to correct logic it causes hydration issue since we set\n  // serveStreamingMetadata to true during export\n  const serveStreamingMetadata =\n    isHtmlBot && isRoutePPREnabled\n      ? false\n      : !userAgent\n        ? true\n        : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n\n  const isSSG = Boolean(\n    (prerenderInfo ||\n      isPrerendered ||\n      prerenderManifest.routes[normalizedSrcPage]) &&\n      // If this is a html bot request and PPR is enabled, then we don't want\n      // to serve a static response.\n      !(isHtmlBot && isRoutePPREnabled)\n  )\n\n  // When a page supports cacheComponents, we can support RDC for Navigations\n  const supportsRDCForNavigations =\n    isRoutePPREnabled && nextConfig.cacheComponents === true\n\n  // In development, we always want to generate dynamic HTML.\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG ||\n    // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof minimalPostponed === 'string' ||\n    // If this handler supports onCacheEntryV2, then we can only support\n    // dynamic responses if it's a dynamic RSC request and not in minimal mode. If it\n    // doesn't support it we must fallback to the default behavior.\n    (supportsRDCForNavigations && getRequestMeta(req, 'onCacheEntryV2')\n      ? // In minimal mode, we'll always want to generate a static response\n        // which will generate the RDC for the route. When resuming a Dynamic\n        // RSC request, we'll pass the minimal postponed data to the render\n        // which will trigger the `supportsDynamicResponse` to be true.\n        isDynamicRSCRequest && !isMinimalMode\n      : // Otherwise, we can support dynamic responses if it's a dynamic RSC request.\n        isDynamicRSCRequest)\n\n  // When html bots request PPR page, perform the full dynamic rendering.\n  const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n\n  let ssgCacheKey: string | null = null\n  if (\n    !isDraftMode &&\n    isSSG &&\n    !supportsDynamicResponse &&\n    !isPossibleServerAction &&\n    !minimalPostponed &&\n    !isDynamicRSCRequest\n  ) {\n    ssgCacheKey = resolvedPathname\n  }\n\n  // the staticPathKey differs from ssgCacheKey since\n  // ssgCacheKey is null in dev since we're always in \"dynamic\"\n  // mode in dev to bypass the cache, but we still need to honor\n  // dynamicParams = false in dev mode\n  let staticPathKey = ssgCacheKey\n  if (!staticPathKey && routeModule.isDev) {\n    staticPathKey = resolvedPathname\n  }\n\n  // If this is a request for an app path that should be statically generated\n  // and we aren't in the edge runtime, strip the flight headers so it will\n  // generate the static response.\n  if (\n    !routeModule.isDev &&\n    !isDraftMode &&\n    isSSG &&\n    isRSCRequest &&\n    !isDynamicRSCRequest\n  ) {\n    stripFlightHeaders(req.headers)\n  }\n\n  const ComponentMod = {\n    ...entryBase,\n    tree,\n    GlobalError,\n    handler,\n    routeModule,\n    __next_app__,\n  }\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  try {\n    const varyHeader = routeModule.getVaryHeader(\n      resolvedPathname,\n      interceptionRoutePatterns\n    )\n    res.setHeader('Vary', varyHeader)\n    const invokeRouteModule = async (\n      span: Span | undefined,\n      context: AppPageRouteHandlerContext\n    ) => {\n      const nextReq = new NodeNextRequest(req)\n      const nextRes = new NodeNextResponse(res)\n\n      return routeModule.render(nextReq, nextRes, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n\n    const incrementalCache = getRequestMeta(req, 'incrementalCache')\n\n    const doRender = async ({\n      span,\n      postponed,\n      fallbackRouteParams,\n      forceStaticRender,\n    }: {\n      span?: Span\n\n      /**\n       * The postponed data for this render. This is only provided when resuming\n       * a render that has been postponed.\n       */\n      postponed: string | undefined\n\n      /**\n       * The unknown route params for this render.\n       */\n      fallbackRouteParams: OpaqueFallbackRouteParams | null\n\n      /**\n       * When true, this indicates that the response generator is being called\n       * in a context where the response must be generated statically.\n       *\n       * CRITICAL: This should only currently be used when revalidating due to a\n       * dynamic RSC request.\n       */\n      forceStaticRender: boolean\n    }): Promise<ResponseCacheEntry> => {\n      const context: AppPageRouteHandlerContext = {\n        query,\n        params,\n        page: normalizedSrcPage,\n        sharedContext: {\n          buildId,\n        },\n        serverComponentsHmrCache: getRequestMeta(\n          req,\n          'serverComponentsHmrCache'\n        ),\n        fallbackRouteParams,\n        renderOpts: {\n          App: () => null,\n          Document: () => null,\n          pageConfig: {},\n          ComponentMod,\n          Component: interopDefault(ComponentMod),\n\n          params,\n          routeModule,\n          page: srcPage,\n          postponed,\n          shouldWaitOnAllReady,\n          serveStreamingMetadata,\n          supportsDynamicResponse:\n            typeof postponed === 'string' || supportsDynamicResponse,\n          buildManifest,\n          nextFontManifest,\n          reactLoadableManifest,\n          subresourceIntegrityManifest,\n          setCacheStatus: routerServerContext?.setCacheStatus,\n          setIsrStatus: routerServerContext?.setIsrStatus,\n          setReactDebugChannel: routerServerContext?.setReactDebugChannel,\n          sendErrorsToBrowser: routerServerContext?.sendErrorsToBrowser,\n\n          dir:\n            process.env.NEXT_RUNTIME === 'nodejs'\n              ? (require('path') as typeof import('path')).join(\n                  /* turbopackIgnore: true */\n                  process.cwd(),\n                  routeModule.relativeProjectDir\n                )\n              : `${process.cwd()}/${routeModule.relativeProjectDir}`,\n          isDraftMode,\n          botType,\n          isOnDemandRevalidate,\n          isPossibleServerAction,\n          assetPrefix: nextConfig.assetPrefix,\n          nextConfigOutput: nextConfig.output,\n          crossOrigin: nextConfig.crossOrigin,\n          trailingSlash: nextConfig.trailingSlash,\n          images: nextConfig.images,\n          previewProps: prerenderManifest.preview,\n          deploymentId: deploymentId,\n          enableTainting: nextConfig.experimental.taint,\n          htmlLimitedBots: nextConfig.htmlLimitedBots,\n          reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n\n          multiZoneDraftMode,\n          incrementalCache,\n          cacheLifeProfiles: nextConfig.cacheLife,\n          basePath: nextConfig.basePath,\n          serverActions: nextConfig.experimental.serverActions,\n\n          ...(isDebugStaticShell ||\n          isDebugDynamicAccesses ||\n          isDebugFallbackShell\n            ? {\n                nextExport: true,\n                supportsDynamicResponse: false,\n                isStaticGeneration: true,\n                isDebugDynamicAccesses: isDebugDynamicAccesses,\n              }\n            : {}),\n          cacheComponents: Boolean(nextConfig.cacheComponents),\n          experimental: {\n            isRoutePPREnabled,\n            expireTime: nextConfig.expireTime,\n            staleTimes: nextConfig.experimental.staleTimes,\n            dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n            inlineCss: Boolean(nextConfig.experimental.inlineCss),\n            authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n            clientTraceMetadata:\n              nextConfig.experimental.clientTraceMetadata || ([] as any),\n            clientParamParsingOrigins:\n              nextConfig.experimental.clientParamParsingOrigins,\n            maxPostponedStateSizeBytes: parseMaxPostponedStateSize(\n              nextConfig.experimental.maxPostponedStateSize\n            ),\n          },\n\n          waitUntil: ctx.waitUntil,\n          onClose: (cb) => {\n            res.on('close', cb)\n          },\n          onAfterTaskError: () => {},\n\n          onInstrumentationRequestError: (\n            error,\n            _request,\n            errorContext,\n            silenceLog\n          ) =>\n            routeModule.onRequestError(\n              req,\n              error,\n              errorContext,\n              silenceLog,\n              routerServerContext\n            ),\n          err: getRequestMeta(req, 'invokeError'),\n          dev: routeModule.isDev,\n        },\n      }\n\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        context.renderOpts.nextExport = true\n        context.renderOpts.supportsDynamicResponse = false\n        context.renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses\n      }\n\n      // When we're revalidating in the background, we should not allow dynamic\n      // responses.\n      if (forceStaticRender) {\n        context.renderOpts.supportsDynamicResponse = false\n      }\n\n      const result = await invokeRouteModule(span, context)\n\n      const { metadata } = result\n\n      const {\n        cacheControl,\n        headers = {},\n        // Add any fetch tags that were on the page to the response headers.\n        fetchTags: cacheTags,\n        fetchMetrics,\n      } = metadata\n\n      if (cacheTags) {\n        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n      }\n\n      // Pull any fetch metrics from the render onto the request.\n      ;(req as any).fetchMetrics = fetchMetrics\n\n      // we don't throw static to dynamic errors in dev as isSSG\n      // is a best guess in dev since we don't have the prerender pass\n      // to know whether the path is actually static or not\n      if (\n        isSSG &&\n        cacheControl?.revalidate === 0 &&\n        !routeModule.isDev &&\n        !isRoutePPREnabled\n      ) {\n        const staticBailoutInfo = metadata.staticBailoutInfo\n\n        const err = new Error(\n          `Page changed from static to dynamic at runtime ${resolvedPathname}${\n            staticBailoutInfo?.description\n              ? `, reason: ${staticBailoutInfo.description}`\n              : ``\n          }` +\n            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n        )\n\n        if (staticBailoutInfo?.stack) {\n          const stack = staticBailoutInfo.stack\n          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n        }\n\n        throw err\n      }\n\n      return {\n        value: {\n          kind: CachedRouteKind.APP_PAGE,\n          html: result,\n          headers,\n          rscData: metadata.flightData,\n          postponed: metadata.postponed,\n          status: metadata.statusCode,\n          segmentData: metadata.segmentData,\n        } satisfies CachedAppPageValue,\n        cacheControl,\n      } satisfies ResponseCacheEntry\n    }\n\n    const responseGenerator: ResponseGenerator = async ({\n      hasResolved,\n      previousCacheEntry: previousIncrementalCacheEntry,\n      isRevalidating,\n      span,\n      forceStaticRender = false,\n    }) => {\n      const isProduction = routeModule.isDev === false\n      const didRespond = hasResolved || res.writableEnded\n\n      // skip on-demand revalidate if cache is not present and\n      // revalidate-if-generated is set\n      if (\n        isOnDemandRevalidate &&\n        revalidateOnlyGenerated &&\n        !previousIncrementalCacheEntry &&\n        !isMinimalMode\n      ) {\n        if (routerServerContext?.render404) {\n          await routerServerContext.render404(req, res)\n        } else {\n          res.statusCode = 404\n          res.end('This page could not be found')\n        }\n        return null\n      }\n\n      let fallbackMode: FallbackMode | undefined\n\n      if (prerenderInfo) {\n        fallbackMode = parseFallbackField(prerenderInfo.fallback)\n      }\n\n      // When serving a HTML bot request, we want to serve a blocking render and\n      // not the prerendered page. This ensures that the correct content is served\n      // to the bot in the head.\n      if (fallbackMode === FallbackMode.PRERENDER && isBot(userAgent)) {\n        if (!isRoutePPREnabled || isHtmlBot) {\n          fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n        }\n      }\n\n      if (previousIncrementalCacheEntry?.isStale === -1) {\n        isOnDemandRevalidate = true\n      }\n\n      // TODO: adapt for PPR\n      // only allow on-demand revalidate for fallback: true/blocking\n      // or for prerendered fallback: false paths\n      if (\n        isOnDemandRevalidate &&\n        (fallbackMode !== FallbackMode.NOT_FOUND ||\n          previousIncrementalCacheEntry)\n      ) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      if (\n        !isMinimalMode &&\n        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n        staticPathKey &&\n        !didRespond &&\n        !isDraftMode &&\n        pageIsDynamic &&\n        (isProduction || !isPrerendered)\n      ) {\n        // if the page has dynamicParams: false and this pathname wasn't\n        // prerendered trigger the no fallback handling\n        if (\n          // In development, fall through to render to handle missing\n          // getStaticPaths.\n          (isProduction || prerenderInfo) &&\n          // When fallback isn't present, abort this render so we 404\n          fallbackMode === FallbackMode.NOT_FOUND\n        ) {\n          if (nextConfig.experimental.adapterPath) {\n            return await render404()\n          }\n          throw new NoFallbackError()\n        }\n\n        // When cacheComponents is enabled, we can use the fallback\n        // response if the request is not a dynamic RSC request because the\n        // RSC data when this feature flag is enabled does not contain any\n        // param references. Without this feature flag enabled, the RSC data\n        // contains param references, and therefore we can't use the fallback.\n        if (\n          isRoutePPREnabled &&\n          (nextConfig.cacheComponents ? !isDynamicRSCRequest : !isRSCRequest)\n        ) {\n          const cacheKey =\n            isProduction && typeof prerenderInfo?.fallback === 'string'\n              ? prerenderInfo.fallback\n              : normalizedSrcPage\n\n          const fallbackRouteParams =\n            // If we're in production and we have fallback route params, then we\n            // can use the manifest fallback route params.\n            isProduction && prerenderInfo?.fallbackRouteParams\n              ? createOpaqueFallbackRouteParams(\n                  prerenderInfo.fallbackRouteParams\n                )\n              : // Otherwise, if we're debugging the fallback shell, then we\n                // have to manually generate the fallback route params.\n                isDebugFallbackShell\n                ? getFallbackRouteParams(normalizedSrcPage, routeModule)\n                : null\n\n          // We use the response cache here to handle the revalidation and\n          // management of the fallback shell.\n          const fallbackResponse = await routeModule.handleResponse({\n            cacheKey,\n            req,\n            nextConfig,\n            routeKind: RouteKind.APP_PAGE,\n            isFallback: true,\n            prerenderManifest,\n            isRoutePPREnabled,\n            responseGenerator: async () =>\n              doRender({\n                span,\n                // We pass `undefined` as rendering a fallback isn't resumed\n                // here.\n                postponed: undefined,\n                fallbackRouteParams,\n                forceStaticRender: false,\n              }),\n            waitUntil: ctx.waitUntil,\n            isMinimalMode,\n          })\n\n          // If the fallback response was set to null, then we should return null.\n          if (fallbackResponse === null) return null\n\n          // Otherwise, if we did get a fallback response, we should return it.\n          if (fallbackResponse) {\n            // Remove the cache control from the response to prevent it from being\n            // used in the surrounding cache.\n            delete fallbackResponse.cacheControl\n\n            return fallbackResponse\n          }\n        }\n      }\n\n      // Only requests that aren't revalidating can be resumed. If we have the\n      // minimal postponed data, then we should resume the render with it.\n      let postponed =\n        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n          ? minimalPostponed\n          : undefined\n\n      // If this is a dynamic RSC request, we should use the postponed data from\n      // the static render (if available). This ensures that we can utilize the\n      // resume data cache (RDC) from the static render to ensure that the data\n      // is consistent between the static and dynamic renders.\n      if (\n        // Only enable RDC for Navigations if the feature is enabled.\n        supportsRDCForNavigations &&\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        !isMinimalMode &&\n        incrementalCache &&\n        isDynamicRSCRequest &&\n        // We don't typically trigger an on-demand revalidation for dynamic RSC\n        // requests, as we're typically revalidating the page in the background\n        // instead. However, if the cache entry is stale, we should trigger a\n        // background revalidation on dynamic RSC requests. This prevents us\n        // from entering an infinite loop of revalidations.\n        !forceStaticRender\n      ) {\n        const incrementalCacheEntry = await incrementalCache.get(\n          resolvedPathname,\n          {\n            kind: IncrementalCacheKind.APP_PAGE,\n            isRoutePPREnabled: true,\n            isFallback: false,\n          }\n        )\n\n        // If the cache entry is found, we should use the postponed data from\n        // the cache.\n        if (\n          incrementalCacheEntry &&\n          incrementalCacheEntry.value &&\n          incrementalCacheEntry.value.kind === CachedRouteKind.APP_PAGE\n        ) {\n          // CRITICAL: we're assigning the postponed data from the cache entry\n          // here as we're using the RDC to resume the render.\n          postponed = incrementalCacheEntry.value.postponed\n\n          // If the cache entry is stale, we should trigger a background\n          // revalidation so that subsequent requests will get a fresh response.\n          if (\n            incrementalCacheEntry &&\n            // We want to trigger this flow if the cache entry is stale and if\n            // the requested revalidation flow is either foreground or\n            // background.\n            (incrementalCacheEntry.isStale === -1 ||\n              incrementalCacheEntry.isStale === true)\n          ) {\n            // We want to schedule this on the next tick to ensure that the\n            // render is not blocked on it.\n            scheduleOnNextTick(async () => {\n              const responseCache = routeModule.getResponseCache(req)\n\n              try {\n                await responseCache.revalidate(\n                  resolvedPathname,\n                  incrementalCache,\n                  isRoutePPREnabled,\n                  false,\n                  (c) =>\n                    responseGenerator({\n                      ...c,\n                      // CRITICAL: we need to set this to true as we're\n                      // revalidating in the background and typically this dynamic\n                      // RSC request is not treated as static.\n                      forceStaticRender: true,\n                    }),\n                  // CRITICAL: we need to pass null here because passing the\n                  // previous cache entry here (which is stale) will switch on\n                  // isOnDemandRevalidate and break the prerendering.\n                  null,\n                  hasResolved,\n                  ctx.waitUntil\n                )\n              } catch (err) {\n                console.error(\n                  'Error revalidating the page in the background',\n                  err\n                )\n              }\n            })\n          }\n        }\n      }\n\n      // When we're in minimal mode, if we're trying to debug the static shell,\n      // we should just return nothing instead of resuming the dynamic render.\n      if (\n        (isDebugStaticShell || isDebugDynamicAccesses) &&\n        typeof postponed !== 'undefined'\n      ) {\n        return {\n          cacheControl: { revalidate: 1, expire: undefined },\n          value: {\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.EMPTY,\n            pageData: {},\n            headers: undefined,\n            status: undefined,\n          } satisfies CachedPageValue,\n        }\n      }\n\n      const fallbackRouteParams =\n        // If we're in production and we have fallback route params, then we\n        // can use the manifest fallback route params if we need to render the\n        // fallback shell.\n        isProduction &&\n        prerenderInfo?.fallbackRouteParams &&\n        getRequestMeta(req, 'renderFallbackShell')\n          ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams)\n          : // Otherwise, if we're debugging the fallback shell, then we have to\n            // manually generate the fallback route params.\n            isDebugFallbackShell\n            ? getFallbackRouteParams(normalizedSrcPage, routeModule)\n            : null\n\n      // Perform the render.\n      return doRender({\n        span,\n        postponed,\n        fallbackRouteParams,\n        forceStaticRender,\n      })\n    }\n\n    const handleResponse = async (span?: Span): Promise<null | void> => {\n      const cacheEntry = await routeModule.handleResponse({\n        cacheKey: ssgCacheKey,\n        responseGenerator: (c) =>\n          responseGenerator({\n            span,\n            ...c,\n          }),\n        routeKind: RouteKind.APP_PAGE,\n        isOnDemandRevalidate,\n        isRoutePPREnabled,\n        req,\n        nextConfig,\n        prerenderManifest,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      // In dev, we should not cache pages for any reason.\n      if (routeModule.isDev) {\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n      }\n\n      if (!cacheEntry) {\n        if (ssgCacheKey) {\n          // A cache entry might not be generated if a response is written\n          // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n          // have a cache key. If we do have a cache key but we don't end up\n          // with a cache entry, then either Next.js or the application has a\n          // bug that needs fixing.\n          throw new Error('invariant: cache entry required but not generated')\n        }\n        return null\n      }\n\n      if (cacheEntry.value?.kind !== CachedRouteKind.APP_PAGE) {\n        throw new Error(\n          `Invariant app-page handler received invalid cache entry ${cacheEntry.value?.kind}`\n        )\n      }\n\n      const didPostpone = typeof cacheEntry.value.postponed === 'string'\n\n      if (\n        isSSG &&\n        // We don't want to send a cache header for requests that contain dynamic\n        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n        // request, then we should set the cache header.\n        !isDynamicRSCRequest &&\n        (!didPostpone || isPrefetchRSCRequest)\n      ) {\n        if (!isMinimalMode) {\n          // set x-nextjs-cache header to match the header\n          // we set for the image-optimizer\n          res.setHeader(\n            'x-nextjs-cache',\n            isOnDemandRevalidate\n              ? 'REVALIDATED'\n              : cacheEntry.isMiss\n                ? 'MISS'\n                : cacheEntry.isStale\n                  ? 'STALE'\n                  : 'HIT'\n          )\n        }\n        // Set a header used by the client router to signal the response is static\n        // and should respect the `static` cache staleTime value.\n        res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n      }\n      const { value: cachedData } = cacheEntry\n\n      // Coerce the cache control parameter from the render.\n      let cacheControl: CacheControl | undefined\n\n      // If this is a resume request in minimal mode it is streamed with dynamic\n      // content and should not be cached.\n      if (minimalPostponed) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      }\n\n      // If this is in minimal mode and this is a flight request that isn't a\n      // prefetch request while PPR is enabled, it cannot be cached as it contains\n      // dynamic content.\n      else if (isDynamicRSCRequest) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      } else if (!routeModule.isDev) {\n        // If this is a preview mode request, we shouldn't cache it\n        if (isDraftMode) {\n          cacheControl = { revalidate: 0, expire: undefined }\n        }\n\n        // If this isn't SSG, then we should set change the header only if it is\n        // not set already.\n        else if (!isSSG) {\n          if (!res.getHeader('Cache-Control')) {\n            cacheControl = { revalidate: 0, expire: undefined }\n          }\n        } else if (cacheEntry.cacheControl) {\n          // If the cache entry has a cache control with a revalidate value that's\n          // a number, use it.\n          if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n            if (cacheEntry.cacheControl.revalidate < 1) {\n              throw new Error(\n                `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n              )\n            }\n\n            cacheControl = {\n              revalidate: cacheEntry.cacheControl.revalidate,\n              expire: cacheEntry.cacheControl?.expire ?? nextConfig.expireTime,\n            }\n          }\n          // Otherwise if the revalidate value is false, then we should use the\n          // cache time of one year.\n          else {\n            cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n          }\n        }\n      }\n\n      cacheEntry.cacheControl = cacheControl\n\n      if (\n        typeof segmentPrefetchHeader === 'string' &&\n        cachedData?.kind === CachedRouteKind.APP_PAGE &&\n        cachedData.segmentData\n      ) {\n        // This is a prefetch request issued by the client Segment Cache. These\n        // should never reach the application layer (lambda). We should either\n        // respond from the cache (HIT) or respond with 204 No Content (MISS).\n\n        // Set a header to indicate that PPR is enabled for this route. This\n        // lets the client distinguish between a regular cache miss and a cache\n        // miss due to PPR being disabled. In other contexts this header is used\n        // to indicate that the response contains dynamic data, but here we're\n        // only using it to indicate that the feature is enabled  the segment\n        // response itself contains whether the data is dynamic.\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n\n        // Add the cache tags header to the response if it exists and we're in\n        // minimal mode while rendering a static page.\n        const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n        if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\n          res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n        }\n\n        const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n        if (matchedSegment !== undefined) {\n          // Cache hit\n          return sendRenderResult({\n            req,\n            res,\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: RenderResult.fromStatic(\n              matchedSegment,\n              RSC_CONTENT_TYPE_HEADER\n            ),\n            cacheControl: cacheEntry.cacheControl,\n          })\n        }\n\n        // Cache miss. Either a cache entry for this route has not been generated\n        // (which technically should not be possible when PPR is enabled, because\n        // at a minimum there should always be a fallback entry) or there's no\n        // match for the requested segment. Respond with a 204 No Content. We\n        // don't bother to respond with 404, because these requests are only\n        // issued as part of a prefetch.\n        res.statusCode = 204\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.EMPTY,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If there's a callback for `onCacheEntry`, call it with the cache entry\n      // and the revalidate options. If we support RDC for Navigations, we\n      // prefer the `onCacheEntryV2` callback. Once RDC for Navigations is the\n      // default, we can remove the fallback to `onCacheEntry` as\n      // `onCacheEntryV2` is now fully supported.\n      const onCacheEntry = supportsRDCForNavigations\n        ? (getRequestMeta(req, 'onCacheEntryV2') ??\n          getRequestMeta(req, 'onCacheEntry'))\n        : getRequestMeta(req, 'onCacheEntry')\n      if (onCacheEntry) {\n        const finished = await onCacheEntry(cacheEntry, {\n          url: getRequestMeta(req, 'initURL') ?? req.url,\n        })\n        if (finished) return null\n      }\n\n      if (cachedData.headers) {\n        const headers = { ...cachedData.headers }\n\n        if (!isMinimalMode || !isSSG) {\n          delete headers[NEXT_CACHE_TAGS_HEADER]\n        }\n\n        for (let [key, value] of Object.entries(headers)) {\n          if (typeof value === 'undefined') continue\n\n          if (Array.isArray(value)) {\n            for (const v of value) {\n              res.appendHeader(key, v)\n            }\n          } else if (typeof value === 'number') {\n            value = value.toString()\n            res.appendHeader(key, value)\n          } else {\n            res.appendHeader(key, value)\n          }\n        }\n      }\n\n      // Add the cache tags header to the response if it exists and we're in\n      // minimal mode while rendering a static page.\n      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      if (isMinimalMode && isSSG && tags && typeof tags === 'string') {\n        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n      }\n\n      // If the request is a data request, then we shouldn't set the status code\n      // from the response because it should always be 200. This should be gated\n      // behind the experimental PPR flag.\n      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n        res.statusCode = cachedData.status\n      }\n\n      // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n      if (\n        !isMinimalMode &&\n        cachedData.status &&\n        RedirectStatusCode[cachedData.status] &&\n        isRSCRequest\n      ) {\n        res.statusCode = 200\n      }\n\n      // Mark that the request did postpone.\n      if (didPostpone && !isDynamicRSCRequest) {\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n      }\n\n      // we don't go through this block when preview mode is true\n      // as preview mode is a dynamic request (bypasses cache) and doesn't\n      // generate both HTML and payloads in the same request so continue to just\n      // return the generated payload\n      if (isRSCRequest && !isDraftMode) {\n        // If this is a dynamic RSC request, then stream the response.\n        if (typeof cachedData.rscData === 'undefined') {\n          // If the response is not an RSC response, then we can't serve it.\n          if (cachedData.html.contentType !== RSC_CONTENT_TYPE_HEADER) {\n            if (nextConfig.cacheComponents) {\n              res.statusCode = 404\n              return sendRenderResult({\n                req,\n                res,\n                generateEtags: nextConfig.generateEtags,\n                poweredByHeader: nextConfig.poweredByHeader,\n                result: RenderResult.EMPTY,\n                cacheControl: cacheEntry.cacheControl,\n              })\n            } else {\n              // Otherwise this case is not expected.\n              throw new InvariantError(\n                `Expected RSC response, got ${cachedData.html.contentType}`\n              )\n            }\n          }\n\n          return sendRenderResult({\n            req,\n            res,\n            generateEtags: nextConfig.generateEtags,\n            poweredByHeader: nextConfig.poweredByHeader,\n            result: cachedData.html,\n            cacheControl: cacheEntry.cacheControl,\n          })\n        }\n\n        // As this isn't a prefetch request, we should serve the static flight\n        // data.\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: RenderResult.fromStatic(\n            cachedData.rscData,\n            RSC_CONTENT_TYPE_HEADER\n          ),\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // This is a request for HTML data.\n      const body = cachedData.html\n\n      // If there's no postponed state, we should just serve the HTML. This\n      // should also be the case for a resume request because it's completed\n      // as a server render (rather than a static render).\n      if (!didPostpone || isMinimalMode || isRSCRequest) {\n        // If we're in test mode, we should add a sentinel chunk to the response\n        // that's between the static and dynamic parts so we can compare the\n        // chunks and add assertions.\n        if (\n          process.env.__NEXT_TEST_MODE &&\n          isMinimalMode &&\n          isRoutePPREnabled &&\n          body.contentType === HTML_CONTENT_TYPE_HEADER\n        ) {\n          // As we're in minimal mode, the static part would have already been\n          // streamed first. The only part that this streams is the dynamic part\n          // so we should FIRST stream the sentinel and THEN the dynamic part.\n          body.unshift(createPPRBoundarySentinel())\n        }\n\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: cacheEntry.cacheControl,\n        })\n      }\n\n      // If we're debugging the static shell or the dynamic API accesses, we\n      // should just serve the HTML without resuming the render. The returned\n      // HTML will be the static shell so all the Dynamic API's will be used\n      // during static generation.\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        // Since we're not resuming the render, we need to at least add the\n        // closing body and html tags to create valid HTML.\n        body.push(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n              controller.close()\n            },\n          })\n        )\n\n        return sendRenderResult({\n          req,\n          res,\n          generateEtags: nextConfig.generateEtags,\n          poweredByHeader: nextConfig.poweredByHeader,\n          result: body,\n          cacheControl: { revalidate: 0, expire: undefined },\n        })\n      }\n\n      // If we're in test mode, we should add a sentinel chunk to the response\n      // that's between the static and dynamic parts so we can compare the\n      // chunks and add assertions.\n      if (process.env.__NEXT_TEST_MODE) {\n        body.push(createPPRBoundarySentinel())\n      }\n\n      // This request has postponed, so let's create a new transformer that the\n      // dynamic data can pipe to that will attach the dynamic data to the end\n      // of the response.\n      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n      body.push(transformer.readable)\n\n      // Perform the render again, but this time, provide the postponed state.\n      // We don't await because we want the result to start streaming now, and\n      // we've already chained the transformer's readable to the render result.\n      doRender({\n        span,\n        postponed: cachedData.postponed,\n        // This is a resume render, not a fallback render, so we don't need to\n        // set this.\n        fallbackRouteParams: null,\n        forceStaticRender: false,\n      })\n        .then(async (result) => {\n          if (!result) {\n            throw new Error('Invariant: expected a result to be returned')\n          }\n\n          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n            throw new Error(\n              `Invariant: expected a page response, got ${result.value?.kind}`\n            )\n          }\n\n          // Pipe the resume result to the transformer.\n          await result.value.html.pipeTo(transformer.writable)\n        })\n        .catch((err) => {\n          // An error occurred during piping or preparing the render, abort\n          // the transformers writer so we can terminate the stream.\n          transformer.writable.abort(err).catch((e) => {\n            console.error(\"couldn't abort transformer\", e)\n          })\n        })\n\n      return sendRenderResult({\n        req,\n        res,\n        generateEtags: nextConfig.generateEtags,\n        poweredByHeader: nextConfig.poweredByHeader,\n        result: body,\n        // We don't want to cache the response if it has postponed data because\n        // the response being sent to the client it's dynamic parts are streamed\n        // to the client on the same request.\n        cacheControl: { revalidate: 0, expire: undefined },\n      })\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      return await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      const silenceLog = false\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: srcPage,\n          routeType: 'render',\n          revalidateReason: getRevalidateReason({\n            isStaticGeneration: isSSG,\n            isOnDemandRevalidate,\n          }),\n        },\n        silenceLog,\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n    throw err\n  }\n}\n\n// TODO: omit this from production builds, only test builds should include it\n/**\n * Creates a readable stream that emits a PPR boundary sentinel.\n *\n * @returns A readable stream that emits a PPR boundary sentinel.\n */\nfunction createPPRBoundarySentinel() {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(\n        new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->')\n      )\n      controller.close()\n    },\n  })\n}\n"],"names":["AppPageRouteModule","RouteKind","getRevalidateReason","getTracer","SpanKind","addRequestMeta","getRequestMeta","BaseServerSpan","interopDefault","stripFlightHeaders","NodeNextRequest","NodeNextResponse","checkIsAppPPREnabled","getFallbackRouteParams","createOpaqueFallbackRouteParams","setManifestsSingleton","isHtmlBotRequest","shouldServeStreamingMetadata","normalizeAppPath","getIsPossibleServerAction","RSC_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_DID_POSTPONE_HEADER","RSC_CONTENT_TYPE_HEADER","getBotType","isBot","CachedRouteKind","IncrementalCacheKind","FallbackMode","parseFallbackField","RenderResult","CACHE_ONE_YEAR","HTML_CONTENT_TYPE_HEADER","NEXT_CACHE_TAGS_HEADER","NEXT_RESUME_HEADER","ENCODED_TAGS","sendRenderResult","NoFallbackError","parseMaxPostponedStateSize","GlobalError","__next_app__","require","__next_app_require__","loadChunk","__next_app_load_chunk__","entryBase","RedirectStatusCode","InvariantError","scheduleOnNextTick","isInterceptionRouteAppPath","routeModule","definition","kind","APP_PAGE","page","pathname","bundlePath","filename","appPaths","userland","loaderTree","tree","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","prerenderManifest","isDev","hrtime","bigint","isMinimalMode","Boolean","MINIMAL_MODE","srcPage","TURBOPACK","replace","multiZoneDraftMode","__NEXT_MULTI_ZONE_DRAFT_MODE","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","buildId","query","params","pageIsDynamic","buildManifest","nextFontManifest","reactLoadableManifest","serverActionsManifest","clientReferenceManifest","subresourceIntegrityManifest","isDraftMode","resolvedPathname","revalidateOnlyGenerated","routerServerContext","nextConfig","parsedUrl","interceptionRoutePatterns","deploymentId","normalizedSrcPage","isOnDemandRevalidate","prerenderInfo","experimental","ppr","cacheComponents","match","isPrerendered","routes","userAgent","headers","botType","isHtmlBot","isPrefetchRSCRequest","isRSCRequest","isPossibleServerAction","couldSupportPPR","method","body","chunk","push","postponed","Buffer","concat","toString","hasDebugStaticShellQuery","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","__nextppronly","hasDebugFallbackShellQuery","isRoutePPREnabled","dynamicRoutes","renderingMode","experimentalTestProxy","isDebugStaticShell","isDebugDynamicAccesses","isDebugFallbackShell","minimalPostponed","undefined","isDynamicRSCRequest","segmentPrefetchHeader","serveStreamingMetadata","htmlLimitedBots","isSSG","supportsRDCForNavigations","supportsDynamicResponse","shouldWaitOnAllReady","ssgCacheKey","staticPathKey","ComponentMod","tracer","activeSpan","getActiveScopeSpan","render404","varyHeader","getVaryHeader","setHeader","invokeRouteModule","span","context","nextReq","nextRes","render","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","incrementalCache","doRender","fallbackRouteParams","forceStaticRender","sharedContext","serverComponentsHmrCache","renderOpts","App","Document","pageConfig","Component","setCacheStatus","setIsrStatus","setReactDebugChannel","sendErrorsToBrowser","dir","NEXT_RUNTIME","join","cwd","assetPrefix","nextConfigOutput","output","crossOrigin","trailingSlash","images","previewProps","preview","enableTainting","taint","reactMaxHeadersLength","cacheLifeProfiles","cacheLife","basePath","serverActions","nextExport","isStaticGeneration","expireTime","staleTimes","dynamicOnHover","inlineCss","authInterrupts","clientTraceMetadata","clientParamParsingOrigins","maxPostponedStateSizeBytes","maxPostponedStateSize","onClose","cb","on","onAfterTaskError","onInstrumentationRequestError","error","_request","errorContext","silenceLog","onRequestError","err","dev","result","metadata","cacheControl","fetchTags","cacheTags","fetchMetrics","revalidate","staticBailoutInfo","Error","description","stack","message","substring","indexOf","value","html","rscData","flightData","status","segmentData","responseGenerator","hasResolved","previousCacheEntry","previousIncrementalCacheEntry","isRevalidating","isProduction","didRespond","writableEnded","fallbackMode","fallback","PRERENDER","BLOCKING_STATIC_RENDER","isStale","NOT_FOUND","adapterPath","cacheKey","fallbackResponse","handleResponse","routeKind","isFallback","incrementalCacheEntry","responseCache","getResponseCache","c","expire","PAGES","EMPTY","pageData","cacheEntry","cachedData","didPostpone","isMiss","getHeader","tags","matchedSegment","generateEtags","poweredByHeader","fromStatic","onCacheEntry","finished","url","key","Object","entries","Array","isArray","v","appendHeader","contentType","__NEXT_TEST_MODE","unshift","createPPRBoundarySentinel","ReadableStream","start","controller","enqueue","CLOSED","BODY_AND_HTML","close","transformer","TransformStream","readable","then","pipeTo","writable","catch","abort","e","withPropagatedContext","trace","spanName","SERVER","attributes","routerKind","routePath","routeType","revalidateReason","TextEncoder","encode"],"mappings":"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","ignoreList":[0]}}]
}